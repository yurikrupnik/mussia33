// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ActiveReceiptRuleSet is the Schema for the ActiveReceiptRuleSets API. Provides a resource to designate the active SES receipt rule set
 *
 * @schema ActiveReceiptRuleSet
 */
export class ActiveReceiptRuleSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ActiveReceiptRuleSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'ActiveReceiptRuleSet',
  }

  /**
   * Renders a Kubernetes manifest for "ActiveReceiptRuleSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ActiveReceiptRuleSetProps): any {
    return {
      ...ActiveReceiptRuleSet.GVK,
      ...toJson_ActiveReceiptRuleSetProps(props),
    };
  }

  /**
   * Defines a "ActiveReceiptRuleSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ActiveReceiptRuleSetProps) {
    super(scope, id, {
      ...ActiveReceiptRuleSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ActiveReceiptRuleSet.GVK,
      ...toJson_ActiveReceiptRuleSetProps(resolved),
    };
  }
}

/**
 * ActiveReceiptRuleSet is the Schema for the ActiveReceiptRuleSets API. Provides a resource to designate the active SES receipt rule set
 *
 * @schema ActiveReceiptRuleSet
 */
export interface ActiveReceiptRuleSetProps {
  /**
   * @schema ActiveReceiptRuleSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ActiveReceiptRuleSetSpec defines the desired state of ActiveReceiptRuleSet
   *
   * @schema ActiveReceiptRuleSet#spec
   */
  readonly spec: ActiveReceiptRuleSetSpec;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetProps(obj: ActiveReceiptRuleSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ActiveReceiptRuleSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActiveReceiptRuleSetSpec defines the desired state of ActiveReceiptRuleSet
 *
 * @schema ActiveReceiptRuleSetSpec
 */
export interface ActiveReceiptRuleSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ActiveReceiptRuleSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: ActiveReceiptRuleSetSpecDeletionPolicy;

  /**
   * @schema ActiveReceiptRuleSetSpec#forProvider
   */
  readonly forProvider: ActiveReceiptRuleSetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ActiveReceiptRuleSetSpec#managementPolicy
   */
  readonly managementPolicy?: ActiveReceiptRuleSetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ActiveReceiptRuleSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: ActiveReceiptRuleSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ActiveReceiptRuleSetSpec#providerRef
   */
  readonly providerRef?: ActiveReceiptRuleSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ActiveReceiptRuleSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ActiveReceiptRuleSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ActiveReceiptRuleSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ActiveReceiptRuleSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpec(obj: ActiveReceiptRuleSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ActiveReceiptRuleSetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ActiveReceiptRuleSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ActiveReceiptRuleSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ActiveReceiptRuleSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ActiveReceiptRuleSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ActiveReceiptRuleSetSpecDeletionPolicy
 */
export enum ActiveReceiptRuleSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ActiveReceiptRuleSetSpecForProvider
 */
export interface ActiveReceiptRuleSetSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ActiveReceiptRuleSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the rule set
   *
   * @schema ActiveReceiptRuleSetSpecForProvider#ruleSetName
   */
  readonly ruleSetName?: string;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpecForProvider(obj: ActiveReceiptRuleSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'ruleSetName': obj.ruleSetName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ActiveReceiptRuleSetSpecManagementPolicy
 */
export enum ActiveReceiptRuleSetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ActiveReceiptRuleSetSpecProviderConfigRef
 */
export interface ActiveReceiptRuleSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActiveReceiptRuleSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActiveReceiptRuleSetSpecProviderConfigRef#policy
   */
  readonly policy?: ActiveReceiptRuleSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpecProviderConfigRef(obj: ActiveReceiptRuleSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActiveReceiptRuleSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ActiveReceiptRuleSetSpecProviderRef
 */
export interface ActiveReceiptRuleSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActiveReceiptRuleSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActiveReceiptRuleSetSpecProviderRef#policy
   */
  readonly policy?: ActiveReceiptRuleSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpecProviderRef(obj: ActiveReceiptRuleSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActiveReceiptRuleSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsTo
 */
export interface ActiveReceiptRuleSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ActiveReceiptRuleSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpecPublishConnectionDetailsTo(obj: ActiveReceiptRuleSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ActiveReceiptRuleSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ActiveReceiptRuleSetSpecWriteConnectionSecretToRef
 */
export interface ActiveReceiptRuleSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ActiveReceiptRuleSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ActiveReceiptRuleSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpecWriteConnectionSecretToRef(obj: ActiveReceiptRuleSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ActiveReceiptRuleSetSpecProviderConfigRefPolicy
 */
export interface ActiveReceiptRuleSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActiveReceiptRuleSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ActiveReceiptRuleSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActiveReceiptRuleSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ActiveReceiptRuleSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpecProviderConfigRefPolicy(obj: ActiveReceiptRuleSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ActiveReceiptRuleSetSpecProviderRefPolicy
 */
export interface ActiveReceiptRuleSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActiveReceiptRuleSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ActiveReceiptRuleSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActiveReceiptRuleSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ActiveReceiptRuleSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpecProviderRefPolicy(obj: ActiveReceiptRuleSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRef
 */
export interface ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRef(obj: ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToMetadata
 */
export interface ActiveReceiptRuleSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpecPublishConnectionDetailsToMetadata(obj: ActiveReceiptRuleSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActiveReceiptRuleSetSpecProviderConfigRefPolicyResolution
 */
export enum ActiveReceiptRuleSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActiveReceiptRuleSetSpecProviderConfigRefPolicyResolve
 */
export enum ActiveReceiptRuleSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActiveReceiptRuleSetSpecProviderRefPolicyResolution
 */
export enum ActiveReceiptRuleSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActiveReceiptRuleSetSpecProviderRefPolicyResolve
 */
export enum ActiveReceiptRuleSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ActiveReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ConfigurationSet is the Schema for the ConfigurationSets API. Provides an SES configuration set
 *
 * @schema ConfigurationSet
 */
export class ConfigurationSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConfigurationSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'ConfigurationSet',
  }

  /**
   * Renders a Kubernetes manifest for "ConfigurationSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationSetProps): any {
    return {
      ...ConfigurationSet.GVK,
      ...toJson_ConfigurationSetProps(props),
    };
  }

  /**
   * Defines a "ConfigurationSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationSetProps) {
    super(scope, id, {
      ...ConfigurationSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConfigurationSet.GVK,
      ...toJson_ConfigurationSetProps(resolved),
    };
  }
}

/**
 * ConfigurationSet is the Schema for the ConfigurationSets API. Provides an SES configuration set
 *
 * @schema ConfigurationSet
 */
export interface ConfigurationSetProps {
  /**
   * @schema ConfigurationSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationSetSpec defines the desired state of ConfigurationSet
   *
   * @schema ConfigurationSet#spec
   */
  readonly spec: ConfigurationSetSpec;

}

/**
 * Converts an object of type 'ConfigurationSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetProps(obj: ConfigurationSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSetSpec defines the desired state of ConfigurationSet
 *
 * @schema ConfigurationSetSpec
 */
export interface ConfigurationSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConfigurationSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationSetSpecDeletionPolicy;

  /**
   * @schema ConfigurationSetSpec#forProvider
   */
  readonly forProvider: ConfigurationSetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConfigurationSetSpec#managementPolicy
   */
  readonly managementPolicy?: ConfigurationSetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConfigurationSetSpec#providerRef
   */
  readonly providerRef?: ConfigurationSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpec(obj: ConfigurationSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationSetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ConfigurationSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConfigurationSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConfigurationSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConfigurationSetSpecDeletionPolicy
 */
export enum ConfigurationSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConfigurationSetSpecForProvider
 */
export interface ConfigurationSetSpecForProvider {
  /**
   * Whether messages that use the configuration set are required to use TLS. See below.
   *
   * @schema ConfigurationSetSpecForProvider#deliveryOptions
   */
  readonly deliveryOptions?: ConfigurationSetSpecForProviderDeliveryOptions[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConfigurationSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Whether or not Amazon SES publishes reputation metrics for the configuration set, such as bounce and complaint rates, to Amazon CloudWatch. The default value is false.
   *
   * @schema ConfigurationSetSpecForProvider#reputationMetricsEnabled
   */
  readonly reputationMetricsEnabled?: boolean;

  /**
   * Whether email sending is enabled or disabled for the configuration set. The default value is true.
   *
   * @schema ConfigurationSetSpecForProvider#sendingEnabled
   */
  readonly sendingEnabled?: boolean;

  /**
   * Domain that is used to redirect email recipients to an Amazon SES-operated domain. See below. NOTE: This functionality is best effort.
   *
   * @schema ConfigurationSetSpecForProvider#trackingOptions
   */
  readonly trackingOptions?: ConfigurationSetSpecForProviderTrackingOptions[];

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProvider(obj: ConfigurationSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryOptions': obj.deliveryOptions?.map(y => toJson_ConfigurationSetSpecForProviderDeliveryOptions(y)),
    'region': obj.region,
    'reputationMetricsEnabled': obj.reputationMetricsEnabled,
    'sendingEnabled': obj.sendingEnabled,
    'trackingOptions': obj.trackingOptions?.map(y => toJson_ConfigurationSetSpecForProviderTrackingOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConfigurationSetSpecManagementPolicy
 */
export enum ConfigurationSetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationSetSpecProviderConfigRef
 */
export interface ConfigurationSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecProviderConfigRef(obj: ConfigurationSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConfigurationSetSpecProviderRef
 */
export interface ConfigurationSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetSpecProviderRef#policy
   */
  readonly policy?: ConfigurationSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecProviderRef(obj: ConfigurationSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsTo
 */
export interface ConfigurationSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsTo(obj: ConfigurationSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationSetSpecWriteConnectionSecretToRef
 */
export interface ConfigurationSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecWriteConnectionSecretToRef(obj: ConfigurationSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetSpecForProviderDeliveryOptions
 */
export interface ConfigurationSetSpecForProviderDeliveryOptions {
  /**
   * Whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is Require, messages are only delivered if a TLS connection can be established. If the value is Optional, messages can be delivered in plain text if a TLS connection can't be established. Valid values: Require or Optional. Defaults to Optional.
   *
   * @default Optional.
   * @schema ConfigurationSetSpecForProviderDeliveryOptions#tlsPolicy
   */
  readonly tlsPolicy?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderDeliveryOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderDeliveryOptions(obj: ConfigurationSetSpecForProviderDeliveryOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tlsPolicy': obj.tlsPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetSpecForProviderTrackingOptions
 */
export interface ConfigurationSetSpecForProviderTrackingOptions {
  /**
   * Custom subdomain that is used to redirect email recipients to the Amazon SES event tracking domain.
   *
   * @schema ConfigurationSetSpecForProviderTrackingOptions#customRedirectDomain
   */
  readonly customRedirectDomain?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderTrackingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderTrackingOptions(obj: ConfigurationSetSpecForProviderTrackingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customRedirectDomain': obj.customRedirectDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetSpecProviderConfigRefPolicy
 */
export interface ConfigurationSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecProviderConfigRefPolicy(obj: ConfigurationSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetSpecProviderRefPolicy
 */
export interface ConfigurationSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecProviderRefPolicy(obj: ConfigurationSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsToMetadata(obj: ConfigurationSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetSpecProviderRefPolicyResolution
 */
export enum ConfigurationSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetSpecProviderRefPolicyResolve
 */
export enum ConfigurationSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DomainDKIM is the Schema for the DomainDKIMs API. Provides an SES domain DKIM generation resource
 *
 * @schema DomainDKIM
 */
export class DomainDkim extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainDKIM"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'DomainDKIM',
  }

  /**
   * Renders a Kubernetes manifest for "DomainDKIM".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainDkimProps): any {
    return {
      ...DomainDkim.GVK,
      ...toJson_DomainDkimProps(props),
    };
  }

  /**
   * Defines a "DomainDKIM" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainDkimProps) {
    super(scope, id, {
      ...DomainDkim.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainDkim.GVK,
      ...toJson_DomainDkimProps(resolved),
    };
  }
}

/**
 * DomainDKIM is the Schema for the DomainDKIMs API. Provides an SES domain DKIM generation resource
 *
 * @schema DomainDKIM
 */
export interface DomainDkimProps {
  /**
   * @schema DomainDKIM#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainDKIMSpec defines the desired state of DomainDKIM
   *
   * @schema DomainDKIM#spec
   */
  readonly spec: DomainDkimSpec;

}

/**
 * Converts an object of type 'DomainDkimProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimProps(obj: DomainDkimProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainDkimSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainDKIMSpec defines the desired state of DomainDKIM
 *
 * @schema DomainDkimSpec
 */
export interface DomainDkimSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainDkimSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainDkimSpecDeletionPolicy;

  /**
   * @schema DomainDkimSpec#forProvider
   */
  readonly forProvider: DomainDkimSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainDkimSpec#managementPolicy
   */
  readonly managementPolicy?: DomainDkimSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainDkimSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainDkimSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DomainDkimSpec#providerRef
   */
  readonly providerRef?: DomainDkimSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainDkimSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainDkimSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainDkimSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainDkimSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainDkimSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpec(obj: DomainDkimSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainDkimSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DomainDkimSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DomainDkimSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DomainDkimSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainDkimSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainDkimSpecDeletionPolicy
 */
export enum DomainDkimSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainDkimSpecForProvider
 */
export interface DomainDkimSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainDkimSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DomainDkimSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpecForProvider(obj: DomainDkimSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainDkimSpecManagementPolicy
 */
export enum DomainDkimSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainDkimSpecProviderConfigRef
 */
export interface DomainDkimSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainDkimSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainDkimSpecProviderConfigRef#policy
   */
  readonly policy?: DomainDkimSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainDkimSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpecProviderConfigRef(obj: DomainDkimSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainDkimSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DomainDkimSpecProviderRef
 */
export interface DomainDkimSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainDkimSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainDkimSpecProviderRef#policy
   */
  readonly policy?: DomainDkimSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DomainDkimSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpecProviderRef(obj: DomainDkimSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainDkimSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainDkimSpecPublishConnectionDetailsTo
 */
export interface DomainDkimSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainDkimSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainDkimSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainDkimSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainDkimSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainDkimSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainDkimSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpecPublishConnectionDetailsTo(obj: DomainDkimSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainDkimSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainDkimSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainDkimSpecWriteConnectionSecretToRef
 */
export interface DomainDkimSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainDkimSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainDkimSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainDkimSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpecWriteConnectionSecretToRef(obj: DomainDkimSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainDkimSpecProviderConfigRefPolicy
 */
export interface DomainDkimSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainDkimSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainDkimSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainDkimSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainDkimSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainDkimSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpecProviderConfigRefPolicy(obj: DomainDkimSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainDkimSpecProviderRefPolicy
 */
export interface DomainDkimSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainDkimSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DomainDkimSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainDkimSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DomainDkimSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainDkimSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpecProviderRefPolicy(obj: DomainDkimSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainDkimSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainDkimSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainDkimSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainDkimSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainDkimSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainDkimSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpecPublishConnectionDetailsToConfigRef(obj: DomainDkimSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainDkimSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainDkimSpecPublishConnectionDetailsToMetadata
 */
export interface DomainDkimSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainDkimSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainDkimSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainDkimSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainDkimSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpecPublishConnectionDetailsToMetadata(obj: DomainDkimSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainDkimSpecProviderConfigRefPolicyResolution
 */
export enum DomainDkimSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainDkimSpecProviderConfigRefPolicyResolve
 */
export enum DomainDkimSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainDkimSpecProviderRefPolicyResolution
 */
export enum DomainDkimSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainDkimSpecProviderRefPolicyResolve
 */
export enum DomainDkimSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainDkimSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainDkimSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainDkimSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainDkimSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainDkimSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainDkimSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainDkimSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainDkimSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainDkimSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainDkimSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainDkimSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainDkimSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainDkimSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DomainIdentity is the Schema for the DomainIdentitys API. Provides an SES domain identity resource
 *
 * @schema DomainIdentity
 */
export class DomainIdentity extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainIdentity"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'DomainIdentity',
  }

  /**
   * Renders a Kubernetes manifest for "DomainIdentity".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainIdentityProps): any {
    return {
      ...DomainIdentity.GVK,
      ...toJson_DomainIdentityProps(props),
    };
  }

  /**
   * Defines a "DomainIdentity" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainIdentityProps) {
    super(scope, id, {
      ...DomainIdentity.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainIdentity.GVK,
      ...toJson_DomainIdentityProps(resolved),
    };
  }
}

/**
 * DomainIdentity is the Schema for the DomainIdentitys API. Provides an SES domain identity resource
 *
 * @schema DomainIdentity
 */
export interface DomainIdentityProps {
  /**
   * @schema DomainIdentity#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainIdentitySpec defines the desired state of DomainIdentity
   *
   * @schema DomainIdentity#spec
   */
  readonly spec: DomainIdentitySpec;

}

/**
 * Converts an object of type 'DomainIdentityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentityProps(obj: DomainIdentityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainIdentitySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainIdentitySpec defines the desired state of DomainIdentity
 *
 * @schema DomainIdentitySpec
 */
export interface DomainIdentitySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainIdentitySpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainIdentitySpecDeletionPolicy;

  /**
   * @schema DomainIdentitySpec#forProvider
   */
  readonly forProvider: DomainIdentitySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainIdentitySpec#managementPolicy
   */
  readonly managementPolicy?: DomainIdentitySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainIdentitySpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainIdentitySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DomainIdentitySpec#providerRef
   */
  readonly providerRef?: DomainIdentitySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainIdentitySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainIdentitySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainIdentitySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainIdentitySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainIdentitySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpec(obj: DomainIdentitySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainIdentitySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DomainIdentitySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DomainIdentitySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DomainIdentitySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainIdentitySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainIdentitySpecDeletionPolicy
 */
export enum DomainIdentitySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainIdentitySpecForProvider
 */
export interface DomainIdentitySpecForProvider {
  /**
   * The domain name to assign to SES
   *
   * @schema DomainIdentitySpecForProvider#domain
   */
  readonly domain?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainIdentitySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DomainIdentitySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpecForProvider(obj: DomainIdentitySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainIdentitySpecManagementPolicy
 */
export enum DomainIdentitySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainIdentitySpecProviderConfigRef
 */
export interface DomainIdentitySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainIdentitySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainIdentitySpecProviderConfigRef#policy
   */
  readonly policy?: DomainIdentitySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainIdentitySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpecProviderConfigRef(obj: DomainIdentitySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainIdentitySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DomainIdentitySpecProviderRef
 */
export interface DomainIdentitySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainIdentitySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainIdentitySpecProviderRef#policy
   */
  readonly policy?: DomainIdentitySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DomainIdentitySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpecProviderRef(obj: DomainIdentitySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainIdentitySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainIdentitySpecPublishConnectionDetailsTo
 */
export interface DomainIdentitySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainIdentitySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainIdentitySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainIdentitySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainIdentitySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainIdentitySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainIdentitySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpecPublishConnectionDetailsTo(obj: DomainIdentitySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainIdentitySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainIdentitySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainIdentitySpecWriteConnectionSecretToRef
 */
export interface DomainIdentitySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainIdentitySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainIdentitySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainIdentitySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpecWriteConnectionSecretToRef(obj: DomainIdentitySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainIdentitySpecProviderConfigRefPolicy
 */
export interface DomainIdentitySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainIdentitySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainIdentitySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainIdentitySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainIdentitySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainIdentitySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpecProviderConfigRefPolicy(obj: DomainIdentitySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainIdentitySpecProviderRefPolicy
 */
export interface DomainIdentitySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainIdentitySpecProviderRefPolicy#resolution
   */
  readonly resolution?: DomainIdentitySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainIdentitySpecProviderRefPolicy#resolve
   */
  readonly resolve?: DomainIdentitySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainIdentitySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpecProviderRefPolicy(obj: DomainIdentitySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainIdentitySpecPublishConnectionDetailsToConfigRef
 */
export interface DomainIdentitySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainIdentitySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainIdentitySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainIdentitySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpecPublishConnectionDetailsToConfigRef(obj: DomainIdentitySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainIdentitySpecPublishConnectionDetailsToMetadata
 */
export interface DomainIdentitySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainIdentitySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainIdentitySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainIdentitySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainIdentitySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpecPublishConnectionDetailsToMetadata(obj: DomainIdentitySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainIdentitySpecProviderConfigRefPolicyResolution
 */
export enum DomainIdentitySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainIdentitySpecProviderConfigRefPolicyResolve
 */
export enum DomainIdentitySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainIdentitySpecProviderRefPolicyResolution
 */
export enum DomainIdentitySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainIdentitySpecProviderRefPolicyResolve
 */
export enum DomainIdentitySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DomainMailFrom is the Schema for the DomainMailFroms API. Provides an SES domain MAIL FROM resource
 *
 * @schema DomainMailFrom
 */
export class DomainMailFrom extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainMailFrom"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'DomainMailFrom',
  }

  /**
   * Renders a Kubernetes manifest for "DomainMailFrom".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainMailFromProps): any {
    return {
      ...DomainMailFrom.GVK,
      ...toJson_DomainMailFromProps(props),
    };
  }

  /**
   * Defines a "DomainMailFrom" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainMailFromProps) {
    super(scope, id, {
      ...DomainMailFrom.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainMailFrom.GVK,
      ...toJson_DomainMailFromProps(resolved),
    };
  }
}

/**
 * DomainMailFrom is the Schema for the DomainMailFroms API. Provides an SES domain MAIL FROM resource
 *
 * @schema DomainMailFrom
 */
export interface DomainMailFromProps {
  /**
   * @schema DomainMailFrom#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainMailFromSpec defines the desired state of DomainMailFrom
   *
   * @schema DomainMailFrom#spec
   */
  readonly spec: DomainMailFromSpec;

}

/**
 * Converts an object of type 'DomainMailFromProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromProps(obj: DomainMailFromProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainMailFromSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainMailFromSpec defines the desired state of DomainMailFrom
 *
 * @schema DomainMailFromSpec
 */
export interface DomainMailFromSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainMailFromSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainMailFromSpecDeletionPolicy;

  /**
   * @schema DomainMailFromSpec#forProvider
   */
  readonly forProvider: DomainMailFromSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainMailFromSpec#managementPolicy
   */
  readonly managementPolicy?: DomainMailFromSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainMailFromSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainMailFromSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DomainMailFromSpec#providerRef
   */
  readonly providerRef?: DomainMailFromSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainMailFromSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainMailFromSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainMailFromSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainMailFromSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainMailFromSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpec(obj: DomainMailFromSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainMailFromSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DomainMailFromSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DomainMailFromSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DomainMailFromSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainMailFromSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainMailFromSpecDeletionPolicy
 */
export enum DomainMailFromSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainMailFromSpecForProvider
 */
export interface DomainMailFromSpecForProvider {
  /**
   * The action that you want Amazon SES to take if it cannot successfully read the required MX record when you send an email. Defaults to UseDefaultValue. See the SES API documentation for more information.
   *
   * @default UseDefaultValue. See the SES API documentation for more information.
   * @schema DomainMailFromSpecForProvider#behaviorOnMxFailure
   */
  readonly behaviorOnMxFailure?: string;

  /**
   * Verified domain name or email identity to generate DKIM tokens for.
   *
   * @schema DomainMailFromSpecForProvider#domain
   */
  readonly domain?: string;

  /**
   * Reference to a DomainIdentity in ses to populate domain.
   *
   * @schema DomainMailFromSpecForProvider#domainRef
   */
  readonly domainRef?: DomainMailFromSpecForProviderDomainRef;

  /**
   * Selector for a DomainIdentity in ses to populate domain.
   *
   * @schema DomainMailFromSpecForProvider#domainSelector
   */
  readonly domainSelector?: DomainMailFromSpecForProviderDomainSelector;

  /**
   * Subdomain (of above domain) which is to be used as MAIL FROM address
   *
   * @schema DomainMailFromSpecForProvider#mailFromDomain
   */
  readonly mailFromDomain?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainMailFromSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DomainMailFromSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecForProvider(obj: DomainMailFromSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'behaviorOnMxFailure': obj.behaviorOnMxFailure,
    'domain': obj.domain,
    'domainRef': toJson_DomainMailFromSpecForProviderDomainRef(obj.domainRef),
    'domainSelector': toJson_DomainMailFromSpecForProviderDomainSelector(obj.domainSelector),
    'mailFromDomain': obj.mailFromDomain,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainMailFromSpecManagementPolicy
 */
export enum DomainMailFromSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainMailFromSpecProviderConfigRef
 */
export interface DomainMailFromSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainMailFromSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainMailFromSpecProviderConfigRef#policy
   */
  readonly policy?: DomainMailFromSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainMailFromSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecProviderConfigRef(obj: DomainMailFromSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainMailFromSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DomainMailFromSpecProviderRef
 */
export interface DomainMailFromSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainMailFromSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainMailFromSpecProviderRef#policy
   */
  readonly policy?: DomainMailFromSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DomainMailFromSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecProviderRef(obj: DomainMailFromSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainMailFromSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainMailFromSpecPublishConnectionDetailsTo
 */
export interface DomainMailFromSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainMailFromSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainMailFromSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainMailFromSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainMailFromSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainMailFromSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainMailFromSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecPublishConnectionDetailsTo(obj: DomainMailFromSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainMailFromSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainMailFromSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainMailFromSpecWriteConnectionSecretToRef
 */
export interface DomainMailFromSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainMailFromSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainMailFromSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainMailFromSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecWriteConnectionSecretToRef(obj: DomainMailFromSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DomainIdentity in ses to populate domain.
 *
 * @schema DomainMailFromSpecForProviderDomainRef
 */
export interface DomainMailFromSpecForProviderDomainRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainMailFromSpecForProviderDomainRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainMailFromSpecForProviderDomainRef#policy
   */
  readonly policy?: DomainMailFromSpecForProviderDomainRefPolicy;

}

/**
 * Converts an object of type 'DomainMailFromSpecForProviderDomainRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecForProviderDomainRef(obj: DomainMailFromSpecForProviderDomainRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainMailFromSpecForProviderDomainRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DomainIdentity in ses to populate domain.
 *
 * @schema DomainMailFromSpecForProviderDomainSelector
 */
export interface DomainMailFromSpecForProviderDomainSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainMailFromSpecForProviderDomainSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainMailFromSpecForProviderDomainSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainMailFromSpecForProviderDomainSelector#policy
   */
  readonly policy?: DomainMailFromSpecForProviderDomainSelectorPolicy;

}

/**
 * Converts an object of type 'DomainMailFromSpecForProviderDomainSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecForProviderDomainSelector(obj: DomainMailFromSpecForProviderDomainSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainMailFromSpecForProviderDomainSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainMailFromSpecProviderConfigRefPolicy
 */
export interface DomainMailFromSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMailFromSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainMailFromSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMailFromSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainMailFromSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainMailFromSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecProviderConfigRefPolicy(obj: DomainMailFromSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainMailFromSpecProviderRefPolicy
 */
export interface DomainMailFromSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMailFromSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DomainMailFromSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMailFromSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DomainMailFromSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainMailFromSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecProviderRefPolicy(obj: DomainMailFromSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainMailFromSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainMailFromSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainMailFromSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainMailFromSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainMailFromSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecPublishConnectionDetailsToConfigRef(obj: DomainMailFromSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainMailFromSpecPublishConnectionDetailsToMetadata
 */
export interface DomainMailFromSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainMailFromSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainMailFromSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainMailFromSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainMailFromSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecPublishConnectionDetailsToMetadata(obj: DomainMailFromSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainMailFromSpecForProviderDomainRefPolicy
 */
export interface DomainMailFromSpecForProviderDomainRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMailFromSpecForProviderDomainRefPolicy#resolution
   */
  readonly resolution?: DomainMailFromSpecForProviderDomainRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMailFromSpecForProviderDomainRefPolicy#resolve
   */
  readonly resolve?: DomainMailFromSpecForProviderDomainRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainMailFromSpecForProviderDomainRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecForProviderDomainRefPolicy(obj: DomainMailFromSpecForProviderDomainRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainMailFromSpecForProviderDomainSelectorPolicy
 */
export interface DomainMailFromSpecForProviderDomainSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMailFromSpecForProviderDomainSelectorPolicy#resolution
   */
  readonly resolution?: DomainMailFromSpecForProviderDomainSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMailFromSpecForProviderDomainSelectorPolicy#resolve
   */
  readonly resolve?: DomainMailFromSpecForProviderDomainSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainMailFromSpecForProviderDomainSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecForProviderDomainSelectorPolicy(obj: DomainMailFromSpecForProviderDomainSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMailFromSpecProviderConfigRefPolicyResolution
 */
export enum DomainMailFromSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMailFromSpecProviderConfigRefPolicyResolve
 */
export enum DomainMailFromSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMailFromSpecProviderRefPolicyResolution
 */
export enum DomainMailFromSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMailFromSpecProviderRefPolicyResolve
 */
export enum DomainMailFromSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMailFromSpecForProviderDomainRefPolicyResolution
 */
export enum DomainMailFromSpecForProviderDomainRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMailFromSpecForProviderDomainRefPolicyResolve
 */
export enum DomainMailFromSpecForProviderDomainRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMailFromSpecForProviderDomainSelectorPolicyResolution
 */
export enum DomainMailFromSpecForProviderDomainSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMailFromSpecForProviderDomainSelectorPolicyResolve
 */
export enum DomainMailFromSpecForProviderDomainSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainMailFromSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EmailIdentity is the Schema for the EmailIdentitys API. Provides an SES email identity resource
 *
 * @schema EmailIdentity
 */
export class EmailIdentity extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EmailIdentity"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'EmailIdentity',
  }

  /**
   * Renders a Kubernetes manifest for "EmailIdentity".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EmailIdentityProps): any {
    return {
      ...EmailIdentity.GVK,
      ...toJson_EmailIdentityProps(props),
    };
  }

  /**
   * Defines a "EmailIdentity" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EmailIdentityProps) {
    super(scope, id, {
      ...EmailIdentity.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EmailIdentity.GVK,
      ...toJson_EmailIdentityProps(resolved),
    };
  }
}

/**
 * EmailIdentity is the Schema for the EmailIdentitys API. Provides an SES email identity resource
 *
 * @schema EmailIdentity
 */
export interface EmailIdentityProps {
  /**
   * @schema EmailIdentity#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EmailIdentitySpec defines the desired state of EmailIdentity
   *
   * @schema EmailIdentity#spec
   */
  readonly spec: EmailIdentitySpec;

}

/**
 * Converts an object of type 'EmailIdentityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityProps(obj: EmailIdentityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EmailIdentitySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmailIdentitySpec defines the desired state of EmailIdentity
 *
 * @schema EmailIdentitySpec
 */
export interface EmailIdentitySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EmailIdentitySpec#deletionPolicy
   */
  readonly deletionPolicy?: EmailIdentitySpecDeletionPolicy;

  /**
   * @schema EmailIdentitySpec#forProvider
   */
  readonly forProvider: EmailIdentitySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EmailIdentitySpec#managementPolicy
   */
  readonly managementPolicy?: EmailIdentitySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EmailIdentitySpec#providerConfigRef
   */
  readonly providerConfigRef?: EmailIdentitySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EmailIdentitySpec#providerRef
   */
  readonly providerRef?: EmailIdentitySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EmailIdentitySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EmailIdentitySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EmailIdentitySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EmailIdentitySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EmailIdentitySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpec(obj: EmailIdentitySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EmailIdentitySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EmailIdentitySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EmailIdentitySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EmailIdentitySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EmailIdentitySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EmailIdentitySpecDeletionPolicy
 */
export enum EmailIdentitySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EmailIdentitySpecForProvider
 */
export interface EmailIdentitySpecForProvider {
  /**
   * The email address to assign to SES.
   *
   * @schema EmailIdentitySpecForProvider#email
   */
  readonly email?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EmailIdentitySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProvider(obj: EmailIdentitySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'email': obj.email,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EmailIdentitySpecManagementPolicy
 */
export enum EmailIdentitySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EmailIdentitySpecProviderConfigRef
 */
export interface EmailIdentitySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentitySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentitySpecProviderConfigRef#policy
   */
  readonly policy?: EmailIdentitySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecProviderConfigRef(obj: EmailIdentitySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentitySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EmailIdentitySpecProviderRef
 */
export interface EmailIdentitySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentitySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentitySpecProviderRef#policy
   */
  readonly policy?: EmailIdentitySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecProviderRef(obj: EmailIdentitySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentitySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsTo
 */
export interface EmailIdentitySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EmailIdentitySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EmailIdentitySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsTo(obj: EmailIdentitySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EmailIdentitySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EmailIdentitySpecWriteConnectionSecretToRef
 */
export interface EmailIdentitySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EmailIdentitySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EmailIdentitySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecWriteConnectionSecretToRef(obj: EmailIdentitySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentitySpecProviderConfigRefPolicy
 */
export interface EmailIdentitySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecProviderConfigRefPolicy(obj: EmailIdentitySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentitySpecProviderRefPolicy
 */
export interface EmailIdentitySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecProviderRefPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecProviderRefPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecProviderRefPolicy(obj: EmailIdentitySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRef
 */
export interface EmailIdentitySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRef(obj: EmailIdentitySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata
 */
export interface EmailIdentitySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsToMetadata(obj: EmailIdentitySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecProviderConfigRefPolicyResolution
 */
export enum EmailIdentitySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecProviderConfigRefPolicyResolve
 */
export enum EmailIdentitySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecProviderRefPolicyResolution
 */
export enum EmailIdentitySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecProviderRefPolicyResolve
 */
export enum EmailIdentitySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy(obj: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EventDestination is the Schema for the EventDestinations API. Provides an SES event destination
 *
 * @schema EventDestination
 */
export class EventDestination extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EventDestination"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'EventDestination',
  }

  /**
   * Renders a Kubernetes manifest for "EventDestination".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EventDestinationProps): any {
    return {
      ...EventDestination.GVK,
      ...toJson_EventDestinationProps(props),
    };
  }

  /**
   * Defines a "EventDestination" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EventDestinationProps) {
    super(scope, id, {
      ...EventDestination.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EventDestination.GVK,
      ...toJson_EventDestinationProps(resolved),
    };
  }
}

/**
 * EventDestination is the Schema for the EventDestinations API. Provides an SES event destination
 *
 * @schema EventDestination
 */
export interface EventDestinationProps {
  /**
   * @schema EventDestination#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EventDestinationSpec defines the desired state of EventDestination
   *
   * @schema EventDestination#spec
   */
  readonly spec: EventDestinationSpec;

}

/**
 * Converts an object of type 'EventDestinationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationProps(obj: EventDestinationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EventDestinationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventDestinationSpec defines the desired state of EventDestination
 *
 * @schema EventDestinationSpec
 */
export interface EventDestinationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventDestinationSpec#deletionPolicy
   */
  readonly deletionPolicy?: EventDestinationSpecDeletionPolicy;

  /**
   * @schema EventDestinationSpec#forProvider
   */
  readonly forProvider: EventDestinationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventDestinationSpec#managementPolicy
   */
  readonly managementPolicy?: EventDestinationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EventDestinationSpec#providerConfigRef
   */
  readonly providerConfigRef?: EventDestinationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EventDestinationSpec#providerRef
   */
  readonly providerRef?: EventDestinationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EventDestinationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EventDestinationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EventDestinationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EventDestinationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EventDestinationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpec(obj: EventDestinationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EventDestinationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EventDestinationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EventDestinationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EventDestinationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EventDestinationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventDestinationSpecDeletionPolicy
 */
export enum EventDestinationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EventDestinationSpecForProvider
 */
export interface EventDestinationSpecForProvider {
  /**
   * CloudWatch destination for the events
   *
   * @schema EventDestinationSpecForProvider#cloudwatchDestination
   */
  readonly cloudwatchDestination?: EventDestinationSpecForProviderCloudwatchDestination[];

  /**
   * The name of the configuration set
   *
   * @schema EventDestinationSpecForProvider#configurationSetName
   */
  readonly configurationSetName?: string;

  /**
   * Reference to a ConfigurationSet in ses to populate configurationSetName.
   *
   * @schema EventDestinationSpecForProvider#configurationSetNameRef
   */
  readonly configurationSetNameRef?: EventDestinationSpecForProviderConfigurationSetNameRef;

  /**
   * Selector for a ConfigurationSet in ses to populate configurationSetName.
   *
   * @schema EventDestinationSpecForProvider#configurationSetNameSelector
   */
  readonly configurationSetNameSelector?: EventDestinationSpecForProviderConfigurationSetNameSelector;

  /**
   * If true, the event destination will be enabled
   *
   * @schema EventDestinationSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Send the events to a kinesis firehose destination
   *
   * @schema EventDestinationSpecForProvider#kinesisDestination
   */
  readonly kinesisDestination?: EventDestinationSpecForProviderKinesisDestination[];

  /**
   * A list of matching types. May be any of "send", "reject", "bounce", "complaint", "delivery", "open", "click", or "renderingFailure".
   *
   * @schema EventDestinationSpecForProvider#matchingTypes
   */
  readonly matchingTypes?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EventDestinationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Send the events to an SNS Topic destination
   *
   * @schema EventDestinationSpecForProvider#snsDestination
   */
  readonly snsDestination?: EventDestinationSpecForProviderSnsDestination[];

}

/**
 * Converts an object of type 'EventDestinationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProvider(obj: EventDestinationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchDestination': obj.cloudwatchDestination?.map(y => toJson_EventDestinationSpecForProviderCloudwatchDestination(y)),
    'configurationSetName': obj.configurationSetName,
    'configurationSetNameRef': toJson_EventDestinationSpecForProviderConfigurationSetNameRef(obj.configurationSetNameRef),
    'configurationSetNameSelector': toJson_EventDestinationSpecForProviderConfigurationSetNameSelector(obj.configurationSetNameSelector),
    'enabled': obj.enabled,
    'kinesisDestination': obj.kinesisDestination?.map(y => toJson_EventDestinationSpecForProviderKinesisDestination(y)),
    'matchingTypes': obj.matchingTypes?.map(y => y),
    'region': obj.region,
    'snsDestination': obj.snsDestination?.map(y => toJson_EventDestinationSpecForProviderSnsDestination(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventDestinationSpecManagementPolicy
 */
export enum EventDestinationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EventDestinationSpecProviderConfigRef
 */
export interface EventDestinationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDestinationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDestinationSpecProviderConfigRef#policy
   */
  readonly policy?: EventDestinationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecProviderConfigRef(obj: EventDestinationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDestinationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EventDestinationSpecProviderRef
 */
export interface EventDestinationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDestinationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDestinationSpecProviderRef#policy
   */
  readonly policy?: EventDestinationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecProviderRef(obj: EventDestinationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDestinationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EventDestinationSpecPublishConnectionDetailsTo
 */
export interface EventDestinationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EventDestinationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EventDestinationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EventDestinationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EventDestinationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EventDestinationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EventDestinationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecPublishConnectionDetailsTo(obj: EventDestinationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EventDestinationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EventDestinationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EventDestinationSpecWriteConnectionSecretToRef
 */
export interface EventDestinationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EventDestinationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EventDestinationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EventDestinationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecWriteConnectionSecretToRef(obj: EventDestinationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventDestinationSpecForProviderCloudwatchDestination
 */
export interface EventDestinationSpecForProviderCloudwatchDestination {
  /**
   * The default value for the event
   *
   * @schema EventDestinationSpecForProviderCloudwatchDestination#defaultValue
   */
  readonly defaultValue: string;

  /**
   * The name for the dimension
   *
   * @schema EventDestinationSpecForProviderCloudwatchDestination#dimensionName
   */
  readonly dimensionName: string;

  /**
   * The source for the value. May be any of "messageTag", "emailHeader" or "linkTag".
   *
   * @schema EventDestinationSpecForProviderCloudwatchDestination#valueSource
   */
  readonly valueSource: string;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderCloudwatchDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderCloudwatchDestination(obj: EventDestinationSpecForProviderCloudwatchDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultValue': obj.defaultValue,
    'dimensionName': obj.dimensionName,
    'valueSource': obj.valueSource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ConfigurationSet in ses to populate configurationSetName.
 *
 * @schema EventDestinationSpecForProviderConfigurationSetNameRef
 */
export interface EventDestinationSpecForProviderConfigurationSetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDestinationSpecForProviderConfigurationSetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDestinationSpecForProviderConfigurationSetNameRef#policy
   */
  readonly policy?: EventDestinationSpecForProviderConfigurationSetNameRefPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderConfigurationSetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderConfigurationSetNameRef(obj: EventDestinationSpecForProviderConfigurationSetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDestinationSpecForProviderConfigurationSetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ConfigurationSet in ses to populate configurationSetName.
 *
 * @schema EventDestinationSpecForProviderConfigurationSetNameSelector
 */
export interface EventDestinationSpecForProviderConfigurationSetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventDestinationSpecForProviderConfigurationSetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventDestinationSpecForProviderConfigurationSetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventDestinationSpecForProviderConfigurationSetNameSelector#policy
   */
  readonly policy?: EventDestinationSpecForProviderConfigurationSetNameSelectorPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderConfigurationSetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderConfigurationSetNameSelector(obj: EventDestinationSpecForProviderConfigurationSetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventDestinationSpecForProviderConfigurationSetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventDestinationSpecForProviderKinesisDestination
 */
export interface EventDestinationSpecForProviderKinesisDestination {
  /**
   * The ARN of the role that has permissions to access the Kinesis Stream
   *
   * @schema EventDestinationSpecForProviderKinesisDestination#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema EventDestinationSpecForProviderKinesisDestination#roleArnRef
   */
  readonly roleArnRef?: EventDestinationSpecForProviderKinesisDestinationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema EventDestinationSpecForProviderKinesisDestination#roleArnSelector
   */
  readonly roleArnSelector?: EventDestinationSpecForProviderKinesisDestinationRoleArnSelector;

  /**
   * The ARN of the Kinesis Stream
   *
   * @schema EventDestinationSpecForProviderKinesisDestination#streamArn
   */
  readonly streamArn?: string;

  /**
   * Reference to a DeliveryStream in firehose to populate streamArn.
   *
   * @schema EventDestinationSpecForProviderKinesisDestination#streamArnRef
   */
  readonly streamArnRef?: EventDestinationSpecForProviderKinesisDestinationStreamArnRef;

  /**
   * Selector for a DeliveryStream in firehose to populate streamArn.
   *
   * @schema EventDestinationSpecForProviderKinesisDestination#streamArnSelector
   */
  readonly streamArnSelector?: EventDestinationSpecForProviderKinesisDestinationStreamArnSelector;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderKinesisDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderKinesisDestination(obj: EventDestinationSpecForProviderKinesisDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_EventDestinationSpecForProviderKinesisDestinationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_EventDestinationSpecForProviderKinesisDestinationRoleArnSelector(obj.roleArnSelector),
    'streamArn': obj.streamArn,
    'streamArnRef': toJson_EventDestinationSpecForProviderKinesisDestinationStreamArnRef(obj.streamArnRef),
    'streamArnSelector': toJson_EventDestinationSpecForProviderKinesisDestinationStreamArnSelector(obj.streamArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventDestinationSpecForProviderSnsDestination
 */
export interface EventDestinationSpecForProviderSnsDestination {
  /**
   * The ARN of the SNS topic
   *
   * @schema EventDestinationSpecForProviderSnsDestination#topicArn
   */
  readonly topicArn?: string;

  /**
   * Reference to a Topic in sns to populate topicArn.
   *
   * @schema EventDestinationSpecForProviderSnsDestination#topicArnRef
   */
  readonly topicArnRef?: EventDestinationSpecForProviderSnsDestinationTopicArnRef;

  /**
   * Selector for a Topic in sns to populate topicArn.
   *
   * @schema EventDestinationSpecForProviderSnsDestination#topicArnSelector
   */
  readonly topicArnSelector?: EventDestinationSpecForProviderSnsDestinationTopicArnSelector;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderSnsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderSnsDestination(obj: EventDestinationSpecForProviderSnsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topicArn': obj.topicArn,
    'topicArnRef': toJson_EventDestinationSpecForProviderSnsDestinationTopicArnRef(obj.topicArnRef),
    'topicArnSelector': toJson_EventDestinationSpecForProviderSnsDestinationTopicArnSelector(obj.topicArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventDestinationSpecProviderConfigRefPolicy
 */
export interface EventDestinationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecProviderConfigRefPolicy(obj: EventDestinationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventDestinationSpecProviderRefPolicy
 */
export interface EventDestinationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecProviderRefPolicy(obj: EventDestinationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EventDestinationSpecPublishConnectionDetailsToConfigRef
 */
export interface EventDestinationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDestinationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDestinationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EventDestinationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecPublishConnectionDetailsToConfigRef(obj: EventDestinationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDestinationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EventDestinationSpecPublishConnectionDetailsToMetadata
 */
export interface EventDestinationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventDestinationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventDestinationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EventDestinationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EventDestinationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecPublishConnectionDetailsToMetadata(obj: EventDestinationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventDestinationSpecForProviderConfigurationSetNameRefPolicy
 */
export interface EventDestinationSpecForProviderConfigurationSetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecForProviderConfigurationSetNameRefPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecForProviderConfigurationSetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecForProviderConfigurationSetNameRefPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecForProviderConfigurationSetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderConfigurationSetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderConfigurationSetNameRefPolicy(obj: EventDestinationSpecForProviderConfigurationSetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventDestinationSpecForProviderConfigurationSetNameSelectorPolicy
 */
export interface EventDestinationSpecForProviderConfigurationSetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecForProviderConfigurationSetNameSelectorPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecForProviderConfigurationSetNameSelectorPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderConfigurationSetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderConfigurationSetNameSelectorPolicy(obj: EventDestinationSpecForProviderConfigurationSetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnRef
 */
export interface EventDestinationSpecForProviderKinesisDestinationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnRef#policy
   */
  readonly policy?: EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderKinesisDestinationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderKinesisDestinationRoleArnRef(obj: EventDestinationSpecForProviderKinesisDestinationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnSelector
 */
export interface EventDestinationSpecForProviderKinesisDestinationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnSelector#policy
   */
  readonly policy?: EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderKinesisDestinationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderKinesisDestinationRoleArnSelector(obj: EventDestinationSpecForProviderKinesisDestinationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DeliveryStream in firehose to populate streamArn.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnRef
 */
export interface EventDestinationSpecForProviderKinesisDestinationStreamArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnRef#policy
   */
  readonly policy?: EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderKinesisDestinationStreamArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderKinesisDestinationStreamArnRef(obj: EventDestinationSpecForProviderKinesisDestinationStreamArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DeliveryStream in firehose to populate streamArn.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnSelector
 */
export interface EventDestinationSpecForProviderKinesisDestinationStreamArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnSelector#policy
   */
  readonly policy?: EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderKinesisDestinationStreamArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderKinesisDestinationStreamArnSelector(obj: EventDestinationSpecForProviderKinesisDestinationStreamArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate topicArn.
 *
 * @schema EventDestinationSpecForProviderSnsDestinationTopicArnRef
 */
export interface EventDestinationSpecForProviderSnsDestinationTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDestinationSpecForProviderSnsDestinationTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDestinationSpecForProviderSnsDestinationTopicArnRef#policy
   */
  readonly policy?: EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderSnsDestinationTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderSnsDestinationTopicArnRef(obj: EventDestinationSpecForProviderSnsDestinationTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate topicArn.
 *
 * @schema EventDestinationSpecForProviderSnsDestinationTopicArnSelector
 */
export interface EventDestinationSpecForProviderSnsDestinationTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventDestinationSpecForProviderSnsDestinationTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventDestinationSpecForProviderSnsDestinationTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventDestinationSpecForProviderSnsDestinationTopicArnSelector#policy
   */
  readonly policy?: EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderSnsDestinationTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderSnsDestinationTopicArnSelector(obj: EventDestinationSpecForProviderSnsDestinationTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecProviderConfigRefPolicyResolution
 */
export enum EventDestinationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecProviderConfigRefPolicyResolve
 */
export enum EventDestinationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecProviderRefPolicyResolution
 */
export enum EventDestinationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecProviderRefPolicyResolve
 */
export enum EventDestinationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EventDestinationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EventDestinationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecPublishConnectionDetailsToConfigRefPolicy(obj: EventDestinationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecForProviderConfigurationSetNameRefPolicyResolution
 */
export enum EventDestinationSpecForProviderConfigurationSetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecForProviderConfigurationSetNameRefPolicyResolve
 */
export enum EventDestinationSpecForProviderConfigurationSetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolution
 */
export enum EventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolve
 */
export enum EventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicy
 */
export interface EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicy(obj: EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicy
 */
export interface EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicy(obj: EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicy
 */
export interface EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicy(obj: EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicy
 */
export interface EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicy(obj: EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicy
 */
export interface EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicy(obj: EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicy
 */
export interface EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicy(obj: EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicyResolution
 */
export enum EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicyResolve
 */
export enum EventDestinationSpecForProviderKinesisDestinationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicyResolution
 */
export enum EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicyResolve
 */
export enum EventDestinationSpecForProviderKinesisDestinationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicyResolution
 */
export enum EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicyResolve
 */
export enum EventDestinationSpecForProviderKinesisDestinationStreamArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicyResolution
 */
export enum EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicyResolve
 */
export enum EventDestinationSpecForProviderKinesisDestinationStreamArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicyResolution
 */
export enum EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicyResolve
 */
export enum EventDestinationSpecForProviderSnsDestinationTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicyResolution
 */
export enum EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicyResolve
 */
export enum EventDestinationSpecForProviderSnsDestinationTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IdentityNotificationTopic is the Schema for the IdentityNotificationTopics API. Setting AWS SES Identity Notification Topic
 *
 * @schema IdentityNotificationTopic
 */
export class IdentityNotificationTopic extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IdentityNotificationTopic"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'IdentityNotificationTopic',
  }

  /**
   * Renders a Kubernetes manifest for "IdentityNotificationTopic".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IdentityNotificationTopicProps): any {
    return {
      ...IdentityNotificationTopic.GVK,
      ...toJson_IdentityNotificationTopicProps(props),
    };
  }

  /**
   * Defines a "IdentityNotificationTopic" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IdentityNotificationTopicProps) {
    super(scope, id, {
      ...IdentityNotificationTopic.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IdentityNotificationTopic.GVK,
      ...toJson_IdentityNotificationTopicProps(resolved),
    };
  }
}

/**
 * IdentityNotificationTopic is the Schema for the IdentityNotificationTopics API. Setting AWS SES Identity Notification Topic
 *
 * @schema IdentityNotificationTopic
 */
export interface IdentityNotificationTopicProps {
  /**
   * @schema IdentityNotificationTopic#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IdentityNotificationTopicSpec defines the desired state of IdentityNotificationTopic
   *
   * @schema IdentityNotificationTopic#spec
   */
  readonly spec: IdentityNotificationTopicSpec;

}

/**
 * Converts an object of type 'IdentityNotificationTopicProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicProps(obj: IdentityNotificationTopicProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IdentityNotificationTopicSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IdentityNotificationTopicSpec defines the desired state of IdentityNotificationTopic
 *
 * @schema IdentityNotificationTopicSpec
 */
export interface IdentityNotificationTopicSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IdentityNotificationTopicSpec#deletionPolicy
   */
  readonly deletionPolicy?: IdentityNotificationTopicSpecDeletionPolicy;

  /**
   * @schema IdentityNotificationTopicSpec#forProvider
   */
  readonly forProvider: IdentityNotificationTopicSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IdentityNotificationTopicSpec#managementPolicy
   */
  readonly managementPolicy?: IdentityNotificationTopicSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IdentityNotificationTopicSpec#providerConfigRef
   */
  readonly providerConfigRef?: IdentityNotificationTopicSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IdentityNotificationTopicSpec#providerRef
   */
  readonly providerRef?: IdentityNotificationTopicSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IdentityNotificationTopicSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IdentityNotificationTopicSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IdentityNotificationTopicSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IdentityNotificationTopicSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpec(obj: IdentityNotificationTopicSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IdentityNotificationTopicSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_IdentityNotificationTopicSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IdentityNotificationTopicSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IdentityNotificationTopicSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IdentityNotificationTopicSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IdentityNotificationTopicSpecDeletionPolicy
 */
export enum IdentityNotificationTopicSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IdentityNotificationTopicSpecForProvider
 */
export interface IdentityNotificationTopicSpecForProvider {
  /**
   * The identity for which the Amazon SNS topic will be set. You can specify an identity by using its name or by using its Amazon Resource Name (ARN).
   *
   * @schema IdentityNotificationTopicSpecForProvider#identity
   */
  readonly identity?: string;

  /**
   * Reference to a DomainIdentity in ses to populate identity.
   *
   * @schema IdentityNotificationTopicSpecForProvider#identityRef
   */
  readonly identityRef?: IdentityNotificationTopicSpecForProviderIdentityRef;

  /**
   * Selector for a DomainIdentity in ses to populate identity.
   *
   * @schema IdentityNotificationTopicSpecForProvider#identitySelector
   */
  readonly identitySelector?: IdentityNotificationTopicSpecForProviderIdentitySelector;

  /**
   * Whether SES should include original email headers in SNS notifications of this type. false by default.
   *
   * @schema IdentityNotificationTopicSpecForProvider#includeOriginalHeaders
   */
  readonly includeOriginalHeaders?: boolean;

  /**
   * The type of notifications that will be published to the specified Amazon SNS topic. Valid Values: Bounce, Complaint or Delivery.
   *
   * @schema IdentityNotificationTopicSpecForProvider#notificationType
   */
  readonly notificationType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IdentityNotificationTopicSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the Amazon SNS topic. Can be set to "" (an empty string) to disable publishing.
   *
   * @schema IdentityNotificationTopicSpecForProvider#topicArn
   */
  readonly topicArn?: string;

  /**
   * Reference to a Topic in sns to populate topicArn.
   *
   * @schema IdentityNotificationTopicSpecForProvider#topicArnRef
   */
  readonly topicArnRef?: IdentityNotificationTopicSpecForProviderTopicArnRef;

  /**
   * Selector for a Topic in sns to populate topicArn.
   *
   * @schema IdentityNotificationTopicSpecForProvider#topicArnSelector
   */
  readonly topicArnSelector?: IdentityNotificationTopicSpecForProviderTopicArnSelector;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecForProvider(obj: IdentityNotificationTopicSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identity': obj.identity,
    'identityRef': toJson_IdentityNotificationTopicSpecForProviderIdentityRef(obj.identityRef),
    'identitySelector': toJson_IdentityNotificationTopicSpecForProviderIdentitySelector(obj.identitySelector),
    'includeOriginalHeaders': obj.includeOriginalHeaders,
    'notificationType': obj.notificationType,
    'region': obj.region,
    'topicArn': obj.topicArn,
    'topicArnRef': toJson_IdentityNotificationTopicSpecForProviderTopicArnRef(obj.topicArnRef),
    'topicArnSelector': toJson_IdentityNotificationTopicSpecForProviderTopicArnSelector(obj.topicArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IdentityNotificationTopicSpecManagementPolicy
 */
export enum IdentityNotificationTopicSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IdentityNotificationTopicSpecProviderConfigRef
 */
export interface IdentityNotificationTopicSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityNotificationTopicSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityNotificationTopicSpecProviderConfigRef#policy
   */
  readonly policy?: IdentityNotificationTopicSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecProviderConfigRef(obj: IdentityNotificationTopicSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityNotificationTopicSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IdentityNotificationTopicSpecProviderRef
 */
export interface IdentityNotificationTopicSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityNotificationTopicSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityNotificationTopicSpecProviderRef#policy
   */
  readonly policy?: IdentityNotificationTopicSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecProviderRef(obj: IdentityNotificationTopicSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityNotificationTopicSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IdentityNotificationTopicSpecPublishConnectionDetailsTo
 */
export interface IdentityNotificationTopicSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IdentityNotificationTopicSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IdentityNotificationTopicSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IdentityNotificationTopicSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IdentityNotificationTopicSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecPublishConnectionDetailsTo(obj: IdentityNotificationTopicSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IdentityNotificationTopicSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IdentityNotificationTopicSpecWriteConnectionSecretToRef
 */
export interface IdentityNotificationTopicSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IdentityNotificationTopicSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IdentityNotificationTopicSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecWriteConnectionSecretToRef(obj: IdentityNotificationTopicSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DomainIdentity in ses to populate identity.
 *
 * @schema IdentityNotificationTopicSpecForProviderIdentityRef
 */
export interface IdentityNotificationTopicSpecForProviderIdentityRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityNotificationTopicSpecForProviderIdentityRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityNotificationTopicSpecForProviderIdentityRef#policy
   */
  readonly policy?: IdentityNotificationTopicSpecForProviderIdentityRefPolicy;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecForProviderIdentityRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecForProviderIdentityRef(obj: IdentityNotificationTopicSpecForProviderIdentityRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityNotificationTopicSpecForProviderIdentityRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DomainIdentity in ses to populate identity.
 *
 * @schema IdentityNotificationTopicSpecForProviderIdentitySelector
 */
export interface IdentityNotificationTopicSpecForProviderIdentitySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IdentityNotificationTopicSpecForProviderIdentitySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IdentityNotificationTopicSpecForProviderIdentitySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IdentityNotificationTopicSpecForProviderIdentitySelector#policy
   */
  readonly policy?: IdentityNotificationTopicSpecForProviderIdentitySelectorPolicy;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecForProviderIdentitySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecForProviderIdentitySelector(obj: IdentityNotificationTopicSpecForProviderIdentitySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IdentityNotificationTopicSpecForProviderIdentitySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate topicArn.
 *
 * @schema IdentityNotificationTopicSpecForProviderTopicArnRef
 */
export interface IdentityNotificationTopicSpecForProviderTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityNotificationTopicSpecForProviderTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityNotificationTopicSpecForProviderTopicArnRef#policy
   */
  readonly policy?: IdentityNotificationTopicSpecForProviderTopicArnRefPolicy;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecForProviderTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecForProviderTopicArnRef(obj: IdentityNotificationTopicSpecForProviderTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityNotificationTopicSpecForProviderTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate topicArn.
 *
 * @schema IdentityNotificationTopicSpecForProviderTopicArnSelector
 */
export interface IdentityNotificationTopicSpecForProviderTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IdentityNotificationTopicSpecForProviderTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IdentityNotificationTopicSpecForProviderTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IdentityNotificationTopicSpecForProviderTopicArnSelector#policy
   */
  readonly policy?: IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecForProviderTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecForProviderTopicArnSelector(obj: IdentityNotificationTopicSpecForProviderTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityNotificationTopicSpecProviderConfigRefPolicy
 */
export interface IdentityNotificationTopicSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityNotificationTopicSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityNotificationTopicSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityNotificationTopicSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityNotificationTopicSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecProviderConfigRefPolicy(obj: IdentityNotificationTopicSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityNotificationTopicSpecProviderRefPolicy
 */
export interface IdentityNotificationTopicSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityNotificationTopicSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IdentityNotificationTopicSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityNotificationTopicSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IdentityNotificationTopicSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecProviderRefPolicy(obj: IdentityNotificationTopicSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRef
 */
export interface IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRef(obj: IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToMetadata
 */
export interface IdentityNotificationTopicSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecPublishConnectionDetailsToMetadata(obj: IdentityNotificationTopicSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityNotificationTopicSpecForProviderIdentityRefPolicy
 */
export interface IdentityNotificationTopicSpecForProviderIdentityRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityNotificationTopicSpecForProviderIdentityRefPolicy#resolution
   */
  readonly resolution?: IdentityNotificationTopicSpecForProviderIdentityRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityNotificationTopicSpecForProviderIdentityRefPolicy#resolve
   */
  readonly resolve?: IdentityNotificationTopicSpecForProviderIdentityRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecForProviderIdentityRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecForProviderIdentityRefPolicy(obj: IdentityNotificationTopicSpecForProviderIdentityRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IdentityNotificationTopicSpecForProviderIdentitySelectorPolicy
 */
export interface IdentityNotificationTopicSpecForProviderIdentitySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityNotificationTopicSpecForProviderIdentitySelectorPolicy#resolution
   */
  readonly resolution?: IdentityNotificationTopicSpecForProviderIdentitySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityNotificationTopicSpecForProviderIdentitySelectorPolicy#resolve
   */
  readonly resolve?: IdentityNotificationTopicSpecForProviderIdentitySelectorPolicyResolve;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecForProviderIdentitySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecForProviderIdentitySelectorPolicy(obj: IdentityNotificationTopicSpecForProviderIdentitySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityNotificationTopicSpecForProviderTopicArnRefPolicy
 */
export interface IdentityNotificationTopicSpecForProviderTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityNotificationTopicSpecForProviderTopicArnRefPolicy#resolution
   */
  readonly resolution?: IdentityNotificationTopicSpecForProviderTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityNotificationTopicSpecForProviderTopicArnRefPolicy#resolve
   */
  readonly resolve?: IdentityNotificationTopicSpecForProviderTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecForProviderTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecForProviderTopicArnRefPolicy(obj: IdentityNotificationTopicSpecForProviderTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicy
 */
export interface IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicy(obj: IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityNotificationTopicSpecProviderConfigRefPolicyResolution
 */
export enum IdentityNotificationTopicSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityNotificationTopicSpecProviderConfigRefPolicyResolve
 */
export enum IdentityNotificationTopicSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityNotificationTopicSpecProviderRefPolicyResolution
 */
export enum IdentityNotificationTopicSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityNotificationTopicSpecProviderRefPolicyResolve
 */
export enum IdentityNotificationTopicSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicy(obj: IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityNotificationTopicSpecForProviderIdentityRefPolicyResolution
 */
export enum IdentityNotificationTopicSpecForProviderIdentityRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityNotificationTopicSpecForProviderIdentityRefPolicyResolve
 */
export enum IdentityNotificationTopicSpecForProviderIdentityRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityNotificationTopicSpecForProviderIdentitySelectorPolicyResolution
 */
export enum IdentityNotificationTopicSpecForProviderIdentitySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityNotificationTopicSpecForProviderIdentitySelectorPolicyResolve
 */
export enum IdentityNotificationTopicSpecForProviderIdentitySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityNotificationTopicSpecForProviderTopicArnRefPolicyResolution
 */
export enum IdentityNotificationTopicSpecForProviderTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityNotificationTopicSpecForProviderTopicArnRefPolicyResolve
 */
export enum IdentityNotificationTopicSpecForProviderTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicyResolution
 */
export enum IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicyResolve
 */
export enum IdentityNotificationTopicSpecForProviderTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IdentityNotificationTopicSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IdentityPolicy is the Schema for the IdentityPolicys API. Manages a SES Identity Policy
 *
 * @schema IdentityPolicy
 */
export class IdentityPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IdentityPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'IdentityPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "IdentityPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IdentityPolicyProps): any {
    return {
      ...IdentityPolicy.GVK,
      ...toJson_IdentityPolicyProps(props),
    };
  }

  /**
   * Defines a "IdentityPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IdentityPolicyProps) {
    super(scope, id, {
      ...IdentityPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IdentityPolicy.GVK,
      ...toJson_IdentityPolicyProps(resolved),
    };
  }
}

/**
 * IdentityPolicy is the Schema for the IdentityPolicys API. Manages a SES Identity Policy
 *
 * @schema IdentityPolicy
 */
export interface IdentityPolicyProps {
  /**
   * @schema IdentityPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IdentityPolicySpec defines the desired state of IdentityPolicy
   *
   * @schema IdentityPolicy#spec
   */
  readonly spec: IdentityPolicySpec;

}

/**
 * Converts an object of type 'IdentityPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicyProps(obj: IdentityPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IdentityPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IdentityPolicySpec defines the desired state of IdentityPolicy
 *
 * @schema IdentityPolicySpec
 */
export interface IdentityPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IdentityPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: IdentityPolicySpecDeletionPolicy;

  /**
   * @schema IdentityPolicySpec#forProvider
   */
  readonly forProvider: IdentityPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IdentityPolicySpec#managementPolicy
   */
  readonly managementPolicy?: IdentityPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IdentityPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: IdentityPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IdentityPolicySpec#providerRef
   */
  readonly providerRef?: IdentityPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IdentityPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IdentityPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IdentityPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IdentityPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IdentityPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpec(obj: IdentityPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IdentityPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_IdentityPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IdentityPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IdentityPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IdentityPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IdentityPolicySpecDeletionPolicy
 */
export enum IdentityPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IdentityPolicySpecForProvider
 */
export interface IdentityPolicySpecForProvider {
  /**
   * Name or Amazon Resource Name (ARN) of the SES Identity.
   *
   * @schema IdentityPolicySpecForProvider#identity
   */
  readonly identity?: string;

  /**
   * Reference to a DomainIdentity in ses to populate identity.
   *
   * @schema IdentityPolicySpecForProvider#identityRef
   */
  readonly identityRef?: IdentityPolicySpecForProviderIdentityRef;

  /**
   * Selector for a DomainIdentity in ses to populate identity.
   *
   * @schema IdentityPolicySpecForProvider#identitySelector
   */
  readonly identitySelector?: IdentityPolicySpecForProviderIdentitySelector;

  /**
   * Name of the policy.
   *
   * @schema IdentityPolicySpecForProvider#name
   */
  readonly name?: string;

  /**
   * JSON string of the policy.
   *
   * @schema IdentityPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IdentityPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'IdentityPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecForProvider(obj: IdentityPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identity': obj.identity,
    'identityRef': toJson_IdentityPolicySpecForProviderIdentityRef(obj.identityRef),
    'identitySelector': toJson_IdentityPolicySpecForProviderIdentitySelector(obj.identitySelector),
    'name': obj.name,
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IdentityPolicySpecManagementPolicy
 */
export enum IdentityPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IdentityPolicySpecProviderConfigRef
 */
export interface IdentityPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityPolicySpecProviderConfigRef#policy
   */
  readonly policy?: IdentityPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecProviderConfigRef(obj: IdentityPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IdentityPolicySpecProviderRef
 */
export interface IdentityPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityPolicySpecProviderRef#policy
   */
  readonly policy?: IdentityPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IdentityPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecProviderRef(obj: IdentityPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IdentityPolicySpecPublishConnectionDetailsTo
 */
export interface IdentityPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IdentityPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IdentityPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IdentityPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IdentityPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IdentityPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IdentityPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecPublishConnectionDetailsTo(obj: IdentityPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IdentityPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IdentityPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IdentityPolicySpecWriteConnectionSecretToRef
 */
export interface IdentityPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IdentityPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IdentityPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IdentityPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecWriteConnectionSecretToRef(obj: IdentityPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DomainIdentity in ses to populate identity.
 *
 * @schema IdentityPolicySpecForProviderIdentityRef
 */
export interface IdentityPolicySpecForProviderIdentityRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityPolicySpecForProviderIdentityRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityPolicySpecForProviderIdentityRef#policy
   */
  readonly policy?: IdentityPolicySpecForProviderIdentityRefPolicy;

}

/**
 * Converts an object of type 'IdentityPolicySpecForProviderIdentityRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecForProviderIdentityRef(obj: IdentityPolicySpecForProviderIdentityRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityPolicySpecForProviderIdentityRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DomainIdentity in ses to populate identity.
 *
 * @schema IdentityPolicySpecForProviderIdentitySelector
 */
export interface IdentityPolicySpecForProviderIdentitySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IdentityPolicySpecForProviderIdentitySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IdentityPolicySpecForProviderIdentitySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IdentityPolicySpecForProviderIdentitySelector#policy
   */
  readonly policy?: IdentityPolicySpecForProviderIdentitySelectorPolicy;

}

/**
 * Converts an object of type 'IdentityPolicySpecForProviderIdentitySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecForProviderIdentitySelector(obj: IdentityPolicySpecForProviderIdentitySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IdentityPolicySpecForProviderIdentitySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityPolicySpecProviderConfigRefPolicy
 */
export interface IdentityPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecProviderConfigRefPolicy(obj: IdentityPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityPolicySpecProviderRefPolicy
 */
export interface IdentityPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: IdentityPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: IdentityPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecProviderRefPolicy(obj: IdentityPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IdentityPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface IdentityPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecPublishConnectionDetailsToConfigRef(obj: IdentityPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IdentityPolicySpecPublishConnectionDetailsToMetadata
 */
export interface IdentityPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IdentityPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IdentityPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecPublishConnectionDetailsToMetadata(obj: IdentityPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityPolicySpecForProviderIdentityRefPolicy
 */
export interface IdentityPolicySpecForProviderIdentityRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityPolicySpecForProviderIdentityRefPolicy#resolution
   */
  readonly resolution?: IdentityPolicySpecForProviderIdentityRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityPolicySpecForProviderIdentityRefPolicy#resolve
   */
  readonly resolve?: IdentityPolicySpecForProviderIdentityRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityPolicySpecForProviderIdentityRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecForProviderIdentityRefPolicy(obj: IdentityPolicySpecForProviderIdentityRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IdentityPolicySpecForProviderIdentitySelectorPolicy
 */
export interface IdentityPolicySpecForProviderIdentitySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityPolicySpecForProviderIdentitySelectorPolicy#resolution
   */
  readonly resolution?: IdentityPolicySpecForProviderIdentitySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityPolicySpecForProviderIdentitySelectorPolicy#resolve
   */
  readonly resolve?: IdentityPolicySpecForProviderIdentitySelectorPolicyResolve;

}

/**
 * Converts an object of type 'IdentityPolicySpecForProviderIdentitySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecForProviderIdentitySelectorPolicy(obj: IdentityPolicySpecForProviderIdentitySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityPolicySpecProviderConfigRefPolicyResolution
 */
export enum IdentityPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityPolicySpecProviderConfigRefPolicyResolve
 */
export enum IdentityPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityPolicySpecProviderRefPolicyResolution
 */
export enum IdentityPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityPolicySpecProviderRefPolicyResolve
 */
export enum IdentityPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityPolicySpecForProviderIdentityRefPolicyResolution
 */
export enum IdentityPolicySpecForProviderIdentityRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityPolicySpecForProviderIdentityRefPolicyResolve
 */
export enum IdentityPolicySpecForProviderIdentityRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityPolicySpecForProviderIdentitySelectorPolicyResolution
 */
export enum IdentityPolicySpecForProviderIdentitySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityPolicySpecForProviderIdentitySelectorPolicyResolve
 */
export enum IdentityPolicySpecForProviderIdentitySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IdentityPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReceiptFilter is the Schema for the ReceiptFilters API. Provides an SES receipt filter
 *
 * @schema ReceiptFilter
 */
export class ReceiptFilter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReceiptFilter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'ReceiptFilter',
  }

  /**
   * Renders a Kubernetes manifest for "ReceiptFilter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReceiptFilterProps): any {
    return {
      ...ReceiptFilter.GVK,
      ...toJson_ReceiptFilterProps(props),
    };
  }

  /**
   * Defines a "ReceiptFilter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReceiptFilterProps) {
    super(scope, id, {
      ...ReceiptFilter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReceiptFilter.GVK,
      ...toJson_ReceiptFilterProps(resolved),
    };
  }
}

/**
 * ReceiptFilter is the Schema for the ReceiptFilters API. Provides an SES receipt filter
 *
 * @schema ReceiptFilter
 */
export interface ReceiptFilterProps {
  /**
   * @schema ReceiptFilter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReceiptFilterSpec defines the desired state of ReceiptFilter
   *
   * @schema ReceiptFilter#spec
   */
  readonly spec: ReceiptFilterSpec;

}

/**
 * Converts an object of type 'ReceiptFilterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterProps(obj: ReceiptFilterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReceiptFilterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReceiptFilterSpec defines the desired state of ReceiptFilter
 *
 * @schema ReceiptFilterSpec
 */
export interface ReceiptFilterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReceiptFilterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReceiptFilterSpecDeletionPolicy;

  /**
   * @schema ReceiptFilterSpec#forProvider
   */
  readonly forProvider: ReceiptFilterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReceiptFilterSpec#managementPolicy
   */
  readonly managementPolicy?: ReceiptFilterSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReceiptFilterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReceiptFilterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReceiptFilterSpec#providerRef
   */
  readonly providerRef?: ReceiptFilterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReceiptFilterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReceiptFilterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReceiptFilterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReceiptFilterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReceiptFilterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpec(obj: ReceiptFilterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReceiptFilterSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ReceiptFilterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReceiptFilterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReceiptFilterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReceiptFilterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReceiptFilterSpecDeletionPolicy
 */
export enum ReceiptFilterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReceiptFilterSpecForProvider
 */
export interface ReceiptFilterSpecForProvider {
  /**
   * The IP address or address range to filter, in CIDR notation
   *
   * @schema ReceiptFilterSpecForProvider#cidr
   */
  readonly cidr?: string;

  /**
   * Block or Allow
   *
   * @schema ReceiptFilterSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ReceiptFilterSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ReceiptFilterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpecForProvider(obj: ReceiptFilterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReceiptFilterSpecManagementPolicy
 */
export enum ReceiptFilterSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReceiptFilterSpecProviderConfigRef
 */
export interface ReceiptFilterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReceiptFilterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReceiptFilterSpecProviderConfigRef#policy
   */
  readonly policy?: ReceiptFilterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReceiptFilterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpecProviderConfigRef(obj: ReceiptFilterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReceiptFilterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReceiptFilterSpecProviderRef
 */
export interface ReceiptFilterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReceiptFilterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReceiptFilterSpecProviderRef#policy
   */
  readonly policy?: ReceiptFilterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReceiptFilterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpecProviderRef(obj: ReceiptFilterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReceiptFilterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReceiptFilterSpecPublishConnectionDetailsTo
 */
export interface ReceiptFilterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReceiptFilterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReceiptFilterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReceiptFilterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReceiptFilterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReceiptFilterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReceiptFilterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpecPublishConnectionDetailsTo(obj: ReceiptFilterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReceiptFilterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReceiptFilterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReceiptFilterSpecWriteConnectionSecretToRef
 */
export interface ReceiptFilterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReceiptFilterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReceiptFilterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReceiptFilterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpecWriteConnectionSecretToRef(obj: ReceiptFilterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReceiptFilterSpecProviderConfigRefPolicy
 */
export interface ReceiptFilterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReceiptFilterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReceiptFilterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReceiptFilterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReceiptFilterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReceiptFilterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpecProviderConfigRefPolicy(obj: ReceiptFilterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReceiptFilterSpecProviderRefPolicy
 */
export interface ReceiptFilterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReceiptFilterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReceiptFilterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReceiptFilterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReceiptFilterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReceiptFilterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpecProviderRefPolicy(obj: ReceiptFilterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReceiptFilterSpecPublishConnectionDetailsToConfigRef
 */
export interface ReceiptFilterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReceiptFilterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReceiptFilterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReceiptFilterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpecPublishConnectionDetailsToConfigRef(obj: ReceiptFilterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReceiptFilterSpecPublishConnectionDetailsToMetadata
 */
export interface ReceiptFilterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReceiptFilterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReceiptFilterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReceiptFilterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReceiptFilterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpecPublishConnectionDetailsToMetadata(obj: ReceiptFilterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReceiptFilterSpecProviderConfigRefPolicyResolution
 */
export enum ReceiptFilterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReceiptFilterSpecProviderConfigRefPolicyResolve
 */
export enum ReceiptFilterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReceiptFilterSpecProviderRefPolicyResolution
 */
export enum ReceiptFilterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReceiptFilterSpecProviderRefPolicyResolve
 */
export enum ReceiptFilterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReceiptFilterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReceiptRule is the Schema for the ReceiptRules API. Provides an SES receipt rule resource
 *
 * @schema ReceiptRule
 */
export class ReceiptRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReceiptRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'ReceiptRule',
  }

  /**
   * Renders a Kubernetes manifest for "ReceiptRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReceiptRuleProps): any {
    return {
      ...ReceiptRule.GVK,
      ...toJson_ReceiptRuleProps(props),
    };
  }

  /**
   * Defines a "ReceiptRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReceiptRuleProps) {
    super(scope, id, {
      ...ReceiptRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReceiptRule.GVK,
      ...toJson_ReceiptRuleProps(resolved),
    };
  }
}

/**
 * ReceiptRule is the Schema for the ReceiptRules API. Provides an SES receipt rule resource
 *
 * @schema ReceiptRule
 */
export interface ReceiptRuleProps {
  /**
   * @schema ReceiptRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReceiptRuleSpec defines the desired state of ReceiptRule
   *
   * @schema ReceiptRule#spec
   */
  readonly spec: ReceiptRuleSpec;

}

/**
 * Converts an object of type 'ReceiptRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleProps(obj: ReceiptRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReceiptRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReceiptRuleSpec defines the desired state of ReceiptRule
 *
 * @schema ReceiptRuleSpec
 */
export interface ReceiptRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReceiptRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReceiptRuleSpecDeletionPolicy;

  /**
   * @schema ReceiptRuleSpec#forProvider
   */
  readonly forProvider: ReceiptRuleSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReceiptRuleSpec#managementPolicy
   */
  readonly managementPolicy?: ReceiptRuleSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReceiptRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReceiptRuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReceiptRuleSpec#providerRef
   */
  readonly providerRef?: ReceiptRuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReceiptRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReceiptRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReceiptRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReceiptRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReceiptRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpec(obj: ReceiptRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReceiptRuleSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ReceiptRuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReceiptRuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReceiptRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReceiptRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReceiptRuleSpecDeletionPolicy
 */
export enum ReceiptRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReceiptRuleSpecForProvider
 */
export interface ReceiptRuleSpecForProvider {
  /**
   * A list of Add Header Action blocks. Documented below.
   *
   * @schema ReceiptRuleSpecForProvider#addHeaderAction
   */
  readonly addHeaderAction?: ReceiptRuleSpecForProviderAddHeaderAction[];

  /**
   * The name of the rule to place this rule after
   *
   * @schema ReceiptRuleSpecForProvider#after
   */
  readonly after?: string;

  /**
   * A list of Bounce Action blocks. Documented below.
   *
   * @schema ReceiptRuleSpecForProvider#bounceAction
   */
  readonly bounceAction?: ReceiptRuleSpecForProviderBounceAction[];

  /**
   * If true, the rule will be enabled
   *
   * @schema ReceiptRuleSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * A list of Lambda Action blocks. Documented below.
   *
   * @schema ReceiptRuleSpecForProvider#lambdaAction
   */
  readonly lambdaAction?: ReceiptRuleSpecForProviderLambdaAction[];

  /**
   * The name of the rule
   *
   * @schema ReceiptRuleSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A list of email addresses
   *
   * @schema ReceiptRuleSpecForProvider#recipients
   */
  readonly recipients?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ReceiptRuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the rule set
   *
   * @schema ReceiptRuleSpecForProvider#ruleSetName
   */
  readonly ruleSetName?: string;

  /**
   * A list of S3 Action blocks. Documented below.
   *
   * @schema ReceiptRuleSpecForProvider#s3Action
   */
  readonly s3Action?: ReceiptRuleSpecForProviderS3Action[];

  /**
   * If true, incoming emails will be scanned for spam and viruses
   *
   * @schema ReceiptRuleSpecForProvider#scanEnabled
   */
  readonly scanEnabled?: boolean;

  /**
   * A list of SNS Action blocks. Documented below.
   *
   * @schema ReceiptRuleSpecForProvider#snsAction
   */
  readonly snsAction?: ReceiptRuleSpecForProviderSnsAction[];

  /**
   * A list of Stop Action blocks. Documented below.
   *
   * @schema ReceiptRuleSpecForProvider#stopAction
   */
  readonly stopAction?: ReceiptRuleSpecForProviderStopAction[];

  /**
   * Require or Optional
   *
   * @schema ReceiptRuleSpecForProvider#tlsPolicy
   */
  readonly tlsPolicy?: string;

  /**
   * A list of WorkMail Action blocks. Documented below.
   *
   * @schema ReceiptRuleSpecForProvider#workmailAction
   */
  readonly workmailAction?: ReceiptRuleSpecForProviderWorkmailAction[];

}

/**
 * Converts an object of type 'ReceiptRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecForProvider(obj: ReceiptRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addHeaderAction': obj.addHeaderAction?.map(y => toJson_ReceiptRuleSpecForProviderAddHeaderAction(y)),
    'after': obj.after,
    'bounceAction': obj.bounceAction?.map(y => toJson_ReceiptRuleSpecForProviderBounceAction(y)),
    'enabled': obj.enabled,
    'lambdaAction': obj.lambdaAction?.map(y => toJson_ReceiptRuleSpecForProviderLambdaAction(y)),
    'name': obj.name,
    'recipients': obj.recipients?.map(y => y),
    'region': obj.region,
    'ruleSetName': obj.ruleSetName,
    's3Action': obj.s3Action?.map(y => toJson_ReceiptRuleSpecForProviderS3Action(y)),
    'scanEnabled': obj.scanEnabled,
    'snsAction': obj.snsAction?.map(y => toJson_ReceiptRuleSpecForProviderSnsAction(y)),
    'stopAction': obj.stopAction?.map(y => toJson_ReceiptRuleSpecForProviderStopAction(y)),
    'tlsPolicy': obj.tlsPolicy,
    'workmailAction': obj.workmailAction?.map(y => toJson_ReceiptRuleSpecForProviderWorkmailAction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReceiptRuleSpecManagementPolicy
 */
export enum ReceiptRuleSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReceiptRuleSpecProviderConfigRef
 */
export interface ReceiptRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReceiptRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReceiptRuleSpecProviderConfigRef#policy
   */
  readonly policy?: ReceiptRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReceiptRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecProviderConfigRef(obj: ReceiptRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReceiptRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReceiptRuleSpecProviderRef
 */
export interface ReceiptRuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReceiptRuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReceiptRuleSpecProviderRef#policy
   */
  readonly policy?: ReceiptRuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReceiptRuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecProviderRef(obj: ReceiptRuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReceiptRuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReceiptRuleSpecPublishConnectionDetailsTo
 */
export interface ReceiptRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReceiptRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReceiptRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReceiptRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReceiptRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReceiptRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReceiptRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecPublishConnectionDetailsTo(obj: ReceiptRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReceiptRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReceiptRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReceiptRuleSpecWriteConnectionSecretToRef
 */
export interface ReceiptRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReceiptRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReceiptRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReceiptRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecWriteConnectionSecretToRef(obj: ReceiptRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReceiptRuleSpecForProviderAddHeaderAction
 */
export interface ReceiptRuleSpecForProviderAddHeaderAction {
  /**
   * The name of the header to add
   *
   * @schema ReceiptRuleSpecForProviderAddHeaderAction#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add
   *
   * @schema ReceiptRuleSpecForProviderAddHeaderAction#headerValue
   */
  readonly headerValue: string;

  /**
   * The position of the action in the receipt rule
   *
   * @schema ReceiptRuleSpecForProviderAddHeaderAction#position
   */
  readonly position: number;

}

/**
 * Converts an object of type 'ReceiptRuleSpecForProviderAddHeaderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecForProviderAddHeaderAction(obj: ReceiptRuleSpecForProviderAddHeaderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'position': obj.position,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReceiptRuleSpecForProviderBounceAction
 */
export interface ReceiptRuleSpecForProviderBounceAction {
  /**
   * The message to send
   *
   * @schema ReceiptRuleSpecForProviderBounceAction#message
   */
  readonly message: string;

  /**
   * The position of the action in the receipt rule
   *
   * @schema ReceiptRuleSpecForProviderBounceAction#position
   */
  readonly position: number;

  /**
   * The email address of the sender
   *
   * @schema ReceiptRuleSpecForProviderBounceAction#sender
   */
  readonly sender: string;

  /**
   * The RFC 5321 SMTP reply code
   *
   * @schema ReceiptRuleSpecForProviderBounceAction#smtpReplyCode
   */
  readonly smtpReplyCode: string;

  /**
   * The RFC 3463 SMTP enhanced status code
   *
   * @schema ReceiptRuleSpecForProviderBounceAction#statusCode
   */
  readonly statusCode?: string;

  /**
   * The ARN of an SNS topic to notify
   *
   * @schema ReceiptRuleSpecForProviderBounceAction#topicArn
   */
  readonly topicArn?: string;

}

/**
 * Converts an object of type 'ReceiptRuleSpecForProviderBounceAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecForProviderBounceAction(obj: ReceiptRuleSpecForProviderBounceAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'message': obj.message,
    'position': obj.position,
    'sender': obj.sender,
    'smtpReplyCode': obj.smtpReplyCode,
    'statusCode': obj.statusCode,
    'topicArn': obj.topicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReceiptRuleSpecForProviderLambdaAction
 */
export interface ReceiptRuleSpecForProviderLambdaAction {
  /**
   * The ARN of the Lambda function to invoke
   *
   * @schema ReceiptRuleSpecForProviderLambdaAction#functionArn
   */
  readonly functionArn: string;

  /**
   * Event or RequestResponse
   *
   * @schema ReceiptRuleSpecForProviderLambdaAction#invocationType
   */
  readonly invocationType?: string;

  /**
   * The position of the action in the receipt rule
   *
   * @schema ReceiptRuleSpecForProviderLambdaAction#position
   */
  readonly position: number;

  /**
   * The ARN of an SNS topic to notify
   *
   * @schema ReceiptRuleSpecForProviderLambdaAction#topicArn
   */
  readonly topicArn?: string;

}

/**
 * Converts an object of type 'ReceiptRuleSpecForProviderLambdaAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecForProviderLambdaAction(obj: ReceiptRuleSpecForProviderLambdaAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionArn': obj.functionArn,
    'invocationType': obj.invocationType,
    'position': obj.position,
    'topicArn': obj.topicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReceiptRuleSpecForProviderS3Action
 */
export interface ReceiptRuleSpecForProviderS3Action {
  /**
   * The name of the S3 bucket
   *
   * @schema ReceiptRuleSpecForProviderS3Action#bucketName
   */
  readonly bucketName: string;

  /**
   * The ARN of the KMS key
   *
   * @schema ReceiptRuleSpecForProviderS3Action#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * The key prefix of the S3 bucket
   *
   * @schema ReceiptRuleSpecForProviderS3Action#objectKeyPrefix
   */
  readonly objectKeyPrefix?: string;

  /**
   * The position of the action in the receipt rule
   *
   * @schema ReceiptRuleSpecForProviderS3Action#position
   */
  readonly position: number;

  /**
   * The ARN of an SNS topic to notify
   *
   * @schema ReceiptRuleSpecForProviderS3Action#topicArn
   */
  readonly topicArn?: string;

}

/**
 * Converts an object of type 'ReceiptRuleSpecForProviderS3Action' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecForProviderS3Action(obj: ReceiptRuleSpecForProviderS3Action | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'kmsKeyArn': obj.kmsKeyArn,
    'objectKeyPrefix': obj.objectKeyPrefix,
    'position': obj.position,
    'topicArn': obj.topicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReceiptRuleSpecForProviderSnsAction
 */
export interface ReceiptRuleSpecForProviderSnsAction {
  /**
   * The encoding to use for the email within the Amazon SNS notification. Default value is UTF-8.
   *
   * @schema ReceiptRuleSpecForProviderSnsAction#encoding
   */
  readonly encoding?: string;

  /**
   * The position of the action in the receipt rule
   *
   * @schema ReceiptRuleSpecForProviderSnsAction#position
   */
  readonly position: number;

  /**
   * The ARN of an SNS topic to notify
   *
   * @schema ReceiptRuleSpecForProviderSnsAction#topicArn
   */
  readonly topicArn: string;

}

/**
 * Converts an object of type 'ReceiptRuleSpecForProviderSnsAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecForProviderSnsAction(obj: ReceiptRuleSpecForProviderSnsAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encoding': obj.encoding,
    'position': obj.position,
    'topicArn': obj.topicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReceiptRuleSpecForProviderStopAction
 */
export interface ReceiptRuleSpecForProviderStopAction {
  /**
   * The position of the action in the receipt rule
   *
   * @schema ReceiptRuleSpecForProviderStopAction#position
   */
  readonly position: number;

  /**
   * The scope to apply. The only acceptable value is RuleSet.
   *
   * @schema ReceiptRuleSpecForProviderStopAction#scope
   */
  readonly scope: string;

  /**
   * The ARN of an SNS topic to notify
   *
   * @schema ReceiptRuleSpecForProviderStopAction#topicArn
   */
  readonly topicArn?: string;

}

/**
 * Converts an object of type 'ReceiptRuleSpecForProviderStopAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecForProviderStopAction(obj: ReceiptRuleSpecForProviderStopAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'position': obj.position,
    'scope': obj.scope,
    'topicArn': obj.topicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReceiptRuleSpecForProviderWorkmailAction
 */
export interface ReceiptRuleSpecForProviderWorkmailAction {
  /**
   * The ARN of the WorkMail organization
   *
   * @schema ReceiptRuleSpecForProviderWorkmailAction#organizationArn
   */
  readonly organizationArn: string;

  /**
   * The position of the action in the receipt rule
   *
   * @schema ReceiptRuleSpecForProviderWorkmailAction#position
   */
  readonly position: number;

  /**
   * The ARN of an SNS topic to notify
   *
   * @schema ReceiptRuleSpecForProviderWorkmailAction#topicArn
   */
  readonly topicArn?: string;

}

/**
 * Converts an object of type 'ReceiptRuleSpecForProviderWorkmailAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecForProviderWorkmailAction(obj: ReceiptRuleSpecForProviderWorkmailAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'organizationArn': obj.organizationArn,
    'position': obj.position,
    'topicArn': obj.topicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReceiptRuleSpecProviderConfigRefPolicy
 */
export interface ReceiptRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReceiptRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReceiptRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReceiptRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReceiptRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReceiptRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecProviderConfigRefPolicy(obj: ReceiptRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReceiptRuleSpecProviderRefPolicy
 */
export interface ReceiptRuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReceiptRuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReceiptRuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReceiptRuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReceiptRuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReceiptRuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecProviderRefPolicy(obj: ReceiptRuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReceiptRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface ReceiptRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReceiptRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReceiptRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReceiptRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecPublishConnectionDetailsToConfigRef(obj: ReceiptRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReceiptRuleSpecPublishConnectionDetailsToMetadata
 */
export interface ReceiptRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReceiptRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReceiptRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReceiptRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReceiptRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecPublishConnectionDetailsToMetadata(obj: ReceiptRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReceiptRuleSpecProviderConfigRefPolicyResolution
 */
export enum ReceiptRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReceiptRuleSpecProviderConfigRefPolicyResolve
 */
export enum ReceiptRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReceiptRuleSpecProviderRefPolicyResolution
 */
export enum ReceiptRuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReceiptRuleSpecProviderRefPolicyResolve
 */
export enum ReceiptRuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReceiptRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReceiptRuleSet is the Schema for the ReceiptRuleSets API. Provides an SES receipt rule set resource
 *
 * @schema ReceiptRuleSet
 */
export class ReceiptRuleSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReceiptRuleSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'ReceiptRuleSet',
  }

  /**
   * Renders a Kubernetes manifest for "ReceiptRuleSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReceiptRuleSetProps): any {
    return {
      ...ReceiptRuleSet.GVK,
      ...toJson_ReceiptRuleSetProps(props),
    };
  }

  /**
   * Defines a "ReceiptRuleSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReceiptRuleSetProps) {
    super(scope, id, {
      ...ReceiptRuleSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReceiptRuleSet.GVK,
      ...toJson_ReceiptRuleSetProps(resolved),
    };
  }
}

/**
 * ReceiptRuleSet is the Schema for the ReceiptRuleSets API. Provides an SES receipt rule set resource
 *
 * @schema ReceiptRuleSet
 */
export interface ReceiptRuleSetProps {
  /**
   * @schema ReceiptRuleSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReceiptRuleSetSpec defines the desired state of ReceiptRuleSet
   *
   * @schema ReceiptRuleSet#spec
   */
  readonly spec: ReceiptRuleSetSpec;

}

/**
 * Converts an object of type 'ReceiptRuleSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetProps(obj: ReceiptRuleSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReceiptRuleSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReceiptRuleSetSpec defines the desired state of ReceiptRuleSet
 *
 * @schema ReceiptRuleSetSpec
 */
export interface ReceiptRuleSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReceiptRuleSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReceiptRuleSetSpecDeletionPolicy;

  /**
   * @schema ReceiptRuleSetSpec#forProvider
   */
  readonly forProvider: ReceiptRuleSetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReceiptRuleSetSpec#managementPolicy
   */
  readonly managementPolicy?: ReceiptRuleSetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReceiptRuleSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReceiptRuleSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReceiptRuleSetSpec#providerRef
   */
  readonly providerRef?: ReceiptRuleSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReceiptRuleSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReceiptRuleSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReceiptRuleSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReceiptRuleSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpec(obj: ReceiptRuleSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReceiptRuleSetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ReceiptRuleSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReceiptRuleSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReceiptRuleSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReceiptRuleSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReceiptRuleSetSpecDeletionPolicy
 */
export enum ReceiptRuleSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReceiptRuleSetSpecForProvider
 */
export interface ReceiptRuleSetSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ReceiptRuleSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Name of the rule set.
   *
   * @schema ReceiptRuleSetSpecForProvider#ruleSetName
   */
  readonly ruleSetName?: string;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpecForProvider(obj: ReceiptRuleSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'ruleSetName': obj.ruleSetName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReceiptRuleSetSpecManagementPolicy
 */
export enum ReceiptRuleSetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReceiptRuleSetSpecProviderConfigRef
 */
export interface ReceiptRuleSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReceiptRuleSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReceiptRuleSetSpecProviderConfigRef#policy
   */
  readonly policy?: ReceiptRuleSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpecProviderConfigRef(obj: ReceiptRuleSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReceiptRuleSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReceiptRuleSetSpecProviderRef
 */
export interface ReceiptRuleSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReceiptRuleSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReceiptRuleSetSpecProviderRef#policy
   */
  readonly policy?: ReceiptRuleSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpecProviderRef(obj: ReceiptRuleSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReceiptRuleSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReceiptRuleSetSpecPublishConnectionDetailsTo
 */
export interface ReceiptRuleSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReceiptRuleSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReceiptRuleSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReceiptRuleSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReceiptRuleSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReceiptRuleSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpecPublishConnectionDetailsTo(obj: ReceiptRuleSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReceiptRuleSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReceiptRuleSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReceiptRuleSetSpecWriteConnectionSecretToRef
 */
export interface ReceiptRuleSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReceiptRuleSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReceiptRuleSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpecWriteConnectionSecretToRef(obj: ReceiptRuleSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReceiptRuleSetSpecProviderConfigRefPolicy
 */
export interface ReceiptRuleSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReceiptRuleSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReceiptRuleSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReceiptRuleSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReceiptRuleSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpecProviderConfigRefPolicy(obj: ReceiptRuleSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReceiptRuleSetSpecProviderRefPolicy
 */
export interface ReceiptRuleSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReceiptRuleSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReceiptRuleSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReceiptRuleSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReceiptRuleSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpecProviderRefPolicy(obj: ReceiptRuleSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReceiptRuleSetSpecPublishConnectionDetailsToConfigRef
 */
export interface ReceiptRuleSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReceiptRuleSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReceiptRuleSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpecPublishConnectionDetailsToConfigRef(obj: ReceiptRuleSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReceiptRuleSetSpecPublishConnectionDetailsToMetadata
 */
export interface ReceiptRuleSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReceiptRuleSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReceiptRuleSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReceiptRuleSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpecPublishConnectionDetailsToMetadata(obj: ReceiptRuleSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReceiptRuleSetSpecProviderConfigRefPolicyResolution
 */
export enum ReceiptRuleSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReceiptRuleSetSpecProviderConfigRefPolicyResolve
 */
export enum ReceiptRuleSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReceiptRuleSetSpecProviderRefPolicyResolution
 */
export enum ReceiptRuleSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReceiptRuleSetSpecProviderRefPolicyResolve
 */
export enum ReceiptRuleSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReceiptRuleSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Template is the Schema for the Templates API. Provides a resource to create a SES template
 *
 * @schema Template
 */
export class Template extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Template"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ses.aws.upbound.io/v1beta1',
    kind: 'Template',
  }

  /**
   * Renders a Kubernetes manifest for "Template".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TemplateProps): any {
    return {
      ...Template.GVK,
      ...toJson_TemplateProps(props),
    };
  }

  /**
   * Defines a "Template" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TemplateProps) {
    super(scope, id, {
      ...Template.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Template.GVK,
      ...toJson_TemplateProps(resolved),
    };
  }
}

/**
 * Template is the Schema for the Templates API. Provides a resource to create a SES template
 *
 * @schema Template
 */
export interface TemplateProps {
  /**
   * @schema Template#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TemplateSpec defines the desired state of Template
   *
   * @schema Template#spec
   */
  readonly spec: TemplateSpec;

}

/**
 * Converts an object of type 'TemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateProps(obj: TemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TemplateSpec defines the desired state of Template
 *
 * @schema TemplateSpec
 */
export interface TemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: TemplateSpecDeletionPolicy;

  /**
   * @schema TemplateSpec#forProvider
   */
  readonly forProvider: TemplateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TemplateSpec#managementPolicy
   */
  readonly managementPolicy?: TemplateSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: TemplateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TemplateSpec#providerRef
   */
  readonly providerRef?: TemplateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpec(obj: TemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TemplateSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TemplateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TemplateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TemplateSpecDeletionPolicy
 */
export enum TemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TemplateSpecForProvider
 */
export interface TemplateSpecForProvider {
  /**
   * The HTML body of the email. Must be less than 500KB in size, including both the text and HTML parts.
   *
   * @schema TemplateSpecForProvider#html
   */
  readonly html?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TemplateSpecForProvider#region
   */
  readonly region: string;

  /**
   * The subject line of the email.
   *
   * @schema TemplateSpecForProvider#subject
   */
  readonly subject?: string;

  /**
   * The email body that will be visible to recipients whose email clients do not display HTML. Must be less than 500KB in size, including both the text and HTML parts.
   *
   * @schema TemplateSpecForProvider#text
   */
  readonly text?: string;

}

/**
 * Converts an object of type 'TemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpecForProvider(obj: TemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'html': obj.html,
    'region': obj.region,
    'subject': obj.subject,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TemplateSpecManagementPolicy
 */
export enum TemplateSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TemplateSpecProviderConfigRef
 */
export interface TemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TemplateSpecProviderConfigRef#policy
   */
  readonly policy?: TemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpecProviderConfigRef(obj: TemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TemplateSpecProviderRef
 */
export interface TemplateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TemplateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TemplateSpecProviderRef#policy
   */
  readonly policy?: TemplateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TemplateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpecProviderRef(obj: TemplateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TemplateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TemplateSpecPublishConnectionDetailsTo
 */
export interface TemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpecPublishConnectionDetailsTo(obj: TemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TemplateSpecWriteConnectionSecretToRef
 */
export interface TemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpecWriteConnectionSecretToRef(obj: TemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TemplateSpecProviderConfigRefPolicy
 */
export interface TemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpecProviderConfigRefPolicy(obj: TemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TemplateSpecProviderRefPolicy
 */
export interface TemplateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TemplateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TemplateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TemplateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TemplateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TemplateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpecProviderRefPolicy(obj: TemplateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface TemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpecPublishConnectionDetailsToConfigRef(obj: TemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TemplateSpecPublishConnectionDetailsToMetadata
 */
export interface TemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpecPublishConnectionDetailsToMetadata(obj: TemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TemplateSpecProviderConfigRefPolicyResolution
 */
export enum TemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TemplateSpecProviderConfigRefPolicyResolve
 */
export enum TemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TemplateSpecProviderRefPolicyResolution
 */
export enum TemplateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TemplateSpecProviderRefPolicyResolve
 */
export enum TemplateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: TemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

