// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ConnectivityTest is the Schema for the ConnectivityTests API. A connectivity test are a static analysis of your resource configurations that enables you to evaluate connectivity to and from Google Cloud resources in your Virtual Private Cloud (VPC) network.
 *
 * @schema ConnectivityTest
 */
export class ConnectivityTest extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConnectivityTest"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanagement.gcp.upbound.io/v1beta1',
    kind: 'ConnectivityTest',
  }

  /**
   * Renders a Kubernetes manifest for "ConnectivityTest".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectivityTestProps): any {
    return {
      ...ConnectivityTest.GVK,
      ...toJson_ConnectivityTestProps(props),
    };
  }

  /**
   * Defines a "ConnectivityTest" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectivityTestProps) {
    super(scope, id, {
      ...ConnectivityTest.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConnectivityTest.GVK,
      ...toJson_ConnectivityTestProps(resolved),
    };
  }
}

/**
 * ConnectivityTest is the Schema for the ConnectivityTests API. A connectivity test are a static analysis of your resource configurations that enables you to evaluate connectivity to and from Google Cloud resources in your Virtual Private Cloud (VPC) network.
 *
 * @schema ConnectivityTest
 */
export interface ConnectivityTestProps {
  /**
   * @schema ConnectivityTest#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectivityTestSpec defines the desired state of ConnectivityTest
   *
   * @schema ConnectivityTest#spec
   */
  readonly spec: ConnectivityTestSpec;

}

/**
 * Converts an object of type 'ConnectivityTestProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestProps(obj: ConnectivityTestProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectivityTestSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectivityTestSpec defines the desired state of ConnectivityTest
 *
 * @schema ConnectivityTestSpec
 */
export interface ConnectivityTestSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectivityTestSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectivityTestSpecDeletionPolicy;

  /**
   * @schema ConnectivityTestSpec#forProvider
   */
  readonly forProvider: ConnectivityTestSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectivityTestSpec#managementPolicy
   */
  readonly managementPolicy?: ConnectivityTestSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectivityTestSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectivityTestSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConnectivityTestSpec#providerRef
   */
  readonly providerRef?: ConnectivityTestSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectivityTestSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectivityTestSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectivityTestSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectivityTestSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectivityTestSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpec(obj: ConnectivityTestSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectivityTestSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ConnectivityTestSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConnectivityTestSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConnectivityTestSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectivityTestSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectivityTestSpecDeletionPolicy
 */
export enum ConnectivityTestSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConnectivityTestSpecForProvider
 */
export interface ConnectivityTestSpecForProvider {
  /**
   * The user-supplied description of the Connectivity Test. Maximum of 512 characters.
   *
   * @schema ConnectivityTestSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Required. Destination specification of the Connectivity Test. You can use a combination of destination IP address, Compute Engine VM instance, or VPC network to uniquely identify the destination location. Even if the destination IP address is not unique, the source IP location is unique. Usually, the analysis can infer the destination endpoint from route information. If the destination you specify is a VM instance and the instance has multiple network interfaces, then you must also specify either a destination IP address or VPC network to identify the destination interface. A reachability analysis proceeds even if the destination location is ambiguous. However, the result can include endpoints that you don't intend to test. Structure is documented below.
   *
   * @schema ConnectivityTestSpecForProvider#destination
   */
  readonly destination?: ConnectivityTestSpecForProviderDestination[];

  /**
   * Resource labels to represent user-provided metadata.
   *
   * @schema ConnectivityTestSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Unique name for the connectivity test.
   *
   * @schema ConnectivityTestSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema ConnectivityTestSpecForProvider#project
   */
  readonly project?: string;

  /**
   * IP Protocol of the test. When not provided, "TCP" is assumed.
   *
   * @schema ConnectivityTestSpecForProvider#protocol
   */
  readonly protocol?: string;

  /**
   * Other projects that may be relevant for reachability analysis. This is applicable to scenarios where a test can cross project boundaries.
   *
   * @schema ConnectivityTestSpecForProvider#relatedProjects
   */
  readonly relatedProjects?: string[];

  /**
   * Required. Source specification of the Connectivity Test. You can use a combination of source IP address, virtual machine (VM) instance, or Compute Engine network to uniquely identify the source location. Examples: If the source IP address is an internal IP address within a Google Cloud Virtual Private Cloud (VPC) network, then you must also specify the VPC network. Otherwise, specify the VM instance, which already contains its internal IP address and VPC network information. If the source of the test is within an on-premises network, then you must provide the destination VPC network. If the source endpoint is a Compute Engine VM instance with multiple network interfaces, the instance itself is not sufficient to identify the endpoint. So, you must also specify the source IP address or VPC network. A reachability analysis proceeds even if the source location is ambiguous. However, the test result may include endpoints that you don't intend to test. Structure is documented below.
   *
   * @schema ConnectivityTestSpecForProvider#source
   */
  readonly source?: ConnectivityTestSpecForProviderSource[];

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProvider(obj: ConnectivityTestSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'destination': obj.destination?.map(y => toJson_ConnectivityTestSpecForProviderDestination(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'project': obj.project,
    'protocol': obj.protocol,
    'relatedProjects': obj.relatedProjects?.map(y => y),
    'source': obj.source?.map(y => toJson_ConnectivityTestSpecForProviderSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectivityTestSpecManagementPolicy
 */
export enum ConnectivityTestSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectivityTestSpecProviderConfigRef
 */
export interface ConnectivityTestSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectivityTestSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecProviderConfigRef(obj: ConnectivityTestSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConnectivityTestSpecProviderRef
 */
export interface ConnectivityTestSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecProviderRef#policy
   */
  readonly policy?: ConnectivityTestSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecProviderRef(obj: ConnectivityTestSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectivityTestSpecPublishConnectionDetailsTo
 */
export interface ConnectivityTestSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectivityTestSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectivityTestSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectivityTestSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectivityTestSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectivityTestSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectivityTestSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecPublishConnectionDetailsTo(obj: ConnectivityTestSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectivityTestSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectivityTestSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectivityTestSpecWriteConnectionSecretToRef
 */
export interface ConnectivityTestSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectivityTestSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectivityTestSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectivityTestSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecWriteConnectionSecretToRef(obj: ConnectivityTestSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectivityTestSpecForProviderDestination
 */
export interface ConnectivityTestSpecForProviderDestination {
  /**
   * A Compute Engine instance URI.
   *
   * @schema ConnectivityTestSpecForProviderDestination#instance
   */
  readonly instance?: string;

  /**
   * Reference to a Instance in compute to populate instance.
   *
   * @schema ConnectivityTestSpecForProviderDestination#instanceRef
   */
  readonly instanceRef?: ConnectivityTestSpecForProviderDestinationInstanceRef;

  /**
   * Selector for a Instance in compute to populate instance.
   *
   * @schema ConnectivityTestSpecForProviderDestination#instanceSelector
   */
  readonly instanceSelector?: ConnectivityTestSpecForProviderDestinationInstanceSelector;

  /**
   * The IP address of the endpoint, which can be an external or internal IP. An IPv6 address is only allowed when the test's destination is a global load balancer VIP.
   *
   * @schema ConnectivityTestSpecForProviderDestination#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * Reference to a Address in compute to populate ipAddress.
   *
   * @schema ConnectivityTestSpecForProviderDestination#ipAddressRef
   */
  readonly ipAddressRef?: ConnectivityTestSpecForProviderDestinationIpAddressRef;

  /**
   * Selector for a Address in compute to populate ipAddress.
   *
   * @schema ConnectivityTestSpecForProviderDestination#ipAddressSelector
   */
  readonly ipAddressSelector?: ConnectivityTestSpecForProviderDestinationIpAddressSelector;

  /**
   * A Compute Engine network URI.
   *
   * @schema ConnectivityTestSpecForProviderDestination#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema ConnectivityTestSpecForProviderDestination#networkRef
   */
  readonly networkRef?: ConnectivityTestSpecForProviderDestinationNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema ConnectivityTestSpecForProviderDestination#networkSelector
   */
  readonly networkSelector?: ConnectivityTestSpecForProviderDestinationNetworkSelector;

  /**
   * The IP protocol port of the endpoint. Only applicable when protocol is TCP or UDP.
   *
   * @schema ConnectivityTestSpecForProviderDestination#port
   */
  readonly port?: number;

  /**
   * Project ID where the endpoint is located. The Project ID can be derived from the URI if you provide a VM instance or network URI. The following are two cases where you must provide the project ID:
   *
   * @schema ConnectivityTestSpecForProviderDestination#projectId
   */
  readonly projectId?: string;

  /**
   * Reference to a Address in compute to populate projectId.
   *
   * @schema ConnectivityTestSpecForProviderDestination#projectIdRef
   */
  readonly projectIdRef?: ConnectivityTestSpecForProviderDestinationProjectIdRef;

  /**
   * Selector for a Address in compute to populate projectId.
   *
   * @schema ConnectivityTestSpecForProviderDestination#projectIdSelector
   */
  readonly projectIdSelector?: ConnectivityTestSpecForProviderDestinationProjectIdSelector;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestination(obj: ConnectivityTestSpecForProviderDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instance': obj.instance,
    'instanceRef': toJson_ConnectivityTestSpecForProviderDestinationInstanceRef(obj.instanceRef),
    'instanceSelector': toJson_ConnectivityTestSpecForProviderDestinationInstanceSelector(obj.instanceSelector),
    'ipAddress': obj.ipAddress,
    'ipAddressRef': toJson_ConnectivityTestSpecForProviderDestinationIpAddressRef(obj.ipAddressRef),
    'ipAddressSelector': toJson_ConnectivityTestSpecForProviderDestinationIpAddressSelector(obj.ipAddressSelector),
    'network': obj.network,
    'networkRef': toJson_ConnectivityTestSpecForProviderDestinationNetworkRef(obj.networkRef),
    'networkSelector': toJson_ConnectivityTestSpecForProviderDestinationNetworkSelector(obj.networkSelector),
    'port': obj.port,
    'projectId': obj.projectId,
    'projectIdRef': toJson_ConnectivityTestSpecForProviderDestinationProjectIdRef(obj.projectIdRef),
    'projectIdSelector': toJson_ConnectivityTestSpecForProviderDestinationProjectIdSelector(obj.projectIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectivityTestSpecForProviderSource
 */
export interface ConnectivityTestSpecForProviderSource {
  /**
   * A Compute Engine instance URI.
   *
   * @schema ConnectivityTestSpecForProviderSource#instance
   */
  readonly instance?: string;

  /**
   * Reference to a Instance in compute to populate instance.
   *
   * @schema ConnectivityTestSpecForProviderSource#instanceRef
   */
  readonly instanceRef?: ConnectivityTestSpecForProviderSourceInstanceRef;

  /**
   * Selector for a Instance in compute to populate instance.
   *
   * @schema ConnectivityTestSpecForProviderSource#instanceSelector
   */
  readonly instanceSelector?: ConnectivityTestSpecForProviderSourceInstanceSelector;

  /**
   * The IP address of the endpoint, which can be an external or internal IP. An IPv6 address is only allowed when the test's destination is a global load balancer VIP.
   *
   * @schema ConnectivityTestSpecForProviderSource#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * Reference to a Address in compute to populate ipAddress.
   *
   * @schema ConnectivityTestSpecForProviderSource#ipAddressRef
   */
  readonly ipAddressRef?: ConnectivityTestSpecForProviderSourceIpAddressRef;

  /**
   * Selector for a Address in compute to populate ipAddress.
   *
   * @schema ConnectivityTestSpecForProviderSource#ipAddressSelector
   */
  readonly ipAddressSelector?: ConnectivityTestSpecForProviderSourceIpAddressSelector;

  /**
   * A Compute Engine network URI.
   *
   * @schema ConnectivityTestSpecForProviderSource#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema ConnectivityTestSpecForProviderSource#networkRef
   */
  readonly networkRef?: ConnectivityTestSpecForProviderSourceNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema ConnectivityTestSpecForProviderSource#networkSelector
   */
  readonly networkSelector?: ConnectivityTestSpecForProviderSourceNetworkSelector;

  /**
   * Type of the network where the endpoint is located. Possible values are: GCP_NETWORK, NON_GCP_NETWORK.
   *
   * @schema ConnectivityTestSpecForProviderSource#networkType
   */
  readonly networkType?: string;

  /**
   * The IP protocol port of the endpoint. Only applicable when protocol is TCP or UDP.
   *
   * @schema ConnectivityTestSpecForProviderSource#port
   */
  readonly port?: number;

  /**
   * Project ID where the endpoint is located. The Project ID can be derived from the URI if you provide a VM instance or network URI. The following are two cases where you must provide the project ID:
   *
   * @schema ConnectivityTestSpecForProviderSource#projectId
   */
  readonly projectId?: string;

  /**
   * Reference to a Address in compute to populate projectId.
   *
   * @schema ConnectivityTestSpecForProviderSource#projectIdRef
   */
  readonly projectIdRef?: ConnectivityTestSpecForProviderSourceProjectIdRef;

  /**
   * Selector for a Address in compute to populate projectId.
   *
   * @schema ConnectivityTestSpecForProviderSource#projectIdSelector
   */
  readonly projectIdSelector?: ConnectivityTestSpecForProviderSourceProjectIdSelector;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSource(obj: ConnectivityTestSpecForProviderSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instance': obj.instance,
    'instanceRef': toJson_ConnectivityTestSpecForProviderSourceInstanceRef(obj.instanceRef),
    'instanceSelector': toJson_ConnectivityTestSpecForProviderSourceInstanceSelector(obj.instanceSelector),
    'ipAddress': obj.ipAddress,
    'ipAddressRef': toJson_ConnectivityTestSpecForProviderSourceIpAddressRef(obj.ipAddressRef),
    'ipAddressSelector': toJson_ConnectivityTestSpecForProviderSourceIpAddressSelector(obj.ipAddressSelector),
    'network': obj.network,
    'networkRef': toJson_ConnectivityTestSpecForProviderSourceNetworkRef(obj.networkRef),
    'networkSelector': toJson_ConnectivityTestSpecForProviderSourceNetworkSelector(obj.networkSelector),
    'networkType': obj.networkType,
    'port': obj.port,
    'projectId': obj.projectId,
    'projectIdRef': toJson_ConnectivityTestSpecForProviderSourceProjectIdRef(obj.projectIdRef),
    'projectIdSelector': toJson_ConnectivityTestSpecForProviderSourceProjectIdSelector(obj.projectIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecProviderConfigRefPolicy
 */
export interface ConnectivityTestSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecProviderConfigRefPolicy(obj: ConnectivityTestSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecProviderRefPolicy
 */
export interface ConnectivityTestSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecProviderRefPolicy(obj: ConnectivityTestSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectivityTestSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectivityTestSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecPublishConnectionDetailsToConfigRef(obj: ConnectivityTestSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectivityTestSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectivityTestSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectivityTestSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectivityTestSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectivityTestSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectivityTestSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecPublishConnectionDetailsToMetadata(obj: ConnectivityTestSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in compute to populate instance.
 *
 * @schema ConnectivityTestSpecForProviderDestinationInstanceRef
 */
export interface ConnectivityTestSpecForProviderDestinationInstanceRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecForProviderDestinationInstanceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecForProviderDestinationInstanceRef#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderDestinationInstanceRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationInstanceRef(obj: ConnectivityTestSpecForProviderDestinationInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecForProviderDestinationInstanceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in compute to populate instance.
 *
 * @schema ConnectivityTestSpecForProviderDestinationInstanceSelector
 */
export interface ConnectivityTestSpecForProviderDestinationInstanceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectivityTestSpecForProviderDestinationInstanceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectivityTestSpecForProviderDestinationInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectivityTestSpecForProviderDestinationInstanceSelector#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationInstanceSelector(obj: ConnectivityTestSpecForProviderDestinationInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Address in compute to populate ipAddress.
 *
 * @schema ConnectivityTestSpecForProviderDestinationIpAddressRef
 */
export interface ConnectivityTestSpecForProviderDestinationIpAddressRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecForProviderDestinationIpAddressRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecForProviderDestinationIpAddressRef#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderDestinationIpAddressRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationIpAddressRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationIpAddressRef(obj: ConnectivityTestSpecForProviderDestinationIpAddressRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecForProviderDestinationIpAddressRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Address in compute to populate ipAddress.
 *
 * @schema ConnectivityTestSpecForProviderDestinationIpAddressSelector
 */
export interface ConnectivityTestSpecForProviderDestinationIpAddressSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectivityTestSpecForProviderDestinationIpAddressSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectivityTestSpecForProviderDestinationIpAddressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectivityTestSpecForProviderDestinationIpAddressSelector#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationIpAddressSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationIpAddressSelector(obj: ConnectivityTestSpecForProviderDestinationIpAddressSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema ConnectivityTestSpecForProviderDestinationNetworkRef
 */
export interface ConnectivityTestSpecForProviderDestinationNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecForProviderDestinationNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecForProviderDestinationNetworkRef#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderDestinationNetworkRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationNetworkRef(obj: ConnectivityTestSpecForProviderDestinationNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecForProviderDestinationNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema ConnectivityTestSpecForProviderDestinationNetworkSelector
 */
export interface ConnectivityTestSpecForProviderDestinationNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectivityTestSpecForProviderDestinationNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectivityTestSpecForProviderDestinationNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectivityTestSpecForProviderDestinationNetworkSelector#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationNetworkSelector(obj: ConnectivityTestSpecForProviderDestinationNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Address in compute to populate projectId.
 *
 * @schema ConnectivityTestSpecForProviderDestinationProjectIdRef
 */
export interface ConnectivityTestSpecForProviderDestinationProjectIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecForProviderDestinationProjectIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecForProviderDestinationProjectIdRef#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderDestinationProjectIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationProjectIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationProjectIdRef(obj: ConnectivityTestSpecForProviderDestinationProjectIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecForProviderDestinationProjectIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Address in compute to populate projectId.
 *
 * @schema ConnectivityTestSpecForProviderDestinationProjectIdSelector
 */
export interface ConnectivityTestSpecForProviderDestinationProjectIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectivityTestSpecForProviderDestinationProjectIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectivityTestSpecForProviderDestinationProjectIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectivityTestSpecForProviderDestinationProjectIdSelector#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationProjectIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationProjectIdSelector(obj: ConnectivityTestSpecForProviderDestinationProjectIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in compute to populate instance.
 *
 * @schema ConnectivityTestSpecForProviderSourceInstanceRef
 */
export interface ConnectivityTestSpecForProviderSourceInstanceRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecForProviderSourceInstanceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecForProviderSourceInstanceRef#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderSourceInstanceRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceInstanceRef(obj: ConnectivityTestSpecForProviderSourceInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecForProviderSourceInstanceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in compute to populate instance.
 *
 * @schema ConnectivityTestSpecForProviderSourceInstanceSelector
 */
export interface ConnectivityTestSpecForProviderSourceInstanceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectivityTestSpecForProviderSourceInstanceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectivityTestSpecForProviderSourceInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectivityTestSpecForProviderSourceInstanceSelector#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderSourceInstanceSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceInstanceSelector(obj: ConnectivityTestSpecForProviderSourceInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectivityTestSpecForProviderSourceInstanceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Address in compute to populate ipAddress.
 *
 * @schema ConnectivityTestSpecForProviderSourceIpAddressRef
 */
export interface ConnectivityTestSpecForProviderSourceIpAddressRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecForProviderSourceIpAddressRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecForProviderSourceIpAddressRef#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderSourceIpAddressRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceIpAddressRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceIpAddressRef(obj: ConnectivityTestSpecForProviderSourceIpAddressRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecForProviderSourceIpAddressRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Address in compute to populate ipAddress.
 *
 * @schema ConnectivityTestSpecForProviderSourceIpAddressSelector
 */
export interface ConnectivityTestSpecForProviderSourceIpAddressSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectivityTestSpecForProviderSourceIpAddressSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectivityTestSpecForProviderSourceIpAddressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectivityTestSpecForProviderSourceIpAddressSelector#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceIpAddressSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceIpAddressSelector(obj: ConnectivityTestSpecForProviderSourceIpAddressSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema ConnectivityTestSpecForProviderSourceNetworkRef
 */
export interface ConnectivityTestSpecForProviderSourceNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecForProviderSourceNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecForProviderSourceNetworkRef#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderSourceNetworkRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceNetworkRef(obj: ConnectivityTestSpecForProviderSourceNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecForProviderSourceNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema ConnectivityTestSpecForProviderSourceNetworkSelector
 */
export interface ConnectivityTestSpecForProviderSourceNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectivityTestSpecForProviderSourceNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectivityTestSpecForProviderSourceNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectivityTestSpecForProviderSourceNetworkSelector#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderSourceNetworkSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceNetworkSelector(obj: ConnectivityTestSpecForProviderSourceNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectivityTestSpecForProviderSourceNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Address in compute to populate projectId.
 *
 * @schema ConnectivityTestSpecForProviderSourceProjectIdRef
 */
export interface ConnectivityTestSpecForProviderSourceProjectIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectivityTestSpecForProviderSourceProjectIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectivityTestSpecForProviderSourceProjectIdRef#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderSourceProjectIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceProjectIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceProjectIdRef(obj: ConnectivityTestSpecForProviderSourceProjectIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectivityTestSpecForProviderSourceProjectIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Address in compute to populate projectId.
 *
 * @schema ConnectivityTestSpecForProviderSourceProjectIdSelector
 */
export interface ConnectivityTestSpecForProviderSourceProjectIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectivityTestSpecForProviderSourceProjectIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectivityTestSpecForProviderSourceProjectIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectivityTestSpecForProviderSourceProjectIdSelector#policy
   */
  readonly policy?: ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceProjectIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceProjectIdSelector(obj: ConnectivityTestSpecForProviderSourceProjectIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecProviderConfigRefPolicyResolution
 */
export enum ConnectivityTestSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecProviderConfigRefPolicyResolve
 */
export enum ConnectivityTestSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecProviderRefPolicyResolution
 */
export enum ConnectivityTestSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecProviderRefPolicyResolve
 */
export enum ConnectivityTestSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecForProviderDestinationInstanceRefPolicy
 */
export interface ConnectivityTestSpecForProviderDestinationInstanceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderDestinationInstanceRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderDestinationInstanceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderDestinationInstanceRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderDestinationInstanceRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationInstanceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationInstanceRefPolicy(obj: ConnectivityTestSpecForProviderDestinationInstanceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicy
 */
export interface ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicy(obj: ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecForProviderDestinationIpAddressRefPolicy
 */
export interface ConnectivityTestSpecForProviderDestinationIpAddressRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderDestinationIpAddressRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderDestinationIpAddressRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderDestinationIpAddressRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderDestinationIpAddressRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationIpAddressRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationIpAddressRefPolicy(obj: ConnectivityTestSpecForProviderDestinationIpAddressRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicy
 */
export interface ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicy(obj: ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecForProviderDestinationNetworkRefPolicy
 */
export interface ConnectivityTestSpecForProviderDestinationNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderDestinationNetworkRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderDestinationNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderDestinationNetworkRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderDestinationNetworkRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationNetworkRefPolicy(obj: ConnectivityTestSpecForProviderDestinationNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicy
 */
export interface ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicy(obj: ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecForProviderDestinationProjectIdRefPolicy
 */
export interface ConnectivityTestSpecForProviderDestinationProjectIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderDestinationProjectIdRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderDestinationProjectIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderDestinationProjectIdRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderDestinationProjectIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationProjectIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationProjectIdRefPolicy(obj: ConnectivityTestSpecForProviderDestinationProjectIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicy
 */
export interface ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicy(obj: ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecForProviderSourceInstanceRefPolicy
 */
export interface ConnectivityTestSpecForProviderSourceInstanceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderSourceInstanceRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderSourceInstanceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderSourceInstanceRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderSourceInstanceRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceInstanceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceInstanceRefPolicy(obj: ConnectivityTestSpecForProviderSourceInstanceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectivityTestSpecForProviderSourceInstanceSelectorPolicy
 */
export interface ConnectivityTestSpecForProviderSourceInstanceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderSourceInstanceSelectorPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderSourceInstanceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderSourceInstanceSelectorPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderSourceInstanceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceInstanceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceInstanceSelectorPolicy(obj: ConnectivityTestSpecForProviderSourceInstanceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecForProviderSourceIpAddressRefPolicy
 */
export interface ConnectivityTestSpecForProviderSourceIpAddressRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderSourceIpAddressRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderSourceIpAddressRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderSourceIpAddressRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderSourceIpAddressRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceIpAddressRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceIpAddressRefPolicy(obj: ConnectivityTestSpecForProviderSourceIpAddressRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicy
 */
export interface ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicy(obj: ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecForProviderSourceNetworkRefPolicy
 */
export interface ConnectivityTestSpecForProviderSourceNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderSourceNetworkRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderSourceNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderSourceNetworkRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderSourceNetworkRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceNetworkRefPolicy(obj: ConnectivityTestSpecForProviderSourceNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectivityTestSpecForProviderSourceNetworkSelectorPolicy
 */
export interface ConnectivityTestSpecForProviderSourceNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderSourceNetworkSelectorPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderSourceNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderSourceNetworkSelectorPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderSourceNetworkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceNetworkSelectorPolicy(obj: ConnectivityTestSpecForProviderSourceNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectivityTestSpecForProviderSourceProjectIdRefPolicy
 */
export interface ConnectivityTestSpecForProviderSourceProjectIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderSourceProjectIdRefPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderSourceProjectIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderSourceProjectIdRefPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderSourceProjectIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceProjectIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceProjectIdRefPolicy(obj: ConnectivityTestSpecForProviderSourceProjectIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicy
 */
export interface ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicy(obj: ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectivityTestSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderDestinationInstanceRefPolicyResolution
 */
export enum ConnectivityTestSpecForProviderDestinationInstanceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderDestinationInstanceRefPolicyResolve
 */
export enum ConnectivityTestSpecForProviderDestinationInstanceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicyResolution
 */
export enum ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicyResolve
 */
export enum ConnectivityTestSpecForProviderDestinationInstanceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderDestinationIpAddressRefPolicyResolution
 */
export enum ConnectivityTestSpecForProviderDestinationIpAddressRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderDestinationIpAddressRefPolicyResolve
 */
export enum ConnectivityTestSpecForProviderDestinationIpAddressRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicyResolution
 */
export enum ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicyResolve
 */
export enum ConnectivityTestSpecForProviderDestinationIpAddressSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderDestinationNetworkRefPolicyResolution
 */
export enum ConnectivityTestSpecForProviderDestinationNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderDestinationNetworkRefPolicyResolve
 */
export enum ConnectivityTestSpecForProviderDestinationNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicyResolution
 */
export enum ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicyResolve
 */
export enum ConnectivityTestSpecForProviderDestinationNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderDestinationProjectIdRefPolicyResolution
 */
export enum ConnectivityTestSpecForProviderDestinationProjectIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderDestinationProjectIdRefPolicyResolve
 */
export enum ConnectivityTestSpecForProviderDestinationProjectIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicyResolution
 */
export enum ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicyResolve
 */
export enum ConnectivityTestSpecForProviderDestinationProjectIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderSourceInstanceRefPolicyResolution
 */
export enum ConnectivityTestSpecForProviderSourceInstanceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderSourceInstanceRefPolicyResolve
 */
export enum ConnectivityTestSpecForProviderSourceInstanceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderSourceInstanceSelectorPolicyResolution
 */
export enum ConnectivityTestSpecForProviderSourceInstanceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderSourceInstanceSelectorPolicyResolve
 */
export enum ConnectivityTestSpecForProviderSourceInstanceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderSourceIpAddressRefPolicyResolution
 */
export enum ConnectivityTestSpecForProviderSourceIpAddressRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderSourceIpAddressRefPolicyResolve
 */
export enum ConnectivityTestSpecForProviderSourceIpAddressRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicyResolution
 */
export enum ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicyResolve
 */
export enum ConnectivityTestSpecForProviderSourceIpAddressSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderSourceNetworkRefPolicyResolution
 */
export enum ConnectivityTestSpecForProviderSourceNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderSourceNetworkRefPolicyResolve
 */
export enum ConnectivityTestSpecForProviderSourceNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderSourceNetworkSelectorPolicyResolution
 */
export enum ConnectivityTestSpecForProviderSourceNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderSourceNetworkSelectorPolicyResolve
 */
export enum ConnectivityTestSpecForProviderSourceNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderSourceProjectIdRefPolicyResolution
 */
export enum ConnectivityTestSpecForProviderSourceProjectIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderSourceProjectIdRefPolicyResolve
 */
export enum ConnectivityTestSpecForProviderSourceProjectIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicyResolution
 */
export enum ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicyResolve
 */
export enum ConnectivityTestSpecForProviderSourceProjectIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

