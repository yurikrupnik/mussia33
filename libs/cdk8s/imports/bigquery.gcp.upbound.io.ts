// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AnalyticsHubDataExchange is the Schema for the AnalyticsHubDataExchanges API. A Bigquery Analytics Hub data exchange
 *
 * @schema AnalyticsHubDataExchange
 */
export class AnalyticsHubDataExchange extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AnalyticsHubDataExchange"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'AnalyticsHubDataExchange',
  }

  /**
   * Renders a Kubernetes manifest for "AnalyticsHubDataExchange".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AnalyticsHubDataExchangeProps): any {
    return {
      ...AnalyticsHubDataExchange.GVK,
      ...toJson_AnalyticsHubDataExchangeProps(props),
    };
  }

  /**
   * Defines a "AnalyticsHubDataExchange" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AnalyticsHubDataExchangeProps) {
    super(scope, id, {
      ...AnalyticsHubDataExchange.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AnalyticsHubDataExchange.GVK,
      ...toJson_AnalyticsHubDataExchangeProps(resolved),
    };
  }
}

/**
 * AnalyticsHubDataExchange is the Schema for the AnalyticsHubDataExchanges API. A Bigquery Analytics Hub data exchange
 *
 * @schema AnalyticsHubDataExchange
 */
export interface AnalyticsHubDataExchangeProps {
  /**
   * @schema AnalyticsHubDataExchange#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AnalyticsHubDataExchangeSpec defines the desired state of AnalyticsHubDataExchange
   *
   * @schema AnalyticsHubDataExchange#spec
   */
  readonly spec: AnalyticsHubDataExchangeSpec;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeProps(obj: AnalyticsHubDataExchangeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AnalyticsHubDataExchangeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnalyticsHubDataExchangeSpec defines the desired state of AnalyticsHubDataExchange
 *
 * @schema AnalyticsHubDataExchangeSpec
 */
export interface AnalyticsHubDataExchangeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AnalyticsHubDataExchangeSpec#deletionPolicy
   */
  readonly deletionPolicy?: AnalyticsHubDataExchangeSpecDeletionPolicy;

  /**
   * @schema AnalyticsHubDataExchangeSpec#forProvider
   */
  readonly forProvider: AnalyticsHubDataExchangeSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AnalyticsHubDataExchangeSpec#providerConfigRef
   */
  readonly providerConfigRef?: AnalyticsHubDataExchangeSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AnalyticsHubDataExchangeSpec#providerRef
   */
  readonly providerRef?: AnalyticsHubDataExchangeSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AnalyticsHubDataExchangeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AnalyticsHubDataExchangeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AnalyticsHubDataExchangeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AnalyticsHubDataExchangeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpec(obj: AnalyticsHubDataExchangeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AnalyticsHubDataExchangeSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AnalyticsHubDataExchangeSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AnalyticsHubDataExchangeSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AnalyticsHubDataExchangeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AnalyticsHubDataExchangeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AnalyticsHubDataExchangeSpecDeletionPolicy
 */
export enum AnalyticsHubDataExchangeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AnalyticsHubDataExchangeSpecForProvider
 */
export interface AnalyticsHubDataExchangeSpecForProvider {
  /**
   * The ID of the data exchange. Must contain only Unicode letters, numbers (0-9), underscores (_). Should not use characters that require URL-escaping, or characters outside of ASCII, spaces.
   *
   * @schema AnalyticsHubDataExchangeSpecForProvider#dataExchangeId
   */
  readonly dataExchangeId: string;

  /**
   * Description of the data exchange.
   *
   * @schema AnalyticsHubDataExchangeSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Human-readable display name of the data exchange. The display name must contain only Unicode letters, numbers (0-9), underscores (_), dashes (-), spaces ( ), and must not start or end with spaces.
   *
   * @schema AnalyticsHubDataExchangeSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * Documentation describing the data exchange.
   *
   * @schema AnalyticsHubDataExchangeSpecForProvider#documentation
   */
  readonly documentation?: string;

  /**
   * Base64 encoded image representing the data exchange.
   *
   * @schema AnalyticsHubDataExchangeSpecForProvider#icon
   */
  readonly icon?: string;

  /**
   * The name of the location this data exchange.
   *
   * @schema AnalyticsHubDataExchangeSpecForProvider#location
   */
  readonly location: string;

  /**
   * Email or URL of the primary point of contact of the data exchange.
   *
   * @schema AnalyticsHubDataExchangeSpecForProvider#primaryContact
   */
  readonly primaryContact?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AnalyticsHubDataExchangeSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpecForProvider(obj: AnalyticsHubDataExchangeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataExchangeId': obj.dataExchangeId,
    'description': obj.description,
    'displayName': obj.displayName,
    'documentation': obj.documentation,
    'icon': obj.icon,
    'location': obj.location,
    'primaryContact': obj.primaryContact,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AnalyticsHubDataExchangeSpecProviderConfigRef
 */
export interface AnalyticsHubDataExchangeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubDataExchangeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubDataExchangeSpecProviderConfigRef#policy
   */
  readonly policy?: AnalyticsHubDataExchangeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpecProviderConfigRef(obj: AnalyticsHubDataExchangeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubDataExchangeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AnalyticsHubDataExchangeSpecProviderRef
 */
export interface AnalyticsHubDataExchangeSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubDataExchangeSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubDataExchangeSpecProviderRef#policy
   */
  readonly policy?: AnalyticsHubDataExchangeSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpecProviderRef(obj: AnalyticsHubDataExchangeSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubDataExchangeSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsTo
 */
export interface AnalyticsHubDataExchangeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AnalyticsHubDataExchangeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpecPublishConnectionDetailsTo(obj: AnalyticsHubDataExchangeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AnalyticsHubDataExchangeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AnalyticsHubDataExchangeSpecWriteConnectionSecretToRef
 */
export interface AnalyticsHubDataExchangeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AnalyticsHubDataExchangeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AnalyticsHubDataExchangeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpecWriteConnectionSecretToRef(obj: AnalyticsHubDataExchangeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubDataExchangeSpecProviderConfigRefPolicy
 */
export interface AnalyticsHubDataExchangeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubDataExchangeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubDataExchangeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubDataExchangeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubDataExchangeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpecProviderConfigRefPolicy(obj: AnalyticsHubDataExchangeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubDataExchangeSpecProviderRefPolicy
 */
export interface AnalyticsHubDataExchangeSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubDataExchangeSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubDataExchangeSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubDataExchangeSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubDataExchangeSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpecProviderRefPolicy(obj: AnalyticsHubDataExchangeSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRef
 */
export interface AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRef(obj: AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToMetadata
 */
export interface AnalyticsHubDataExchangeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpecPublishConnectionDetailsToMetadata(obj: AnalyticsHubDataExchangeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubDataExchangeSpecProviderConfigRefPolicyResolution
 */
export enum AnalyticsHubDataExchangeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubDataExchangeSpecProviderConfigRefPolicyResolve
 */
export enum AnalyticsHubDataExchangeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubDataExchangeSpecProviderRefPolicyResolution
 */
export enum AnalyticsHubDataExchangeSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubDataExchangeSpecProviderRefPolicyResolve
 */
export enum AnalyticsHubDataExchangeSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicy(obj: AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AnalyticsHubDataExchangeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AnalyticsHubDataExchangeIAMMember is the Schema for the AnalyticsHubDataExchangeIAMMembers API. <no value>
 *
 * @schema AnalyticsHubDataExchangeIAMMember
 */
export class AnalyticsHubDataExchangeIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AnalyticsHubDataExchangeIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'AnalyticsHubDataExchangeIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "AnalyticsHubDataExchangeIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AnalyticsHubDataExchangeIamMemberProps): any {
    return {
      ...AnalyticsHubDataExchangeIamMember.GVK,
      ...toJson_AnalyticsHubDataExchangeIamMemberProps(props),
    };
  }

  /**
   * Defines a "AnalyticsHubDataExchangeIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AnalyticsHubDataExchangeIamMemberProps) {
    super(scope, id, {
      ...AnalyticsHubDataExchangeIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AnalyticsHubDataExchangeIamMember.GVK,
      ...toJson_AnalyticsHubDataExchangeIamMemberProps(resolved),
    };
  }
}

/**
 * AnalyticsHubDataExchangeIAMMember is the Schema for the AnalyticsHubDataExchangeIAMMembers API. <no value>
 *
 * @schema AnalyticsHubDataExchangeIAMMember
 */
export interface AnalyticsHubDataExchangeIamMemberProps {
  /**
   * @schema AnalyticsHubDataExchangeIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AnalyticsHubDataExchangeIAMMemberSpec defines the desired state of AnalyticsHubDataExchangeIAMMember
   *
   * @schema AnalyticsHubDataExchangeIAMMember#spec
   */
  readonly spec: AnalyticsHubDataExchangeIamMemberSpec;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberProps(obj: AnalyticsHubDataExchangeIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AnalyticsHubDataExchangeIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnalyticsHubDataExchangeIAMMemberSpec defines the desired state of AnalyticsHubDataExchangeIAMMember
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpec
 */
export interface AnalyticsHubDataExchangeIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: AnalyticsHubDataExchangeIamMemberSpecDeletionPolicy;

  /**
   * @schema AnalyticsHubDataExchangeIamMemberSpec#forProvider
   */
  readonly forProvider: AnalyticsHubDataExchangeIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: AnalyticsHubDataExchangeIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpec#providerRef
   */
  readonly providerRef?: AnalyticsHubDataExchangeIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AnalyticsHubDataExchangeIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpec(obj: AnalyticsHubDataExchangeIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AnalyticsHubDataExchangeIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AnalyticsHubDataExchangeIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AnalyticsHubDataExchangeIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AnalyticsHubDataExchangeIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecDeletionPolicy
 */
export enum AnalyticsHubDataExchangeIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AnalyticsHubDataExchangeIamMemberSpecForProvider
 */
export interface AnalyticsHubDataExchangeIamMemberSpecForProvider {
  /**
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProvider#condition
   */
  readonly condition?: AnalyticsHubDataExchangeIamMemberSpecForProviderCondition[];

  /**
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProvider#dataExchangeId
   */
  readonly dataExchangeId?: string;

  /**
   * Reference to a AnalyticsHubDataExchange in bigquery to populate dataExchangeId.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProvider#dataExchangeIdRef
   */
  readonly dataExchangeIdRef?: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRef;

  /**
   * Selector for a AnalyticsHubDataExchange in bigquery to populate dataExchangeId.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProvider#dataExchangeIdSelector
   */
  readonly dataExchangeIdSelector?: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelector;

  /**
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProvider#location
   */
  readonly location?: string;

  /**
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecForProvider(obj: AnalyticsHubDataExchangeIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_AnalyticsHubDataExchangeIamMemberSpecForProviderCondition(y)),
    'dataExchangeId': obj.dataExchangeId,
    'dataExchangeIdRef': toJson_AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRef(obj.dataExchangeIdRef),
    'dataExchangeIdSelector': toJson_AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelector(obj.dataExchangeIdSelector),
    'location': obj.location,
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecProviderConfigRef
 */
export interface AnalyticsHubDataExchangeIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecProviderConfigRef(obj: AnalyticsHubDataExchangeIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecProviderRef
 */
export interface AnalyticsHubDataExchangeIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecProviderRef#policy
   */
  readonly policy?: AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecProviderRef(obj: AnalyticsHubDataExchangeIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsTo
 */
export interface AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsTo(obj: AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecWriteConnectionSecretToRef
 */
export interface AnalyticsHubDataExchangeIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecWriteConnectionSecretToRef(obj: AnalyticsHubDataExchangeIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderCondition
 */
export interface AnalyticsHubDataExchangeIamMemberSpecForProviderCondition {
  /**
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecForProviderCondition(obj: AnalyticsHubDataExchangeIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AnalyticsHubDataExchange in bigquery to populate dataExchangeId.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRef
 */
export interface AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRef#policy
   */
  readonly policy?: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRef(obj: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AnalyticsHubDataExchange in bigquery to populate dataExchangeId.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelector
 */
export interface AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelector#policy
   */
  readonly policy?: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelector(obj: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicy
 */
export interface AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicy(obj: AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicy
 */
export interface AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicy(obj: AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRef(obj: AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToMetadata(obj: AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicy
 */
export interface AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicy(obj: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicy
 */
export interface AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicy#resolution
   */
  readonly resolution?: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicy#resolve
   */
  readonly resolve?: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicy(obj: AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum AnalyticsHubDataExchangeIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicyResolution
 */
export enum AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicyResolve
 */
export enum AnalyticsHubDataExchangeIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicyResolution
 */
export enum AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicyResolve
 */
export enum AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicyResolution
 */
export enum AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicyResolve
 */
export enum AnalyticsHubDataExchangeIamMemberSpecForProviderDataExchangeIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AnalyticsHubDataExchangeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AnalyticsHubListing is the Schema for the AnalyticsHubListings API. A Bigquery Analytics Hub data exchange listing
 *
 * @schema AnalyticsHubListing
 */
export class AnalyticsHubListing extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AnalyticsHubListing"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'AnalyticsHubListing',
  }

  /**
   * Renders a Kubernetes manifest for "AnalyticsHubListing".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AnalyticsHubListingProps): any {
    return {
      ...AnalyticsHubListing.GVK,
      ...toJson_AnalyticsHubListingProps(props),
    };
  }

  /**
   * Defines a "AnalyticsHubListing" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AnalyticsHubListingProps) {
    super(scope, id, {
      ...AnalyticsHubListing.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AnalyticsHubListing.GVK,
      ...toJson_AnalyticsHubListingProps(resolved),
    };
  }
}

/**
 * AnalyticsHubListing is the Schema for the AnalyticsHubListings API. A Bigquery Analytics Hub data exchange listing
 *
 * @schema AnalyticsHubListing
 */
export interface AnalyticsHubListingProps {
  /**
   * @schema AnalyticsHubListing#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AnalyticsHubListingSpec defines the desired state of AnalyticsHubListing
   *
   * @schema AnalyticsHubListing#spec
   */
  readonly spec: AnalyticsHubListingSpec;

}

/**
 * Converts an object of type 'AnalyticsHubListingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingProps(obj: AnalyticsHubListingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AnalyticsHubListingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnalyticsHubListingSpec defines the desired state of AnalyticsHubListing
 *
 * @schema AnalyticsHubListingSpec
 */
export interface AnalyticsHubListingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AnalyticsHubListingSpec#deletionPolicy
   */
  readonly deletionPolicy?: AnalyticsHubListingSpecDeletionPolicy;

  /**
   * @schema AnalyticsHubListingSpec#forProvider
   */
  readonly forProvider: AnalyticsHubListingSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AnalyticsHubListingSpec#providerConfigRef
   */
  readonly providerConfigRef?: AnalyticsHubListingSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AnalyticsHubListingSpec#providerRef
   */
  readonly providerRef?: AnalyticsHubListingSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AnalyticsHubListingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AnalyticsHubListingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AnalyticsHubListingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AnalyticsHubListingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpec(obj: AnalyticsHubListingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AnalyticsHubListingSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AnalyticsHubListingSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AnalyticsHubListingSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AnalyticsHubListingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AnalyticsHubListingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AnalyticsHubListingSpecDeletionPolicy
 */
export enum AnalyticsHubListingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AnalyticsHubListingSpecForProvider
 */
export interface AnalyticsHubListingSpecForProvider {
  /**
   * Shared dataset i.e. BigQuery dataset source. Structure is documented below.
   *
   * @schema AnalyticsHubListingSpecForProvider#bigqueryDataset
   */
  readonly bigqueryDataset: AnalyticsHubListingSpecForProviderBigqueryDataset[];

  /**
   * Categories of the listing. Up to two categories are allowed.
   *
   * @schema AnalyticsHubListingSpecForProvider#categories
   */
  readonly categories?: string[];

  /**
   * The ID of the data exchange. Must contain only Unicode letters, numbers (0-9), underscores (_). Should not use characters that require URL-escaping, or characters outside of ASCII, spaces.
   *
   * @schema AnalyticsHubListingSpecForProvider#dataExchangeId
   */
  readonly dataExchangeId?: string;

  /**
   * Reference to a AnalyticsHubDataExchange in bigquery to populate dataExchangeId.
   *
   * @schema AnalyticsHubListingSpecForProvider#dataExchangeIdRef
   */
  readonly dataExchangeIdRef?: AnalyticsHubListingSpecForProviderDataExchangeIdRef;

  /**
   * Selector for a AnalyticsHubDataExchange in bigquery to populate dataExchangeId.
   *
   * @schema AnalyticsHubListingSpecForProvider#dataExchangeIdSelector
   */
  readonly dataExchangeIdSelector?: AnalyticsHubListingSpecForProviderDataExchangeIdSelector;

  /**
   * Details of the data provider who owns the source data. Structure is documented below.
   *
   * @schema AnalyticsHubListingSpecForProvider#dataProvider
   */
  readonly dataProvider?: AnalyticsHubListingSpecForProviderDataProvider[];

  /**
   * Short description of the listing. The description must not contain Unicode non-characters and C0 and C1 control codes except tabs (HT), new lines (LF), carriage returns (CR), and page breaks (FF).
   *
   * @schema AnalyticsHubListingSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Human-readable display name of the listing. The display name must contain only Unicode letters, numbers (0-9), underscores (_), dashes (-), spaces ( ), ampersands (&) and can't start or end with spaces.
   *
   * @schema AnalyticsHubListingSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * Documentation describing the listing.
   *
   * @schema AnalyticsHubListingSpecForProvider#documentation
   */
  readonly documentation?: string;

  /**
   * Base64 encoded image representing the listing.
   *
   * @schema AnalyticsHubListingSpecForProvider#icon
   */
  readonly icon?: string;

  /**
   * The name of the location this data exchange listing.
   *
   * @schema AnalyticsHubListingSpecForProvider#location
   */
  readonly location: string;

  /**
   * Email or URL of the listing publisher.
   *
   * @schema AnalyticsHubListingSpecForProvider#primaryContact
   */
  readonly primaryContact?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AnalyticsHubListingSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Details of the publisher who owns the listing and who can share the source data. Structure is documented below.
   *
   * @schema AnalyticsHubListingSpecForProvider#publisher
   */
  readonly publisher?: AnalyticsHubListingSpecForProviderPublisher[];

  /**
   * Email or URL of the request access of the listing. Subscribers can use this reference to request access.
   *
   * @schema AnalyticsHubListingSpecForProvider#requestAccess
   */
  readonly requestAccess?: string;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProvider(obj: AnalyticsHubListingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigqueryDataset': obj.bigqueryDataset?.map(y => toJson_AnalyticsHubListingSpecForProviderBigqueryDataset(y)),
    'categories': obj.categories?.map(y => y),
    'dataExchangeId': obj.dataExchangeId,
    'dataExchangeIdRef': toJson_AnalyticsHubListingSpecForProviderDataExchangeIdRef(obj.dataExchangeIdRef),
    'dataExchangeIdSelector': toJson_AnalyticsHubListingSpecForProviderDataExchangeIdSelector(obj.dataExchangeIdSelector),
    'dataProvider': obj.dataProvider?.map(y => toJson_AnalyticsHubListingSpecForProviderDataProvider(y)),
    'description': obj.description,
    'displayName': obj.displayName,
    'documentation': obj.documentation,
    'icon': obj.icon,
    'location': obj.location,
    'primaryContact': obj.primaryContact,
    'project': obj.project,
    'publisher': obj.publisher?.map(y => toJson_AnalyticsHubListingSpecForProviderPublisher(y)),
    'requestAccess': obj.requestAccess,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AnalyticsHubListingSpecProviderConfigRef
 */
export interface AnalyticsHubListingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubListingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubListingSpecProviderConfigRef#policy
   */
  readonly policy?: AnalyticsHubListingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecProviderConfigRef(obj: AnalyticsHubListingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubListingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AnalyticsHubListingSpecProviderRef
 */
export interface AnalyticsHubListingSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubListingSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubListingSpecProviderRef#policy
   */
  readonly policy?: AnalyticsHubListingSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecProviderRef(obj: AnalyticsHubListingSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubListingSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AnalyticsHubListingSpecPublishConnectionDetailsTo
 */
export interface AnalyticsHubListingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AnalyticsHubListingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AnalyticsHubListingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AnalyticsHubListingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AnalyticsHubListingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AnalyticsHubListingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecPublishConnectionDetailsTo(obj: AnalyticsHubListingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AnalyticsHubListingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AnalyticsHubListingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AnalyticsHubListingSpecWriteConnectionSecretToRef
 */
export interface AnalyticsHubListingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AnalyticsHubListingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AnalyticsHubListingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecWriteConnectionSecretToRef(obj: AnalyticsHubListingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AnalyticsHubListingSpecForProviderBigqueryDataset
 */
export interface AnalyticsHubListingSpecForProviderBigqueryDataset {
  /**
   * Resource name of the dataset source for this listing. e.g. projects/myproject/datasets/123
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDataset#dataset
   */
  readonly dataset?: string;

  /**
   * Reference to a Dataset in bigquery to populate dataset.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDataset#datasetRef
   */
  readonly datasetRef?: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRef;

  /**
   * Selector for a Dataset in bigquery to populate dataset.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDataset#datasetSelector
   */
  readonly datasetSelector?: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelector;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderBigqueryDataset' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderBigqueryDataset(obj: AnalyticsHubListingSpecForProviderBigqueryDataset | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataset': obj.dataset,
    'datasetRef': toJson_AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRef(obj.datasetRef),
    'datasetSelector': toJson_AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelector(obj.datasetSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AnalyticsHubDataExchange in bigquery to populate dataExchangeId.
 *
 * @schema AnalyticsHubListingSpecForProviderDataExchangeIdRef
 */
export interface AnalyticsHubListingSpecForProviderDataExchangeIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubListingSpecForProviderDataExchangeIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubListingSpecForProviderDataExchangeIdRef#policy
   */
  readonly policy?: AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderDataExchangeIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderDataExchangeIdRef(obj: AnalyticsHubListingSpecForProviderDataExchangeIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AnalyticsHubDataExchange in bigquery to populate dataExchangeId.
 *
 * @schema AnalyticsHubListingSpecForProviderDataExchangeIdSelector
 */
export interface AnalyticsHubListingSpecForProviderDataExchangeIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AnalyticsHubListingSpecForProviderDataExchangeIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AnalyticsHubListingSpecForProviderDataExchangeIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AnalyticsHubListingSpecForProviderDataExchangeIdSelector#policy
   */
  readonly policy?: AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderDataExchangeIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderDataExchangeIdSelector(obj: AnalyticsHubListingSpecForProviderDataExchangeIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AnalyticsHubListingSpecForProviderDataProvider
 */
export interface AnalyticsHubListingSpecForProviderDataProvider {
  /**
   * Name of the data provider.
   *
   * @schema AnalyticsHubListingSpecForProviderDataProvider#name
   */
  readonly name: string;

  /**
   * Email or URL of the data provider.
   *
   * @schema AnalyticsHubListingSpecForProviderDataProvider#primaryContact
   */
  readonly primaryContact?: string;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderDataProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderDataProvider(obj: AnalyticsHubListingSpecForProviderDataProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'primaryContact': obj.primaryContact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AnalyticsHubListingSpecForProviderPublisher
 */
export interface AnalyticsHubListingSpecForProviderPublisher {
  /**
   * Name of the listing publisher.
   *
   * @schema AnalyticsHubListingSpecForProviderPublisher#name
   */
  readonly name: string;

  /**
   * Email or URL of the listing publisher.
   *
   * @schema AnalyticsHubListingSpecForProviderPublisher#primaryContact
   */
  readonly primaryContact?: string;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderPublisher' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderPublisher(obj: AnalyticsHubListingSpecForProviderPublisher | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'primaryContact': obj.primaryContact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubListingSpecProviderConfigRefPolicy
 */
export interface AnalyticsHubListingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubListingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubListingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubListingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubListingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecProviderConfigRefPolicy(obj: AnalyticsHubListingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubListingSpecProviderRefPolicy
 */
export interface AnalyticsHubListingSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubListingSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubListingSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubListingSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubListingSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecProviderRefPolicy(obj: AnalyticsHubListingSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AnalyticsHubListingSpecPublishConnectionDetailsToConfigRef
 */
export interface AnalyticsHubListingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubListingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubListingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecPublishConnectionDetailsToConfigRef(obj: AnalyticsHubListingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AnalyticsHubListingSpecPublishConnectionDetailsToMetadata
 */
export interface AnalyticsHubListingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AnalyticsHubListingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AnalyticsHubListingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AnalyticsHubListingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecPublishConnectionDetailsToMetadata(obj: AnalyticsHubListingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate dataset.
 *
 * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRef
 */
export interface AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRef#policy
   */
  readonly policy?: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRef(obj: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate dataset.
 *
 * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelector
 */
export interface AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelector#policy
   */
  readonly policy?: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicy;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelector(obj: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicy
 */
export interface AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicy(obj: AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicy
 */
export interface AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicy#resolution
   */
  readonly resolution?: AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicy#resolve
   */
  readonly resolve?: AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicy(obj: AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubListingSpecProviderConfigRefPolicyResolution
 */
export enum AnalyticsHubListingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubListingSpecProviderConfigRefPolicyResolve
 */
export enum AnalyticsHubListingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubListingSpecProviderRefPolicyResolution
 */
export enum AnalyticsHubListingSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubListingSpecProviderRefPolicyResolve
 */
export enum AnalyticsHubListingSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicy(obj: AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicy
 */
export interface AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicy#resolution
   */
  readonly resolution?: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicy#resolve
   */
  readonly resolve?: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicy(obj: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicy
 */
export interface AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicy#resolution
   */
  readonly resolution?: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicy#resolve
   */
  readonly resolve?: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicy(obj: AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicyResolution
 */
export enum AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicyResolve
 */
export enum AnalyticsHubListingSpecForProviderDataExchangeIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicyResolution
 */
export enum AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicyResolve
 */
export enum AnalyticsHubListingSpecForProviderDataExchangeIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AnalyticsHubListingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicyResolution
 */
export enum AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicyResolve
 */
export enum AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicyResolution
 */
export enum AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicyResolve
 */
export enum AnalyticsHubListingSpecForProviderBigqueryDatasetDatasetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Connection is the Schema for the Connections API. A connection allows BigQuery connections to external data sources.
 *
 * @schema Connection
 */
export class Connection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Connection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'Connection',
  }

  /**
   * Renders a Kubernetes manifest for "Connection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectionProps): any {
    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(props),
    };
  }

  /**
   * Defines a "Connection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectionProps) {
    super(scope, id, {
      ...Connection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(resolved),
    };
  }
}

/**
 * Connection is the Schema for the Connections API. A connection allows BigQuery connections to external data sources.
 *
 * @schema Connection
 */
export interface ConnectionProps {
  /**
   * @schema Connection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectionSpec defines the desired state of Connection
   *
   * @schema Connection#spec
   */
  readonly spec: ConnectionSpec;

}

/**
 * Converts an object of type 'ConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProps(obj: ConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionSpec defines the desired state of Connection
 *
 * @schema ConnectionSpec
 */
export interface ConnectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ConnectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectionSpecDeletionPolicy;

  /**
   * @schema ConnectionSpec#forProvider
   */
  readonly forProvider: ConnectionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConnectionSpec#providerRef
   */
  readonly providerRef?: ConnectionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpec(obj: ConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ConnectionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConnectionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConnectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ConnectionSpecDeletionPolicy
 */
export enum ConnectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConnectionSpecForProvider
 */
export interface ConnectionSpecForProvider {
  /**
   * Connection properties specific to Amazon Web Services. Structure is documented below.
   *
   * @schema ConnectionSpecForProvider#aws
   */
  readonly aws?: ConnectionSpecForProviderAws[];

  /**
   * Container for connection properties specific to Azure. Structure is documented below.
   *
   * @schema ConnectionSpecForProvider#azure
   */
  readonly azure?: ConnectionSpecForProviderAzure[];

  /**
   * Container for connection properties for delegation of access to GCP resources. Structure is documented below.
   *
   * @schema ConnectionSpecForProvider#cloudResource
   */
  readonly cloudResource?: any[];

  /**
   * Connection properties specific to Cloud Spanner Structure is documented below.
   *
   * @schema ConnectionSpecForProvider#cloudSpanner
   */
  readonly cloudSpanner?: ConnectionSpecForProviderCloudSpanner[];

  /**
   * Connection properties specific to the Cloud SQL. Structure is documented below.
   *
   * @schema ConnectionSpecForProvider#cloudSql
   */
  readonly cloudSql?: ConnectionSpecForProviderCloudSql[];

  /**
   * Optional connection id that should be assigned to the created connection.
   *
   * @schema ConnectionSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * A descriptive description for the connection
   *
   * @schema ConnectionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A descriptive name for the connection
   *
   * @schema ConnectionSpecForProvider#friendlyName
   */
  readonly friendlyName?: string;

  /**
   * The geographic location where the connection should reside. Cloud SQL instance must be in the same location as the connection with following exceptions: Cloud SQL us-central1 maps to BigQuery US, Cloud SQL europe-west1 maps to BigQuery EU. Examples: US, EU, asia-northeast1, us-central1, europe-west1. Spanner Connections same as spanner region AWS allowed regions are aws-us-east-1 Azure allowed regions are azure-eastus2
   *
   * @schema ConnectionSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema ConnectionSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProvider(obj: ConnectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aws': obj.aws?.map(y => toJson_ConnectionSpecForProviderAws(y)),
    'azure': obj.azure?.map(y => toJson_ConnectionSpecForProviderAzure(y)),
    'cloudResource': obj.cloudResource?.map(y => y),
    'cloudSpanner': obj.cloudSpanner?.map(y => toJson_ConnectionSpecForProviderCloudSpanner(y)),
    'cloudSql': obj.cloudSql?.map(y => toJson_ConnectionSpecForProviderCloudSql(y)),
    'connectionId': obj.connectionId,
    'description': obj.description,
    'friendlyName': obj.friendlyName,
    'location': obj.location,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectionSpecProviderConfigRef
 */
export interface ConnectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRef(obj: ConnectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConnectionSpecProviderRef
 */
export interface ConnectionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecProviderRef#policy
   */
  readonly policy?: ConnectionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderRef(obj: ConnectionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectionSpecPublishConnectionDetailsTo
 */
export interface ConnectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsTo(obj: ConnectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectionSpecWriteConnectionSecretToRef
 */
export interface ConnectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecWriteConnectionSecretToRef(obj: ConnectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAws
 */
export interface ConnectionSpecForProviderAws {
  /**
   * Authentication using Google owned service account to assume into customer's AWS IAM Role. Structure is documented below.
   *
   * @schema ConnectionSpecForProviderAws#accessRole
   */
  readonly accessRole: ConnectionSpecForProviderAwsAccessRole[];

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAws(obj: ConnectionSpecForProviderAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessRole': obj.accessRole?.map(y => toJson_ConnectionSpecForProviderAwsAccessRole(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAzure
 */
export interface ConnectionSpecForProviderAzure {
  /**
   * The id of customer's directory that host the data.
   *
   * @schema ConnectionSpecForProviderAzure#customerTenantId
   */
  readonly customerTenantId: string;

  /**
   * The Azure Application (client) ID where the federated credentials will be hosted.
   *
   * @schema ConnectionSpecForProviderAzure#federatedApplicationClientId
   */
  readonly federatedApplicationClientId?: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAzure(obj: ConnectionSpecForProviderAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerTenantId': obj.customerTenantId,
    'federatedApplicationClientId': obj.federatedApplicationClientId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderCloudSpanner
 */
export interface ConnectionSpecForProviderCloudSpanner {
  /**
   * Cloud Spanner database in the form `project/instance/database'
   *
   * @schema ConnectionSpecForProviderCloudSpanner#database
   */
  readonly database: string;

  /**
   * If parallelism should be used when reading from Cloud Spanner
   *
   * @schema ConnectionSpecForProviderCloudSpanner#useParallelism
   */
  readonly useParallelism?: boolean;

  /**
   * If the serverless analytics service should be used to read data from Cloud Spanner. useParallelism must be set when using serverless analytics
   *
   * @schema ConnectionSpecForProviderCloudSpanner#useServerlessAnalytics
   */
  readonly useServerlessAnalytics?: boolean;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSpanner' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSpanner(obj: ConnectionSpecForProviderCloudSpanner | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'useParallelism': obj.useParallelism,
    'useServerlessAnalytics': obj.useServerlessAnalytics,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderCloudSql
 */
export interface ConnectionSpecForProviderCloudSql {
  /**
   * Cloud SQL properties. Structure is documented below.
   *
   * @schema ConnectionSpecForProviderCloudSql#credential
   */
  readonly credential: ConnectionSpecForProviderCloudSqlCredential[];

  /**
   * Database name.
   *
   * @schema ConnectionSpecForProviderCloudSql#database
   */
  readonly database?: string;

  /**
   * Reference to a Database in sql to populate database.
   *
   * @schema ConnectionSpecForProviderCloudSql#databaseRef
   */
  readonly databaseRef?: ConnectionSpecForProviderCloudSqlDatabaseRef;

  /**
   * Selector for a Database in sql to populate database.
   *
   * @schema ConnectionSpecForProviderCloudSql#databaseSelector
   */
  readonly databaseSelector?: ConnectionSpecForProviderCloudSqlDatabaseSelector;

  /**
   * Cloud SQL instance ID in the form project:location:instance.
   *
   * @schema ConnectionSpecForProviderCloudSql#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a DatabaseInstance in sql to populate instanceId.
   *
   * @schema ConnectionSpecForProviderCloudSql#instanceIdRef
   */
  readonly instanceIdRef?: ConnectionSpecForProviderCloudSqlInstanceIdRef;

  /**
   * Selector for a DatabaseInstance in sql to populate instanceId.
   *
   * @schema ConnectionSpecForProviderCloudSql#instanceIdSelector
   */
  readonly instanceIdSelector?: ConnectionSpecForProviderCloudSqlInstanceIdSelector;

  /**
   * Type of the Cloud SQL database. Possible values are DATABASE_TYPE_UNSPECIFIED, POSTGRES, and MYSQL.
   *
   * @schema ConnectionSpecForProviderCloudSql#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSql' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSql(obj: ConnectionSpecForProviderCloudSql | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credential': obj.credential?.map(y => toJson_ConnectionSpecForProviderCloudSqlCredential(y)),
    'database': obj.database,
    'databaseRef': toJson_ConnectionSpecForProviderCloudSqlDatabaseRef(obj.databaseRef),
    'databaseSelector': toJson_ConnectionSpecForProviderCloudSqlDatabaseSelector(obj.databaseSelector),
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_ConnectionSpecForProviderCloudSqlInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_ConnectionSpecForProviderCloudSqlInstanceIdSelector(obj.instanceIdSelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecProviderConfigRefPolicy
 */
export interface ConnectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRefPolicy(obj: ConnectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecProviderRefPolicy
 */
export interface ConnectionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderRefPolicy(obj: ConnectionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj: ConnectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj: ConnectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAwsAccessRole
 */
export interface ConnectionSpecForProviderAwsAccessRole {
  /**
   * The user’s AWS IAM Role that trusts the Google-owned AWS IAM user Connection.
   *
   * @schema ConnectionSpecForProviderAwsAccessRole#iamRoleId
   */
  readonly iamRoleId: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAwsAccessRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAwsAccessRole(obj: ConnectionSpecForProviderAwsAccessRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iamRoleId': obj.iamRoleId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderCloudSqlCredential
 */
export interface ConnectionSpecForProviderCloudSqlCredential {
  /**
   * Password for database. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredential#passwordSecretRef
   */
  readonly passwordSecretRef: ConnectionSpecForProviderCloudSqlCredentialPasswordSecretRef;

  /**
   * Username for database.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredential#username
   */
  readonly username?: string;

  /**
   * Reference to a User in sql to populate username.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredential#usernameRef
   */
  readonly usernameRef?: ConnectionSpecForProviderCloudSqlCredentialUsernameRef;

  /**
   * Selector for a User in sql to populate username.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredential#usernameSelector
   */
  readonly usernameSelector?: ConnectionSpecForProviderCloudSqlCredentialUsernameSelector;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlCredential' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlCredential(obj: ConnectionSpecForProviderCloudSqlCredential | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretRef': toJson_ConnectionSpecForProviderCloudSqlCredentialPasswordSecretRef(obj.passwordSecretRef),
    'username': obj.username,
    'usernameRef': toJson_ConnectionSpecForProviderCloudSqlCredentialUsernameRef(obj.usernameRef),
    'usernameSelector': toJson_ConnectionSpecForProviderCloudSqlCredentialUsernameSelector(obj.usernameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Database in sql to populate database.
 *
 * @schema ConnectionSpecForProviderCloudSqlDatabaseRef
 */
export interface ConnectionSpecForProviderCloudSqlDatabaseRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecForProviderCloudSqlDatabaseRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecForProviderCloudSqlDatabaseRef#policy
   */
  readonly policy?: ConnectionSpecForProviderCloudSqlDatabaseRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlDatabaseRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlDatabaseRef(obj: ConnectionSpecForProviderCloudSqlDatabaseRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecForProviderCloudSqlDatabaseRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Database in sql to populate database.
 *
 * @schema ConnectionSpecForProviderCloudSqlDatabaseSelector
 */
export interface ConnectionSpecForProviderCloudSqlDatabaseSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionSpecForProviderCloudSqlDatabaseSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionSpecForProviderCloudSqlDatabaseSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionSpecForProviderCloudSqlDatabaseSelector#policy
   */
  readonly policy?: ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlDatabaseSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlDatabaseSelector(obj: ConnectionSpecForProviderCloudSqlDatabaseSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DatabaseInstance in sql to populate instanceId.
 *
 * @schema ConnectionSpecForProviderCloudSqlInstanceIdRef
 */
export interface ConnectionSpecForProviderCloudSqlInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecForProviderCloudSqlInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecForProviderCloudSqlInstanceIdRef#policy
   */
  readonly policy?: ConnectionSpecForProviderCloudSqlInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlInstanceIdRef(obj: ConnectionSpecForProviderCloudSqlInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecForProviderCloudSqlInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DatabaseInstance in sql to populate instanceId.
 *
 * @schema ConnectionSpecForProviderCloudSqlInstanceIdSelector
 */
export interface ConnectionSpecForProviderCloudSqlInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionSpecForProviderCloudSqlInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionSpecForProviderCloudSqlInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionSpecForProviderCloudSqlInstanceIdSelector#policy
   */
  readonly policy?: ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlInstanceIdSelector(obj: ConnectionSpecForProviderCloudSqlInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolution
 */
export enum ConnectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolve
 */
export enum ConnectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecProviderRefPolicyResolution
 */
export enum ConnectionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecProviderRefPolicyResolve
 */
export enum ConnectionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for database. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema ConnectionSpecForProviderCloudSqlCredentialPasswordSecretRef
 */
export interface ConnectionSpecForProviderCloudSqlCredentialPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlCredentialPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlCredentialPasswordSecretRef(obj: ConnectionSpecForProviderCloudSqlCredentialPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in sql to populate username.
 *
 * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameRef
 */
export interface ConnectionSpecForProviderCloudSqlCredentialUsernameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameRef#policy
   */
  readonly policy?: ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlCredentialUsernameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlCredentialUsernameRef(obj: ConnectionSpecForProviderCloudSqlCredentialUsernameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in sql to populate username.
 *
 * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameSelector
 */
export interface ConnectionSpecForProviderCloudSqlCredentialUsernameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameSelector#policy
   */
  readonly policy?: ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlCredentialUsernameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlCredentialUsernameSelector(obj: ConnectionSpecForProviderCloudSqlCredentialUsernameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecForProviderCloudSqlDatabaseRefPolicy
 */
export interface ConnectionSpecForProviderCloudSqlDatabaseRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderCloudSqlDatabaseRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderCloudSqlDatabaseRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderCloudSqlDatabaseRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderCloudSqlDatabaseRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlDatabaseRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlDatabaseRefPolicy(obj: ConnectionSpecForProviderCloudSqlDatabaseRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicy
 */
export interface ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicy(obj: ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecForProviderCloudSqlInstanceIdRefPolicy
 */
export interface ConnectionSpecForProviderCloudSqlInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderCloudSqlInstanceIdRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderCloudSqlInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderCloudSqlInstanceIdRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderCloudSqlInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlInstanceIdRefPolicy(obj: ConnectionSpecForProviderCloudSqlInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicy
 */
export interface ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicy(obj: ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicy
 */
export interface ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicy(obj: ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicy
 */
export interface ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicy(obj: ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderCloudSqlDatabaseRefPolicyResolution
 */
export enum ConnectionSpecForProviderCloudSqlDatabaseRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderCloudSqlDatabaseRefPolicyResolve
 */
export enum ConnectionSpecForProviderCloudSqlDatabaseRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicyResolution
 */
export enum ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicyResolve
 */
export enum ConnectionSpecForProviderCloudSqlDatabaseSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderCloudSqlInstanceIdRefPolicyResolution
 */
export enum ConnectionSpecForProviderCloudSqlInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderCloudSqlInstanceIdRefPolicyResolve
 */
export enum ConnectionSpecForProviderCloudSqlInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicyResolution
 */
export enum ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicyResolve
 */
export enum ConnectionSpecForProviderCloudSqlInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicyResolution
 */
export enum ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicyResolve
 */
export enum ConnectionSpecForProviderCloudSqlCredentialUsernameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicyResolution
 */
export enum ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicyResolve
 */
export enum ConnectionSpecForProviderCloudSqlCredentialUsernameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Dataset is the Schema for the Datasets API. Datasets allow you to organize and control access to your tables.
 *
 * @schema Dataset
 */
export class Dataset extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Dataset"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'Dataset',
  }

  /**
   * Renders a Kubernetes manifest for "Dataset".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatasetProps): any {
    return {
      ...Dataset.GVK,
      ...toJson_DatasetProps(props),
    };
  }

  /**
   * Defines a "Dataset" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatasetProps) {
    super(scope, id, {
      ...Dataset.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Dataset.GVK,
      ...toJson_DatasetProps(resolved),
    };
  }
}

/**
 * Dataset is the Schema for the Datasets API. Datasets allow you to organize and control access to your tables.
 *
 * @schema Dataset
 */
export interface DatasetProps {
  /**
   * @schema Dataset#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatasetSpec defines the desired state of Dataset
   *
   * @schema Dataset#spec
   */
  readonly spec: DatasetSpec;

}

/**
 * Converts an object of type 'DatasetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetProps(obj: DatasetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatasetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatasetSpec defines the desired state of Dataset
 *
 * @schema DatasetSpec
 */
export interface DatasetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DatasetSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatasetSpecDeletionPolicy;

  /**
   * @schema DatasetSpec#forProvider
   */
  readonly forProvider: DatasetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatasetSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatasetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DatasetSpec#providerRef
   */
  readonly providerRef?: DatasetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatasetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatasetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatasetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatasetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatasetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpec(obj: DatasetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatasetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DatasetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DatasetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DatasetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatasetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DatasetSpecDeletionPolicy
 */
export enum DatasetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatasetSpecForProvider
 */
export interface DatasetSpecForProvider {
  /**
   * An array of objects that define dataset access for one or more entities. Structure is documented below.
   *
   * @schema DatasetSpecForProvider#access
   */
  readonly access?: DatasetSpecForProviderAccess[];

  /**
   * The default encryption key for all tables in the dataset. Once this property is set, all newly-created partitioned tables in the dataset will have encryption key set to this value, unless table creation request (or query) overrides the key. Structure is documented below.
   *
   * @schema DatasetSpecForProvider#defaultEncryptionConfiguration
   */
  readonly defaultEncryptionConfiguration?: DatasetSpecForProviderDefaultEncryptionConfiguration[];

  /**
   * The default partition expiration for all partitioned tables in the dataset, in milliseconds.
   *
   * @schema DatasetSpecForProvider#defaultPartitionExpirationMs
   */
  readonly defaultPartitionExpirationMs?: number;

  /**
   * The default lifetime of all tables in the dataset, in milliseconds. The minimum value is 3600000 milliseconds (one hour).
   *
   * @schema DatasetSpecForProvider#defaultTableExpirationMs
   */
  readonly defaultTableExpirationMs?: number;

  /**
   * If set to true, delete all the tables in the dataset when destroying the resource; otherwise, destroying the resource will fail if tables are present.
   *
   * @schema DatasetSpecForProvider#deleteContentsOnDestroy
   */
  readonly deleteContentsOnDestroy?: boolean;

  /**
   * A user-friendly description of the dataset
   *
   * @schema DatasetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A descriptive name for the dataset
   *
   * @schema DatasetSpecForProvider#friendlyName
   */
  readonly friendlyName?: string;

  /**
   * The labels associated with this dataset. You can use these to organize and group your datasets
   *
   * @schema DatasetSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The geographic location where the dataset should reside. See official docs.
   *
   * @schema DatasetSpecForProvider#location
   */
  readonly location?: string;

  /**
   * Defines the time travel window in hours. The value can be from 48 to 168 hours (2 to 7 days).
   *
   * @schema DatasetSpecForProvider#maxTimeTravelHours
   */
  readonly maxTimeTravelHours?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DatasetSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'DatasetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProvider(obj: DatasetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'access': obj.access?.map(y => toJson_DatasetSpecForProviderAccess(y)),
    'defaultEncryptionConfiguration': obj.defaultEncryptionConfiguration?.map(y => toJson_DatasetSpecForProviderDefaultEncryptionConfiguration(y)),
    'defaultPartitionExpirationMs': obj.defaultPartitionExpirationMs,
    'defaultTableExpirationMs': obj.defaultTableExpirationMs,
    'deleteContentsOnDestroy': obj.deleteContentsOnDestroy,
    'description': obj.description,
    'friendlyName': obj.friendlyName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'maxTimeTravelHours': obj.maxTimeTravelHours,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatasetSpecProviderConfigRef
 */
export interface DatasetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecProviderConfigRef#policy
   */
  readonly policy?: DatasetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecProviderConfigRef(obj: DatasetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DatasetSpecProviderRef
 */
export interface DatasetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecProviderRef#policy
   */
  readonly policy?: DatasetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecProviderRef(obj: DatasetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatasetSpecPublishConnectionDetailsTo
 */
export interface DatasetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatasetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatasetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatasetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatasetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatasetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsTo(obj: DatasetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatasetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatasetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatasetSpecWriteConnectionSecretToRef
 */
export interface DatasetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatasetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatasetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatasetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecWriteConnectionSecretToRef(obj: DatasetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetSpecForProviderAccess
 */
export interface DatasetSpecForProviderAccess {
  /**
   * Grants all resources of particular types in a particular dataset read access to the current dataset. Structure is documented below.
   *
   * @schema DatasetSpecForProviderAccess#dataset
   */
  readonly dataset?: DatasetSpecForProviderAccessDataset[];

  /**
   * A domain to grant access to. Any users signed in with the domain specified will be granted the specified access
   *
   * @schema DatasetSpecForProviderAccess#domain
   */
  readonly domain?: string;

  /**
   * An email address of a Google Group to grant access to.
   *
   * @schema DatasetSpecForProviderAccess#groupByEmail
   */
  readonly groupByEmail?: string;

  /**
   * Describes the rights granted to the user specified by the other member of the access object. Basic, predefined, and custom roles are supported. Predefined roles that have equivalent basic roles are swapped by the API to their basic counterparts. See official docs.
   *
   * @schema DatasetSpecForProviderAccess#role
   */
  readonly role?: string;

  /**
   * A routine from a different dataset to grant access to. Queries executed against that routine will have read access to tables in this dataset. The role field is not required when this field is set. If that routine is updated by any user, access to the routine needs to be granted again via an update operation. Structure is documented below.
   *
   * @schema DatasetSpecForProviderAccess#routine
   */
  readonly routine?: DatasetSpecForProviderAccessRoutine[];

  /**
   * A special group to grant access to. Possible values include:
   *
   * @schema DatasetSpecForProviderAccess#specialGroup
   */
  readonly specialGroup?: string;

  /**
   * An email address of a user to grant access to. For example: fred@example.com
   *
   * @schema DatasetSpecForProviderAccess#userByEmail
   */
  readonly userByEmail?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate userByEmail.
   *
   * @schema DatasetSpecForProviderAccess#userByEmailRef
   */
  readonly userByEmailRef?: DatasetSpecForProviderAccessUserByEmailRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate userByEmail.
   *
   * @schema DatasetSpecForProviderAccess#userByEmailSelector
   */
  readonly userByEmailSelector?: DatasetSpecForProviderAccessUserByEmailSelector;

  /**
   * A view from a different dataset to grant access to. Queries executed against that view will have read access to tables in this dataset. The role field is not required when this field is set. If that view is updated by any user, access to the view needs to be granted again via an update operation. Structure is documented below.
   *
   * @schema DatasetSpecForProviderAccess#view
   */
  readonly view?: DatasetSpecForProviderAccessView[];

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccess(obj: DatasetSpecForProviderAccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataset': obj.dataset?.map(y => toJson_DatasetSpecForProviderAccessDataset(y)),
    'domain': obj.domain,
    'groupByEmail': obj.groupByEmail,
    'role': obj.role,
    'routine': obj.routine?.map(y => toJson_DatasetSpecForProviderAccessRoutine(y)),
    'specialGroup': obj.specialGroup,
    'userByEmail': obj.userByEmail,
    'userByEmailRef': toJson_DatasetSpecForProviderAccessUserByEmailRef(obj.userByEmailRef),
    'userByEmailSelector': toJson_DatasetSpecForProviderAccessUserByEmailSelector(obj.userByEmailSelector),
    'view': obj.view?.map(y => toJson_DatasetSpecForProviderAccessView(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetSpecForProviderDefaultEncryptionConfiguration
 */
export interface DatasetSpecForProviderDefaultEncryptionConfiguration {
  /**
   * Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfiguration#kmsKeyName
   */
  readonly kmsKeyName?: string;

  /**
   * Reference to a CryptoKey in kms to populate kmsKeyName.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfiguration#kmsKeyNameRef
   */
  readonly kmsKeyNameRef?: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRef;

  /**
   * Selector for a CryptoKey in kms to populate kmsKeyName.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfiguration#kmsKeyNameSelector
   */
  readonly kmsKeyNameSelector?: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelector;

}

/**
 * Converts an object of type 'DatasetSpecForProviderDefaultEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderDefaultEncryptionConfiguration(obj: DatasetSpecForProviderDefaultEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
    'kmsKeyNameRef': toJson_DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRef(obj.kmsKeyNameRef),
    'kmsKeyNameSelector': toJson_DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelector(obj.kmsKeyNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecProviderConfigRefPolicy
 */
export interface DatasetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecProviderConfigRefPolicy(obj: DatasetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecProviderRefPolicy
 */
export interface DatasetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecProviderRefPolicy(obj: DatasetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRef
 */
export interface DatasetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatasetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsToConfigRef(obj: DatasetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatasetSpecPublishConnectionDetailsToMetadata
 */
export interface DatasetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatasetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsToMetadata(obj: DatasetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetSpecForProviderAccessDataset
 */
export interface DatasetSpecForProviderAccessDataset {
  /**
   * The dataset this entry applies to Structure is documented below.
   *
   * @schema DatasetSpecForProviderAccessDataset#dataset
   */
  readonly dataset: DatasetSpecForProviderAccessDatasetDataset[];

  /**
   * Which resources in the dataset this entry applies to. Currently, only views are supported, but additional target types may be added in the future. Possible values: VIEWS
   *
   * @schema DatasetSpecForProviderAccessDataset#targetTypes
   */
  readonly targetTypes: string[];

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessDataset' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessDataset(obj: DatasetSpecForProviderAccessDataset | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataset': obj.dataset?.map(y => toJson_DatasetSpecForProviderAccessDatasetDataset(y)),
    'targetTypes': obj.targetTypes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetSpecForProviderAccessRoutine
 */
export interface DatasetSpecForProviderAccessRoutine {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema DatasetSpecForProviderAccessRoutine#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Routine in bigquery to populate datasetId.
   *
   * @schema DatasetSpecForProviderAccessRoutine#datasetIdRef
   */
  readonly datasetIdRef?: DatasetSpecForProviderAccessRoutineDatasetIdRef;

  /**
   * Selector for a Routine in bigquery to populate datasetId.
   *
   * @schema DatasetSpecForProviderAccessRoutine#datasetIdSelector
   */
  readonly datasetIdSelector?: DatasetSpecForProviderAccessRoutineDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema DatasetSpecForProviderAccessRoutine#projectId
   */
  readonly projectId?: string;

  /**
   * Reference to a Routine in bigquery to populate projectId.
   *
   * @schema DatasetSpecForProviderAccessRoutine#projectIdRef
   */
  readonly projectIdRef?: DatasetSpecForProviderAccessRoutineProjectIdRef;

  /**
   * Selector for a Routine in bigquery to populate projectId.
   *
   * @schema DatasetSpecForProviderAccessRoutine#projectIdSelector
   */
  readonly projectIdSelector?: DatasetSpecForProviderAccessRoutineProjectIdSelector;

  /**
   * The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
   *
   * @schema DatasetSpecForProviderAccessRoutine#routineId
   */
  readonly routineId?: string;

  /**
   * Reference to a Routine in bigquery to populate routineId.
   *
   * @schema DatasetSpecForProviderAccessRoutine#routineIdRef
   */
  readonly routineIdRef?: DatasetSpecForProviderAccessRoutineRoutineIdRef;

  /**
   * Selector for a Routine in bigquery to populate routineId.
   *
   * @schema DatasetSpecForProviderAccessRoutine#routineIdSelector
   */
  readonly routineIdSelector?: DatasetSpecForProviderAccessRoutineRoutineIdSelector;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutine(obj: DatasetSpecForProviderAccessRoutine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_DatasetSpecForProviderAccessRoutineDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_DatasetSpecForProviderAccessRoutineDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
    'projectIdRef': toJson_DatasetSpecForProviderAccessRoutineProjectIdRef(obj.projectIdRef),
    'projectIdSelector': toJson_DatasetSpecForProviderAccessRoutineProjectIdSelector(obj.projectIdSelector),
    'routineId': obj.routineId,
    'routineIdRef': toJson_DatasetSpecForProviderAccessRoutineRoutineIdRef(obj.routineIdRef),
    'routineIdSelector': toJson_DatasetSpecForProviderAccessRoutineRoutineIdSelector(obj.routineIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate userByEmail.
 *
 * @schema DatasetSpecForProviderAccessUserByEmailRef
 */
export interface DatasetSpecForProviderAccessUserByEmailRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecForProviderAccessUserByEmailRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecForProviderAccessUserByEmailRef#policy
   */
  readonly policy?: DatasetSpecForProviderAccessUserByEmailRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessUserByEmailRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessUserByEmailRef(obj: DatasetSpecForProviderAccessUserByEmailRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecForProviderAccessUserByEmailRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate userByEmail.
 *
 * @schema DatasetSpecForProviderAccessUserByEmailSelector
 */
export interface DatasetSpecForProviderAccessUserByEmailSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetSpecForProviderAccessUserByEmailSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetSpecForProviderAccessUserByEmailSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetSpecForProviderAccessUserByEmailSelector#policy
   */
  readonly policy?: DatasetSpecForProviderAccessUserByEmailSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessUserByEmailSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessUserByEmailSelector(obj: DatasetSpecForProviderAccessUserByEmailSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetSpecForProviderAccessUserByEmailSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetSpecForProviderAccessView
 */
export interface DatasetSpecForProviderAccessView {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema DatasetSpecForProviderAccessView#datasetId
   */
  readonly datasetId: string;

  /**
   * The ID of the project containing this table.
   *
   * @schema DatasetSpecForProviderAccessView#projectId
   */
  readonly projectId: string;

  /**
   * The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
   *
   * @schema DatasetSpecForProviderAccessView#tableId
   */
  readonly tableId: string;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessView(obj: DatasetSpecForProviderAccessView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate kmsKeyName.
 *
 * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRef
 */
export interface DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRef#policy
   */
  readonly policy?: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRef(obj: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate kmsKeyName.
 *
 * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelector
 */
export interface DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelector#policy
   */
  readonly policy?: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelector(obj: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecProviderConfigRefPolicyResolution
 */
export enum DatasetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecProviderConfigRefPolicyResolve
 */
export enum DatasetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecProviderRefPolicyResolution
 */
export enum DatasetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecProviderRefPolicyResolve
 */
export enum DatasetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatasetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatasetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetSpecForProviderAccessDatasetDataset
 */
export interface DatasetSpecForProviderAccessDatasetDataset {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema DatasetSpecForProviderAccessDatasetDataset#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetSpecForProviderAccessDatasetDataset#datasetIdRef
   */
  readonly datasetIdRef?: DatasetSpecForProviderAccessDatasetDatasetDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetSpecForProviderAccessDatasetDataset#datasetIdSelector
   */
  readonly datasetIdSelector?: DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema DatasetSpecForProviderAccessDatasetDataset#projectId
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessDatasetDataset' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessDatasetDataset(obj: DatasetSpecForProviderAccessDatasetDataset | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_DatasetSpecForProviderAccessDatasetDatasetDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Routine in bigquery to populate datasetId.
 *
 * @schema DatasetSpecForProviderAccessRoutineDatasetIdRef
 */
export interface DatasetSpecForProviderAccessRoutineDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecForProviderAccessRoutineDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecForProviderAccessRoutineDatasetIdRef#policy
   */
  readonly policy?: DatasetSpecForProviderAccessRoutineDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineDatasetIdRef(obj: DatasetSpecForProviderAccessRoutineDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecForProviderAccessRoutineDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Routine in bigquery to populate datasetId.
 *
 * @schema DatasetSpecForProviderAccessRoutineDatasetIdSelector
 */
export interface DatasetSpecForProviderAccessRoutineDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetSpecForProviderAccessRoutineDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetSpecForProviderAccessRoutineDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetSpecForProviderAccessRoutineDatasetIdSelector#policy
   */
  readonly policy?: DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineDatasetIdSelector(obj: DatasetSpecForProviderAccessRoutineDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Routine in bigquery to populate projectId.
 *
 * @schema DatasetSpecForProviderAccessRoutineProjectIdRef
 */
export interface DatasetSpecForProviderAccessRoutineProjectIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecForProviderAccessRoutineProjectIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecForProviderAccessRoutineProjectIdRef#policy
   */
  readonly policy?: DatasetSpecForProviderAccessRoutineProjectIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineProjectIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineProjectIdRef(obj: DatasetSpecForProviderAccessRoutineProjectIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecForProviderAccessRoutineProjectIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Routine in bigquery to populate projectId.
 *
 * @schema DatasetSpecForProviderAccessRoutineProjectIdSelector
 */
export interface DatasetSpecForProviderAccessRoutineProjectIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetSpecForProviderAccessRoutineProjectIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetSpecForProviderAccessRoutineProjectIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetSpecForProviderAccessRoutineProjectIdSelector#policy
   */
  readonly policy?: DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineProjectIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineProjectIdSelector(obj: DatasetSpecForProviderAccessRoutineProjectIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Routine in bigquery to populate routineId.
 *
 * @schema DatasetSpecForProviderAccessRoutineRoutineIdRef
 */
export interface DatasetSpecForProviderAccessRoutineRoutineIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecForProviderAccessRoutineRoutineIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecForProviderAccessRoutineRoutineIdRef#policy
   */
  readonly policy?: DatasetSpecForProviderAccessRoutineRoutineIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineRoutineIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineRoutineIdRef(obj: DatasetSpecForProviderAccessRoutineRoutineIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecForProviderAccessRoutineRoutineIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Routine in bigquery to populate routineId.
 *
 * @schema DatasetSpecForProviderAccessRoutineRoutineIdSelector
 */
export interface DatasetSpecForProviderAccessRoutineRoutineIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetSpecForProviderAccessRoutineRoutineIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetSpecForProviderAccessRoutineRoutineIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetSpecForProviderAccessRoutineRoutineIdSelector#policy
   */
  readonly policy?: DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineRoutineIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineRoutineIdSelector(obj: DatasetSpecForProviderAccessRoutineRoutineIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecForProviderAccessUserByEmailRefPolicy
 */
export interface DatasetSpecForProviderAccessUserByEmailRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderAccessUserByEmailRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderAccessUserByEmailRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderAccessUserByEmailRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderAccessUserByEmailRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessUserByEmailRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessUserByEmailRefPolicy(obj: DatasetSpecForProviderAccessUserByEmailRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetSpecForProviderAccessUserByEmailSelectorPolicy
 */
export interface DatasetSpecForProviderAccessUserByEmailSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderAccessUserByEmailSelectorPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderAccessUserByEmailSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderAccessUserByEmailSelectorPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderAccessUserByEmailSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessUserByEmailSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessUserByEmailSelectorPolicy(obj: DatasetSpecForProviderAccessUserByEmailSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicy
 */
export interface DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicy(obj: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicy
 */
export interface DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicy(obj: DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdRef
 */
export interface DatasetSpecForProviderAccessDatasetDatasetDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdRef#policy
   */
  readonly policy?: DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessDatasetDatasetDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessDatasetDatasetDatasetIdRef(obj: DatasetSpecForProviderAccessDatasetDatasetDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelector
 */
export interface DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelector#policy
   */
  readonly policy?: DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelector(obj: DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecForProviderAccessRoutineDatasetIdRefPolicy
 */
export interface DatasetSpecForProviderAccessRoutineDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderAccessRoutineDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderAccessRoutineDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderAccessRoutineDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderAccessRoutineDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineDatasetIdRefPolicy(obj: DatasetSpecForProviderAccessRoutineDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicy
 */
export interface DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicy(obj: DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecForProviderAccessRoutineProjectIdRefPolicy
 */
export interface DatasetSpecForProviderAccessRoutineProjectIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderAccessRoutineProjectIdRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderAccessRoutineProjectIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderAccessRoutineProjectIdRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderAccessRoutineProjectIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineProjectIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineProjectIdRefPolicy(obj: DatasetSpecForProviderAccessRoutineProjectIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicy
 */
export interface DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicy(obj: DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecForProviderAccessRoutineRoutineIdRefPolicy
 */
export interface DatasetSpecForProviderAccessRoutineRoutineIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderAccessRoutineRoutineIdRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderAccessRoutineRoutineIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderAccessRoutineRoutineIdRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderAccessRoutineRoutineIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineRoutineIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineRoutineIdRefPolicy(obj: DatasetSpecForProviderAccessRoutineRoutineIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicy
 */
export interface DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicy(obj: DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderAccessUserByEmailRefPolicyResolution
 */
export enum DatasetSpecForProviderAccessUserByEmailRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderAccessUserByEmailRefPolicyResolve
 */
export enum DatasetSpecForProviderAccessUserByEmailRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderAccessUserByEmailSelectorPolicyResolution
 */
export enum DatasetSpecForProviderAccessUserByEmailSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderAccessUserByEmailSelectorPolicyResolve
 */
export enum DatasetSpecForProviderAccessUserByEmailSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicyResolution
 */
export enum DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicyResolve
 */
export enum DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicyResolution
 */
export enum DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicyResolve
 */
export enum DatasetSpecForProviderDefaultEncryptionConfigurationKmsKeyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicy
 */
export interface DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicy(obj: DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicy
 */
export interface DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicy(obj: DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderAccessRoutineDatasetIdRefPolicyResolution
 */
export enum DatasetSpecForProviderAccessRoutineDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderAccessRoutineDatasetIdRefPolicyResolve
 */
export enum DatasetSpecForProviderAccessRoutineDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicyResolution
 */
export enum DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicyResolve
 */
export enum DatasetSpecForProviderAccessRoutineDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderAccessRoutineProjectIdRefPolicyResolution
 */
export enum DatasetSpecForProviderAccessRoutineProjectIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderAccessRoutineProjectIdRefPolicyResolve
 */
export enum DatasetSpecForProviderAccessRoutineProjectIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicyResolution
 */
export enum DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicyResolve
 */
export enum DatasetSpecForProviderAccessRoutineProjectIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderAccessRoutineRoutineIdRefPolicyResolution
 */
export enum DatasetSpecForProviderAccessRoutineRoutineIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderAccessRoutineRoutineIdRefPolicyResolve
 */
export enum DatasetSpecForProviderAccessRoutineRoutineIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicyResolution
 */
export enum DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicyResolve
 */
export enum DatasetSpecForProviderAccessRoutineRoutineIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicyResolution
 */
export enum DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicyResolve
 */
export enum DatasetSpecForProviderAccessDatasetDatasetDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicyResolution
 */
export enum DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicyResolve
 */
export enum DatasetSpecForProviderAccessDatasetDatasetDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DatasetAccess is the Schema for the DatasetAccesss API. Gives dataset access for a single entity.
 *
 * @schema DatasetAccess
 */
export class DatasetAccess extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DatasetAccess"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'DatasetAccess',
  }

  /**
   * Renders a Kubernetes manifest for "DatasetAccess".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatasetAccessProps): any {
    return {
      ...DatasetAccess.GVK,
      ...toJson_DatasetAccessProps(props),
    };
  }

  /**
   * Defines a "DatasetAccess" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatasetAccessProps) {
    super(scope, id, {
      ...DatasetAccess.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DatasetAccess.GVK,
      ...toJson_DatasetAccessProps(resolved),
    };
  }
}

/**
 * DatasetAccess is the Schema for the DatasetAccesss API. Gives dataset access for a single entity.
 *
 * @schema DatasetAccess
 */
export interface DatasetAccessProps {
  /**
   * @schema DatasetAccess#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatasetAccessSpec defines the desired state of DatasetAccess
   *
   * @schema DatasetAccess#spec
   */
  readonly spec: DatasetAccessSpec;

}

/**
 * Converts an object of type 'DatasetAccessProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessProps(obj: DatasetAccessProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatasetAccessSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatasetAccessSpec defines the desired state of DatasetAccess
 *
 * @schema DatasetAccessSpec
 */
export interface DatasetAccessSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DatasetAccessSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatasetAccessSpecDeletionPolicy;

  /**
   * @schema DatasetAccessSpec#forProvider
   */
  readonly forProvider: DatasetAccessSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatasetAccessSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatasetAccessSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DatasetAccessSpec#providerRef
   */
  readonly providerRef?: DatasetAccessSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatasetAccessSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatasetAccessSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatasetAccessSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatasetAccessSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatasetAccessSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpec(obj: DatasetAccessSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatasetAccessSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DatasetAccessSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DatasetAccessSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DatasetAccessSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatasetAccessSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DatasetAccessSpecDeletionPolicy
 */
export enum DatasetAccessSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatasetAccessSpecForProvider
 */
export interface DatasetAccessSpecForProvider {
  /**
   * Grants all resources of particular types in a particular dataset read access to the current dataset. Structure is documented below.
   *
   * @schema DatasetAccessSpecForProvider#dataset
   */
  readonly dataset?: DatasetAccessSpecForProviderDataset[];

  /**
   * A unique ID for this dataset, without the project name. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
   *
   * @schema DatasetAccessSpecForProvider#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetAccessSpecForProvider#datasetIdRef
   */
  readonly datasetIdRef?: DatasetAccessSpecForProviderDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetAccessSpecForProvider#datasetIdSelector
   */
  readonly datasetIdSelector?: DatasetAccessSpecForProviderDatasetIdSelector;

  /**
   * A domain to grant access to. Any users signed in with the domain specified will be granted the specified access
   *
   * @schema DatasetAccessSpecForProvider#domain
   */
  readonly domain?: string;

  /**
   * An email address of a Google Group to grant access to.
   *
   * @schema DatasetAccessSpecForProvider#groupByEmail
   */
  readonly groupByEmail?: string;

  /**
   * Some other type of member that appears in the IAM Policy but isn't a user, group, domain, or special group. For example: allUsers
   *
   * @schema DatasetAccessSpecForProvider#iamMember
   */
  readonly iamMember?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DatasetAccessSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Describes the rights granted to the user specified by the other member of the access object. Basic, predefined, and custom roles are supported. Predefined roles that have equivalent basic roles are swapped by the API to their basic counterparts, and will show a diff post-create. See official docs.
   *
   * @schema DatasetAccessSpecForProvider#role
   */
  readonly role?: string;

  /**
   * A routine from a different dataset to grant access to. Queries executed against that routine will have read access to tables in this dataset. The role field is not required when this field is set. If that routine is updated by any user, access to the routine needs to be granted again via an update operation. Structure is documented below.
   *
   * @schema DatasetAccessSpecForProvider#routine
   */
  readonly routine?: DatasetAccessSpecForProviderRoutine[];

  /**
   * A special group to grant access to. Possible values include:
   *
   * @schema DatasetAccessSpecForProvider#specialGroup
   */
  readonly specialGroup?: string;

  /**
   * An email address of a user to grant access to. For example: fred@example.com
   *
   * @schema DatasetAccessSpecForProvider#userByEmail
   */
  readonly userByEmail?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate userByEmail.
   *
   * @schema DatasetAccessSpecForProvider#userByEmailRef
   */
  readonly userByEmailRef?: DatasetAccessSpecForProviderUserByEmailRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate userByEmail.
   *
   * @schema DatasetAccessSpecForProvider#userByEmailSelector
   */
  readonly userByEmailSelector?: DatasetAccessSpecForProviderUserByEmailSelector;

  /**
   * A view from a different dataset to grant access to. Queries executed against that view will have read access to tables in this dataset. The role field is not required when this field is set. If that view is updated by any user, access to the view needs to be granted again via an update operation. Structure is documented below.
   *
   * @schema DatasetAccessSpecForProvider#view
   */
  readonly view?: DatasetAccessSpecForProviderView[];

}

/**
 * Converts an object of type 'DatasetAccessSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProvider(obj: DatasetAccessSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataset': obj.dataset?.map(y => toJson_DatasetAccessSpecForProviderDataset(y)),
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_DatasetAccessSpecForProviderDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_DatasetAccessSpecForProviderDatasetIdSelector(obj.datasetIdSelector),
    'domain': obj.domain,
    'groupByEmail': obj.groupByEmail,
    'iamMember': obj.iamMember,
    'project': obj.project,
    'role': obj.role,
    'routine': obj.routine?.map(y => toJson_DatasetAccessSpecForProviderRoutine(y)),
    'specialGroup': obj.specialGroup,
    'userByEmail': obj.userByEmail,
    'userByEmailRef': toJson_DatasetAccessSpecForProviderUserByEmailRef(obj.userByEmailRef),
    'userByEmailSelector': toJson_DatasetAccessSpecForProviderUserByEmailSelector(obj.userByEmailSelector),
    'view': obj.view?.map(y => toJson_DatasetAccessSpecForProviderView(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatasetAccessSpecProviderConfigRef
 */
export interface DatasetAccessSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecProviderConfigRef#policy
   */
  readonly policy?: DatasetAccessSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecProviderConfigRef(obj: DatasetAccessSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DatasetAccessSpecProviderRef
 */
export interface DatasetAccessSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecProviderRef#policy
   */
  readonly policy?: DatasetAccessSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecProviderRef(obj: DatasetAccessSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatasetAccessSpecPublishConnectionDetailsTo
 */
export interface DatasetAccessSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatasetAccessSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatasetAccessSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatasetAccessSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatasetAccessSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatasetAccessSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatasetAccessSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecPublishConnectionDetailsTo(obj: DatasetAccessSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatasetAccessSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatasetAccessSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatasetAccessSpecWriteConnectionSecretToRef
 */
export interface DatasetAccessSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatasetAccessSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatasetAccessSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatasetAccessSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecWriteConnectionSecretToRef(obj: DatasetAccessSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetAccessSpecForProviderDataset
 */
export interface DatasetAccessSpecForProviderDataset {
  /**
   * The dataset this entry applies to Structure is documented below.
   *
   * @schema DatasetAccessSpecForProviderDataset#dataset
   */
  readonly dataset: DatasetAccessSpecForProviderDatasetDataset[];

  /**
   * Which resources in the dataset this entry applies to. Currently, only views are supported, but additional target types may be added in the future. Possible values: VIEWS
   *
   * @schema DatasetAccessSpecForProviderDataset#targetTypes
   */
  readonly targetTypes: string[];

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderDataset' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderDataset(obj: DatasetAccessSpecForProviderDataset | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataset': obj.dataset?.map(y => toJson_DatasetAccessSpecForProviderDatasetDataset(y)),
    'targetTypes': obj.targetTypes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetAccessSpecForProviderDatasetIdRef
 */
export interface DatasetAccessSpecForProviderDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecForProviderDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecForProviderDatasetIdRef#policy
   */
  readonly policy?: DatasetAccessSpecForProviderDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderDatasetIdRef(obj: DatasetAccessSpecForProviderDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecForProviderDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetAccessSpecForProviderDatasetIdSelector
 */
export interface DatasetAccessSpecForProviderDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetAccessSpecForProviderDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetAccessSpecForProviderDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetAccessSpecForProviderDatasetIdSelector#policy
   */
  readonly policy?: DatasetAccessSpecForProviderDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderDatasetIdSelector(obj: DatasetAccessSpecForProviderDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetAccessSpecForProviderDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetAccessSpecForProviderRoutine
 */
export interface DatasetAccessSpecForProviderRoutine {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema DatasetAccessSpecForProviderRoutine#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Routine in bigquery to populate datasetId.
   *
   * @schema DatasetAccessSpecForProviderRoutine#datasetIdRef
   */
  readonly datasetIdRef?: DatasetAccessSpecForProviderRoutineDatasetIdRef;

  /**
   * Selector for a Routine in bigquery to populate datasetId.
   *
   * @schema DatasetAccessSpecForProviderRoutine#datasetIdSelector
   */
  readonly datasetIdSelector?: DatasetAccessSpecForProviderRoutineDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema DatasetAccessSpecForProviderRoutine#projectId
   */
  readonly projectId?: string;

  /**
   * Reference to a Routine in bigquery to populate projectId.
   *
   * @schema DatasetAccessSpecForProviderRoutine#projectIdRef
   */
  readonly projectIdRef?: DatasetAccessSpecForProviderRoutineProjectIdRef;

  /**
   * Selector for a Routine in bigquery to populate projectId.
   *
   * @schema DatasetAccessSpecForProviderRoutine#projectIdSelector
   */
  readonly projectIdSelector?: DatasetAccessSpecForProviderRoutineProjectIdSelector;

  /**
   * The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
   *
   * @schema DatasetAccessSpecForProviderRoutine#routineId
   */
  readonly routineId?: string;

  /**
   * Reference to a Routine in bigquery to populate routineId.
   *
   * @schema DatasetAccessSpecForProviderRoutine#routineIdRef
   */
  readonly routineIdRef?: DatasetAccessSpecForProviderRoutineRoutineIdRef;

  /**
   * Selector for a Routine in bigquery to populate routineId.
   *
   * @schema DatasetAccessSpecForProviderRoutine#routineIdSelector
   */
  readonly routineIdSelector?: DatasetAccessSpecForProviderRoutineRoutineIdSelector;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutine(obj: DatasetAccessSpecForProviderRoutine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_DatasetAccessSpecForProviderRoutineDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_DatasetAccessSpecForProviderRoutineDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
    'projectIdRef': toJson_DatasetAccessSpecForProviderRoutineProjectIdRef(obj.projectIdRef),
    'projectIdSelector': toJson_DatasetAccessSpecForProviderRoutineProjectIdSelector(obj.projectIdSelector),
    'routineId': obj.routineId,
    'routineIdRef': toJson_DatasetAccessSpecForProviderRoutineRoutineIdRef(obj.routineIdRef),
    'routineIdSelector': toJson_DatasetAccessSpecForProviderRoutineRoutineIdSelector(obj.routineIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate userByEmail.
 *
 * @schema DatasetAccessSpecForProviderUserByEmailRef
 */
export interface DatasetAccessSpecForProviderUserByEmailRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecForProviderUserByEmailRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecForProviderUserByEmailRef#policy
   */
  readonly policy?: DatasetAccessSpecForProviderUserByEmailRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderUserByEmailRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderUserByEmailRef(obj: DatasetAccessSpecForProviderUserByEmailRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecForProviderUserByEmailRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate userByEmail.
 *
 * @schema DatasetAccessSpecForProviderUserByEmailSelector
 */
export interface DatasetAccessSpecForProviderUserByEmailSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetAccessSpecForProviderUserByEmailSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetAccessSpecForProviderUserByEmailSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetAccessSpecForProviderUserByEmailSelector#policy
   */
  readonly policy?: DatasetAccessSpecForProviderUserByEmailSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderUserByEmailSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderUserByEmailSelector(obj: DatasetAccessSpecForProviderUserByEmailSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetAccessSpecForProviderUserByEmailSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetAccessSpecForProviderView
 */
export interface DatasetAccessSpecForProviderView {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema DatasetAccessSpecForProviderView#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetAccessSpecForProviderView#datasetIdRef
   */
  readonly datasetIdRef?: DatasetAccessSpecForProviderViewDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetAccessSpecForProviderView#datasetIdSelector
   */
  readonly datasetIdSelector?: DatasetAccessSpecForProviderViewDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema DatasetAccessSpecForProviderView#projectId
   */
  readonly projectId: string;

  /**
   * The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
   *
   * @schema DatasetAccessSpecForProviderView#tableId
   */
  readonly tableId?: string;

  /**
   * Reference to a Table in bigquery to populate tableId.
   *
   * @schema DatasetAccessSpecForProviderView#tableIdRef
   */
  readonly tableIdRef?: DatasetAccessSpecForProviderViewTableIdRef;

  /**
   * Selector for a Table in bigquery to populate tableId.
   *
   * @schema DatasetAccessSpecForProviderView#tableIdSelector
   */
  readonly tableIdSelector?: DatasetAccessSpecForProviderViewTableIdSelector;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderView(obj: DatasetAccessSpecForProviderView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_DatasetAccessSpecForProviderViewDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_DatasetAccessSpecForProviderViewDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
    'tableId': obj.tableId,
    'tableIdRef': toJson_DatasetAccessSpecForProviderViewTableIdRef(obj.tableIdRef),
    'tableIdSelector': toJson_DatasetAccessSpecForProviderViewTableIdSelector(obj.tableIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecProviderConfigRefPolicy
 */
export interface DatasetAccessSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecProviderConfigRefPolicy(obj: DatasetAccessSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecProviderRefPolicy
 */
export interface DatasetAccessSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecProviderRefPolicy(obj: DatasetAccessSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatasetAccessSpecPublishConnectionDetailsToConfigRef
 */
export interface DatasetAccessSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecPublishConnectionDetailsToConfigRef(obj: DatasetAccessSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatasetAccessSpecPublishConnectionDetailsToMetadata
 */
export interface DatasetAccessSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetAccessSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetAccessSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatasetAccessSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatasetAccessSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecPublishConnectionDetailsToMetadata(obj: DatasetAccessSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetAccessSpecForProviderDatasetDataset
 */
export interface DatasetAccessSpecForProviderDatasetDataset {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema DatasetAccessSpecForProviderDatasetDataset#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetAccessSpecForProviderDatasetDataset#datasetIdRef
   */
  readonly datasetIdRef?: DatasetAccessSpecForProviderDatasetDatasetDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetAccessSpecForProviderDatasetDataset#datasetIdSelector
   */
  readonly datasetIdSelector?: DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema DatasetAccessSpecForProviderDatasetDataset#projectId
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderDatasetDataset' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderDatasetDataset(obj: DatasetAccessSpecForProviderDatasetDataset | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_DatasetAccessSpecForProviderDatasetDatasetDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecForProviderDatasetIdRefPolicy
 */
export interface DatasetAccessSpecForProviderDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderDatasetIdRefPolicy(obj: DatasetAccessSpecForProviderDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetAccessSpecForProviderDatasetIdSelectorPolicy
 */
export interface DatasetAccessSpecForProviderDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderDatasetIdSelectorPolicy(obj: DatasetAccessSpecForProviderDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Routine in bigquery to populate datasetId.
 *
 * @schema DatasetAccessSpecForProviderRoutineDatasetIdRef
 */
export interface DatasetAccessSpecForProviderRoutineDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecForProviderRoutineDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecForProviderRoutineDatasetIdRef#policy
   */
  readonly policy?: DatasetAccessSpecForProviderRoutineDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineDatasetIdRef(obj: DatasetAccessSpecForProviderRoutineDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecForProviderRoutineDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Routine in bigquery to populate datasetId.
 *
 * @schema DatasetAccessSpecForProviderRoutineDatasetIdSelector
 */
export interface DatasetAccessSpecForProviderRoutineDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetAccessSpecForProviderRoutineDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetAccessSpecForProviderRoutineDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetAccessSpecForProviderRoutineDatasetIdSelector#policy
   */
  readonly policy?: DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineDatasetIdSelector(obj: DatasetAccessSpecForProviderRoutineDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Routine in bigquery to populate projectId.
 *
 * @schema DatasetAccessSpecForProviderRoutineProjectIdRef
 */
export interface DatasetAccessSpecForProviderRoutineProjectIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecForProviderRoutineProjectIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecForProviderRoutineProjectIdRef#policy
   */
  readonly policy?: DatasetAccessSpecForProviderRoutineProjectIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineProjectIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineProjectIdRef(obj: DatasetAccessSpecForProviderRoutineProjectIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecForProviderRoutineProjectIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Routine in bigquery to populate projectId.
 *
 * @schema DatasetAccessSpecForProviderRoutineProjectIdSelector
 */
export interface DatasetAccessSpecForProviderRoutineProjectIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetAccessSpecForProviderRoutineProjectIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetAccessSpecForProviderRoutineProjectIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetAccessSpecForProviderRoutineProjectIdSelector#policy
   */
  readonly policy?: DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineProjectIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineProjectIdSelector(obj: DatasetAccessSpecForProviderRoutineProjectIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Routine in bigquery to populate routineId.
 *
 * @schema DatasetAccessSpecForProviderRoutineRoutineIdRef
 */
export interface DatasetAccessSpecForProviderRoutineRoutineIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecForProviderRoutineRoutineIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecForProviderRoutineRoutineIdRef#policy
   */
  readonly policy?: DatasetAccessSpecForProviderRoutineRoutineIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineRoutineIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineRoutineIdRef(obj: DatasetAccessSpecForProviderRoutineRoutineIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecForProviderRoutineRoutineIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Routine in bigquery to populate routineId.
 *
 * @schema DatasetAccessSpecForProviderRoutineRoutineIdSelector
 */
export interface DatasetAccessSpecForProviderRoutineRoutineIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetAccessSpecForProviderRoutineRoutineIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetAccessSpecForProviderRoutineRoutineIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetAccessSpecForProviderRoutineRoutineIdSelector#policy
   */
  readonly policy?: DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineRoutineIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineRoutineIdSelector(obj: DatasetAccessSpecForProviderRoutineRoutineIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecForProviderUserByEmailRefPolicy
 */
export interface DatasetAccessSpecForProviderUserByEmailRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderUserByEmailRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderUserByEmailRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderUserByEmailRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderUserByEmailRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderUserByEmailRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderUserByEmailRefPolicy(obj: DatasetAccessSpecForProviderUserByEmailRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetAccessSpecForProviderUserByEmailSelectorPolicy
 */
export interface DatasetAccessSpecForProviderUserByEmailSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderUserByEmailSelectorPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderUserByEmailSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderUserByEmailSelectorPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderUserByEmailSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderUserByEmailSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderUserByEmailSelectorPolicy(obj: DatasetAccessSpecForProviderUserByEmailSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetAccessSpecForProviderViewDatasetIdRef
 */
export interface DatasetAccessSpecForProviderViewDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecForProviderViewDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecForProviderViewDatasetIdRef#policy
   */
  readonly policy?: DatasetAccessSpecForProviderViewDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderViewDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderViewDatasetIdRef(obj: DatasetAccessSpecForProviderViewDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecForProviderViewDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetAccessSpecForProviderViewDatasetIdSelector
 */
export interface DatasetAccessSpecForProviderViewDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetAccessSpecForProviderViewDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetAccessSpecForProviderViewDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetAccessSpecForProviderViewDatasetIdSelector#policy
   */
  readonly policy?: DatasetAccessSpecForProviderViewDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderViewDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderViewDatasetIdSelector(obj: DatasetAccessSpecForProviderViewDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetAccessSpecForProviderViewDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in bigquery to populate tableId.
 *
 * @schema DatasetAccessSpecForProviderViewTableIdRef
 */
export interface DatasetAccessSpecForProviderViewTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecForProviderViewTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecForProviderViewTableIdRef#policy
   */
  readonly policy?: DatasetAccessSpecForProviderViewTableIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderViewTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderViewTableIdRef(obj: DatasetAccessSpecForProviderViewTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecForProviderViewTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in bigquery to populate tableId.
 *
 * @schema DatasetAccessSpecForProviderViewTableIdSelector
 */
export interface DatasetAccessSpecForProviderViewTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetAccessSpecForProviderViewTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetAccessSpecForProviderViewTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetAccessSpecForProviderViewTableIdSelector#policy
   */
  readonly policy?: DatasetAccessSpecForProviderViewTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderViewTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderViewTableIdSelector(obj: DatasetAccessSpecForProviderViewTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetAccessSpecForProviderViewTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecProviderConfigRefPolicyResolution
 */
export enum DatasetAccessSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecProviderConfigRefPolicyResolve
 */
export enum DatasetAccessSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecProviderRefPolicyResolution
 */
export enum DatasetAccessSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecProviderRefPolicyResolve
 */
export enum DatasetAccessSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdRef
 */
export interface DatasetAccessSpecForProviderDatasetDatasetDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdRef#policy
   */
  readonly policy?: DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderDatasetDatasetDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderDatasetDatasetDatasetIdRef(obj: DatasetAccessSpecForProviderDatasetDatasetDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelector
 */
export interface DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelector#policy
   */
  readonly policy?: DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelector(obj: DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderDatasetIdRefPolicyResolution
 */
export enum DatasetAccessSpecForProviderDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderDatasetIdRefPolicyResolve
 */
export enum DatasetAccessSpecForProviderDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderDatasetIdSelectorPolicyResolution
 */
export enum DatasetAccessSpecForProviderDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderDatasetIdSelectorPolicyResolve
 */
export enum DatasetAccessSpecForProviderDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecForProviderRoutineDatasetIdRefPolicy
 */
export interface DatasetAccessSpecForProviderRoutineDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderRoutineDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderRoutineDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderRoutineDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderRoutineDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineDatasetIdRefPolicy(obj: DatasetAccessSpecForProviderRoutineDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicy
 */
export interface DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicy(obj: DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecForProviderRoutineProjectIdRefPolicy
 */
export interface DatasetAccessSpecForProviderRoutineProjectIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderRoutineProjectIdRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderRoutineProjectIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderRoutineProjectIdRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderRoutineProjectIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineProjectIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineProjectIdRefPolicy(obj: DatasetAccessSpecForProviderRoutineProjectIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicy
 */
export interface DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicy(obj: DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecForProviderRoutineRoutineIdRefPolicy
 */
export interface DatasetAccessSpecForProviderRoutineRoutineIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderRoutineRoutineIdRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderRoutineRoutineIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderRoutineRoutineIdRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderRoutineRoutineIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineRoutineIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineRoutineIdRefPolicy(obj: DatasetAccessSpecForProviderRoutineRoutineIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicy
 */
export interface DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicy(obj: DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderUserByEmailRefPolicyResolution
 */
export enum DatasetAccessSpecForProviderUserByEmailRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderUserByEmailRefPolicyResolve
 */
export enum DatasetAccessSpecForProviderUserByEmailRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderUserByEmailSelectorPolicyResolution
 */
export enum DatasetAccessSpecForProviderUserByEmailSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderUserByEmailSelectorPolicyResolve
 */
export enum DatasetAccessSpecForProviderUserByEmailSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecForProviderViewDatasetIdRefPolicy
 */
export interface DatasetAccessSpecForProviderViewDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderViewDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderViewDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderViewDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderViewDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderViewDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderViewDatasetIdRefPolicy(obj: DatasetAccessSpecForProviderViewDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetAccessSpecForProviderViewDatasetIdSelectorPolicy
 */
export interface DatasetAccessSpecForProviderViewDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderViewDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderViewDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderViewDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderViewDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderViewDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderViewDatasetIdSelectorPolicy(obj: DatasetAccessSpecForProviderViewDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecForProviderViewTableIdRefPolicy
 */
export interface DatasetAccessSpecForProviderViewTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderViewTableIdRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderViewTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderViewTableIdRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderViewTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderViewTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderViewTableIdRefPolicy(obj: DatasetAccessSpecForProviderViewTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetAccessSpecForProviderViewTableIdSelectorPolicy
 */
export interface DatasetAccessSpecForProviderViewTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderViewTableIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderViewTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderViewTableIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderViewTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderViewTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderViewTableIdSelectorPolicy(obj: DatasetAccessSpecForProviderViewTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatasetAccessSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicy
 */
export interface DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicy(obj: DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicy
 */
export interface DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicy(obj: DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderRoutineDatasetIdRefPolicyResolution
 */
export enum DatasetAccessSpecForProviderRoutineDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderRoutineDatasetIdRefPolicyResolve
 */
export enum DatasetAccessSpecForProviderRoutineDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicyResolution
 */
export enum DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicyResolve
 */
export enum DatasetAccessSpecForProviderRoutineDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderRoutineProjectIdRefPolicyResolution
 */
export enum DatasetAccessSpecForProviderRoutineProjectIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderRoutineProjectIdRefPolicyResolve
 */
export enum DatasetAccessSpecForProviderRoutineProjectIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicyResolution
 */
export enum DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicyResolve
 */
export enum DatasetAccessSpecForProviderRoutineProjectIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderRoutineRoutineIdRefPolicyResolution
 */
export enum DatasetAccessSpecForProviderRoutineRoutineIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderRoutineRoutineIdRefPolicyResolve
 */
export enum DatasetAccessSpecForProviderRoutineRoutineIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicyResolution
 */
export enum DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicyResolve
 */
export enum DatasetAccessSpecForProviderRoutineRoutineIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderViewDatasetIdRefPolicyResolution
 */
export enum DatasetAccessSpecForProviderViewDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderViewDatasetIdRefPolicyResolve
 */
export enum DatasetAccessSpecForProviderViewDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderViewDatasetIdSelectorPolicyResolution
 */
export enum DatasetAccessSpecForProviderViewDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderViewDatasetIdSelectorPolicyResolve
 */
export enum DatasetAccessSpecForProviderViewDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderViewTableIdRefPolicyResolution
 */
export enum DatasetAccessSpecForProviderViewTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderViewTableIdRefPolicyResolve
 */
export enum DatasetAccessSpecForProviderViewTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderViewTableIdSelectorPolicyResolution
 */
export enum DatasetAccessSpecForProviderViewTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderViewTableIdSelectorPolicyResolve
 */
export enum DatasetAccessSpecForProviderViewTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicyResolution
 */
export enum DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicyResolve
 */
export enum DatasetAccessSpecForProviderDatasetDatasetDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicyResolution
 */
export enum DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicyResolve
 */
export enum DatasetAccessSpecForProviderDatasetDatasetDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DatasetIAMBinding is the Schema for the DatasetIAMBindings API. <no value>
 *
 * @schema DatasetIAMBinding
 */
export class DatasetIamBinding extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DatasetIAMBinding"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'DatasetIAMBinding',
  }

  /**
   * Renders a Kubernetes manifest for "DatasetIAMBinding".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatasetIamBindingProps): any {
    return {
      ...DatasetIamBinding.GVK,
      ...toJson_DatasetIamBindingProps(props),
    };
  }

  /**
   * Defines a "DatasetIAMBinding" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatasetIamBindingProps) {
    super(scope, id, {
      ...DatasetIamBinding.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DatasetIamBinding.GVK,
      ...toJson_DatasetIamBindingProps(resolved),
    };
  }
}

/**
 * DatasetIAMBinding is the Schema for the DatasetIAMBindings API. <no value>
 *
 * @schema DatasetIAMBinding
 */
export interface DatasetIamBindingProps {
  /**
   * @schema DatasetIAMBinding#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatasetIAMBindingSpec defines the desired state of DatasetIAMBinding
   *
   * @schema DatasetIAMBinding#spec
   */
  readonly spec: DatasetIamBindingSpec;

}

/**
 * Converts an object of type 'DatasetIamBindingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingProps(obj: DatasetIamBindingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatasetIamBindingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatasetIAMBindingSpec defines the desired state of DatasetIAMBinding
 *
 * @schema DatasetIamBindingSpec
 */
export interface DatasetIamBindingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DatasetIamBindingSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatasetIamBindingSpecDeletionPolicy;

  /**
   * @schema DatasetIamBindingSpec#forProvider
   */
  readonly forProvider: DatasetIamBindingSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatasetIamBindingSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatasetIamBindingSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DatasetIamBindingSpec#providerRef
   */
  readonly providerRef?: DatasetIamBindingSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatasetIamBindingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatasetIamBindingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatasetIamBindingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatasetIamBindingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatasetIamBindingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpec(obj: DatasetIamBindingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatasetIamBindingSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DatasetIamBindingSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DatasetIamBindingSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DatasetIamBindingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatasetIamBindingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DatasetIamBindingSpecDeletionPolicy
 */
export enum DatasetIamBindingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatasetIamBindingSpecForProvider
 */
export interface DatasetIamBindingSpecForProvider {
  /**
   * @schema DatasetIamBindingSpecForProvider#condition
   */
  readonly condition?: DatasetIamBindingSpecForProviderCondition[];

  /**
   * @schema DatasetIamBindingSpecForProvider#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetIamBindingSpecForProvider#datasetIdRef
   */
  readonly datasetIdRef?: DatasetIamBindingSpecForProviderDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetIamBindingSpecForProvider#datasetIdSelector
   */
  readonly datasetIdSelector?: DatasetIamBindingSpecForProviderDatasetIdSelector;

  /**
   * @schema DatasetIamBindingSpecForProvider#members
   */
  readonly members: string[];

  /**
   * @schema DatasetIamBindingSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema DatasetIamBindingSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecForProvider(obj: DatasetIamBindingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_DatasetIamBindingSpecForProviderCondition(y)),
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_DatasetIamBindingSpecForProviderDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_DatasetIamBindingSpecForProviderDatasetIdSelector(obj.datasetIdSelector),
    'members': obj.members?.map(y => y),
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatasetIamBindingSpecProviderConfigRef
 */
export interface DatasetIamBindingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamBindingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamBindingSpecProviderConfigRef#policy
   */
  readonly policy?: DatasetIamBindingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecProviderConfigRef(obj: DatasetIamBindingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamBindingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DatasetIamBindingSpecProviderRef
 */
export interface DatasetIamBindingSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamBindingSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamBindingSpecProviderRef#policy
   */
  readonly policy?: DatasetIamBindingSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecProviderRef(obj: DatasetIamBindingSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamBindingSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatasetIamBindingSpecPublishConnectionDetailsTo
 */
export interface DatasetIamBindingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatasetIamBindingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatasetIamBindingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatasetIamBindingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatasetIamBindingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatasetIamBindingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecPublishConnectionDetailsTo(obj: DatasetIamBindingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatasetIamBindingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatasetIamBindingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatasetIamBindingSpecWriteConnectionSecretToRef
 */
export interface DatasetIamBindingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatasetIamBindingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatasetIamBindingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecWriteConnectionSecretToRef(obj: DatasetIamBindingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetIamBindingSpecForProviderCondition
 */
export interface DatasetIamBindingSpecForProviderCondition {
  /**
   * @schema DatasetIamBindingSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema DatasetIamBindingSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema DatasetIamBindingSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecForProviderCondition(obj: DatasetIamBindingSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetIamBindingSpecForProviderDatasetIdRef
 */
export interface DatasetIamBindingSpecForProviderDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamBindingSpecForProviderDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamBindingSpecForProviderDatasetIdRef#policy
   */
  readonly policy?: DatasetIamBindingSpecForProviderDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecForProviderDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecForProviderDatasetIdRef(obj: DatasetIamBindingSpecForProviderDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamBindingSpecForProviderDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetIamBindingSpecForProviderDatasetIdSelector
 */
export interface DatasetIamBindingSpecForProviderDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetIamBindingSpecForProviderDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetIamBindingSpecForProviderDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetIamBindingSpecForProviderDatasetIdSelector#policy
   */
  readonly policy?: DatasetIamBindingSpecForProviderDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecForProviderDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecForProviderDatasetIdSelector(obj: DatasetIamBindingSpecForProviderDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetIamBindingSpecForProviderDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamBindingSpecProviderConfigRefPolicy
 */
export interface DatasetIamBindingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamBindingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetIamBindingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamBindingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetIamBindingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecProviderConfigRefPolicy(obj: DatasetIamBindingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamBindingSpecProviderRefPolicy
 */
export interface DatasetIamBindingSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamBindingSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DatasetIamBindingSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamBindingSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DatasetIamBindingSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecProviderRefPolicy(obj: DatasetIamBindingSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatasetIamBindingSpecPublishConnectionDetailsToConfigRef
 */
export interface DatasetIamBindingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamBindingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamBindingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecPublishConnectionDetailsToConfigRef(obj: DatasetIamBindingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatasetIamBindingSpecPublishConnectionDetailsToMetadata
 */
export interface DatasetIamBindingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetIamBindingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetIamBindingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatasetIamBindingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecPublishConnectionDetailsToMetadata(obj: DatasetIamBindingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamBindingSpecForProviderDatasetIdRefPolicy
 */
export interface DatasetIamBindingSpecForProviderDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamBindingSpecForProviderDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DatasetIamBindingSpecForProviderDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamBindingSpecForProviderDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DatasetIamBindingSpecForProviderDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecForProviderDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecForProviderDatasetIdRefPolicy(obj: DatasetIamBindingSpecForProviderDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetIamBindingSpecForProviderDatasetIdSelectorPolicy
 */
export interface DatasetIamBindingSpecForProviderDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamBindingSpecForProviderDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetIamBindingSpecForProviderDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamBindingSpecForProviderDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetIamBindingSpecForProviderDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecForProviderDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecForProviderDatasetIdSelectorPolicy(obj: DatasetIamBindingSpecForProviderDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamBindingSpecProviderConfigRefPolicyResolution
 */
export enum DatasetIamBindingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamBindingSpecProviderConfigRefPolicyResolve
 */
export enum DatasetIamBindingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamBindingSpecProviderRefPolicyResolution
 */
export enum DatasetIamBindingSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamBindingSpecProviderRefPolicyResolve
 */
export enum DatasetIamBindingSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamBindingSpecForProviderDatasetIdRefPolicyResolution
 */
export enum DatasetIamBindingSpecForProviderDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamBindingSpecForProviderDatasetIdRefPolicyResolve
 */
export enum DatasetIamBindingSpecForProviderDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamBindingSpecForProviderDatasetIdSelectorPolicyResolution
 */
export enum DatasetIamBindingSpecForProviderDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamBindingSpecForProviderDatasetIdSelectorPolicyResolve
 */
export enum DatasetIamBindingSpecForProviderDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatasetIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DatasetIAMMember is the Schema for the DatasetIAMMembers API. <no value>
 *
 * @schema DatasetIAMMember
 */
export class DatasetIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DatasetIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'DatasetIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "DatasetIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatasetIamMemberProps): any {
    return {
      ...DatasetIamMember.GVK,
      ...toJson_DatasetIamMemberProps(props),
    };
  }

  /**
   * Defines a "DatasetIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatasetIamMemberProps) {
    super(scope, id, {
      ...DatasetIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DatasetIamMember.GVK,
      ...toJson_DatasetIamMemberProps(resolved),
    };
  }
}

/**
 * DatasetIAMMember is the Schema for the DatasetIAMMembers API. <no value>
 *
 * @schema DatasetIAMMember
 */
export interface DatasetIamMemberProps {
  /**
   * @schema DatasetIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatasetIAMMemberSpec defines the desired state of DatasetIAMMember
   *
   * @schema DatasetIAMMember#spec
   */
  readonly spec: DatasetIamMemberSpec;

}

/**
 * Converts an object of type 'DatasetIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberProps(obj: DatasetIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatasetIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatasetIAMMemberSpec defines the desired state of DatasetIAMMember
 *
 * @schema DatasetIamMemberSpec
 */
export interface DatasetIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DatasetIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatasetIamMemberSpecDeletionPolicy;

  /**
   * @schema DatasetIamMemberSpec#forProvider
   */
  readonly forProvider: DatasetIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatasetIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatasetIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DatasetIamMemberSpec#providerRef
   */
  readonly providerRef?: DatasetIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatasetIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatasetIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatasetIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatasetIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatasetIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpec(obj: DatasetIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatasetIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DatasetIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DatasetIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DatasetIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatasetIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DatasetIamMemberSpecDeletionPolicy
 */
export enum DatasetIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatasetIamMemberSpecForProvider
 */
export interface DatasetIamMemberSpecForProvider {
  /**
   * @schema DatasetIamMemberSpecForProvider#condition
   */
  readonly condition?: DatasetIamMemberSpecForProviderCondition[];

  /**
   * @schema DatasetIamMemberSpecForProvider#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetIamMemberSpecForProvider#datasetIdRef
   */
  readonly datasetIdRef?: DatasetIamMemberSpecForProviderDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetIamMemberSpecForProvider#datasetIdSelector
   */
  readonly datasetIdSelector?: DatasetIamMemberSpecForProviderDatasetIdSelector;

  /**
   * @schema DatasetIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema DatasetIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema DatasetIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProvider(obj: DatasetIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_DatasetIamMemberSpecForProviderCondition(y)),
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_DatasetIamMemberSpecForProviderDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_DatasetIamMemberSpecForProviderDatasetIdSelector(obj.datasetIdSelector),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatasetIamMemberSpecProviderConfigRef
 */
export interface DatasetIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: DatasetIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecProviderConfigRef(obj: DatasetIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DatasetIamMemberSpecProviderRef
 */
export interface DatasetIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamMemberSpecProviderRef#policy
   */
  readonly policy?: DatasetIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecProviderRef(obj: DatasetIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsTo
 */
export interface DatasetIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatasetIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatasetIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecPublishConnectionDetailsTo(obj: DatasetIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatasetIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatasetIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatasetIamMemberSpecWriteConnectionSecretToRef
 */
export interface DatasetIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatasetIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatasetIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecWriteConnectionSecretToRef(obj: DatasetIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetIamMemberSpecForProviderCondition
 */
export interface DatasetIamMemberSpecForProviderCondition {
  /**
   * @schema DatasetIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema DatasetIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema DatasetIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProviderCondition(obj: DatasetIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdRef
 */
export interface DatasetIamMemberSpecForProviderDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdRef#policy
   */
  readonly policy?: DatasetIamMemberSpecForProviderDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProviderDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProviderDatasetIdRef(obj: DatasetIamMemberSpecForProviderDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamMemberSpecForProviderDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdSelector
 */
export interface DatasetIamMemberSpecForProviderDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdSelector#policy
   */
  readonly policy?: DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProviderDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProviderDatasetIdSelector(obj: DatasetIamMemberSpecForProviderDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamMemberSpecProviderConfigRefPolicy
 */
export interface DatasetIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecProviderConfigRefPolicy(obj: DatasetIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamMemberSpecProviderRefPolicy
 */
export interface DatasetIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DatasetIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DatasetIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecProviderRefPolicy(obj: DatasetIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface DatasetIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecPublishConnectionDetailsToConfigRef(obj: DatasetIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface DatasetIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecPublishConnectionDetailsToMetadata(obj: DatasetIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdRefPolicy
 */
export interface DatasetIamMemberSpecForProviderDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProviderDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProviderDatasetIdRefPolicy(obj: DatasetIamMemberSpecForProviderDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy
 */
export interface DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy(obj: DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum DatasetIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum DatasetIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamMemberSpecProviderRefPolicyResolution
 */
export enum DatasetIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamMemberSpecProviderRefPolicyResolve
 */
export enum DatasetIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolution
 */
export enum DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolve
 */
export enum DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolution
 */
export enum DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolve
 */
export enum DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DatasetIAMPolicy is the Schema for the DatasetIAMPolicys API. Collection of resources to manage IAM policy for a BigQuery dataset.
 *
 * @schema DatasetIAMPolicy
 */
export class DatasetIamPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DatasetIAMPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'DatasetIAMPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "DatasetIAMPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatasetIamPolicyProps): any {
    return {
      ...DatasetIamPolicy.GVK,
      ...toJson_DatasetIamPolicyProps(props),
    };
  }

  /**
   * Defines a "DatasetIAMPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatasetIamPolicyProps) {
    super(scope, id, {
      ...DatasetIamPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DatasetIamPolicy.GVK,
      ...toJson_DatasetIamPolicyProps(resolved),
    };
  }
}

/**
 * DatasetIAMPolicy is the Schema for the DatasetIAMPolicys API. Collection of resources to manage IAM policy for a BigQuery dataset.
 *
 * @schema DatasetIAMPolicy
 */
export interface DatasetIamPolicyProps {
  /**
   * @schema DatasetIAMPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatasetIAMPolicySpec defines the desired state of DatasetIAMPolicy
   *
   * @schema DatasetIAMPolicy#spec
   */
  readonly spec: DatasetIamPolicySpec;

}

/**
 * Converts an object of type 'DatasetIamPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicyProps(obj: DatasetIamPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatasetIamPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatasetIAMPolicySpec defines the desired state of DatasetIAMPolicy
 *
 * @schema DatasetIamPolicySpec
 */
export interface DatasetIamPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DatasetIamPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: DatasetIamPolicySpecDeletionPolicy;

  /**
   * @schema DatasetIamPolicySpec#forProvider
   */
  readonly forProvider: DatasetIamPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatasetIamPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: DatasetIamPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DatasetIamPolicySpec#providerRef
   */
  readonly providerRef?: DatasetIamPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatasetIamPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatasetIamPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatasetIamPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatasetIamPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatasetIamPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpec(obj: DatasetIamPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatasetIamPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DatasetIamPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DatasetIamPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DatasetIamPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatasetIamPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DatasetIamPolicySpecDeletionPolicy
 */
export enum DatasetIamPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatasetIamPolicySpecForProvider
 */
export interface DatasetIamPolicySpecForProvider {
  /**
   * The dataset ID.
   *
   * @schema DatasetIamPolicySpecForProvider#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetIamPolicySpecForProvider#datasetIdRef
   */
  readonly datasetIdRef?: DatasetIamPolicySpecForProviderDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema DatasetIamPolicySpecForProvider#datasetIdSelector
   */
  readonly datasetIdSelector?: DatasetIamPolicySpecForProviderDatasetIdSelector;

  /**
   * The policy data generated by a google_iam_policy data source.
   *
   * @schema DatasetIamPolicySpecForProvider#policyData
   */
  readonly policyData: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DatasetIamPolicySpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecForProvider(obj: DatasetIamPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_DatasetIamPolicySpecForProviderDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_DatasetIamPolicySpecForProviderDatasetIdSelector(obj.datasetIdSelector),
    'policyData': obj.policyData,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatasetIamPolicySpecProviderConfigRef
 */
export interface DatasetIamPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamPolicySpecProviderConfigRef#policy
   */
  readonly policy?: DatasetIamPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecProviderConfigRef(obj: DatasetIamPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DatasetIamPolicySpecProviderRef
 */
export interface DatasetIamPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamPolicySpecProviderRef#policy
   */
  readonly policy?: DatasetIamPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecProviderRef(obj: DatasetIamPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatasetIamPolicySpecPublishConnectionDetailsTo
 */
export interface DatasetIamPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatasetIamPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatasetIamPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatasetIamPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatasetIamPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatasetIamPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecPublishConnectionDetailsTo(obj: DatasetIamPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatasetIamPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatasetIamPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatasetIamPolicySpecWriteConnectionSecretToRef
 */
export interface DatasetIamPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatasetIamPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatasetIamPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecWriteConnectionSecretToRef(obj: DatasetIamPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetIamPolicySpecForProviderDatasetIdRef
 */
export interface DatasetIamPolicySpecForProviderDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamPolicySpecForProviderDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamPolicySpecForProviderDatasetIdRef#policy
   */
  readonly policy?: DatasetIamPolicySpecForProviderDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecForProviderDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecForProviderDatasetIdRef(obj: DatasetIamPolicySpecForProviderDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamPolicySpecForProviderDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema DatasetIamPolicySpecForProviderDatasetIdSelector
 */
export interface DatasetIamPolicySpecForProviderDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetIamPolicySpecForProviderDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetIamPolicySpecForProviderDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetIamPolicySpecForProviderDatasetIdSelector#policy
   */
  readonly policy?: DatasetIamPolicySpecForProviderDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecForProviderDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecForProviderDatasetIdSelector(obj: DatasetIamPolicySpecForProviderDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetIamPolicySpecForProviderDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamPolicySpecProviderConfigRefPolicy
 */
export interface DatasetIamPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetIamPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetIamPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecProviderConfigRefPolicy(obj: DatasetIamPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamPolicySpecProviderRefPolicy
 */
export interface DatasetIamPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: DatasetIamPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: DatasetIamPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecProviderRefPolicy(obj: DatasetIamPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatasetIamPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface DatasetIamPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecPublishConnectionDetailsToConfigRef(obj: DatasetIamPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatasetIamPolicySpecPublishConnectionDetailsToMetadata
 */
export interface DatasetIamPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetIamPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetIamPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatasetIamPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecPublishConnectionDetailsToMetadata(obj: DatasetIamPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamPolicySpecForProviderDatasetIdRefPolicy
 */
export interface DatasetIamPolicySpecForProviderDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamPolicySpecForProviderDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DatasetIamPolicySpecForProviderDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamPolicySpecForProviderDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DatasetIamPolicySpecForProviderDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecForProviderDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecForProviderDatasetIdRefPolicy(obj: DatasetIamPolicySpecForProviderDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetIamPolicySpecForProviderDatasetIdSelectorPolicy
 */
export interface DatasetIamPolicySpecForProviderDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamPolicySpecForProviderDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetIamPolicySpecForProviderDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamPolicySpecForProviderDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetIamPolicySpecForProviderDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecForProviderDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecForProviderDatasetIdSelectorPolicy(obj: DatasetIamPolicySpecForProviderDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamPolicySpecProviderConfigRefPolicyResolution
 */
export enum DatasetIamPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamPolicySpecProviderConfigRefPolicyResolve
 */
export enum DatasetIamPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamPolicySpecProviderRefPolicyResolution
 */
export enum DatasetIamPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamPolicySpecProviderRefPolicyResolve
 */
export enum DatasetIamPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamPolicySpecForProviderDatasetIdRefPolicyResolution
 */
export enum DatasetIamPolicySpecForProviderDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamPolicySpecForProviderDatasetIdRefPolicyResolve
 */
export enum DatasetIamPolicySpecForProviderDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamPolicySpecForProviderDatasetIdSelectorPolicyResolution
 */
export enum DatasetIamPolicySpecForProviderDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamPolicySpecForProviderDatasetIdSelectorPolicyResolve
 */
export enum DatasetIamPolicySpecForProviderDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatasetIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DataTransferConfig is the Schema for the DataTransferConfigs API. Represents a data transfer configuration.
 *
 * @schema DataTransferConfig
 */
export class DataTransferConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DataTransferConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'DataTransferConfig',
  }

  /**
   * Renders a Kubernetes manifest for "DataTransferConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DataTransferConfigProps): any {
    return {
      ...DataTransferConfig.GVK,
      ...toJson_DataTransferConfigProps(props),
    };
  }

  /**
   * Defines a "DataTransferConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DataTransferConfigProps) {
    super(scope, id, {
      ...DataTransferConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DataTransferConfig.GVK,
      ...toJson_DataTransferConfigProps(resolved),
    };
  }
}

/**
 * DataTransferConfig is the Schema for the DataTransferConfigs API. Represents a data transfer configuration.
 *
 * @schema DataTransferConfig
 */
export interface DataTransferConfigProps {
  /**
   * @schema DataTransferConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DataTransferConfigSpec defines the desired state of DataTransferConfig
   *
   * @schema DataTransferConfig#spec
   */
  readonly spec: DataTransferConfigSpec;

}

/**
 * Converts an object of type 'DataTransferConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigProps(obj: DataTransferConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DataTransferConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataTransferConfigSpec defines the desired state of DataTransferConfig
 *
 * @schema DataTransferConfigSpec
 */
export interface DataTransferConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DataTransferConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: DataTransferConfigSpecDeletionPolicy;

  /**
   * @schema DataTransferConfigSpec#forProvider
   */
  readonly forProvider: DataTransferConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DataTransferConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: DataTransferConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DataTransferConfigSpec#providerRef
   */
  readonly providerRef?: DataTransferConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DataTransferConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DataTransferConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DataTransferConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DataTransferConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DataTransferConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpec(obj: DataTransferConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DataTransferConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DataTransferConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DataTransferConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DataTransferConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DataTransferConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DataTransferConfigSpecDeletionPolicy
 */
export enum DataTransferConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DataTransferConfigSpecForProvider
 */
export interface DataTransferConfigSpecForProvider {
  /**
   * The number of days to look back to automatically refresh the data. For example, if dataRefreshWindowDays = 10, then every day BigQuery reingests data for [today-10, today-1], rather than ingesting data for just [today-1]. Only valid if the data source supports the feature. Set the value to 0 to use the default value.
   *
   * @schema DataTransferConfigSpecForProvider#dataRefreshWindowDays
   */
  readonly dataRefreshWindowDays?: number;

  /**
   * The data source id. Cannot be changed once the transfer config is created.
   *
   * @schema DataTransferConfigSpecForProvider#dataSourceId
   */
  readonly dataSourceId: string;

  /**
   * The BigQuery target dataset id.
   *
   * @schema DataTransferConfigSpecForProvider#destinationDatasetId
   */
  readonly destinationDatasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate destinationDatasetId.
   *
   * @schema DataTransferConfigSpecForProvider#destinationDatasetIdRef
   */
  readonly destinationDatasetIdRef?: DataTransferConfigSpecForProviderDestinationDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate destinationDatasetId.
   *
   * @schema DataTransferConfigSpecForProvider#destinationDatasetIdSelector
   */
  readonly destinationDatasetIdSelector?: DataTransferConfigSpecForProviderDestinationDatasetIdSelector;

  /**
   * When set to true, no runs are scheduled for a given transfer.
   *
   * @schema DataTransferConfigSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * The user specified display name for the transfer config.
   *
   * @schema DataTransferConfigSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * Email notifications will be sent according to these preferences to the email address of the user who owns this transfer config. Structure is documented below.
   *
   * @schema DataTransferConfigSpecForProvider#emailPreferences
   */
  readonly emailPreferences?: DataTransferConfigSpecForProviderEmailPreferences[];

  /**
   * The geographic location where the transfer config should reside. Examples: US, EU, asia-northeast1. The default value is US.
   *
   * @schema DataTransferConfigSpecForProvider#location
   */
  readonly location?: string;

  /**
   * Pub/Sub topic where notifications will be sent after transfer runs associated with this transfer config finish.
   *
   * @schema DataTransferConfigSpecForProvider#notificationPubsubTopic
   */
  readonly notificationPubsubTopic?: string;

  /**
   * Parameters specific to each data source. For more information see the bq tab in the 'Setting up a data transfer' section for each data source. For example the parameters for Cloud Storage transfers are listed here: https://cloud.google.com/bigquery-transfer/docs/cloud-storage-transfer#bq NOTE : If you are attempting to update a parameter that cannot be updated (due to api limitations) please force recreation of the resource.
   *
   * @schema DataTransferConfigSpecForProvider#params
   */
  readonly params: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DataTransferConfigSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Data transfer schedule. If the data source does not support a custom schedule, this should be empty. If it is empty, the default value for the data source will be used. The specified times are in UTC. Examples of valid format: 1st,3rd monday of month 15:30, every wed,fri of jan, jun 13:15, and first sunday of quarter 00:00. See more explanation about the format here: https://cloud.google.com/appengine/docs/flexible/python/scheduling-jobs-with-cron-yaml#the_schedule_format NOTE: the granularity should be at least 8 hours, or less frequent.
   *
   * @schema DataTransferConfigSpecForProvider#schedule
   */
  readonly schedule?: string;

  /**
   * Options customizing the data transfer schedule. Structure is documented below.
   *
   * @schema DataTransferConfigSpecForProvider#scheduleOptions
   */
  readonly scheduleOptions?: DataTransferConfigSpecForProviderScheduleOptions[];

  /**
   * Different parameters are configured primarily using the the params field on this resource. This block contains the parameters which contain secrets or passwords so that they can be marked sensitive and hidden from plan output. The name of the field, eg: secret_access_key, will be the key in the params map in the api request. Credentials may not be specified in both locations and will cause an error. Changing from one location to a different credential configuration in the config will require an apply to update state. Structure is documented below.
   *
   * @schema DataTransferConfigSpecForProvider#sensitiveParams
   */
  readonly sensitiveParams?: DataTransferConfigSpecForProviderSensitiveParams[];

  /**
   * Service account email. If this field is set, transfer config will be created with this service account credentials. It requires that requesting user calling this API has permissions to act as this service account.
   *
   * @schema DataTransferConfigSpecForProvider#serviceAccountName
   */
  readonly serviceAccountName?: string;

}

/**
 * Converts an object of type 'DataTransferConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecForProvider(obj: DataTransferConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataRefreshWindowDays': obj.dataRefreshWindowDays,
    'dataSourceId': obj.dataSourceId,
    'destinationDatasetId': obj.destinationDatasetId,
    'destinationDatasetIdRef': toJson_DataTransferConfigSpecForProviderDestinationDatasetIdRef(obj.destinationDatasetIdRef),
    'destinationDatasetIdSelector': toJson_DataTransferConfigSpecForProviderDestinationDatasetIdSelector(obj.destinationDatasetIdSelector),
    'disabled': obj.disabled,
    'displayName': obj.displayName,
    'emailPreferences': obj.emailPreferences?.map(y => toJson_DataTransferConfigSpecForProviderEmailPreferences(y)),
    'location': obj.location,
    'notificationPubsubTopic': obj.notificationPubsubTopic,
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'schedule': obj.schedule,
    'scheduleOptions': obj.scheduleOptions?.map(y => toJson_DataTransferConfigSpecForProviderScheduleOptions(y)),
    'sensitiveParams': obj.sensitiveParams?.map(y => toJson_DataTransferConfigSpecForProviderSensitiveParams(y)),
    'serviceAccountName': obj.serviceAccountName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DataTransferConfigSpecProviderConfigRef
 */
export interface DataTransferConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataTransferConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataTransferConfigSpecProviderConfigRef#policy
   */
  readonly policy?: DataTransferConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DataTransferConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecProviderConfigRef(obj: DataTransferConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataTransferConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DataTransferConfigSpecProviderRef
 */
export interface DataTransferConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataTransferConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataTransferConfigSpecProviderRef#policy
   */
  readonly policy?: DataTransferConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DataTransferConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecProviderRef(obj: DataTransferConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataTransferConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DataTransferConfigSpecPublishConnectionDetailsTo
 */
export interface DataTransferConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DataTransferConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DataTransferConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DataTransferConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DataTransferConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DataTransferConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DataTransferConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecPublishConnectionDetailsTo(obj: DataTransferConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DataTransferConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DataTransferConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DataTransferConfigSpecWriteConnectionSecretToRef
 */
export interface DataTransferConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DataTransferConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DataTransferConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DataTransferConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecWriteConnectionSecretToRef(obj: DataTransferConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate destinationDatasetId.
 *
 * @schema DataTransferConfigSpecForProviderDestinationDatasetIdRef
 */
export interface DataTransferConfigSpecForProviderDestinationDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataTransferConfigSpecForProviderDestinationDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataTransferConfigSpecForProviderDestinationDatasetIdRef#policy
   */
  readonly policy?: DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DataTransferConfigSpecForProviderDestinationDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecForProviderDestinationDatasetIdRef(obj: DataTransferConfigSpecForProviderDestinationDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate destinationDatasetId.
 *
 * @schema DataTransferConfigSpecForProviderDestinationDatasetIdSelector
 */
export interface DataTransferConfigSpecForProviderDestinationDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DataTransferConfigSpecForProviderDestinationDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DataTransferConfigSpecForProviderDestinationDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DataTransferConfigSpecForProviderDestinationDatasetIdSelector#policy
   */
  readonly policy?: DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DataTransferConfigSpecForProviderDestinationDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecForProviderDestinationDatasetIdSelector(obj: DataTransferConfigSpecForProviderDestinationDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataTransferConfigSpecForProviderEmailPreferences
 */
export interface DataTransferConfigSpecForProviderEmailPreferences {
  /**
   * If true, email notifications will be sent on transfer run failures.
   *
   * @schema DataTransferConfigSpecForProviderEmailPreferences#enableFailureEmail
   */
  readonly enableFailureEmail: boolean;

}

/**
 * Converts an object of type 'DataTransferConfigSpecForProviderEmailPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecForProviderEmailPreferences(obj: DataTransferConfigSpecForProviderEmailPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableFailureEmail': obj.enableFailureEmail,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataTransferConfigSpecForProviderScheduleOptions
 */
export interface DataTransferConfigSpecForProviderScheduleOptions {
  /**
   * If true, automatic scheduling of data transfer runs for this configuration will be disabled. The runs can be started on ad-hoc basis using transferConfigs.startManualRuns API. When automatic scheduling is disabled, the TransferConfig.schedule field will be ignored.
   *
   * @schema DataTransferConfigSpecForProviderScheduleOptions#disableAutoScheduling
   */
  readonly disableAutoScheduling?: boolean;

  /**
   * Defines time to stop scheduling transfer runs. A transfer run cannot be scheduled at or after the end time. The end time can be changed at any moment. The time when a data transfer can be triggered manually is not limited by this option.
   *
   * @schema DataTransferConfigSpecForProviderScheduleOptions#endTime
   */
  readonly endTime?: string;

  /**
   * Specifies time to start scheduling transfer runs. The first run will be scheduled at or after the start time according to a recurrence pattern defined in the schedule string. The start time can be changed at any moment. The time when a data transfer can be triggered manually is not limited by this option.
   *
   * @schema DataTransferConfigSpecForProviderScheduleOptions#startTime
   */
  readonly startTime?: string;

}

/**
 * Converts an object of type 'DataTransferConfigSpecForProviderScheduleOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecForProviderScheduleOptions(obj: DataTransferConfigSpecForProviderScheduleOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableAutoScheduling': obj.disableAutoScheduling,
    'endTime': obj.endTime,
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataTransferConfigSpecForProviderSensitiveParams
 */
export interface DataTransferConfigSpecForProviderSensitiveParams {
  /**
   * The Secret Access Key of the AWS account transferring data from. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema DataTransferConfigSpecForProviderSensitiveParams#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef: DataTransferConfigSpecForProviderSensitiveParamsSecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'DataTransferConfigSpecForProviderSensitiveParams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecForProviderSensitiveParams(obj: DataTransferConfigSpecForProviderSensitiveParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretAccessKeySecretRef': toJson_DataTransferConfigSpecForProviderSensitiveParamsSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataTransferConfigSpecProviderConfigRefPolicy
 */
export interface DataTransferConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataTransferConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DataTransferConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataTransferConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DataTransferConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataTransferConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecProviderConfigRefPolicy(obj: DataTransferConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataTransferConfigSpecProviderRefPolicy
 */
export interface DataTransferConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataTransferConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DataTransferConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataTransferConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DataTransferConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DataTransferConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecProviderRefPolicy(obj: DataTransferConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DataTransferConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface DataTransferConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataTransferConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataTransferConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DataTransferConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecPublishConnectionDetailsToConfigRef(obj: DataTransferConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DataTransferConfigSpecPublishConnectionDetailsToMetadata
 */
export interface DataTransferConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataTransferConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataTransferConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DataTransferConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DataTransferConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecPublishConnectionDetailsToMetadata(obj: DataTransferConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicy
 */
export interface DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicy(obj: DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicy
 */
export interface DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicy(obj: DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret Access Key of the AWS account transferring data from. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema DataTransferConfigSpecForProviderSensitiveParamsSecretAccessKeySecretRef
 */
export interface DataTransferConfigSpecForProviderSensitiveParamsSecretAccessKeySecretRef {
  /**
   * The key to select.
   *
   * @schema DataTransferConfigSpecForProviderSensitiveParamsSecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DataTransferConfigSpecForProviderSensitiveParamsSecretAccessKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DataTransferConfigSpecForProviderSensitiveParamsSecretAccessKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DataTransferConfigSpecForProviderSensitiveParamsSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecForProviderSensitiveParamsSecretAccessKeySecretRef(obj: DataTransferConfigSpecForProviderSensitiveParamsSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataTransferConfigSpecProviderConfigRefPolicyResolution
 */
export enum DataTransferConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataTransferConfigSpecProviderConfigRefPolicyResolve
 */
export enum DataTransferConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataTransferConfigSpecProviderRefPolicyResolution
 */
export enum DataTransferConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataTransferConfigSpecProviderRefPolicyResolve
 */
export enum DataTransferConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicyResolution
 */
export enum DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicyResolve
 */
export enum DataTransferConfigSpecForProviderDestinationDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicyResolution
 */
export enum DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicyResolve
 */
export enum DataTransferConfigSpecForProviderDestinationDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DataTransferConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Job is the Schema for the Jobs API. Jobs are actions that BigQuery runs on your behalf to load data, export data, query data, or copy data.
 *
 * @schema Job
 */
export class Job extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Job"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'Job',
  }

  /**
   * Renders a Kubernetes manifest for "Job".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: JobProps): any {
    return {
      ...Job.GVK,
      ...toJson_JobProps(props),
    };
  }

  /**
   * Defines a "Job" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: JobProps) {
    super(scope, id, {
      ...Job.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Job.GVK,
      ...toJson_JobProps(resolved),
    };
  }
}

/**
 * Job is the Schema for the Jobs API. Jobs are actions that BigQuery runs on your behalf to load data, export data, query data, or copy data.
 *
 * @schema Job
 */
export interface JobProps {
  /**
   * @schema Job#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * JobSpec defines the desired state of Job
   *
   * @schema Job#spec
   */
  readonly spec: JobSpec;

}

/**
 * Converts an object of type 'JobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobProps(obj: JobProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_JobSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JobSpec defines the desired state of Job
 *
 * @schema JobSpec
 */
export interface JobSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema JobSpec#deletionPolicy
   */
  readonly deletionPolicy?: JobSpecDeletionPolicy;

  /**
   * @schema JobSpec#forProvider
   */
  readonly forProvider: JobSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema JobSpec#providerConfigRef
   */
  readonly providerConfigRef?: JobSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema JobSpec#providerRef
   */
  readonly providerRef?: JobSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema JobSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: JobSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema JobSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: JobSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'JobSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpec(obj: JobSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_JobSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_JobSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_JobSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_JobSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_JobSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema JobSpecDeletionPolicy
 */
export enum JobSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema JobSpecForProvider
 */
export interface JobSpecForProvider {
  /**
   * Copies a table. Structure is documented below.
   *
   * @schema JobSpecForProvider#copy
   */
  readonly copy?: JobSpecForProviderCopy[];

  /**
   * Configures an extract job. Structure is documented below.
   *
   * @schema JobSpecForProvider#extract
   */
  readonly extract?: JobSpecForProviderExtract[];

  /**
   * The ID of the job. The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores (_), or dashes (-). The maximum length is 1,024 characters.
   *
   * @schema JobSpecForProvider#jobId
   */
  readonly jobId: string;

  /**
   * Job timeout in milliseconds. If this time limit is exceeded, BigQuery may attempt to terminate the job.
   *
   * @schema JobSpecForProvider#jobTimeoutMs
   */
  readonly jobTimeoutMs?: string;

  /**
   * The labels associated with this job. You can use these to organize and group your jobs.
   *
   * @schema JobSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Configures a load job. Structure is documented below.
   *
   * @schema JobSpecForProvider#load
   */
  readonly load?: JobSpecForProviderLoad[];

  /**
   * The geographic location of the job. The default value is US.
   *
   * @schema JobSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema JobSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Configures a query job. Structure is documented below.
   *
   * @schema JobSpecForProvider#query
   */
  readonly query?: JobSpecForProviderQuery[];

}

/**
 * Converts an object of type 'JobSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProvider(obj: JobSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'copy': obj.copy?.map(y => toJson_JobSpecForProviderCopy(y)),
    'extract': obj.extract?.map(y => toJson_JobSpecForProviderExtract(y)),
    'jobId': obj.jobId,
    'jobTimeoutMs': obj.jobTimeoutMs,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'load': obj.load?.map(y => toJson_JobSpecForProviderLoad(y)),
    'location': obj.location,
    'project': obj.project,
    'query': obj.query?.map(y => toJson_JobSpecForProviderQuery(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema JobSpecProviderConfigRef
 */
export interface JobSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecProviderConfigRef#policy
   */
  readonly policy?: JobSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'JobSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecProviderConfigRef(obj: JobSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema JobSpecProviderRef
 */
export interface JobSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecProviderRef#policy
   */
  readonly policy?: JobSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'JobSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecProviderRef(obj: JobSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema JobSpecPublishConnectionDetailsTo
 */
export interface JobSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema JobSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: JobSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema JobSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: JobSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema JobSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsTo(obj: JobSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_JobSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_JobSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema JobSpecWriteConnectionSecretToRef
 */
export interface JobSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema JobSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema JobSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'JobSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecWriteConnectionSecretToRef(obj: JobSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCopy
 */
export interface JobSpecForProviderCopy {
  /**
   * Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. Creation, truncation and append actions occur as one atomic update upon job completion Default value is CREATE_IF_NEEDED. Possible values are CREATE_IF_NEEDED and CREATE_NEVER.
   *
   * @schema JobSpecForProviderCopy#createDisposition
   */
  readonly createDisposition?: string;

  /**
   * Custom encryption configuration (e.g., Cloud KMS keys) Structure is documented below.
   *
   * @schema JobSpecForProviderCopy#destinationEncryptionConfiguration
   */
  readonly destinationEncryptionConfiguration?: JobSpecForProviderCopyDestinationEncryptionConfiguration[];

  /**
   * The destination table. Structure is documented below.
   *
   * @schema JobSpecForProviderCopy#destinationTable
   */
  readonly destinationTable?: JobSpecForProviderCopyDestinationTable[];

  /**
   * Source tables to copy. Structure is documented below.
   *
   * @schema JobSpecForProviderCopy#sourceTables
   */
  readonly sourceTables: JobSpecForProviderCopySourceTables[];

  /**
   * Specifies the action that occurs if the destination table already exists. The following values are supported: WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result. WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion. Default value is WRITE_EMPTY. Possible values are WRITE_TRUNCATE, WRITE_APPEND, and WRITE_EMPTY.
   *
   * @schema JobSpecForProviderCopy#writeDisposition
   */
  readonly writeDisposition?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCopy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopy(obj: JobSpecForProviderCopy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createDisposition': obj.createDisposition,
    'destinationEncryptionConfiguration': obj.destinationEncryptionConfiguration?.map(y => toJson_JobSpecForProviderCopyDestinationEncryptionConfiguration(y)),
    'destinationTable': obj.destinationTable?.map(y => toJson_JobSpecForProviderCopyDestinationTable(y)),
    'sourceTables': obj.sourceTables?.map(y => toJson_JobSpecForProviderCopySourceTables(y)),
    'writeDisposition': obj.writeDisposition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderExtract
 */
export interface JobSpecForProviderExtract {
  /**
   * The compression type to use for exported files. Possible values include GZIP, DEFLATE, SNAPPY, and NONE. The default value is NONE. DEFLATE and SNAPPY are only supported for Avro.
   *
   * @schema JobSpecForProviderExtract#compression
   */
  readonly compression?: string;

  /**
   * The exported file format. Possible values include CSV, NEWLINE_DELIMITED_JSON and AVRO for tables and SAVED_MODEL for models. The default value for tables is CSV. Tables with nested or repeated fields cannot be exported as CSV. The default value for models is SAVED_MODEL.
   *
   * @schema JobSpecForProviderExtract#destinationFormat
   */
  readonly destinationFormat?: string;

  /**
   * A list of fully-qualified Google Cloud Storage URIs where the extracted table should be written.
   *
   * @schema JobSpecForProviderExtract#destinationUris
   */
  readonly destinationUris: string[];

  /**
   * When extracting data in CSV format, this defines the delimiter to use between fields in the exported data. Default is ','
   *
   * @default '
   * @schema JobSpecForProviderExtract#fieldDelimiter
   */
  readonly fieldDelimiter?: string;

  /**
   * Whether to print out a header row in the results. Default is true.
   *
   * @default true.
   * @schema JobSpecForProviderExtract#printHeader
   */
  readonly printHeader?: boolean;

  /**
   * A reference to the model being exported. Structure is documented below.
   *
   * @schema JobSpecForProviderExtract#sourceModel
   */
  readonly sourceModel?: JobSpecForProviderExtractSourceModel[];

  /**
   * A reference to the table being exported. Structure is documented below.
   *
   * @schema JobSpecForProviderExtract#sourceTable
   */
  readonly sourceTable?: JobSpecForProviderExtractSourceTable[];

  /**
   * Whether to use logical types when extracting to AVRO format.
   *
   * @schema JobSpecForProviderExtract#useAvroLogicalTypes
   */
  readonly useAvroLogicalTypes?: boolean;

}

/**
 * Converts an object of type 'JobSpecForProviderExtract' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtract(obj: JobSpecForProviderExtract | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compression': obj.compression,
    'destinationFormat': obj.destinationFormat,
    'destinationUris': obj.destinationUris?.map(y => y),
    'fieldDelimiter': obj.fieldDelimiter,
    'printHeader': obj.printHeader,
    'sourceModel': obj.sourceModel?.map(y => toJson_JobSpecForProviderExtractSourceModel(y)),
    'sourceTable': obj.sourceTable?.map(y => toJson_JobSpecForProviderExtractSourceTable(y)),
    'useAvroLogicalTypes': obj.useAvroLogicalTypes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderLoad
 */
export interface JobSpecForProviderLoad {
  /**
   * Accept rows that are missing trailing optional columns. The missing values are treated as nulls. If false, records with missing trailing columns are treated as bad records, and if there are too many bad records, an invalid error is returned in the job result. The default value is false. Only applicable to CSV, ignored for other formats.
   *
   * @schema JobSpecForProviderLoad#allowJaggedRows
   */
  readonly allowJaggedRows?: boolean;

  /**
   * Indicates if BigQuery should allow quoted data sections that contain newline characters in a CSV file. The default value is false.
   *
   * @schema JobSpecForProviderLoad#allowQuotedNewlines
   */
  readonly allowQuotedNewlines?: boolean;

  /**
   * Indicates if we should automatically infer the options and schema for CSV and JSON sources.
   *
   * @schema JobSpecForProviderLoad#autodetect
   */
  readonly autodetect?: boolean;

  /**
   * Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. Creation, truncation and append actions occur as one atomic update upon job completion Default value is CREATE_IF_NEEDED. Possible values are CREATE_IF_NEEDED and CREATE_NEVER.
   *
   * @schema JobSpecForProviderLoad#createDisposition
   */
  readonly createDisposition?: string;

  /**
   * Custom encryption configuration (e.g., Cloud KMS keys) Structure is documented below.
   *
   * @schema JobSpecForProviderLoad#destinationEncryptionConfiguration
   */
  readonly destinationEncryptionConfiguration?: JobSpecForProviderLoadDestinationEncryptionConfiguration[];

  /**
   * The destination table to load the data into. Structure is documented below.
   *
   * @schema JobSpecForProviderLoad#destinationTable
   */
  readonly destinationTable: JobSpecForProviderLoadDestinationTable[];

  /**
   * The character encoding of the data. The supported values are UTF-8 or ISO-8859-1. The default value is UTF-8. BigQuery decodes the data after the raw, binary data has been split using the values of the quote and fieldDelimiter properties.
   *
   * @schema JobSpecForProviderLoad#encoding
   */
  readonly encoding?: string;

  /**
   * The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. To use a character in the range 128-255, you must encode the character as UTF8. BigQuery converts the string to ISO-8859-1 encoding, and then uses the first byte of the encoded string to split the data in its raw, binary state. BigQuery also supports the escape sequence "\t" to specify a tab separator. The default value is a comma (',').
   *
   * @schema JobSpecForProviderLoad#fieldDelimiter
   */
  readonly fieldDelimiter?: string;

  /**
   * Indicates if BigQuery should allow extra values that are not represented in the table schema. If true, the extra values are ignored. If false, records with extra columns are treated as bad records, and if there are too many bad records, an invalid error is returned in the job result. The default value is false. The sourceFormat property determines what BigQuery treats as an extra value: CSV: Trailing columns JSON: Named values that don't match any column names
   *
   * @schema JobSpecForProviderLoad#ignoreUnknownValues
   */
  readonly ignoreUnknownValues?: boolean;

  /**
   * If sourceFormat is set to newline-delimited JSON, indicates whether it should be processed as a JSON variant such as GeoJSON. For a sourceFormat other than JSON, omit this field. If the sourceFormat is newline-delimited JSON: - for newline-delimited GeoJSON: set to GEOJSON.
   *
   * @schema JobSpecForProviderLoad#jsonExtension
   */
  readonly jsonExtension?: string;

  /**
   * The maximum number of bad records that BigQuery can ignore when running the job. If the number of bad records exceeds this value, an invalid error is returned in the job result. The default value is 0, which requires that all records are valid.
   *
   * @schema JobSpecForProviderLoad#maxBadRecords
   */
  readonly maxBadRecords?: number;

  /**
   * Specifies a string that represents a null value in a CSV file. For example, if you specify "\N", BigQuery interprets "\N" as a null value when loading a CSV file. The default value is the empty string. If you set this property to a custom value, BigQuery throws an error if an empty string is present for all data types except for STRING and BYTE. For STRING and BYTE columns, BigQuery interprets the empty string as an empty value.
   *
   * @schema JobSpecForProviderLoad#nullMarker
   */
  readonly nullMarker?: string;

  /**
   * If sourceFormat is set to "DATASTORE_BACKUP", indicates which entity properties to load into BigQuery from a Cloud Datastore backup. Property names are case sensitive and must be top-level properties. If no properties are specified, BigQuery loads all properties. If any named property isn't found in the Cloud Datastore backup, an invalid error is returned in the job result.
   *
   * @schema JobSpecForProviderLoad#projectionFields
   */
  readonly projectionFields?: string[];

  /**
   * The value that is used to quote data sections in a CSV file. BigQuery converts the string to ISO-8859-1 encoding, and then uses the first byte of the encoded string to split the data in its raw, binary state. The default value is a double-quote ('"'). If your data does not contain quoted sections, set the property value to an empty string. If your data contains quoted newline characters, you must also set the allowQuotedNewlines property to true.
   *
   * @schema JobSpecForProviderLoad#quote
   */
  readonly quote?: string;

  /**
   * Allows the schema of the destination table to be updated as a side effect of the load job if a schema is autodetected or supplied in the job configuration. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
   *
   * @schema JobSpecForProviderLoad#schemaUpdateOptions
   */
  readonly schemaUpdateOptions?: string[];

  /**
   * The number of rows at the top of a CSV file that BigQuery will skip when loading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped. When autodetect is on, the behavior is the following: skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If they are not detected, the row is read as data. Otherwise data is read starting from the second row. skipLeadingRows is 0 - Instructs autodetect that there are no headers and data should be read starting from the first row. skipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect headers in row N. If headers are not detected, row N is just skipped. Otherwise row N is used to extract column names for the detected schema.
   *
   * @schema JobSpecForProviderLoad#skipLeadingRows
   */
  readonly skipLeadingRows?: number;

  /**
   * The format of the data files. For CSV files, specify "CSV". For datastore backups, specify "DATASTORE_BACKUP". For newline-delimited JSON, specify "NEWLINE_DELIMITED_JSON". For Avro, specify "AVRO". For parquet, specify "PARQUET". For orc, specify "ORC". [Beta] For Bigtable, specify "BIGTABLE". The default value is CSV.
   *
   * @schema JobSpecForProviderLoad#sourceFormat
   */
  readonly sourceFormat?: string;

  /**
   * The fully-qualified URIs that point to your data in Google Cloud. For Google Cloud Storage URIs: Each URI can contain one '*' wildcard character and it must come after the 'bucket' name. Size limits related to load jobs apply to external data sources. For Google Cloud Bigtable URIs: Exactly one URI can be specified and it has be a fully specified and valid HTTPS URL for a Google Cloud Bigtable table. For Google Cloud Datastore backups: Exactly one URI can be specified. Also, the '*' wildcard character is not allowed.
   *
   * @schema JobSpecForProviderLoad#sourceUris
   */
  readonly sourceUris: string[];

  /**
   * Time-based partitioning specification for the destination table. Structure is documented below.
   *
   * @schema JobSpecForProviderLoad#timePartitioning
   */
  readonly timePartitioning?: JobSpecForProviderLoadTimePartitioning[];

  /**
   * Specifies the action that occurs if the destination table already exists. The following values are supported: WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result. WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion. Default value is WRITE_EMPTY. Possible values are WRITE_TRUNCATE, WRITE_APPEND, and WRITE_EMPTY.
   *
   * @schema JobSpecForProviderLoad#writeDisposition
   */
  readonly writeDisposition?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderLoad' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoad(obj: JobSpecForProviderLoad | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowJaggedRows': obj.allowJaggedRows,
    'allowQuotedNewlines': obj.allowQuotedNewlines,
    'autodetect': obj.autodetect,
    'createDisposition': obj.createDisposition,
    'destinationEncryptionConfiguration': obj.destinationEncryptionConfiguration?.map(y => toJson_JobSpecForProviderLoadDestinationEncryptionConfiguration(y)),
    'destinationTable': obj.destinationTable?.map(y => toJson_JobSpecForProviderLoadDestinationTable(y)),
    'encoding': obj.encoding,
    'fieldDelimiter': obj.fieldDelimiter,
    'ignoreUnknownValues': obj.ignoreUnknownValues,
    'jsonExtension': obj.jsonExtension,
    'maxBadRecords': obj.maxBadRecords,
    'nullMarker': obj.nullMarker,
    'projectionFields': obj.projectionFields?.map(y => y),
    'quote': obj.quote,
    'schemaUpdateOptions': obj.schemaUpdateOptions?.map(y => y),
    'skipLeadingRows': obj.skipLeadingRows,
    'sourceFormat': obj.sourceFormat,
    'sourceUris': obj.sourceUris?.map(y => y),
    'timePartitioning': obj.timePartitioning?.map(y => toJson_JobSpecForProviderLoadTimePartitioning(y)),
    'writeDisposition': obj.writeDisposition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderQuery
 */
export interface JobSpecForProviderQuery {
  /**
   * If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed. However, you must still set destinationTable when result size exceeds the allowed maximum response size.
   *
   * @schema JobSpecForProviderQuery#allowLargeResults
   */
  readonly allowLargeResults?: boolean;

  /**
   * Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. Creation, truncation and append actions occur as one atomic update upon job completion Default value is CREATE_IF_NEEDED. Possible values are CREATE_IF_NEEDED and CREATE_NEVER.
   *
   * @schema JobSpecForProviderQuery#createDisposition
   */
  readonly createDisposition?: string;

  /**
   * Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names. Structure is documented below.
   *
   * @schema JobSpecForProviderQuery#defaultDataset
   */
  readonly defaultDataset?: JobSpecForProviderQueryDefaultDataset[];

  /**
   * Custom encryption configuration (e.g., Cloud KMS keys) Structure is documented below.
   *
   * @schema JobSpecForProviderQuery#destinationEncryptionConfiguration
   */
  readonly destinationEncryptionConfiguration?: JobSpecForProviderQueryDestinationEncryptionConfiguration[];

  /**
   * Describes the table where the query results should be stored. This property must be set for large results that exceed the maximum response size. For queries that produce anonymous (cached) results, this field will be populated by BigQuery. Structure is documented below.
   *
   * @schema JobSpecForProviderQuery#destinationTable
   */
  readonly destinationTable?: JobSpecForProviderQueryDestinationTable[];

  /**
   * If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results. allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
   *
   * @schema JobSpecForProviderQuery#flattenResults
   */
  readonly flattenResults?: boolean;

  /**
   * Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge). If unspecified, this will be set to your project default.
   *
   * @schema JobSpecForProviderQuery#maximumBillingTier
   */
  readonly maximumBillingTier?: number;

  /**
   * Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge). If unspecified, this will be set to your project default.
   *
   * @schema JobSpecForProviderQuery#maximumBytesBilled
   */
  readonly maximumBytesBilled?: string;

  /**
   * Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
   *
   * @schema JobSpecForProviderQuery#parameterMode
   */
  readonly parameterMode?: string;

  /**
   * Specifies a priority for the query. Default value is INTERACTIVE. Possible values are INTERACTIVE and BATCH.
   *
   * @schema JobSpecForProviderQuery#priority
   */
  readonly priority?: string;

  /**
   * SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL. NOTE: queries containing DML language (DELETE, UPDATE, MERGE, INSERT) must specify create_disposition = "" and write_disposition = "".
   *
   * @schema JobSpecForProviderQuery#query
   */
  readonly query: string;

  /**
   * Allows the schema of the destination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
   *
   * @schema JobSpecForProviderQuery#schemaUpdateOptions
   */
  readonly schemaUpdateOptions?: string[];

  /**
   * Options controlling the execution of scripts. Structure is documented below.
   *
   * @schema JobSpecForProviderQuery#scriptOptions
   */
  readonly scriptOptions?: JobSpecForProviderQueryScriptOptions[];

  /**
   * Specifies whether to use BigQuery's legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery's standard SQL.
   *
   * @schema JobSpecForProviderQuery#useLegacySql
   */
  readonly useLegacySql?: boolean;

  /**
   * Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified. The default value is true.
   *
   * @schema JobSpecForProviderQuery#useQueryCache
   */
  readonly useQueryCache?: boolean;

  /**
   * Describes user-defined function resources used in the query. Structure is documented below.
   *
   * @schema JobSpecForProviderQuery#userDefinedFunctionResources
   */
  readonly userDefinedFunctionResources?: JobSpecForProviderQueryUserDefinedFunctionResources[];

  /**
   * Specifies the action that occurs if the destination table already exists. The following values are supported: WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result. WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion. Default value is WRITE_EMPTY. Possible values are WRITE_TRUNCATE, WRITE_APPEND, and WRITE_EMPTY.
   *
   * @schema JobSpecForProviderQuery#writeDisposition
   */
  readonly writeDisposition?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQuery(obj: JobSpecForProviderQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowLargeResults': obj.allowLargeResults,
    'createDisposition': obj.createDisposition,
    'defaultDataset': obj.defaultDataset?.map(y => toJson_JobSpecForProviderQueryDefaultDataset(y)),
    'destinationEncryptionConfiguration': obj.destinationEncryptionConfiguration?.map(y => toJson_JobSpecForProviderQueryDestinationEncryptionConfiguration(y)),
    'destinationTable': obj.destinationTable?.map(y => toJson_JobSpecForProviderQueryDestinationTable(y)),
    'flattenResults': obj.flattenResults,
    'maximumBillingTier': obj.maximumBillingTier,
    'maximumBytesBilled': obj.maximumBytesBilled,
    'parameterMode': obj.parameterMode,
    'priority': obj.priority,
    'query': obj.query,
    'schemaUpdateOptions': obj.schemaUpdateOptions?.map(y => y),
    'scriptOptions': obj.scriptOptions?.map(y => toJson_JobSpecForProviderQueryScriptOptions(y)),
    'useLegacySql': obj.useLegacySql,
    'useQueryCache': obj.useQueryCache,
    'userDefinedFunctionResources': obj.userDefinedFunctionResources?.map(y => toJson_JobSpecForProviderQueryUserDefinedFunctionResources(y)),
    'writeDisposition': obj.writeDisposition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecProviderConfigRefPolicy
 */
export interface JobSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: JobSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: JobSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecProviderConfigRefPolicy(obj: JobSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecProviderRefPolicy
 */
export interface JobSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecProviderRefPolicy#resolution
   */
  readonly resolution?: JobSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecProviderRefPolicy#resolve
   */
  readonly resolve?: JobSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecProviderRefPolicy(obj: JobSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRef
 */
export interface JobSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: JobSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsToConfigRef(obj: JobSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema JobSpecPublishConnectionDetailsToMetadata
 */
export interface JobSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema JobSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema JobSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema JobSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsToMetadata(obj: JobSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCopyDestinationEncryptionConfiguration
 */
export interface JobSpecForProviderCopyDestinationEncryptionConfiguration {
  /**
   * Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfiguration#kmsKeyName
   */
  readonly kmsKeyName?: string;

  /**
   * Reference to a CryptoKey in kms to populate kmsKeyName.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfiguration#kmsKeyNameRef
   */
  readonly kmsKeyNameRef?: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRef;

  /**
   * Selector for a CryptoKey in kms to populate kmsKeyName.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfiguration#kmsKeyNameSelector
   */
  readonly kmsKeyNameSelector?: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelector;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationEncryptionConfiguration(obj: JobSpecForProviderCopyDestinationEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
    'kmsKeyNameRef': toJson_JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRef(obj.kmsKeyNameRef),
    'kmsKeyNameSelector': toJson_JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelector(obj.kmsKeyNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCopyDestinationTable
 */
export interface JobSpecForProviderCopyDestinationTable {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobSpecForProviderCopyDestinationTable#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema JobSpecForProviderCopyDestinationTable#datasetIdRef
   */
  readonly datasetIdRef?: JobSpecForProviderCopyDestinationTableDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema JobSpecForProviderCopyDestinationTable#datasetIdSelector
   */
  readonly datasetIdSelector?: JobSpecForProviderCopyDestinationTableDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobSpecForProviderCopyDestinationTable#projectId
   */
  readonly projectId?: string;

  /**
   * The table. Can be specified {{table_id}} if project_id and dataset_id are also set, or of the form projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}} if not.
   *
   * @schema JobSpecForProviderCopyDestinationTable#tableId
   */
  readonly tableId?: string;

  /**
   * Reference to a Table in bigquery to populate tableId.
   *
   * @schema JobSpecForProviderCopyDestinationTable#tableIdRef
   */
  readonly tableIdRef?: JobSpecForProviderCopyDestinationTableTableIdRef;

  /**
   * Selector for a Table in bigquery to populate tableId.
   *
   * @schema JobSpecForProviderCopyDestinationTable#tableIdSelector
   */
  readonly tableIdSelector?: JobSpecForProviderCopyDestinationTableTableIdSelector;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationTable(obj: JobSpecForProviderCopyDestinationTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_JobSpecForProviderCopyDestinationTableDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_JobSpecForProviderCopyDestinationTableDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
    'tableId': obj.tableId,
    'tableIdRef': toJson_JobSpecForProviderCopyDestinationTableTableIdRef(obj.tableIdRef),
    'tableIdSelector': toJson_JobSpecForProviderCopyDestinationTableTableIdSelector(obj.tableIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCopySourceTables
 */
export interface JobSpecForProviderCopySourceTables {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobSpecForProviderCopySourceTables#datasetId
   */
  readonly datasetId?: string;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobSpecForProviderCopySourceTables#projectId
   */
  readonly projectId?: string;

  /**
   * The table. Can be specified {{table_id}} if project_id and dataset_id are also set, or of the form projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}} if not.
   *
   * @schema JobSpecForProviderCopySourceTables#tableId
   */
  readonly tableId: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCopySourceTables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopySourceTables(obj: JobSpecForProviderCopySourceTables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderExtractSourceModel
 */
export interface JobSpecForProviderExtractSourceModel {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobSpecForProviderExtractSourceModel#datasetId
   */
  readonly datasetId: string;

  /**
   * The ID of the model.
   *
   * @schema JobSpecForProviderExtractSourceModel#modelId
   */
  readonly modelId: string;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobSpecForProviderExtractSourceModel#projectId
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'JobSpecForProviderExtractSourceModel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtractSourceModel(obj: JobSpecForProviderExtractSourceModel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'modelId': obj.modelId,
    'projectId': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderExtractSourceTable
 */
export interface JobSpecForProviderExtractSourceTable {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobSpecForProviderExtractSourceTable#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema JobSpecForProviderExtractSourceTable#datasetIdRef
   */
  readonly datasetIdRef?: JobSpecForProviderExtractSourceTableDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema JobSpecForProviderExtractSourceTable#datasetIdSelector
   */
  readonly datasetIdSelector?: JobSpecForProviderExtractSourceTableDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobSpecForProviderExtractSourceTable#projectId
   */
  readonly projectId?: string;

  /**
   * The table. Can be specified {{table_id}} if project_id and dataset_id are also set, or of the form projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}} if not.
   *
   * @schema JobSpecForProviderExtractSourceTable#tableId
   */
  readonly tableId?: string;

  /**
   * Reference to a Table in bigquery to populate tableId.
   *
   * @schema JobSpecForProviderExtractSourceTable#tableIdRef
   */
  readonly tableIdRef?: JobSpecForProviderExtractSourceTableTableIdRef;

  /**
   * Selector for a Table in bigquery to populate tableId.
   *
   * @schema JobSpecForProviderExtractSourceTable#tableIdSelector
   */
  readonly tableIdSelector?: JobSpecForProviderExtractSourceTableTableIdSelector;

}

/**
 * Converts an object of type 'JobSpecForProviderExtractSourceTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtractSourceTable(obj: JobSpecForProviderExtractSourceTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_JobSpecForProviderExtractSourceTableDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_JobSpecForProviderExtractSourceTableDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
    'tableId': obj.tableId,
    'tableIdRef': toJson_JobSpecForProviderExtractSourceTableTableIdRef(obj.tableIdRef),
    'tableIdSelector': toJson_JobSpecForProviderExtractSourceTableTableIdSelector(obj.tableIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderLoadDestinationEncryptionConfiguration
 */
export interface JobSpecForProviderLoadDestinationEncryptionConfiguration {
  /**
   * Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key.
   *
   * @schema JobSpecForProviderLoadDestinationEncryptionConfiguration#kmsKeyName
   */
  readonly kmsKeyName: string;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadDestinationEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadDestinationEncryptionConfiguration(obj: JobSpecForProviderLoadDestinationEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderLoadDestinationTable
 */
export interface JobSpecForProviderLoadDestinationTable {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobSpecForProviderLoadDestinationTable#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema JobSpecForProviderLoadDestinationTable#datasetIdRef
   */
  readonly datasetIdRef?: JobSpecForProviderLoadDestinationTableDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema JobSpecForProviderLoadDestinationTable#datasetIdSelector
   */
  readonly datasetIdSelector?: JobSpecForProviderLoadDestinationTableDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobSpecForProviderLoadDestinationTable#projectId
   */
  readonly projectId?: string;

  /**
   * The table. Can be specified {{table_id}} if project_id and dataset_id are also set, or of the form projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}} if not.
   *
   * @schema JobSpecForProviderLoadDestinationTable#tableId
   */
  readonly tableId?: string;

  /**
   * Reference to a Table in bigquery to populate tableId.
   *
   * @schema JobSpecForProviderLoadDestinationTable#tableIdRef
   */
  readonly tableIdRef?: JobSpecForProviderLoadDestinationTableTableIdRef;

  /**
   * Selector for a Table in bigquery to populate tableId.
   *
   * @schema JobSpecForProviderLoadDestinationTable#tableIdSelector
   */
  readonly tableIdSelector?: JobSpecForProviderLoadDestinationTableTableIdSelector;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadDestinationTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadDestinationTable(obj: JobSpecForProviderLoadDestinationTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_JobSpecForProviderLoadDestinationTableDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_JobSpecForProviderLoadDestinationTableDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
    'tableId': obj.tableId,
    'tableIdRef': toJson_JobSpecForProviderLoadDestinationTableTableIdRef(obj.tableIdRef),
    'tableIdSelector': toJson_JobSpecForProviderLoadDestinationTableTableIdSelector(obj.tableIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderLoadTimePartitioning
 */
export interface JobSpecForProviderLoadTimePartitioning {
  /**
   * Number of milliseconds for which to keep the storage for a partition. A wrapper is used here because 0 is an invalid value.
   *
   * @schema JobSpecForProviderLoadTimePartitioning#expirationMs
   */
  readonly expirationMs?: string;

  /**
   * If not set, the table is partitioned by pseudo column '_PARTITIONTIME'; if set, the table is partitioned by this field. The field must be a top-level TIMESTAMP or DATE field. Its mode must be NULLABLE or REQUIRED. A wrapper is used here because an empty string is an invalid value.
   *
   * @schema JobSpecForProviderLoadTimePartitioning#field
   */
  readonly field?: string;

  /**
   * The only type supported is DAY, which will generate one partition per day. Providing an empty string used to cause an error, but in OnePlatform the field will be treated as unset.
   *
   * @schema JobSpecForProviderLoadTimePartitioning#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadTimePartitioning' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadTimePartitioning(obj: JobSpecForProviderLoadTimePartitioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expirationMs': obj.expirationMs,
    'field': obj.field,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderQueryDefaultDataset
 */
export interface JobSpecForProviderQueryDefaultDataset {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobSpecForProviderQueryDefaultDataset#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema JobSpecForProviderQueryDefaultDataset#datasetIdRef
   */
  readonly datasetIdRef?: JobSpecForProviderQueryDefaultDatasetDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema JobSpecForProviderQueryDefaultDataset#datasetIdSelector
   */
  readonly datasetIdSelector?: JobSpecForProviderQueryDefaultDatasetDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobSpecForProviderQueryDefaultDataset#projectId
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDefaultDataset' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDefaultDataset(obj: JobSpecForProviderQueryDefaultDataset | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_JobSpecForProviderQueryDefaultDatasetDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_JobSpecForProviderQueryDefaultDatasetDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderQueryDestinationEncryptionConfiguration
 */
export interface JobSpecForProviderQueryDestinationEncryptionConfiguration {
  /**
   * Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key.
   *
   * @schema JobSpecForProviderQueryDestinationEncryptionConfiguration#kmsKeyName
   */
  readonly kmsKeyName: string;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDestinationEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDestinationEncryptionConfiguration(obj: JobSpecForProviderQueryDestinationEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderQueryDestinationTable
 */
export interface JobSpecForProviderQueryDestinationTable {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobSpecForProviderQueryDestinationTable#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema JobSpecForProviderQueryDestinationTable#datasetIdRef
   */
  readonly datasetIdRef?: JobSpecForProviderQueryDestinationTableDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema JobSpecForProviderQueryDestinationTable#datasetIdSelector
   */
  readonly datasetIdSelector?: JobSpecForProviderQueryDestinationTableDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobSpecForProviderQueryDestinationTable#projectId
   */
  readonly projectId?: string;

  /**
   * The table. Can be specified {{table_id}} if project_id and dataset_id are also set, or of the form projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}} if not.
   *
   * @schema JobSpecForProviderQueryDestinationTable#tableId
   */
  readonly tableId?: string;

  /**
   * Reference to a Table in bigquery to populate tableId.
   *
   * @schema JobSpecForProviderQueryDestinationTable#tableIdRef
   */
  readonly tableIdRef?: JobSpecForProviderQueryDestinationTableTableIdRef;

  /**
   * Selector for a Table in bigquery to populate tableId.
   *
   * @schema JobSpecForProviderQueryDestinationTable#tableIdSelector
   */
  readonly tableIdSelector?: JobSpecForProviderQueryDestinationTableTableIdSelector;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDestinationTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDestinationTable(obj: JobSpecForProviderQueryDestinationTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_JobSpecForProviderQueryDestinationTableDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_JobSpecForProviderQueryDestinationTableDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
    'tableId': obj.tableId,
    'tableIdRef': toJson_JobSpecForProviderQueryDestinationTableTableIdRef(obj.tableIdRef),
    'tableIdSelector': toJson_JobSpecForProviderQueryDestinationTableTableIdSelector(obj.tableIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderQueryScriptOptions
 */
export interface JobSpecForProviderQueryScriptOptions {
  /**
   * Determines which statement in the script represents the "key result", used to populate the schema and query results of the script job. Possible values are LAST and FIRST_SELECT.
   *
   * @schema JobSpecForProviderQueryScriptOptions#keyResultStatement
   */
  readonly keyResultStatement?: string;

  /**
   * Limit on the number of bytes billed per statement. Exceeding this budget results in an error.
   *
   * @schema JobSpecForProviderQueryScriptOptions#statementByteBudget
   */
  readonly statementByteBudget?: string;

  /**
   * Timeout period for each statement in a script.
   *
   * @schema JobSpecForProviderQueryScriptOptions#statementTimeoutMs
   */
  readonly statementTimeoutMs?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryScriptOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryScriptOptions(obj: JobSpecForProviderQueryScriptOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyResultStatement': obj.keyResultStatement,
    'statementByteBudget': obj.statementByteBudget,
    'statementTimeoutMs': obj.statementTimeoutMs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderQueryUserDefinedFunctionResources
 */
export interface JobSpecForProviderQueryUserDefinedFunctionResources {
  /**
   * An inline resource that contains code for a user-defined function (UDF). Providing a inline code resource is equivalent to providing a URI for a file containing the same code.
   *
   * @schema JobSpecForProviderQueryUserDefinedFunctionResources#inlineCode
   */
  readonly inlineCode?: string;

  /**
   * A code resource to load from a Google Cloud Storage URI (gs://bucket/path).
   *
   * @schema JobSpecForProviderQueryUserDefinedFunctionResources#resourceUri
   */
  readonly resourceUri?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryUserDefinedFunctionResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryUserDefinedFunctionResources(obj: JobSpecForProviderQueryUserDefinedFunctionResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inlineCode': obj.inlineCode,
    'resourceUri': obj.resourceUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecProviderConfigRefPolicyResolution
 */
export enum JobSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecProviderConfigRefPolicyResolve
 */
export enum JobSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecProviderRefPolicyResolution
 */
export enum JobSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecProviderRefPolicyResolve
 */
export enum JobSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface JobSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: JobSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: JobSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsToConfigRefPolicy(obj: JobSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate kmsKeyName.
 *
 * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRef
 */
export interface JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRef#policy
   */
  readonly policy?: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRef(obj: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate kmsKeyName.
 *
 * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelector
 */
export interface JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelector#policy
   */
  readonly policy?: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelector(obj: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema JobSpecForProviderCopyDestinationTableDatasetIdRef
 */
export interface JobSpecForProviderCopyDestinationTableDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderCopyDestinationTableDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderCopyDestinationTableDatasetIdRef#policy
   */
  readonly policy?: JobSpecForProviderCopyDestinationTableDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationTableDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationTableDatasetIdRef(obj: JobSpecForProviderCopyDestinationTableDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderCopyDestinationTableDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema JobSpecForProviderCopyDestinationTableDatasetIdSelector
 */
export interface JobSpecForProviderCopyDestinationTableDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderCopyDestinationTableDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderCopyDestinationTableDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderCopyDestinationTableDatasetIdSelector#policy
   */
  readonly policy?: JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationTableDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationTableDatasetIdSelector(obj: JobSpecForProviderCopyDestinationTableDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in bigquery to populate tableId.
 *
 * @schema JobSpecForProviderCopyDestinationTableTableIdRef
 */
export interface JobSpecForProviderCopyDestinationTableTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderCopyDestinationTableTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderCopyDestinationTableTableIdRef#policy
   */
  readonly policy?: JobSpecForProviderCopyDestinationTableTableIdRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationTableTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationTableTableIdRef(obj: JobSpecForProviderCopyDestinationTableTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderCopyDestinationTableTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in bigquery to populate tableId.
 *
 * @schema JobSpecForProviderCopyDestinationTableTableIdSelector
 */
export interface JobSpecForProviderCopyDestinationTableTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderCopyDestinationTableTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderCopyDestinationTableTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderCopyDestinationTableTableIdSelector#policy
   */
  readonly policy?: JobSpecForProviderCopyDestinationTableTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationTableTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationTableTableIdSelector(obj: JobSpecForProviderCopyDestinationTableTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderCopyDestinationTableTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema JobSpecForProviderExtractSourceTableDatasetIdRef
 */
export interface JobSpecForProviderExtractSourceTableDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderExtractSourceTableDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderExtractSourceTableDatasetIdRef#policy
   */
  readonly policy?: JobSpecForProviderExtractSourceTableDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderExtractSourceTableDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtractSourceTableDatasetIdRef(obj: JobSpecForProviderExtractSourceTableDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderExtractSourceTableDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema JobSpecForProviderExtractSourceTableDatasetIdSelector
 */
export interface JobSpecForProviderExtractSourceTableDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderExtractSourceTableDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderExtractSourceTableDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderExtractSourceTableDatasetIdSelector#policy
   */
  readonly policy?: JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderExtractSourceTableDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtractSourceTableDatasetIdSelector(obj: JobSpecForProviderExtractSourceTableDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in bigquery to populate tableId.
 *
 * @schema JobSpecForProviderExtractSourceTableTableIdRef
 */
export interface JobSpecForProviderExtractSourceTableTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderExtractSourceTableTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderExtractSourceTableTableIdRef#policy
   */
  readonly policy?: JobSpecForProviderExtractSourceTableTableIdRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderExtractSourceTableTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtractSourceTableTableIdRef(obj: JobSpecForProviderExtractSourceTableTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderExtractSourceTableTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in bigquery to populate tableId.
 *
 * @schema JobSpecForProviderExtractSourceTableTableIdSelector
 */
export interface JobSpecForProviderExtractSourceTableTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderExtractSourceTableTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderExtractSourceTableTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderExtractSourceTableTableIdSelector#policy
   */
  readonly policy?: JobSpecForProviderExtractSourceTableTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderExtractSourceTableTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtractSourceTableTableIdSelector(obj: JobSpecForProviderExtractSourceTableTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderExtractSourceTableTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema JobSpecForProviderLoadDestinationTableDatasetIdRef
 */
export interface JobSpecForProviderLoadDestinationTableDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderLoadDestinationTableDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderLoadDestinationTableDatasetIdRef#policy
   */
  readonly policy?: JobSpecForProviderLoadDestinationTableDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadDestinationTableDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadDestinationTableDatasetIdRef(obj: JobSpecForProviderLoadDestinationTableDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderLoadDestinationTableDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema JobSpecForProviderLoadDestinationTableDatasetIdSelector
 */
export interface JobSpecForProviderLoadDestinationTableDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderLoadDestinationTableDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderLoadDestinationTableDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderLoadDestinationTableDatasetIdSelector#policy
   */
  readonly policy?: JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadDestinationTableDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadDestinationTableDatasetIdSelector(obj: JobSpecForProviderLoadDestinationTableDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in bigquery to populate tableId.
 *
 * @schema JobSpecForProviderLoadDestinationTableTableIdRef
 */
export interface JobSpecForProviderLoadDestinationTableTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderLoadDestinationTableTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderLoadDestinationTableTableIdRef#policy
   */
  readonly policy?: JobSpecForProviderLoadDestinationTableTableIdRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadDestinationTableTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadDestinationTableTableIdRef(obj: JobSpecForProviderLoadDestinationTableTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderLoadDestinationTableTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in bigquery to populate tableId.
 *
 * @schema JobSpecForProviderLoadDestinationTableTableIdSelector
 */
export interface JobSpecForProviderLoadDestinationTableTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderLoadDestinationTableTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderLoadDestinationTableTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderLoadDestinationTableTableIdSelector#policy
   */
  readonly policy?: JobSpecForProviderLoadDestinationTableTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadDestinationTableTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadDestinationTableTableIdSelector(obj: JobSpecForProviderLoadDestinationTableTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderLoadDestinationTableTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdRef
 */
export interface JobSpecForProviderQueryDefaultDatasetDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdRef#policy
   */
  readonly policy?: JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDefaultDatasetDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDefaultDatasetDatasetIdRef(obj: JobSpecForProviderQueryDefaultDatasetDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdSelector
 */
export interface JobSpecForProviderQueryDefaultDatasetDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdSelector#policy
   */
  readonly policy?: JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDefaultDatasetDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDefaultDatasetDatasetIdSelector(obj: JobSpecForProviderQueryDefaultDatasetDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema JobSpecForProviderQueryDestinationTableDatasetIdRef
 */
export interface JobSpecForProviderQueryDestinationTableDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderQueryDestinationTableDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderQueryDestinationTableDatasetIdRef#policy
   */
  readonly policy?: JobSpecForProviderQueryDestinationTableDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDestinationTableDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDestinationTableDatasetIdRef(obj: JobSpecForProviderQueryDestinationTableDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderQueryDestinationTableDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema JobSpecForProviderQueryDestinationTableDatasetIdSelector
 */
export interface JobSpecForProviderQueryDestinationTableDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderQueryDestinationTableDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderQueryDestinationTableDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderQueryDestinationTableDatasetIdSelector#policy
   */
  readonly policy?: JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDestinationTableDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDestinationTableDatasetIdSelector(obj: JobSpecForProviderQueryDestinationTableDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in bigquery to populate tableId.
 *
 * @schema JobSpecForProviderQueryDestinationTableTableIdRef
 */
export interface JobSpecForProviderQueryDestinationTableTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderQueryDestinationTableTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderQueryDestinationTableTableIdRef#policy
   */
  readonly policy?: JobSpecForProviderQueryDestinationTableTableIdRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDestinationTableTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDestinationTableTableIdRef(obj: JobSpecForProviderQueryDestinationTableTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderQueryDestinationTableTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in bigquery to populate tableId.
 *
 * @schema JobSpecForProviderQueryDestinationTableTableIdSelector
 */
export interface JobSpecForProviderQueryDestinationTableTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderQueryDestinationTableTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderQueryDestinationTableTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderQueryDestinationTableTableIdSelector#policy
   */
  readonly policy?: JobSpecForProviderQueryDestinationTableTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDestinationTableTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDestinationTableTableIdSelector(obj: JobSpecForProviderQueryDestinationTableTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderQueryDestinationTableTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum JobSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum JobSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicy
 */
export interface JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicy(obj: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicy
 */
export interface JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicy(obj: JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderCopyDestinationTableDatasetIdRefPolicy
 */
export interface JobSpecForProviderCopyDestinationTableDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderCopyDestinationTableDatasetIdRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderCopyDestinationTableDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderCopyDestinationTableDatasetIdRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderCopyDestinationTableDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationTableDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationTableDatasetIdRefPolicy(obj: JobSpecForProviderCopyDestinationTableDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicy
 */
export interface JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicy(obj: JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderCopyDestinationTableTableIdRefPolicy
 */
export interface JobSpecForProviderCopyDestinationTableTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderCopyDestinationTableTableIdRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderCopyDestinationTableTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderCopyDestinationTableTableIdRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderCopyDestinationTableTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationTableTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationTableTableIdRefPolicy(obj: JobSpecForProviderCopyDestinationTableTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderCopyDestinationTableTableIdSelectorPolicy
 */
export interface JobSpecForProviderCopyDestinationTableTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderCopyDestinationTableTableIdSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderCopyDestinationTableTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderCopyDestinationTableTableIdSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderCopyDestinationTableTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderCopyDestinationTableTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCopyDestinationTableTableIdSelectorPolicy(obj: JobSpecForProviderCopyDestinationTableTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderExtractSourceTableDatasetIdRefPolicy
 */
export interface JobSpecForProviderExtractSourceTableDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderExtractSourceTableDatasetIdRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderExtractSourceTableDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderExtractSourceTableDatasetIdRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderExtractSourceTableDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderExtractSourceTableDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtractSourceTableDatasetIdRefPolicy(obj: JobSpecForProviderExtractSourceTableDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicy
 */
export interface JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicy(obj: JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderExtractSourceTableTableIdRefPolicy
 */
export interface JobSpecForProviderExtractSourceTableTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderExtractSourceTableTableIdRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderExtractSourceTableTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderExtractSourceTableTableIdRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderExtractSourceTableTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderExtractSourceTableTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtractSourceTableTableIdRefPolicy(obj: JobSpecForProviderExtractSourceTableTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderExtractSourceTableTableIdSelectorPolicy
 */
export interface JobSpecForProviderExtractSourceTableTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderExtractSourceTableTableIdSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderExtractSourceTableTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderExtractSourceTableTableIdSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderExtractSourceTableTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderExtractSourceTableTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExtractSourceTableTableIdSelectorPolicy(obj: JobSpecForProviderExtractSourceTableTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderLoadDestinationTableDatasetIdRefPolicy
 */
export interface JobSpecForProviderLoadDestinationTableDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderLoadDestinationTableDatasetIdRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderLoadDestinationTableDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderLoadDestinationTableDatasetIdRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderLoadDestinationTableDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadDestinationTableDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadDestinationTableDatasetIdRefPolicy(obj: JobSpecForProviderLoadDestinationTableDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicy
 */
export interface JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicy(obj: JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderLoadDestinationTableTableIdRefPolicy
 */
export interface JobSpecForProviderLoadDestinationTableTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderLoadDestinationTableTableIdRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderLoadDestinationTableTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderLoadDestinationTableTableIdRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderLoadDestinationTableTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadDestinationTableTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadDestinationTableTableIdRefPolicy(obj: JobSpecForProviderLoadDestinationTableTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderLoadDestinationTableTableIdSelectorPolicy
 */
export interface JobSpecForProviderLoadDestinationTableTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderLoadDestinationTableTableIdSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderLoadDestinationTableTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderLoadDestinationTableTableIdSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderLoadDestinationTableTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderLoadDestinationTableTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderLoadDestinationTableTableIdSelectorPolicy(obj: JobSpecForProviderLoadDestinationTableTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicy
 */
export interface JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicy(obj: JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicy
 */
export interface JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicy(obj: JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderQueryDestinationTableDatasetIdRefPolicy
 */
export interface JobSpecForProviderQueryDestinationTableDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderQueryDestinationTableDatasetIdRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderQueryDestinationTableDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderQueryDestinationTableDatasetIdRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderQueryDestinationTableDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDestinationTableDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDestinationTableDatasetIdRefPolicy(obj: JobSpecForProviderQueryDestinationTableDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicy
 */
export interface JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicy(obj: JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderQueryDestinationTableTableIdRefPolicy
 */
export interface JobSpecForProviderQueryDestinationTableTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderQueryDestinationTableTableIdRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderQueryDestinationTableTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderQueryDestinationTableTableIdRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderQueryDestinationTableTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDestinationTableTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDestinationTableTableIdRefPolicy(obj: JobSpecForProviderQueryDestinationTableTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderQueryDestinationTableTableIdSelectorPolicy
 */
export interface JobSpecForProviderQueryDestinationTableTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderQueryDestinationTableTableIdSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderQueryDestinationTableTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderQueryDestinationTableTableIdSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderQueryDestinationTableTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderQueryDestinationTableTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderQueryDestinationTableTableIdSelectorPolicy(obj: JobSpecForProviderQueryDestinationTableTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicyResolution
 */
export enum JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicyResolve
 */
export enum JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicyResolution
 */
export enum JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicyResolve
 */
export enum JobSpecForProviderCopyDestinationEncryptionConfigurationKmsKeyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderCopyDestinationTableDatasetIdRefPolicyResolution
 */
export enum JobSpecForProviderCopyDestinationTableDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderCopyDestinationTableDatasetIdRefPolicyResolve
 */
export enum JobSpecForProviderCopyDestinationTableDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicyResolution
 */
export enum JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicyResolve
 */
export enum JobSpecForProviderCopyDestinationTableDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderCopyDestinationTableTableIdRefPolicyResolution
 */
export enum JobSpecForProviderCopyDestinationTableTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderCopyDestinationTableTableIdRefPolicyResolve
 */
export enum JobSpecForProviderCopyDestinationTableTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderCopyDestinationTableTableIdSelectorPolicyResolution
 */
export enum JobSpecForProviderCopyDestinationTableTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderCopyDestinationTableTableIdSelectorPolicyResolve
 */
export enum JobSpecForProviderCopyDestinationTableTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderExtractSourceTableDatasetIdRefPolicyResolution
 */
export enum JobSpecForProviderExtractSourceTableDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderExtractSourceTableDatasetIdRefPolicyResolve
 */
export enum JobSpecForProviderExtractSourceTableDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicyResolution
 */
export enum JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicyResolve
 */
export enum JobSpecForProviderExtractSourceTableDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderExtractSourceTableTableIdRefPolicyResolution
 */
export enum JobSpecForProviderExtractSourceTableTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderExtractSourceTableTableIdRefPolicyResolve
 */
export enum JobSpecForProviderExtractSourceTableTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderExtractSourceTableTableIdSelectorPolicyResolution
 */
export enum JobSpecForProviderExtractSourceTableTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderExtractSourceTableTableIdSelectorPolicyResolve
 */
export enum JobSpecForProviderExtractSourceTableTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderLoadDestinationTableDatasetIdRefPolicyResolution
 */
export enum JobSpecForProviderLoadDestinationTableDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderLoadDestinationTableDatasetIdRefPolicyResolve
 */
export enum JobSpecForProviderLoadDestinationTableDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicyResolution
 */
export enum JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicyResolve
 */
export enum JobSpecForProviderLoadDestinationTableDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderLoadDestinationTableTableIdRefPolicyResolution
 */
export enum JobSpecForProviderLoadDestinationTableTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderLoadDestinationTableTableIdRefPolicyResolve
 */
export enum JobSpecForProviderLoadDestinationTableTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderLoadDestinationTableTableIdSelectorPolicyResolution
 */
export enum JobSpecForProviderLoadDestinationTableTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderLoadDestinationTableTableIdSelectorPolicyResolve
 */
export enum JobSpecForProviderLoadDestinationTableTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicyResolution
 */
export enum JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicyResolve
 */
export enum JobSpecForProviderQueryDefaultDatasetDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicyResolution
 */
export enum JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicyResolve
 */
export enum JobSpecForProviderQueryDefaultDatasetDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderQueryDestinationTableDatasetIdRefPolicyResolution
 */
export enum JobSpecForProviderQueryDestinationTableDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderQueryDestinationTableDatasetIdRefPolicyResolve
 */
export enum JobSpecForProviderQueryDestinationTableDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicyResolution
 */
export enum JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicyResolve
 */
export enum JobSpecForProviderQueryDestinationTableDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderQueryDestinationTableTableIdRefPolicyResolution
 */
export enum JobSpecForProviderQueryDestinationTableTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderQueryDestinationTableTableIdRefPolicyResolve
 */
export enum JobSpecForProviderQueryDestinationTableTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderQueryDestinationTableTableIdSelectorPolicyResolution
 */
export enum JobSpecForProviderQueryDestinationTableTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderQueryDestinationTableTableIdSelectorPolicyResolve
 */
export enum JobSpecForProviderQueryDestinationTableTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Reservation is the Schema for the Reservations API. A reservation is a mechanism used to guarantee BigQuery slots to users.
 *
 * @schema Reservation
 */
export class Reservation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Reservation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'Reservation',
  }

  /**
   * Renders a Kubernetes manifest for "Reservation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReservationProps): any {
    return {
      ...Reservation.GVK,
      ...toJson_ReservationProps(props),
    };
  }

  /**
   * Defines a "Reservation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReservationProps) {
    super(scope, id, {
      ...Reservation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Reservation.GVK,
      ...toJson_ReservationProps(resolved),
    };
  }
}

/**
 * Reservation is the Schema for the Reservations API. A reservation is a mechanism used to guarantee BigQuery slots to users.
 *
 * @schema Reservation
 */
export interface ReservationProps {
  /**
   * @schema Reservation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReservationSpec defines the desired state of Reservation
   *
   * @schema Reservation#spec
   */
  readonly spec: ReservationSpec;

}

/**
 * Converts an object of type 'ReservationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationProps(obj: ReservationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReservationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReservationSpec defines the desired state of Reservation
 *
 * @schema ReservationSpec
 */
export interface ReservationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ReservationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReservationSpecDeletionPolicy;

  /**
   * @schema ReservationSpec#forProvider
   */
  readonly forProvider: ReservationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReservationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReservationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReservationSpec#providerRef
   */
  readonly providerRef?: ReservationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReservationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReservationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReservationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReservationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReservationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpec(obj: ReservationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReservationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ReservationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReservationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReservationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReservationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ReservationSpecDeletionPolicy
 */
export enum ReservationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReservationSpecForProvider
 */
export interface ReservationSpecForProvider {
  /**
   * Maximum number of queries that are allowed to run concurrently in this reservation. This is a soft limit due to asynchronous nature of the system and various optimizations for small queries. Default value is 0 which means that concurrency will be automatically set based on the reservation size.
   *
   * @schema ReservationSpecForProvider#concurrency
   */
  readonly concurrency?: number;

  /**
   * If false, any query using this reservation will use idle slots from other reservations within the same admin project. If true, a query using this reservation will execute with the slot capacity specified above at most.
   *
   * @schema ReservationSpecForProvider#ignoreIdleSlots
   */
  readonly ignoreIdleSlots?: boolean;

  /**
   * The geographic location where the transfer config should reside. Examples: US, EU, asia-northeast1. The default value is US.
   *
   * @schema ReservationSpecForProvider#location
   */
  readonly location?: string;

  /**
   * Applicable only for reservations located within one of the BigQuery multi-regions (US or EU). If set to true, this reservation is placed in the organization's secondary region which is designated for disaster recovery purposes. If false, this reservation is placed in the organization's default region.
   *
   * @schema ReservationSpecForProvider#multiRegionAuxiliary
   */
  readonly multiRegionAuxiliary?: boolean;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema ReservationSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Minimum slots available to this reservation. A slot is a unit of computational power in BigQuery, and serves as the unit of parallelism. Queries using this reservation might use more slots during runtime if ignoreIdleSlots is set to false.
   *
   * @schema ReservationSpecForProvider#slotCapacity
   */
  readonly slotCapacity: number;

}

/**
 * Converts an object of type 'ReservationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpecForProvider(obj: ReservationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'concurrency': obj.concurrency,
    'ignoreIdleSlots': obj.ignoreIdleSlots,
    'location': obj.location,
    'multiRegionAuxiliary': obj.multiRegionAuxiliary,
    'project': obj.project,
    'slotCapacity': obj.slotCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReservationSpecProviderConfigRef
 */
export interface ReservationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReservationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReservationSpecProviderConfigRef#policy
   */
  readonly policy?: ReservationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReservationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpecProviderConfigRef(obj: ReservationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReservationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReservationSpecProviderRef
 */
export interface ReservationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReservationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReservationSpecProviderRef#policy
   */
  readonly policy?: ReservationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReservationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpecProviderRef(obj: ReservationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReservationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReservationSpecPublishConnectionDetailsTo
 */
export interface ReservationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReservationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReservationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReservationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReservationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReservationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReservationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpecPublishConnectionDetailsTo(obj: ReservationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReservationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReservationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReservationSpecWriteConnectionSecretToRef
 */
export interface ReservationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReservationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReservationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReservationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpecWriteConnectionSecretToRef(obj: ReservationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReservationSpecProviderConfigRefPolicy
 */
export interface ReservationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReservationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReservationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReservationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReservationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReservationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpecProviderConfigRefPolicy(obj: ReservationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReservationSpecProviderRefPolicy
 */
export interface ReservationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReservationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReservationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReservationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReservationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReservationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpecProviderRefPolicy(obj: ReservationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReservationSpecPublishConnectionDetailsToConfigRef
 */
export interface ReservationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReservationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReservationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReservationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReservationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpecPublishConnectionDetailsToConfigRef(obj: ReservationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReservationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReservationSpecPublishConnectionDetailsToMetadata
 */
export interface ReservationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReservationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReservationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReservationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReservationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpecPublishConnectionDetailsToMetadata(obj: ReservationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReservationSpecProviderConfigRefPolicyResolution
 */
export enum ReservationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReservationSpecProviderConfigRefPolicyResolve
 */
export enum ReservationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReservationSpecProviderRefPolicyResolution
 */
export enum ReservationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReservationSpecProviderRefPolicyResolve
 */
export enum ReservationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReservationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReservationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReservationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReservationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReservationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReservationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReservationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReservationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReservationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReservationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReservationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReservationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReservationAssignment is the Schema for the ReservationAssignments API. The BigqueryReservation Assignment resource
 *
 * @schema ReservationAssignment
 */
export class ReservationAssignment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReservationAssignment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'ReservationAssignment',
  }

  /**
   * Renders a Kubernetes manifest for "ReservationAssignment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReservationAssignmentProps): any {
    return {
      ...ReservationAssignment.GVK,
      ...toJson_ReservationAssignmentProps(props),
    };
  }

  /**
   * Defines a "ReservationAssignment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReservationAssignmentProps) {
    super(scope, id, {
      ...ReservationAssignment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReservationAssignment.GVK,
      ...toJson_ReservationAssignmentProps(resolved),
    };
  }
}

/**
 * ReservationAssignment is the Schema for the ReservationAssignments API. The BigqueryReservation Assignment resource
 *
 * @schema ReservationAssignment
 */
export interface ReservationAssignmentProps {
  /**
   * @schema ReservationAssignment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReservationAssignmentSpec defines the desired state of ReservationAssignment
   *
   * @schema ReservationAssignment#spec
   */
  readonly spec: ReservationAssignmentSpec;

}

/**
 * Converts an object of type 'ReservationAssignmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentProps(obj: ReservationAssignmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReservationAssignmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReservationAssignmentSpec defines the desired state of ReservationAssignment
 *
 * @schema ReservationAssignmentSpec
 */
export interface ReservationAssignmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ReservationAssignmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReservationAssignmentSpecDeletionPolicy;

  /**
   * @schema ReservationAssignmentSpec#forProvider
   */
  readonly forProvider: ReservationAssignmentSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReservationAssignmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReservationAssignmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReservationAssignmentSpec#providerRef
   */
  readonly providerRef?: ReservationAssignmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReservationAssignmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReservationAssignmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReservationAssignmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReservationAssignmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReservationAssignmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpec(obj: ReservationAssignmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReservationAssignmentSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ReservationAssignmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReservationAssignmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReservationAssignmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReservationAssignmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ReservationAssignmentSpecDeletionPolicy
 */
export enum ReservationAssignmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReservationAssignmentSpecForProvider
 */
export interface ReservationAssignmentSpecForProvider {
  /**
   * The resource which will use the reservation. E.g. projects/myproject, folders/123, organizations/456.
   *
   * @schema ReservationAssignmentSpecForProvider#assignee
   */
  readonly assignee: string;

  /**
   * Types of job, which could be specified when using the reservation. Possible values: JOB_TYPE_UNSPECIFIED, PIPELINE, QUERY
   *
   * @schema ReservationAssignmentSpecForProvider#jobType
   */
  readonly jobType: string;

  /**
   * The location for the resource
   *
   * @schema ReservationAssignmentSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The project for the resource
   *
   * @schema ReservationAssignmentSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The reservation for the resource
   *
   * @schema ReservationAssignmentSpecForProvider#reservation
   */
  readonly reservation?: string;

  /**
   * Reference to a Reservation in bigquery to populate reservation.
   *
   * @schema ReservationAssignmentSpecForProvider#reservationRef
   */
  readonly reservationRef?: ReservationAssignmentSpecForProviderReservationRef;

  /**
   * Selector for a Reservation in bigquery to populate reservation.
   *
   * @schema ReservationAssignmentSpecForProvider#reservationSelector
   */
  readonly reservationSelector?: ReservationAssignmentSpecForProviderReservationSelector;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecForProvider(obj: ReservationAssignmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assignee': obj.assignee,
    'jobType': obj.jobType,
    'location': obj.location,
    'project': obj.project,
    'reservation': obj.reservation,
    'reservationRef': toJson_ReservationAssignmentSpecForProviderReservationRef(obj.reservationRef),
    'reservationSelector': toJson_ReservationAssignmentSpecForProviderReservationSelector(obj.reservationSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReservationAssignmentSpecProviderConfigRef
 */
export interface ReservationAssignmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReservationAssignmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReservationAssignmentSpecProviderConfigRef#policy
   */
  readonly policy?: ReservationAssignmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecProviderConfigRef(obj: ReservationAssignmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReservationAssignmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReservationAssignmentSpecProviderRef
 */
export interface ReservationAssignmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReservationAssignmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReservationAssignmentSpecProviderRef#policy
   */
  readonly policy?: ReservationAssignmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecProviderRef(obj: ReservationAssignmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReservationAssignmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReservationAssignmentSpecPublishConnectionDetailsTo
 */
export interface ReservationAssignmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReservationAssignmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReservationAssignmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReservationAssignmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReservationAssignmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReservationAssignmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecPublishConnectionDetailsTo(obj: ReservationAssignmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReservationAssignmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReservationAssignmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReservationAssignmentSpecWriteConnectionSecretToRef
 */
export interface ReservationAssignmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReservationAssignmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReservationAssignmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecWriteConnectionSecretToRef(obj: ReservationAssignmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Reservation in bigquery to populate reservation.
 *
 * @schema ReservationAssignmentSpecForProviderReservationRef
 */
export interface ReservationAssignmentSpecForProviderReservationRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReservationAssignmentSpecForProviderReservationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReservationAssignmentSpecForProviderReservationRef#policy
   */
  readonly policy?: ReservationAssignmentSpecForProviderReservationRefPolicy;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecForProviderReservationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecForProviderReservationRef(obj: ReservationAssignmentSpecForProviderReservationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReservationAssignmentSpecForProviderReservationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Reservation in bigquery to populate reservation.
 *
 * @schema ReservationAssignmentSpecForProviderReservationSelector
 */
export interface ReservationAssignmentSpecForProviderReservationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReservationAssignmentSpecForProviderReservationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReservationAssignmentSpecForProviderReservationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReservationAssignmentSpecForProviderReservationSelector#policy
   */
  readonly policy?: ReservationAssignmentSpecForProviderReservationSelectorPolicy;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecForProviderReservationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecForProviderReservationSelector(obj: ReservationAssignmentSpecForProviderReservationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReservationAssignmentSpecForProviderReservationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReservationAssignmentSpecProviderConfigRefPolicy
 */
export interface ReservationAssignmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReservationAssignmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReservationAssignmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReservationAssignmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReservationAssignmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecProviderConfigRefPolicy(obj: ReservationAssignmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReservationAssignmentSpecProviderRefPolicy
 */
export interface ReservationAssignmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReservationAssignmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReservationAssignmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReservationAssignmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReservationAssignmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecProviderRefPolicy(obj: ReservationAssignmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReservationAssignmentSpecPublishConnectionDetailsToConfigRef
 */
export interface ReservationAssignmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReservationAssignmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReservationAssignmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecPublishConnectionDetailsToConfigRef(obj: ReservationAssignmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReservationAssignmentSpecPublishConnectionDetailsToMetadata
 */
export interface ReservationAssignmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReservationAssignmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReservationAssignmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReservationAssignmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecPublishConnectionDetailsToMetadata(obj: ReservationAssignmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReservationAssignmentSpecForProviderReservationRefPolicy
 */
export interface ReservationAssignmentSpecForProviderReservationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReservationAssignmentSpecForProviderReservationRefPolicy#resolution
   */
  readonly resolution?: ReservationAssignmentSpecForProviderReservationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReservationAssignmentSpecForProviderReservationRefPolicy#resolve
   */
  readonly resolve?: ReservationAssignmentSpecForProviderReservationRefPolicyResolve;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecForProviderReservationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecForProviderReservationRefPolicy(obj: ReservationAssignmentSpecForProviderReservationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReservationAssignmentSpecForProviderReservationSelectorPolicy
 */
export interface ReservationAssignmentSpecForProviderReservationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReservationAssignmentSpecForProviderReservationSelectorPolicy#resolution
   */
  readonly resolution?: ReservationAssignmentSpecForProviderReservationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReservationAssignmentSpecForProviderReservationSelectorPolicy#resolve
   */
  readonly resolve?: ReservationAssignmentSpecForProviderReservationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecForProviderReservationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecForProviderReservationSelectorPolicy(obj: ReservationAssignmentSpecForProviderReservationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReservationAssignmentSpecProviderConfigRefPolicyResolution
 */
export enum ReservationAssignmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReservationAssignmentSpecProviderConfigRefPolicyResolve
 */
export enum ReservationAssignmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReservationAssignmentSpecProviderRefPolicyResolution
 */
export enum ReservationAssignmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReservationAssignmentSpecProviderRefPolicyResolve
 */
export enum ReservationAssignmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReservationAssignmentSpecForProviderReservationRefPolicyResolution
 */
export enum ReservationAssignmentSpecForProviderReservationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReservationAssignmentSpecForProviderReservationRefPolicyResolve
 */
export enum ReservationAssignmentSpecForProviderReservationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReservationAssignmentSpecForProviderReservationSelectorPolicyResolution
 */
export enum ReservationAssignmentSpecForProviderReservationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReservationAssignmentSpecForProviderReservationSelectorPolicyResolve
 */
export enum ReservationAssignmentSpecForProviderReservationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReservationAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Routine is the Schema for the Routines API. A user-defined function or a stored procedure that belongs to a Dataset
 *
 * @schema Routine
 */
export class Routine extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Routine"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'Routine',
  }

  /**
   * Renders a Kubernetes manifest for "Routine".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RoutineProps): any {
    return {
      ...Routine.GVK,
      ...toJson_RoutineProps(props),
    };
  }

  /**
   * Defines a "Routine" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RoutineProps) {
    super(scope, id, {
      ...Routine.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Routine.GVK,
      ...toJson_RoutineProps(resolved),
    };
  }
}

/**
 * Routine is the Schema for the Routines API. A user-defined function or a stored procedure that belongs to a Dataset
 *
 * @schema Routine
 */
export interface RoutineProps {
  /**
   * @schema Routine#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RoutineSpec defines the desired state of Routine
   *
   * @schema Routine#spec
   */
  readonly spec: RoutineSpec;

}

/**
 * Converts an object of type 'RoutineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineProps(obj: RoutineProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RoutineSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoutineSpec defines the desired state of Routine
 *
 * @schema RoutineSpec
 */
export interface RoutineSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RoutineSpec#deletionPolicy
   */
  readonly deletionPolicy?: RoutineSpecDeletionPolicy;

  /**
   * @schema RoutineSpec#forProvider
   */
  readonly forProvider: RoutineSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RoutineSpec#providerConfigRef
   */
  readonly providerConfigRef?: RoutineSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RoutineSpec#providerRef
   */
  readonly providerRef?: RoutineSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RoutineSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RoutineSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RoutineSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RoutineSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RoutineSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpec(obj: RoutineSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RoutineSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RoutineSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RoutineSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RoutineSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RoutineSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RoutineSpecDeletionPolicy
 */
export enum RoutineSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RoutineSpecForProvider
 */
export interface RoutineSpecForProvider {
  /**
   * Input/output argument of a function or a stored procedure. Structure is documented below.
   *
   * @schema RoutineSpecForProvider#arguments
   */
  readonly arguments?: RoutineSpecForProviderArguments[];

  /**
   * The ID of the dataset containing this routine
   *
   * @schema RoutineSpecForProvider#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema RoutineSpecForProvider#datasetIdRef
   */
  readonly datasetIdRef?: RoutineSpecForProviderDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema RoutineSpecForProvider#datasetIdSelector
   */
  readonly datasetIdSelector?: RoutineSpecForProviderDatasetIdSelector;

  /**
   * The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses.
   *
   * @schema RoutineSpecForProvider#definitionBody
   */
  readonly definitionBody: string;

  /**
   * The description of the routine if defined.
   *
   * @schema RoutineSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The determinism level of the JavaScript UDF if defined. Possible values are DETERMINISM_LEVEL_UNSPECIFIED, DETERMINISTIC, and NOT_DETERMINISTIC.
   *
   * @schema RoutineSpecForProvider#determinismLevel
   */
  readonly determinismLevel?: string;

  /**
   * Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
   *
   * @schema RoutineSpecForProvider#importedLibraries
   */
  readonly importedLibraries?: string[];

  /**
   * The language of the routine. Possible values are SQL and JAVASCRIPT.
   *
   * @schema RoutineSpecForProvider#language
   */
  readonly language?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema RoutineSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Optional. Can be set only if routineType = "TABLE_VALUED_FUNCTION". If absent, the return table type is inferred from definitionBody at query time in each query that references this routine. If present, then the columns in the evaluated table result will be cast to match the column types specificed in return table type, at query time.
   *
   * @schema RoutineSpecForProvider#returnTableType
   */
  readonly returnTableType?: string;

  /**
   * A JSON schema for the return type. Optional if language = "SQL"; required otherwise. If absent, the return type is inferred from definitionBody at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. ~>NOTE: Because this field expects a JSON string, any changes to the string will create a diff, even if the JSON itself hasn't changed. If the API returns a different value for the same schema, e.g. it switche d the order of values or replaced STRUCT field type with RECORD field type, we currently cannot suppress the recurring diff this causes. As a workaround, we recommend using the schema as returned by the API.
   *
   * @schema RoutineSpecForProvider#returnType
   */
  readonly returnType?: string;

  /**
   * The type of routine. Possible values are SCALAR_FUNCTION, PROCEDURE, and TABLE_VALUED_FUNCTION.
   *
   * @schema RoutineSpecForProvider#routineType
   */
  readonly routineType?: string;

}

/**
 * Converts an object of type 'RoutineSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecForProvider(obj: RoutineSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arguments': obj.arguments?.map(y => toJson_RoutineSpecForProviderArguments(y)),
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_RoutineSpecForProviderDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_RoutineSpecForProviderDatasetIdSelector(obj.datasetIdSelector),
    'definitionBody': obj.definitionBody,
    'description': obj.description,
    'determinismLevel': obj.determinismLevel,
    'importedLibraries': obj.importedLibraries?.map(y => y),
    'language': obj.language,
    'project': obj.project,
    'returnTableType': obj.returnTableType,
    'returnType': obj.returnType,
    'routineType': obj.routineType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RoutineSpecProviderConfigRef
 */
export interface RoutineSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutineSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutineSpecProviderConfigRef#policy
   */
  readonly policy?: RoutineSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RoutineSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecProviderConfigRef(obj: RoutineSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutineSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RoutineSpecProviderRef
 */
export interface RoutineSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutineSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutineSpecProviderRef#policy
   */
  readonly policy?: RoutineSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RoutineSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecProviderRef(obj: RoutineSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutineSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RoutineSpecPublishConnectionDetailsTo
 */
export interface RoutineSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RoutineSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RoutineSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RoutineSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RoutineSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RoutineSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RoutineSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecPublishConnectionDetailsTo(obj: RoutineSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RoutineSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RoutineSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RoutineSpecWriteConnectionSecretToRef
 */
export interface RoutineSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RoutineSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RoutineSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RoutineSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecWriteConnectionSecretToRef(obj: RoutineSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RoutineSpecForProviderArguments
 */
export interface RoutineSpecForProviderArguments {
  /**
   * Defaults to FIXED_TYPE. Default value is FIXED_TYPE. Possible values are FIXED_TYPE and ANY_TYPE.
   *
   * @default FIXED_TYPE. Default value is FIXED_TYPE. Possible values are FIXED_TYPE and ANY_TYPE.
   * @schema RoutineSpecForProviderArguments#argumentKind
   */
  readonly argumentKind?: string;

  /**
   * A JSON schema for the data type. Required unless argumentKind = ANY_TYPE. ~>NOTE: Because this field expects a JSON string, any changes to the string will create a diff, even if the JSON itself hasn't changed. If the API returns a different value for the same schema, e.g. it switched the order of values or replaced STRUCT field type with RECORD field type, we currently cannot suppress the recurring diff this causes. As a workaround, we recommend using the schema as returned by the API.
   *
   * @schema RoutineSpecForProviderArguments#dataType
   */
  readonly dataType?: string;

  /**
   * Specifies whether the argument is input or output. Can be set for procedures only. Possible values are IN, OUT, and INOUT.
   *
   * @schema RoutineSpecForProviderArguments#mode
   */
  readonly mode?: string;

  /**
   * The name of this argument. Can be absent for function return argument.
   *
   * @schema RoutineSpecForProviderArguments#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RoutineSpecForProviderArguments' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecForProviderArguments(obj: RoutineSpecForProviderArguments | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'argumentKind': obj.argumentKind,
    'dataType': obj.dataType,
    'mode': obj.mode,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema RoutineSpecForProviderDatasetIdRef
 */
export interface RoutineSpecForProviderDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutineSpecForProviderDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutineSpecForProviderDatasetIdRef#policy
   */
  readonly policy?: RoutineSpecForProviderDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'RoutineSpecForProviderDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecForProviderDatasetIdRef(obj: RoutineSpecForProviderDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutineSpecForProviderDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema RoutineSpecForProviderDatasetIdSelector
 */
export interface RoutineSpecForProviderDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RoutineSpecForProviderDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RoutineSpecForProviderDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RoutineSpecForProviderDatasetIdSelector#policy
   */
  readonly policy?: RoutineSpecForProviderDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'RoutineSpecForProviderDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecForProviderDatasetIdSelector(obj: RoutineSpecForProviderDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RoutineSpecForProviderDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutineSpecProviderConfigRefPolicy
 */
export interface RoutineSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutineSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RoutineSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutineSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RoutineSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutineSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecProviderConfigRefPolicy(obj: RoutineSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutineSpecProviderRefPolicy
 */
export interface RoutineSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutineSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RoutineSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutineSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RoutineSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutineSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecProviderRefPolicy(obj: RoutineSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RoutineSpecPublishConnectionDetailsToConfigRef
 */
export interface RoutineSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutineSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutineSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RoutineSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RoutineSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecPublishConnectionDetailsToConfigRef(obj: RoutineSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutineSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RoutineSpecPublishConnectionDetailsToMetadata
 */
export interface RoutineSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RoutineSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RoutineSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RoutineSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RoutineSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecPublishConnectionDetailsToMetadata(obj: RoutineSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutineSpecForProviderDatasetIdRefPolicy
 */
export interface RoutineSpecForProviderDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutineSpecForProviderDatasetIdRefPolicy#resolution
   */
  readonly resolution?: RoutineSpecForProviderDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutineSpecForProviderDatasetIdRefPolicy#resolve
   */
  readonly resolve?: RoutineSpecForProviderDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutineSpecForProviderDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecForProviderDatasetIdRefPolicy(obj: RoutineSpecForProviderDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RoutineSpecForProviderDatasetIdSelectorPolicy
 */
export interface RoutineSpecForProviderDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutineSpecForProviderDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: RoutineSpecForProviderDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutineSpecForProviderDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: RoutineSpecForProviderDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RoutineSpecForProviderDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecForProviderDatasetIdSelectorPolicy(obj: RoutineSpecForProviderDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutineSpecProviderConfigRefPolicyResolution
 */
export enum RoutineSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutineSpecProviderConfigRefPolicyResolve
 */
export enum RoutineSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutineSpecProviderRefPolicyResolution
 */
export enum RoutineSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutineSpecProviderRefPolicyResolve
 */
export enum RoutineSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RoutineSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RoutineSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutineSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RoutineSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutineSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RoutineSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutineSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutineSpecPublishConnectionDetailsToConfigRefPolicy(obj: RoutineSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutineSpecForProviderDatasetIdRefPolicyResolution
 */
export enum RoutineSpecForProviderDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutineSpecForProviderDatasetIdRefPolicyResolve
 */
export enum RoutineSpecForProviderDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutineSpecForProviderDatasetIdSelectorPolicyResolution
 */
export enum RoutineSpecForProviderDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutineSpecForProviderDatasetIdSelectorPolicyResolve
 */
export enum RoutineSpecForProviderDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutineSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RoutineSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutineSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RoutineSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Table is the Schema for the Tables API. Creates a table resource in a dataset for Google BigQuery.
 *
 * @schema Table
 */
export class Table extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Table"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'Table',
  }

  /**
   * Renders a Kubernetes manifest for "Table".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TableProps): any {
    return {
      ...Table.GVK,
      ...toJson_TableProps(props),
    };
  }

  /**
   * Defines a "Table" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TableProps) {
    super(scope, id, {
      ...Table.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Table.GVK,
      ...toJson_TableProps(resolved),
    };
  }
}

/**
 * Table is the Schema for the Tables API. Creates a table resource in a dataset for Google BigQuery.
 *
 * @schema Table
 */
export interface TableProps {
  /**
   * @schema Table#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TableSpec defines the desired state of Table
   *
   * @schema Table#spec
   */
  readonly spec: TableSpec;

}

/**
 * Converts an object of type 'TableProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableProps(obj: TableProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TableSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableSpec defines the desired state of Table
 *
 * @schema TableSpec
 */
export interface TableSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TableSpec#deletionPolicy
   */
  readonly deletionPolicy?: TableSpecDeletionPolicy;

  /**
   * @schema TableSpec#forProvider
   */
  readonly forProvider: TableSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TableSpec#providerConfigRef
   */
  readonly providerConfigRef?: TableSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TableSpec#providerRef
   */
  readonly providerRef?: TableSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TableSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TableSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TableSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TableSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TableSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpec(obj: TableSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TableSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TableSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TableSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TableSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TableSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TableSpecDeletionPolicy
 */
export enum TableSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TableSpecForProvider
 */
export interface TableSpecForProvider {
  /**
   * Specifies column names to use for data clustering. Up to four top-level columns are allowed, and should be specified in descending priority order.
   *
   * @schema TableSpecForProvider#clustering
   */
  readonly clustering?: string[];

  /**
   * The dataset ID to create the table in. Changing this forces a new resource to be created.
   *
   * @schema TableSpecForProvider#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema TableSpecForProvider#datasetIdRef
   */
  readonly datasetIdRef?: TableSpecForProviderDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema TableSpecForProvider#datasetIdSelector
   */
  readonly datasetIdSelector?: TableSpecForProviderDatasetIdSelector;

  /**
   * @schema TableSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * The field description.
   *
   * @schema TableSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies how the table should be encrypted. If left blank, the table will be encrypted with a Google-managed key; that process is transparent to the user.  Structure is documented below.
   *
   * @schema TableSpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: TableSpecForProviderEncryptionConfiguration[];

  /**
   * The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed.
   *
   * @schema TableSpecForProvider#expirationTime
   */
  readonly expirationTime?: number;

  /**
   * Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table. Structure is documented below.
   *
   * @schema TableSpecForProvider#externalDataConfiguration
   */
  readonly externalDataConfiguration?: TableSpecForProviderExternalDataConfiguration[];

  /**
   * A descriptive name for the table.
   *
   * @schema TableSpecForProvider#friendlyName
   */
  readonly friendlyName?: string;

  /**
   * A mapping of labels to assign to the resource.
   *
   * @schema TableSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * If specified, configures this table as a materialized view. Structure is documented below.
   *
   * @schema TableSpecForProvider#materializedView
   */
  readonly materializedView?: TableSpecForProviderMaterializedView[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema TableSpecForProvider#project
   */
  readonly project?: string;

  /**
   * If specified, configures range-based partitioning for this table. Structure is documented below.
   *
   * @schema TableSpecForProvider#rangePartitioning
   */
  readonly rangePartitioning?: TableSpecForProviderRangePartitioning[];

  /**
   * A JSON schema for the table.
   *
   * @schema TableSpecForProvider#schema
   */
  readonly schema?: string;

  /**
   * If specified, configures time-based partitioning for this table. Structure is documented below.
   *
   * @schema TableSpecForProvider#timePartitioning
   */
  readonly timePartitioning?: TableSpecForProviderTimePartitioning[];

  /**
   * If specified, configures this table as a view. Structure is documented below.
   *
   * @schema TableSpecForProvider#view
   */
  readonly view?: TableSpecForProviderView[];

}

/**
 * Converts an object of type 'TableSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProvider(obj: TableSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clustering': obj.clustering?.map(y => y),
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_TableSpecForProviderDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_TableSpecForProviderDatasetIdSelector(obj.datasetIdSelector),
    'deletionProtection': obj.deletionProtection,
    'description': obj.description,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_TableSpecForProviderEncryptionConfiguration(y)),
    'expirationTime': obj.expirationTime,
    'externalDataConfiguration': obj.externalDataConfiguration?.map(y => toJson_TableSpecForProviderExternalDataConfiguration(y)),
    'friendlyName': obj.friendlyName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'materializedView': obj.materializedView?.map(y => toJson_TableSpecForProviderMaterializedView(y)),
    'project': obj.project,
    'rangePartitioning': obj.rangePartitioning?.map(y => toJson_TableSpecForProviderRangePartitioning(y)),
    'schema': obj.schema,
    'timePartitioning': obj.timePartitioning?.map(y => toJson_TableSpecForProviderTimePartitioning(y)),
    'view': obj.view?.map(y => toJson_TableSpecForProviderView(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TableSpecProviderConfigRef
 */
export interface TableSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecProviderConfigRef#policy
   */
  readonly policy?: TableSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TableSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderConfigRef(obj: TableSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TableSpecProviderRef
 */
export interface TableSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecProviderRef#policy
   */
  readonly policy?: TableSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TableSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderRef(obj: TableSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TableSpecPublishConnectionDetailsTo
 */
export interface TableSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TableSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TableSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsTo(obj: TableSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TableSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TableSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TableSpecWriteConnectionSecretToRef
 */
export interface TableSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TableSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TableSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TableSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecWriteConnectionSecretToRef(obj: TableSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema TableSpecForProviderDatasetIdRef
 */
export interface TableSpecForProviderDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecForProviderDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecForProviderDatasetIdRef#policy
   */
  readonly policy?: TableSpecForProviderDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'TableSpecForProviderDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderDatasetIdRef(obj: TableSpecForProviderDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecForProviderDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema TableSpecForProviderDatasetIdSelector
 */
export interface TableSpecForProviderDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableSpecForProviderDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableSpecForProviderDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableSpecForProviderDatasetIdSelector#policy
   */
  readonly policy?: TableSpecForProviderDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'TableSpecForProviderDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderDatasetIdSelector(obj: TableSpecForProviderDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableSpecForProviderDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderEncryptionConfiguration
 */
export interface TableSpecForProviderEncryptionConfiguration {
  /**
   * The self link or full name of a key which should be used to encrypt this table.  Note that the default bigquery service account will need to have encrypt/decrypt permissions on this key - you may want to see the google_bigquery_default_service_account datasource and the google_kms_crypto_key_iam_binding resource.
   *
   * @schema TableSpecForProviderEncryptionConfiguration#kmsKeyName
   */
  readonly kmsKeyName: string;

}

/**
 * Converts an object of type 'TableSpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderEncryptionConfiguration(obj: TableSpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderExternalDataConfiguration
 */
export interface TableSpecForProviderExternalDataConfiguration {
  /**
   * - Let BigQuery try to autodetect the schema and format of the table.
   *
   * @schema TableSpecForProviderExternalDataConfiguration#autodetect
   */
  readonly autodetect: boolean;

  /**
   * Additional options if source_format is set to "AVRO".  Structure is documented below.
   *
   * @schema TableSpecForProviderExternalDataConfiguration#avroOptions
   */
  readonly avroOptions?: TableSpecForProviderExternalDataConfigurationAvroOptions[];

  /**
   * The compression type of the data source. Valid values are "NONE" or "GZIP".
   *
   * @schema TableSpecForProviderExternalDataConfiguration#compression
   */
  readonly compression?: string;

  /**
   * The connection specifying the credentials to be used to read external storage, such as Azure Blob, Cloud Storage, or S3. The connection_id can have the form {{project}}.{{location}}.{{connection_id}} or projects/{{project}}/locations/{{location}}/connections/{{connection_id}}.
   *
   * @schema TableSpecForProviderExternalDataConfiguration#connectionId
   */
  readonly connectionId?: string;

  /**
   * Additional properties to set if source_format is set to "CSV". Structure is documented below.
   *
   * @schema TableSpecForProviderExternalDataConfiguration#csvOptions
   */
  readonly csvOptions?: TableSpecForProviderExternalDataConfigurationCsvOptions[];

  /**
   * Additional options if source_format is set to "GOOGLE_SHEETS". Structure is documented below.
   *
   * @schema TableSpecForProviderExternalDataConfiguration#googleSheetsOptions
   */
  readonly googleSheetsOptions?: TableSpecForProviderExternalDataConfigurationGoogleSheetsOptions[];

  /**
   * When set, configures hive partitioning support. Not all storage formats support hive partitioning -- requesting hive partitioning on an unsupported format will lead to an error, as will providing an invalid specification. Structure is documented below.
   *
   * @schema TableSpecForProviderExternalDataConfiguration#hivePartitioningOptions
   */
  readonly hivePartitioningOptions?: TableSpecForProviderExternalDataConfigurationHivePartitioningOptions[];

  /**
   * Indicates if BigQuery should allow extra values that are not represented in the table schema. If true, the extra values are ignored. If false, records with extra columns are treated as bad records, and if there are too many bad records, an invalid error is returned in the job result. The default value is false.
   *
   * @schema TableSpecForProviderExternalDataConfiguration#ignoreUnknownValues
   */
  readonly ignoreUnknownValues?: boolean;

  /**
   * The maximum number of bad records that BigQuery can ignore when reading data.
   *
   * @schema TableSpecForProviderExternalDataConfiguration#maxBadRecords
   */
  readonly maxBadRecords?: number;

  /**
   * When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
   *
   * @schema TableSpecForProviderExternalDataConfiguration#referenceFileSchemaUri
   */
  readonly referenceFileSchemaUri?: string;

  /**
   * A JSON schema for the external table. Schema is required for CSV and JSON formats if autodetect is not on. Schema is disallowed for Google Cloud Bigtable, Cloud Datastore backups, Avro, ORC and Parquet formats. ~>NOTE: Because this field expects a JSON string, any changes to the string will create a diff, even if the JSON itself hasn't changed. Furthermore drift for this field cannot not be detected because BigQuery only uses this schema to compute the effective schema for the table, therefore any changes on the configured value will force the table to be recreated. This schema is effectively only applied when creating a table from an external datasource, after creation the computed schema will be stored in google_bigquery_table.schema
   *
   * @schema TableSpecForProviderExternalDataConfiguration#schema
   */
  readonly schema?: string;

  /**
   * The data format. Supported values are: "CSV", "GOOGLE_SHEETS", "NEWLINE_DELIMITED_JSON", "AVRO", "PARQUET", "ORC", "DATSTORE_BACKUP", and "BIGTABLE". To use "GOOGLE_SHEETS" the scopes must include "https://www.googleapis.com/auth/drive.readonly".
   *
   * @schema TableSpecForProviderExternalDataConfiguration#sourceFormat
   */
  readonly sourceFormat: string;

  /**
   * A list of the fully-qualified URIs that point to your data in Google Cloud.
   *
   * @schema TableSpecForProviderExternalDataConfiguration#sourceUris
   */
  readonly sourceUris: string[];

}

/**
 * Converts an object of type 'TableSpecForProviderExternalDataConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderExternalDataConfiguration(obj: TableSpecForProviderExternalDataConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autodetect': obj.autodetect,
    'avroOptions': obj.avroOptions?.map(y => toJson_TableSpecForProviderExternalDataConfigurationAvroOptions(y)),
    'compression': obj.compression,
    'connectionId': obj.connectionId,
    'csvOptions': obj.csvOptions?.map(y => toJson_TableSpecForProviderExternalDataConfigurationCsvOptions(y)),
    'googleSheetsOptions': obj.googleSheetsOptions?.map(y => toJson_TableSpecForProviderExternalDataConfigurationGoogleSheetsOptions(y)),
    'hivePartitioningOptions': obj.hivePartitioningOptions?.map(y => toJson_TableSpecForProviderExternalDataConfigurationHivePartitioningOptions(y)),
    'ignoreUnknownValues': obj.ignoreUnknownValues,
    'maxBadRecords': obj.maxBadRecords,
    'referenceFileSchemaUri': obj.referenceFileSchemaUri,
    'schema': obj.schema,
    'sourceFormat': obj.sourceFormat,
    'sourceUris': obj.sourceUris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderMaterializedView
 */
export interface TableSpecForProviderMaterializedView {
  /**
   * Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated. The default value is true.
   *
   * @schema TableSpecForProviderMaterializedView#enableRefresh
   */
  readonly enableRefresh?: boolean;

  /**
   * A query whose result is persisted.
   *
   * @schema TableSpecForProviderMaterializedView#query
   */
  readonly query: string;

  /**
   * The maximum frequency at which this materialized view will be refreshed. The default value is 1800000
   *
   * @schema TableSpecForProviderMaterializedView#refreshIntervalMs
   */
  readonly refreshIntervalMs?: number;

}

/**
 * Converts an object of type 'TableSpecForProviderMaterializedView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderMaterializedView(obj: TableSpecForProviderMaterializedView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableRefresh': obj.enableRefresh,
    'query': obj.query,
    'refreshIntervalMs': obj.refreshIntervalMs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderRangePartitioning
 */
export interface TableSpecForProviderRangePartitioning {
  /**
   * The field used to determine how to create a range-based partition.
   *
   * @schema TableSpecForProviderRangePartitioning#field
   */
  readonly field: string;

  /**
   * Information required to partition based on ranges. Structure is documented below.
   *
   * @schema TableSpecForProviderRangePartitioning#range
   */
  readonly range: TableSpecForProviderRangePartitioningRange[];

}

/**
 * Converts an object of type 'TableSpecForProviderRangePartitioning' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderRangePartitioning(obj: TableSpecForProviderRangePartitioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
    'range': obj.range?.map(y => toJson_TableSpecForProviderRangePartitioningRange(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderTimePartitioning
 */
export interface TableSpecForProviderTimePartitioning {
  /**
   * Number of milliseconds for which to keep the storage for a partition.
   *
   * @schema TableSpecForProviderTimePartitioning#expirationMs
   */
  readonly expirationMs?: number;

  /**
   * The field used to determine how to create a time-based partition. If time-based partitioning is enabled without this value, the table is partitioned based on the load time.
   *
   * @schema TableSpecForProviderTimePartitioning#field
   */
  readonly field?: string;

  /**
   * If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
   *
   * @schema TableSpecForProviderTimePartitioning#requirePartitionFilter
   */
  readonly requirePartitionFilter?: boolean;

  /**
   * The supported types are DAY, HOUR, MONTH, and YEAR, which will generate one partition per day, hour, month, and year, respectively.
   *
   * @schema TableSpecForProviderTimePartitioning#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TableSpecForProviderTimePartitioning' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderTimePartitioning(obj: TableSpecForProviderTimePartitioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expirationMs': obj.expirationMs,
    'field': obj.field,
    'requirePartitionFilter': obj.requirePartitionFilter,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderView
 */
export interface TableSpecForProviderView {
  /**
   * A query that BigQuery executes when the view is referenced.
   *
   * @schema TableSpecForProviderView#query
   */
  readonly query: string;

  /**
   * Specifies whether to use BigQuery's legacy SQL for this view. The default value is true. If set to false, the view will use BigQuery's standard SQL.
   *
   * @schema TableSpecForProviderView#useLegacySql
   */
  readonly useLegacySql?: boolean;

}

/**
 * Converts an object of type 'TableSpecForProviderView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderView(obj: TableSpecForProviderView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'query': obj.query,
    'useLegacySql': obj.useLegacySql,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableSpecProviderConfigRefPolicy
 */
export interface TableSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TableSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TableSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderConfigRefPolicy(obj: TableSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableSpecProviderRefPolicy
 */
export interface TableSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TableSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TableSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderRefPolicy(obj: TableSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRef
 */
export interface TableSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TableSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToConfigRef(obj: TableSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TableSpecPublishConnectionDetailsToMetadata
 */
export interface TableSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToMetadata(obj: TableSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableSpecForProviderDatasetIdRefPolicy
 */
export interface TableSpecForProviderDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecForProviderDatasetIdRefPolicy#resolution
   */
  readonly resolution?: TableSpecForProviderDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecForProviderDatasetIdRefPolicy#resolve
   */
  readonly resolve?: TableSpecForProviderDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecForProviderDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderDatasetIdRefPolicy(obj: TableSpecForProviderDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableSpecForProviderDatasetIdSelectorPolicy
 */
export interface TableSpecForProviderDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecForProviderDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: TableSpecForProviderDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecForProviderDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: TableSpecForProviderDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecForProviderDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderDatasetIdSelectorPolicy(obj: TableSpecForProviderDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderExternalDataConfigurationAvroOptions
 */
export interface TableSpecForProviderExternalDataConfigurationAvroOptions {
  /**
   * If is set to true, indicates whether to interpret logical types as the corresponding BigQuery data type (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
   *
   * @schema TableSpecForProviderExternalDataConfigurationAvroOptions#useAvroLogicalTypes
   */
  readonly useAvroLogicalTypes: boolean;

}

/**
 * Converts an object of type 'TableSpecForProviderExternalDataConfigurationAvroOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderExternalDataConfigurationAvroOptions(obj: TableSpecForProviderExternalDataConfigurationAvroOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'useAvroLogicalTypes': obj.useAvroLogicalTypes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderExternalDataConfigurationCsvOptions
 */
export interface TableSpecForProviderExternalDataConfigurationCsvOptions {
  /**
   * Indicates if BigQuery should accept rows that are missing trailing optional columns.
   *
   * @schema TableSpecForProviderExternalDataConfigurationCsvOptions#allowJaggedRows
   */
  readonly allowJaggedRows?: boolean;

  /**
   * Indicates if BigQuery should allow quoted data sections that contain newline characters in a CSV file. The default value is false.
   *
   * @schema TableSpecForProviderExternalDataConfigurationCsvOptions#allowQuotedNewlines
   */
  readonly allowQuotedNewlines?: boolean;

  /**
   * The character encoding of the data. The supported values are UTF-8 or ISO-8859-1.
   *
   * @schema TableSpecForProviderExternalDataConfigurationCsvOptions#encoding
   */
  readonly encoding?: string;

  /**
   * The separator for fields in a CSV file.
   *
   * @schema TableSpecForProviderExternalDataConfigurationCsvOptions#fieldDelimiter
   */
  readonly fieldDelimiter?: string;

  /**
   * The value that is used to quote data sections in a CSV file. If your data does not contain quoted sections, set the property value to an empty string. If your data contains quoted newline characters, you must also set the allow_quoted_newlines property to true.
   *
   * @schema TableSpecForProviderExternalDataConfigurationCsvOptions#quote
   */
  readonly quote: string;

  /**
   * The number of rows at the top of the sheet that BigQuery will skip when reading the data. At least one of range or skip_leading_rows must be set.
   *
   * @schema TableSpecForProviderExternalDataConfigurationCsvOptions#skipLeadingRows
   */
  readonly skipLeadingRows?: number;

}

/**
 * Converts an object of type 'TableSpecForProviderExternalDataConfigurationCsvOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderExternalDataConfigurationCsvOptions(obj: TableSpecForProviderExternalDataConfigurationCsvOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowJaggedRows': obj.allowJaggedRows,
    'allowQuotedNewlines': obj.allowQuotedNewlines,
    'encoding': obj.encoding,
    'fieldDelimiter': obj.fieldDelimiter,
    'quote': obj.quote,
    'skipLeadingRows': obj.skipLeadingRows,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderExternalDataConfigurationGoogleSheetsOptions
 */
export interface TableSpecForProviderExternalDataConfigurationGoogleSheetsOptions {
  /**
   * Information required to partition based on ranges. Structure is documented below.
   *
   * @schema TableSpecForProviderExternalDataConfigurationGoogleSheetsOptions#range
   */
  readonly range?: string;

  /**
   * The number of rows at the top of the sheet that BigQuery will skip when reading the data. At least one of range or skip_leading_rows must be set.
   *
   * @schema TableSpecForProviderExternalDataConfigurationGoogleSheetsOptions#skipLeadingRows
   */
  readonly skipLeadingRows?: number;

}

/**
 * Converts an object of type 'TableSpecForProviderExternalDataConfigurationGoogleSheetsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderExternalDataConfigurationGoogleSheetsOptions(obj: TableSpecForProviderExternalDataConfigurationGoogleSheetsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'range': obj.range,
    'skipLeadingRows': obj.skipLeadingRows,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderExternalDataConfigurationHivePartitioningOptions
 */
export interface TableSpecForProviderExternalDataConfigurationHivePartitioningOptions {
  /**
   * When set, what mode of hive partitioning to use when reading data. The following modes are supported.
   *
   * @schema TableSpecForProviderExternalDataConfigurationHivePartitioningOptions#mode
   */
  readonly mode?: string;

  /**
   * If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
   *
   * @schema TableSpecForProviderExternalDataConfigurationHivePartitioningOptions#requirePartitionFilter
   */
  readonly requirePartitionFilter?: boolean;

  /**
   * When hive partition detection is requested, a common for all source uris must be required. The prefix must end immediately before the partition key encoding begins. For example, consider files following this data layout. gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro When hive partitioning is requested with either AUTO or STRINGS detection, the common prefix can be either of gs://bucket/path_to_table or gs://bucket/path_to_table/. Note that when mode is set to CUSTOM, you must encode the partition key schema within the source_uri_prefix by setting source_uri_prefix to gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}.
   *
   * @schema TableSpecForProviderExternalDataConfigurationHivePartitioningOptions#sourceUriPrefix
   */
  readonly sourceUriPrefix?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderExternalDataConfigurationHivePartitioningOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderExternalDataConfigurationHivePartitioningOptions(obj: TableSpecForProviderExternalDataConfigurationHivePartitioningOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'requirePartitionFilter': obj.requirePartitionFilter,
    'sourceUriPrefix': obj.sourceUriPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderRangePartitioningRange
 */
export interface TableSpecForProviderRangePartitioningRange {
  /**
   * End of the range partitioning, exclusive.
   *
   * @schema TableSpecForProviderRangePartitioningRange#end
   */
  readonly end: number;

  /**
   * The width of each range within the partition.
   *
   * @schema TableSpecForProviderRangePartitioningRange#interval
   */
  readonly interval: number;

  /**
   * Start of the range partitioning, inclusive.
   *
   * @schema TableSpecForProviderRangePartitioningRange#start
   */
  readonly start: number;

}

/**
 * Converts an object of type 'TableSpecForProviderRangePartitioningRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderRangePartitioningRange(obj: TableSpecForProviderRangePartitioningRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'interval': obj.interval,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecProviderConfigRefPolicyResolution
 */
export enum TableSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecProviderConfigRefPolicyResolve
 */
export enum TableSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecProviderRefPolicyResolution
 */
export enum TableSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecProviderRefPolicyResolve
 */
export enum TableSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TableSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TableSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TableSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToConfigRefPolicy(obj: TableSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecForProviderDatasetIdRefPolicyResolution
 */
export enum TableSpecForProviderDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecForProviderDatasetIdRefPolicyResolve
 */
export enum TableSpecForProviderDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecForProviderDatasetIdSelectorPolicyResolution
 */
export enum TableSpecForProviderDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecForProviderDatasetIdSelectorPolicyResolve
 */
export enum TableSpecForProviderDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TableSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TableSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TableIAMBinding is the Schema for the TableIAMBindings API. <no value>
 *
 * @schema TableIAMBinding
 */
export class TableIamBinding extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TableIAMBinding"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'TableIAMBinding',
  }

  /**
   * Renders a Kubernetes manifest for "TableIAMBinding".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TableIamBindingProps): any {
    return {
      ...TableIamBinding.GVK,
      ...toJson_TableIamBindingProps(props),
    };
  }

  /**
   * Defines a "TableIAMBinding" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TableIamBindingProps) {
    super(scope, id, {
      ...TableIamBinding.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TableIamBinding.GVK,
      ...toJson_TableIamBindingProps(resolved),
    };
  }
}

/**
 * TableIAMBinding is the Schema for the TableIAMBindings API. <no value>
 *
 * @schema TableIAMBinding
 */
export interface TableIamBindingProps {
  /**
   * @schema TableIAMBinding#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TableIAMBindingSpec defines the desired state of TableIAMBinding
   *
   * @schema TableIAMBinding#spec
   */
  readonly spec: TableIamBindingSpec;

}

/**
 * Converts an object of type 'TableIamBindingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingProps(obj: TableIamBindingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TableIamBindingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableIAMBindingSpec defines the desired state of TableIAMBinding
 *
 * @schema TableIamBindingSpec
 */
export interface TableIamBindingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TableIamBindingSpec#deletionPolicy
   */
  readonly deletionPolicy?: TableIamBindingSpecDeletionPolicy;

  /**
   * @schema TableIamBindingSpec#forProvider
   */
  readonly forProvider: TableIamBindingSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TableIamBindingSpec#providerConfigRef
   */
  readonly providerConfigRef?: TableIamBindingSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TableIamBindingSpec#providerRef
   */
  readonly providerRef?: TableIamBindingSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TableIamBindingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TableIamBindingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TableIamBindingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TableIamBindingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TableIamBindingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpec(obj: TableIamBindingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TableIamBindingSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TableIamBindingSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TableIamBindingSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TableIamBindingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TableIamBindingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TableIamBindingSpecDeletionPolicy
 */
export enum TableIamBindingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TableIamBindingSpecForProvider
 */
export interface TableIamBindingSpecForProvider {
  /**
   * @schema TableIamBindingSpecForProvider#condition
   */
  readonly condition?: TableIamBindingSpecForProviderCondition[];

  /**
   * @schema TableIamBindingSpecForProvider#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema TableIamBindingSpecForProvider#datasetIdRef
   */
  readonly datasetIdRef?: TableIamBindingSpecForProviderDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema TableIamBindingSpecForProvider#datasetIdSelector
   */
  readonly datasetIdSelector?: TableIamBindingSpecForProviderDatasetIdSelector;

  /**
   * @schema TableIamBindingSpecForProvider#members
   */
  readonly members: string[];

  /**
   * @schema TableIamBindingSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema TableIamBindingSpecForProvider#role
   */
  readonly role: string;

  /**
   * @schema TableIamBindingSpecForProvider#tableId
   */
  readonly tableId?: string;

  /**
   * Reference to a Table in bigquery to populate tableId.
   *
   * @schema TableIamBindingSpecForProvider#tableIdRef
   */
  readonly tableIdRef?: TableIamBindingSpecForProviderTableIdRef;

  /**
   * Selector for a Table in bigquery to populate tableId.
   *
   * @schema TableIamBindingSpecForProvider#tableIdSelector
   */
  readonly tableIdSelector?: TableIamBindingSpecForProviderTableIdSelector;

}

/**
 * Converts an object of type 'TableIamBindingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecForProvider(obj: TableIamBindingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_TableIamBindingSpecForProviderCondition(y)),
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_TableIamBindingSpecForProviderDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_TableIamBindingSpecForProviderDatasetIdSelector(obj.datasetIdSelector),
    'members': obj.members?.map(y => y),
    'project': obj.project,
    'role': obj.role,
    'tableId': obj.tableId,
    'tableIdRef': toJson_TableIamBindingSpecForProviderTableIdRef(obj.tableIdRef),
    'tableIdSelector': toJson_TableIamBindingSpecForProviderTableIdSelector(obj.tableIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TableIamBindingSpecProviderConfigRef
 */
export interface TableIamBindingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamBindingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamBindingSpecProviderConfigRef#policy
   */
  readonly policy?: TableIamBindingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TableIamBindingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecProviderConfigRef(obj: TableIamBindingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamBindingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TableIamBindingSpecProviderRef
 */
export interface TableIamBindingSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamBindingSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamBindingSpecProviderRef#policy
   */
  readonly policy?: TableIamBindingSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TableIamBindingSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecProviderRef(obj: TableIamBindingSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamBindingSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TableIamBindingSpecPublishConnectionDetailsTo
 */
export interface TableIamBindingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TableIamBindingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TableIamBindingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TableIamBindingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TableIamBindingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TableIamBindingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TableIamBindingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecPublishConnectionDetailsTo(obj: TableIamBindingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TableIamBindingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TableIamBindingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TableIamBindingSpecWriteConnectionSecretToRef
 */
export interface TableIamBindingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TableIamBindingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TableIamBindingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TableIamBindingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecWriteConnectionSecretToRef(obj: TableIamBindingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableIamBindingSpecForProviderCondition
 */
export interface TableIamBindingSpecForProviderCondition {
  /**
   * @schema TableIamBindingSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema TableIamBindingSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema TableIamBindingSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'TableIamBindingSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecForProviderCondition(obj: TableIamBindingSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema TableIamBindingSpecForProviderDatasetIdRef
 */
export interface TableIamBindingSpecForProviderDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamBindingSpecForProviderDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamBindingSpecForProviderDatasetIdRef#policy
   */
  readonly policy?: TableIamBindingSpecForProviderDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'TableIamBindingSpecForProviderDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecForProviderDatasetIdRef(obj: TableIamBindingSpecForProviderDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamBindingSpecForProviderDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema TableIamBindingSpecForProviderDatasetIdSelector
 */
export interface TableIamBindingSpecForProviderDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableIamBindingSpecForProviderDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableIamBindingSpecForProviderDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableIamBindingSpecForProviderDatasetIdSelector#policy
   */
  readonly policy?: TableIamBindingSpecForProviderDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'TableIamBindingSpecForProviderDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecForProviderDatasetIdSelector(obj: TableIamBindingSpecForProviderDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableIamBindingSpecForProviderDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in bigquery to populate tableId.
 *
 * @schema TableIamBindingSpecForProviderTableIdRef
 */
export interface TableIamBindingSpecForProviderTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamBindingSpecForProviderTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamBindingSpecForProviderTableIdRef#policy
   */
  readonly policy?: TableIamBindingSpecForProviderTableIdRefPolicy;

}

/**
 * Converts an object of type 'TableIamBindingSpecForProviderTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecForProviderTableIdRef(obj: TableIamBindingSpecForProviderTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamBindingSpecForProviderTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in bigquery to populate tableId.
 *
 * @schema TableIamBindingSpecForProviderTableIdSelector
 */
export interface TableIamBindingSpecForProviderTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableIamBindingSpecForProviderTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableIamBindingSpecForProviderTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableIamBindingSpecForProviderTableIdSelector#policy
   */
  readonly policy?: TableIamBindingSpecForProviderTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'TableIamBindingSpecForProviderTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecForProviderTableIdSelector(obj: TableIamBindingSpecForProviderTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableIamBindingSpecForProviderTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamBindingSpecProviderConfigRefPolicy
 */
export interface TableIamBindingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamBindingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TableIamBindingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamBindingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TableIamBindingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamBindingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecProviderConfigRefPolicy(obj: TableIamBindingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamBindingSpecProviderRefPolicy
 */
export interface TableIamBindingSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamBindingSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TableIamBindingSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamBindingSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TableIamBindingSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamBindingSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecProviderRefPolicy(obj: TableIamBindingSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TableIamBindingSpecPublishConnectionDetailsToConfigRef
 */
export interface TableIamBindingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamBindingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamBindingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TableIamBindingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecPublishConnectionDetailsToConfigRef(obj: TableIamBindingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TableIamBindingSpecPublishConnectionDetailsToMetadata
 */
export interface TableIamBindingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableIamBindingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableIamBindingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TableIamBindingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TableIamBindingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecPublishConnectionDetailsToMetadata(obj: TableIamBindingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamBindingSpecForProviderDatasetIdRefPolicy
 */
export interface TableIamBindingSpecForProviderDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamBindingSpecForProviderDatasetIdRefPolicy#resolution
   */
  readonly resolution?: TableIamBindingSpecForProviderDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamBindingSpecForProviderDatasetIdRefPolicy#resolve
   */
  readonly resolve?: TableIamBindingSpecForProviderDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamBindingSpecForProviderDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecForProviderDatasetIdRefPolicy(obj: TableIamBindingSpecForProviderDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableIamBindingSpecForProviderDatasetIdSelectorPolicy
 */
export interface TableIamBindingSpecForProviderDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamBindingSpecForProviderDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: TableIamBindingSpecForProviderDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamBindingSpecForProviderDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: TableIamBindingSpecForProviderDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableIamBindingSpecForProviderDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecForProviderDatasetIdSelectorPolicy(obj: TableIamBindingSpecForProviderDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamBindingSpecForProviderTableIdRefPolicy
 */
export interface TableIamBindingSpecForProviderTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamBindingSpecForProviderTableIdRefPolicy#resolution
   */
  readonly resolution?: TableIamBindingSpecForProviderTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamBindingSpecForProviderTableIdRefPolicy#resolve
   */
  readonly resolve?: TableIamBindingSpecForProviderTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamBindingSpecForProviderTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecForProviderTableIdRefPolicy(obj: TableIamBindingSpecForProviderTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableIamBindingSpecForProviderTableIdSelectorPolicy
 */
export interface TableIamBindingSpecForProviderTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamBindingSpecForProviderTableIdSelectorPolicy#resolution
   */
  readonly resolution?: TableIamBindingSpecForProviderTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamBindingSpecForProviderTableIdSelectorPolicy#resolve
   */
  readonly resolve?: TableIamBindingSpecForProviderTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableIamBindingSpecForProviderTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecForProviderTableIdSelectorPolicy(obj: TableIamBindingSpecForProviderTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamBindingSpecProviderConfigRefPolicyResolution
 */
export enum TableIamBindingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamBindingSpecProviderConfigRefPolicyResolve
 */
export enum TableIamBindingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamBindingSpecProviderRefPolicyResolution
 */
export enum TableIamBindingSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamBindingSpecProviderRefPolicyResolve
 */
export enum TableIamBindingSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicy(obj: TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamBindingSpecForProviderDatasetIdRefPolicyResolution
 */
export enum TableIamBindingSpecForProviderDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamBindingSpecForProviderDatasetIdRefPolicyResolve
 */
export enum TableIamBindingSpecForProviderDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamBindingSpecForProviderDatasetIdSelectorPolicyResolution
 */
export enum TableIamBindingSpecForProviderDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamBindingSpecForProviderDatasetIdSelectorPolicyResolve
 */
export enum TableIamBindingSpecForProviderDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamBindingSpecForProviderTableIdRefPolicyResolution
 */
export enum TableIamBindingSpecForProviderTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamBindingSpecForProviderTableIdRefPolicyResolve
 */
export enum TableIamBindingSpecForProviderTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamBindingSpecForProviderTableIdSelectorPolicyResolution
 */
export enum TableIamBindingSpecForProviderTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamBindingSpecForProviderTableIdSelectorPolicyResolve
 */
export enum TableIamBindingSpecForProviderTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TableIamBindingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TableIAMMember is the Schema for the TableIAMMembers API. <no value>
 *
 * @schema TableIAMMember
 */
export class TableIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TableIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'TableIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "TableIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TableIamMemberProps): any {
    return {
      ...TableIamMember.GVK,
      ...toJson_TableIamMemberProps(props),
    };
  }

  /**
   * Defines a "TableIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TableIamMemberProps) {
    super(scope, id, {
      ...TableIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TableIamMember.GVK,
      ...toJson_TableIamMemberProps(resolved),
    };
  }
}

/**
 * TableIAMMember is the Schema for the TableIAMMembers API. <no value>
 *
 * @schema TableIAMMember
 */
export interface TableIamMemberProps {
  /**
   * @schema TableIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TableIAMMemberSpec defines the desired state of TableIAMMember
   *
   * @schema TableIAMMember#spec
   */
  readonly spec: TableIamMemberSpec;

}

/**
 * Converts an object of type 'TableIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberProps(obj: TableIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TableIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableIAMMemberSpec defines the desired state of TableIAMMember
 *
 * @schema TableIamMemberSpec
 */
export interface TableIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TableIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: TableIamMemberSpecDeletionPolicy;

  /**
   * @schema TableIamMemberSpec#forProvider
   */
  readonly forProvider: TableIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TableIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: TableIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TableIamMemberSpec#providerRef
   */
  readonly providerRef?: TableIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TableIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TableIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TableIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TableIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TableIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpec(obj: TableIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TableIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TableIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TableIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TableIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TableIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TableIamMemberSpecDeletionPolicy
 */
export enum TableIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TableIamMemberSpecForProvider
 */
export interface TableIamMemberSpecForProvider {
  /**
   * @schema TableIamMemberSpecForProvider#condition
   */
  readonly condition?: TableIamMemberSpecForProviderCondition[];

  /**
   * @schema TableIamMemberSpecForProvider#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema TableIamMemberSpecForProvider#datasetIdRef
   */
  readonly datasetIdRef?: TableIamMemberSpecForProviderDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema TableIamMemberSpecForProvider#datasetIdSelector
   */
  readonly datasetIdSelector?: TableIamMemberSpecForProviderDatasetIdSelector;

  /**
   * @schema TableIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema TableIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema TableIamMemberSpecForProvider#role
   */
  readonly role: string;

  /**
   * @schema TableIamMemberSpecForProvider#tableId
   */
  readonly tableId?: string;

  /**
   * Reference to a Table in bigquery to populate tableId.
   *
   * @schema TableIamMemberSpecForProvider#tableIdRef
   */
  readonly tableIdRef?: TableIamMemberSpecForProviderTableIdRef;

  /**
   * Selector for a Table in bigquery to populate tableId.
   *
   * @schema TableIamMemberSpecForProvider#tableIdSelector
   */
  readonly tableIdSelector?: TableIamMemberSpecForProviderTableIdSelector;

}

/**
 * Converts an object of type 'TableIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecForProvider(obj: TableIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_TableIamMemberSpecForProviderCondition(y)),
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_TableIamMemberSpecForProviderDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_TableIamMemberSpecForProviderDatasetIdSelector(obj.datasetIdSelector),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
    'tableId': obj.tableId,
    'tableIdRef': toJson_TableIamMemberSpecForProviderTableIdRef(obj.tableIdRef),
    'tableIdSelector': toJson_TableIamMemberSpecForProviderTableIdSelector(obj.tableIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TableIamMemberSpecProviderConfigRef
 */
export interface TableIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: TableIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TableIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecProviderConfigRef(obj: TableIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TableIamMemberSpecProviderRef
 */
export interface TableIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamMemberSpecProviderRef#policy
   */
  readonly policy?: TableIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TableIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecProviderRef(obj: TableIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TableIamMemberSpecPublishConnectionDetailsTo
 */
export interface TableIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TableIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TableIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TableIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TableIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TableIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TableIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecPublishConnectionDetailsTo(obj: TableIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TableIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TableIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TableIamMemberSpecWriteConnectionSecretToRef
 */
export interface TableIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TableIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TableIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TableIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecWriteConnectionSecretToRef(obj: TableIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableIamMemberSpecForProviderCondition
 */
export interface TableIamMemberSpecForProviderCondition {
  /**
   * @schema TableIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema TableIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema TableIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'TableIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecForProviderCondition(obj: TableIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema TableIamMemberSpecForProviderDatasetIdRef
 */
export interface TableIamMemberSpecForProviderDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamMemberSpecForProviderDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamMemberSpecForProviderDatasetIdRef#policy
   */
  readonly policy?: TableIamMemberSpecForProviderDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'TableIamMemberSpecForProviderDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecForProviderDatasetIdRef(obj: TableIamMemberSpecForProviderDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamMemberSpecForProviderDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema TableIamMemberSpecForProviderDatasetIdSelector
 */
export interface TableIamMemberSpecForProviderDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableIamMemberSpecForProviderDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableIamMemberSpecForProviderDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableIamMemberSpecForProviderDatasetIdSelector#policy
   */
  readonly policy?: TableIamMemberSpecForProviderDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'TableIamMemberSpecForProviderDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecForProviderDatasetIdSelector(obj: TableIamMemberSpecForProviderDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableIamMemberSpecForProviderDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in bigquery to populate tableId.
 *
 * @schema TableIamMemberSpecForProviderTableIdRef
 */
export interface TableIamMemberSpecForProviderTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamMemberSpecForProviderTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamMemberSpecForProviderTableIdRef#policy
   */
  readonly policy?: TableIamMemberSpecForProviderTableIdRefPolicy;

}

/**
 * Converts an object of type 'TableIamMemberSpecForProviderTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecForProviderTableIdRef(obj: TableIamMemberSpecForProviderTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamMemberSpecForProviderTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in bigquery to populate tableId.
 *
 * @schema TableIamMemberSpecForProviderTableIdSelector
 */
export interface TableIamMemberSpecForProviderTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableIamMemberSpecForProviderTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableIamMemberSpecForProviderTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableIamMemberSpecForProviderTableIdSelector#policy
   */
  readonly policy?: TableIamMemberSpecForProviderTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'TableIamMemberSpecForProviderTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecForProviderTableIdSelector(obj: TableIamMemberSpecForProviderTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableIamMemberSpecForProviderTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamMemberSpecProviderConfigRefPolicy
 */
export interface TableIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TableIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TableIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecProviderConfigRefPolicy(obj: TableIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamMemberSpecProviderRefPolicy
 */
export interface TableIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TableIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TableIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecProviderRefPolicy(obj: TableIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TableIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface TableIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TableIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecPublishConnectionDetailsToConfigRef(obj: TableIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TableIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface TableIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TableIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TableIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecPublishConnectionDetailsToMetadata(obj: TableIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamMemberSpecForProviderDatasetIdRefPolicy
 */
export interface TableIamMemberSpecForProviderDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamMemberSpecForProviderDatasetIdRefPolicy#resolution
   */
  readonly resolution?: TableIamMemberSpecForProviderDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamMemberSpecForProviderDatasetIdRefPolicy#resolve
   */
  readonly resolve?: TableIamMemberSpecForProviderDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamMemberSpecForProviderDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecForProviderDatasetIdRefPolicy(obj: TableIamMemberSpecForProviderDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableIamMemberSpecForProviderDatasetIdSelectorPolicy
 */
export interface TableIamMemberSpecForProviderDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamMemberSpecForProviderDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: TableIamMemberSpecForProviderDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamMemberSpecForProviderDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: TableIamMemberSpecForProviderDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableIamMemberSpecForProviderDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecForProviderDatasetIdSelectorPolicy(obj: TableIamMemberSpecForProviderDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamMemberSpecForProviderTableIdRefPolicy
 */
export interface TableIamMemberSpecForProviderTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamMemberSpecForProviderTableIdRefPolicy#resolution
   */
  readonly resolution?: TableIamMemberSpecForProviderTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamMemberSpecForProviderTableIdRefPolicy#resolve
   */
  readonly resolve?: TableIamMemberSpecForProviderTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamMemberSpecForProviderTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecForProviderTableIdRefPolicy(obj: TableIamMemberSpecForProviderTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableIamMemberSpecForProviderTableIdSelectorPolicy
 */
export interface TableIamMemberSpecForProviderTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamMemberSpecForProviderTableIdSelectorPolicy#resolution
   */
  readonly resolution?: TableIamMemberSpecForProviderTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamMemberSpecForProviderTableIdSelectorPolicy#resolve
   */
  readonly resolve?: TableIamMemberSpecForProviderTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableIamMemberSpecForProviderTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecForProviderTableIdSelectorPolicy(obj: TableIamMemberSpecForProviderTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum TableIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum TableIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamMemberSpecProviderRefPolicyResolution
 */
export enum TableIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamMemberSpecProviderRefPolicyResolve
 */
export enum TableIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamMemberSpecForProviderDatasetIdRefPolicyResolution
 */
export enum TableIamMemberSpecForProviderDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamMemberSpecForProviderDatasetIdRefPolicyResolve
 */
export enum TableIamMemberSpecForProviderDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamMemberSpecForProviderDatasetIdSelectorPolicyResolution
 */
export enum TableIamMemberSpecForProviderDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamMemberSpecForProviderDatasetIdSelectorPolicyResolve
 */
export enum TableIamMemberSpecForProviderDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamMemberSpecForProviderTableIdRefPolicyResolution
 */
export enum TableIamMemberSpecForProviderTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamMemberSpecForProviderTableIdRefPolicyResolve
 */
export enum TableIamMemberSpecForProviderTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamMemberSpecForProviderTableIdSelectorPolicyResolution
 */
export enum TableIamMemberSpecForProviderTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamMemberSpecForProviderTableIdSelectorPolicyResolve
 */
export enum TableIamMemberSpecForProviderTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TableIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TableIAMPolicy is the Schema for the TableIAMPolicys API. Collection of resources to manage IAM policy for BigQuery Table
 *
 * @schema TableIAMPolicy
 */
export class TableIamPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TableIAMPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bigquery.gcp.upbound.io/v1beta1',
    kind: 'TableIAMPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "TableIAMPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TableIamPolicyProps): any {
    return {
      ...TableIamPolicy.GVK,
      ...toJson_TableIamPolicyProps(props),
    };
  }

  /**
   * Defines a "TableIAMPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TableIamPolicyProps) {
    super(scope, id, {
      ...TableIamPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TableIamPolicy.GVK,
      ...toJson_TableIamPolicyProps(resolved),
    };
  }
}

/**
 * TableIAMPolicy is the Schema for the TableIAMPolicys API. Collection of resources to manage IAM policy for BigQuery Table
 *
 * @schema TableIAMPolicy
 */
export interface TableIamPolicyProps {
  /**
   * @schema TableIAMPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TableIAMPolicySpec defines the desired state of TableIAMPolicy
   *
   * @schema TableIAMPolicy#spec
   */
  readonly spec: TableIamPolicySpec;

}

/**
 * Converts an object of type 'TableIamPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicyProps(obj: TableIamPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TableIamPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableIAMPolicySpec defines the desired state of TableIAMPolicy
 *
 * @schema TableIamPolicySpec
 */
export interface TableIamPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TableIamPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: TableIamPolicySpecDeletionPolicy;

  /**
   * @schema TableIamPolicySpec#forProvider
   */
  readonly forProvider: TableIamPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TableIamPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: TableIamPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TableIamPolicySpec#providerRef
   */
  readonly providerRef?: TableIamPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TableIamPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TableIamPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TableIamPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TableIamPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TableIamPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpec(obj: TableIamPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TableIamPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TableIamPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TableIamPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TableIamPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TableIamPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TableIamPolicySpecDeletionPolicy
 */
export enum TableIamPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TableIamPolicySpecForProvider
 */
export interface TableIamPolicySpecForProvider {
  /**
   * @schema TableIamPolicySpecForProvider#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema TableIamPolicySpecForProvider#datasetIdRef
   */
  readonly datasetIdRef?: TableIamPolicySpecForProviderDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema TableIamPolicySpecForProvider#datasetIdSelector
   */
  readonly datasetIdSelector?: TableIamPolicySpecForProviderDatasetIdSelector;

  /**
   * The policy data generated by a google_iam_policy data source.
   *
   * @schema TableIamPolicySpecForProvider#policyData
   */
  readonly policyData: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
   *
   * @schema TableIamPolicySpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema TableIamPolicySpecForProvider#tableId
   */
  readonly tableId?: string;

  /**
   * Reference to a Table in bigquery to populate tableId.
   *
   * @schema TableIamPolicySpecForProvider#tableIdRef
   */
  readonly tableIdRef?: TableIamPolicySpecForProviderTableIdRef;

  /**
   * Selector for a Table in bigquery to populate tableId.
   *
   * @schema TableIamPolicySpecForProvider#tableIdSelector
   */
  readonly tableIdSelector?: TableIamPolicySpecForProviderTableIdSelector;

}

/**
 * Converts an object of type 'TableIamPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecForProvider(obj: TableIamPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_TableIamPolicySpecForProviderDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_TableIamPolicySpecForProviderDatasetIdSelector(obj.datasetIdSelector),
    'policyData': obj.policyData,
    'project': obj.project,
    'tableId': obj.tableId,
    'tableIdRef': toJson_TableIamPolicySpecForProviderTableIdRef(obj.tableIdRef),
    'tableIdSelector': toJson_TableIamPolicySpecForProviderTableIdSelector(obj.tableIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TableIamPolicySpecProviderConfigRef
 */
export interface TableIamPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamPolicySpecProviderConfigRef#policy
   */
  readonly policy?: TableIamPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TableIamPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecProviderConfigRef(obj: TableIamPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TableIamPolicySpecProviderRef
 */
export interface TableIamPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamPolicySpecProviderRef#policy
   */
  readonly policy?: TableIamPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TableIamPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecProviderRef(obj: TableIamPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TableIamPolicySpecPublishConnectionDetailsTo
 */
export interface TableIamPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TableIamPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TableIamPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TableIamPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TableIamPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TableIamPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TableIamPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecPublishConnectionDetailsTo(obj: TableIamPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TableIamPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TableIamPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TableIamPolicySpecWriteConnectionSecretToRef
 */
export interface TableIamPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TableIamPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TableIamPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TableIamPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecWriteConnectionSecretToRef(obj: TableIamPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema TableIamPolicySpecForProviderDatasetIdRef
 */
export interface TableIamPolicySpecForProviderDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamPolicySpecForProviderDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamPolicySpecForProviderDatasetIdRef#policy
   */
  readonly policy?: TableIamPolicySpecForProviderDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'TableIamPolicySpecForProviderDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecForProviderDatasetIdRef(obj: TableIamPolicySpecForProviderDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamPolicySpecForProviderDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema TableIamPolicySpecForProviderDatasetIdSelector
 */
export interface TableIamPolicySpecForProviderDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableIamPolicySpecForProviderDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableIamPolicySpecForProviderDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableIamPolicySpecForProviderDatasetIdSelector#policy
   */
  readonly policy?: TableIamPolicySpecForProviderDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'TableIamPolicySpecForProviderDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecForProviderDatasetIdSelector(obj: TableIamPolicySpecForProviderDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableIamPolicySpecForProviderDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in bigquery to populate tableId.
 *
 * @schema TableIamPolicySpecForProviderTableIdRef
 */
export interface TableIamPolicySpecForProviderTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamPolicySpecForProviderTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamPolicySpecForProviderTableIdRef#policy
   */
  readonly policy?: TableIamPolicySpecForProviderTableIdRefPolicy;

}

/**
 * Converts an object of type 'TableIamPolicySpecForProviderTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecForProviderTableIdRef(obj: TableIamPolicySpecForProviderTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamPolicySpecForProviderTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in bigquery to populate tableId.
 *
 * @schema TableIamPolicySpecForProviderTableIdSelector
 */
export interface TableIamPolicySpecForProviderTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableIamPolicySpecForProviderTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableIamPolicySpecForProviderTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableIamPolicySpecForProviderTableIdSelector#policy
   */
  readonly policy?: TableIamPolicySpecForProviderTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'TableIamPolicySpecForProviderTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecForProviderTableIdSelector(obj: TableIamPolicySpecForProviderTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableIamPolicySpecForProviderTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamPolicySpecProviderConfigRefPolicy
 */
export interface TableIamPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TableIamPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TableIamPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecProviderConfigRefPolicy(obj: TableIamPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamPolicySpecProviderRefPolicy
 */
export interface TableIamPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: TableIamPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: TableIamPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecProviderRefPolicy(obj: TableIamPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TableIamPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface TableIamPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableIamPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableIamPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TableIamPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecPublishConnectionDetailsToConfigRef(obj: TableIamPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TableIamPolicySpecPublishConnectionDetailsToMetadata
 */
export interface TableIamPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableIamPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableIamPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TableIamPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TableIamPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecPublishConnectionDetailsToMetadata(obj: TableIamPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamPolicySpecForProviderDatasetIdRefPolicy
 */
export interface TableIamPolicySpecForProviderDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamPolicySpecForProviderDatasetIdRefPolicy#resolution
   */
  readonly resolution?: TableIamPolicySpecForProviderDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamPolicySpecForProviderDatasetIdRefPolicy#resolve
   */
  readonly resolve?: TableIamPolicySpecForProviderDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamPolicySpecForProviderDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecForProviderDatasetIdRefPolicy(obj: TableIamPolicySpecForProviderDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableIamPolicySpecForProviderDatasetIdSelectorPolicy
 */
export interface TableIamPolicySpecForProviderDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamPolicySpecForProviderDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: TableIamPolicySpecForProviderDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamPolicySpecForProviderDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: TableIamPolicySpecForProviderDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableIamPolicySpecForProviderDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecForProviderDatasetIdSelectorPolicy(obj: TableIamPolicySpecForProviderDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableIamPolicySpecForProviderTableIdRefPolicy
 */
export interface TableIamPolicySpecForProviderTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamPolicySpecForProviderTableIdRefPolicy#resolution
   */
  readonly resolution?: TableIamPolicySpecForProviderTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamPolicySpecForProviderTableIdRefPolicy#resolve
   */
  readonly resolve?: TableIamPolicySpecForProviderTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamPolicySpecForProviderTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecForProviderTableIdRefPolicy(obj: TableIamPolicySpecForProviderTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableIamPolicySpecForProviderTableIdSelectorPolicy
 */
export interface TableIamPolicySpecForProviderTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamPolicySpecForProviderTableIdSelectorPolicy#resolution
   */
  readonly resolution?: TableIamPolicySpecForProviderTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamPolicySpecForProviderTableIdSelectorPolicy#resolve
   */
  readonly resolve?: TableIamPolicySpecForProviderTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableIamPolicySpecForProviderTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecForProviderTableIdSelectorPolicy(obj: TableIamPolicySpecForProviderTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamPolicySpecProviderConfigRefPolicyResolution
 */
export enum TableIamPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamPolicySpecProviderConfigRefPolicyResolve
 */
export enum TableIamPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamPolicySpecProviderRefPolicyResolution
 */
export enum TableIamPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamPolicySpecProviderRefPolicyResolve
 */
export enum TableIamPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamPolicySpecForProviderDatasetIdRefPolicyResolution
 */
export enum TableIamPolicySpecForProviderDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamPolicySpecForProviderDatasetIdRefPolicyResolve
 */
export enum TableIamPolicySpecForProviderDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamPolicySpecForProviderDatasetIdSelectorPolicyResolution
 */
export enum TableIamPolicySpecForProviderDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamPolicySpecForProviderDatasetIdSelectorPolicyResolve
 */
export enum TableIamPolicySpecForProviderDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamPolicySpecForProviderTableIdRefPolicyResolution
 */
export enum TableIamPolicySpecForProviderTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamPolicySpecForProviderTableIdRefPolicyResolve
 */
export enum TableIamPolicySpecForProviderTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamPolicySpecForProviderTableIdSelectorPolicyResolution
 */
export enum TableIamPolicySpecForProviderTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamPolicySpecForProviderTableIdSelectorPolicyResolve
 */
export enum TableIamPolicySpecForProviderTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TableIamPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

