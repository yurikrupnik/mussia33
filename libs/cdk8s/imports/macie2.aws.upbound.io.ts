// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Account is the Schema for the Accounts API. Provides a resource to manage Amazon Macie on an AWS Account.
 *
 * @schema Account
 */
export class Account extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Account"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'macie2.aws.upbound.io/v1beta1',
    kind: 'Account',
  }

  /**
   * Renders a Kubernetes manifest for "Account".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccountProps): any {
    return {
      ...Account.GVK,
      ...toJson_AccountProps(props),
    };
  }

  /**
   * Defines a "Account" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccountProps) {
    super(scope, id, {
      ...Account.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Account.GVK,
      ...toJson_AccountProps(resolved),
    };
  }
}

/**
 * Account is the Schema for the Accounts API. Provides a resource to manage Amazon Macie on an AWS Account.
 *
 * @schema Account
 */
export interface AccountProps {
  /**
   * @schema Account#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccountSpec defines the desired state of Account
   *
   * @schema Account#spec
   */
  readonly spec: AccountSpec;

}

/**
 * Converts an object of type 'AccountProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountProps(obj: AccountProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccountSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccountSpec defines the desired state of Account
 *
 * @schema AccountSpec
 */
export interface AccountSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccountSpecDeletionPolicy;

  /**
   * @schema AccountSpec#forProvider
   */
  readonly forProvider: AccountSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountSpec#managementPolicy
   */
  readonly managementPolicy?: AccountSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccountSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccountSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AccountSpec#providerRef
   */
  readonly providerRef?: AccountSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccountSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccountSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccountSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccountSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccountSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpec(obj: AccountSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccountSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AccountSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AccountSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AccountSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccountSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountSpecDeletionPolicy
 */
export enum AccountSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccountSpecForProvider
 */
export interface AccountSpecForProvider {
  /**
   * Specifies how often to publish updates to policy findings for the account. This includes publishing updates to AWS Security Hub and Amazon EventBridge (formerly called Amazon CloudWatch Events). Valid values are FIFTEEN_MINUTES, ONE_HOUR or SIX_HOURS.
   *
   * @schema AccountSpecForProvider#findingPublishingFrequency
   */
  readonly findingPublishingFrequency?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccountSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the status for the account. To enable Amazon Macie and start all Macie activities for the account, set this value to ENABLED. Valid values are ENABLED or PAUSED.
   *
   * @schema AccountSpecForProvider#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'AccountSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecForProvider(obj: AccountSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'findingPublishingFrequency': obj.findingPublishingFrequency,
    'region': obj.region,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountSpecManagementPolicy
 */
export enum AccountSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccountSpecProviderConfigRef
 */
export interface AccountSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecProviderConfigRef#policy
   */
  readonly policy?: AccountSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderConfigRef(obj: AccountSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AccountSpecProviderRef
 */
export interface AccountSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecProviderRef#policy
   */
  readonly policy?: AccountSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderRef(obj: AccountSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccountSpecPublishConnectionDetailsTo
 */
export interface AccountSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccountSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccountSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsTo(obj: AccountSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccountSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccountSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccountSpecWriteConnectionSecretToRef
 */
export interface AccountSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccountSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccountSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccountSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecWriteConnectionSecretToRef(obj: AccountSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSpecProviderConfigRefPolicy
 */
export interface AccountSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderConfigRefPolicy(obj: AccountSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSpecProviderRefPolicy
 */
export interface AccountSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AccountSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AccountSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderRefPolicy(obj: AccountSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRef
 */
export interface AccountSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccountSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToConfigRef(obj: AccountSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccountSpecPublishConnectionDetailsToMetadata
 */
export interface AccountSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToMetadata(obj: AccountSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecProviderConfigRefPolicyResolution
 */
export enum AccountSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecProviderConfigRefPolicyResolve
 */
export enum AccountSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecProviderRefPolicyResolution
 */
export enum AccountSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecProviderRefPolicyResolve
 */
export enum AccountSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccountSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccountSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClassificationJob is the Schema for the ClassificationJobs API. Provides a resource to manage an AWS Macie Classification Job.
 *
 * @schema ClassificationJob
 */
export class ClassificationJob extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClassificationJob"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'macie2.aws.upbound.io/v1beta1',
    kind: 'ClassificationJob',
  }

  /**
   * Renders a Kubernetes manifest for "ClassificationJob".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClassificationJobProps): any {
    return {
      ...ClassificationJob.GVK,
      ...toJson_ClassificationJobProps(props),
    };
  }

  /**
   * Defines a "ClassificationJob" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClassificationJobProps) {
    super(scope, id, {
      ...ClassificationJob.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClassificationJob.GVK,
      ...toJson_ClassificationJobProps(resolved),
    };
  }
}

/**
 * ClassificationJob is the Schema for the ClassificationJobs API. Provides a resource to manage an AWS Macie Classification Job.
 *
 * @schema ClassificationJob
 */
export interface ClassificationJobProps {
  /**
   * @schema ClassificationJob#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClassificationJobSpec defines the desired state of ClassificationJob
   *
   * @schema ClassificationJob#spec
   */
  readonly spec: ClassificationJobSpec;

}

/**
 * Converts an object of type 'ClassificationJobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobProps(obj: ClassificationJobProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClassificationJobSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClassificationJobSpec defines the desired state of ClassificationJob
 *
 * @schema ClassificationJobSpec
 */
export interface ClassificationJobSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClassificationJobSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClassificationJobSpecDeletionPolicy;

  /**
   * @schema ClassificationJobSpec#forProvider
   */
  readonly forProvider: ClassificationJobSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClassificationJobSpec#managementPolicy
   */
  readonly managementPolicy?: ClassificationJobSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClassificationJobSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClassificationJobSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClassificationJobSpec#providerRef
   */
  readonly providerRef?: ClassificationJobSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClassificationJobSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClassificationJobSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClassificationJobSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClassificationJobSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClassificationJobSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpec(obj: ClassificationJobSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClassificationJobSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ClassificationJobSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClassificationJobSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClassificationJobSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClassificationJobSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClassificationJobSpecDeletionPolicy
 */
export enum ClassificationJobSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClassificationJobSpecForProvider
 */
export interface ClassificationJobSpecForProvider {
  /**
   * The custom data identifiers to use for data analysis and classification.
   *
   * @schema ClassificationJobSpecForProvider#customDataIdentifierIds
   */
  readonly customDataIdentifierIds?: string[];

  /**
   * A custom description of the job. The description can contain as many as 200 characters.
   *
   * @schema ClassificationJobSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies whether to analyze all existing, eligible objects immediately after the job is created.
   *
   * @schema ClassificationJobSpecForProvider#initialRun
   */
  readonly initialRun?: boolean;

  /**
   * The status for the job. Valid values are: CANCELLED, RUNNING and USER_PAUSED
   *
   * @schema ClassificationJobSpecForProvider#jobStatus
   */
  readonly jobStatus?: string;

  /**
   * The schedule for running the job. Valid values are: ONE_TIME - Run the job only once. If you specify this value, don't specify a value for the schedule_frequency property. SCHEDULED - Run the job on a daily, weekly, or monthly basis. If you specify this value, use the schedule_frequency property to define the recurrence pattern for the job.
   *
   * @schema ClassificationJobSpecForProvider#jobType
   */
  readonly jobType?: string;

  /**
   * A custom name for the job. The name can contain as many as 500 characters. Conflicts with name_prefix.
   *
   * @schema ClassificationJobSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClassificationJobSpecForProvider#region
   */
  readonly region: string;

  /**
   * The S3 buckets that contain the objects to analyze, and the scope of that analysis. (documented below)
   *
   * @schema ClassificationJobSpecForProvider#s3JobDefinition
   */
  readonly s3JobDefinition?: ClassificationJobSpecForProviderS3JobDefinition[];

  /**
   * The sampling depth, as a percentage, to apply when processing objects. This value determines the percentage of eligible objects that the job analyzes. If this value is less than 100, Amazon Macie selects the objects to analyze at random, up to the specified percentage, and analyzes all the data in those objects.
   *
   * @schema ClassificationJobSpecForProvider#samplingPercentage
   */
  readonly samplingPercentage?: number;

  /**
   * The recurrence pattern for running the job. To run the job only once, don't specify a value for this property and set the value for the job_type property to ONE_TIME. (documented below)
   *
   * @schema ClassificationJobSpecForProvider#scheduleFrequency
   */
  readonly scheduleFrequency?: ClassificationJobSpecForProviderScheduleFrequency[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ClassificationJobSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClassificationJobSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProvider(obj: ClassificationJobSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customDataIdentifierIds': obj.customDataIdentifierIds?.map(y => y),
    'description': obj.description,
    'initialRun': obj.initialRun,
    'jobStatus': obj.jobStatus,
    'jobType': obj.jobType,
    'name': obj.name,
    'region': obj.region,
    's3JobDefinition': obj.s3JobDefinition?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinition(y)),
    'samplingPercentage': obj.samplingPercentage,
    'scheduleFrequency': obj.scheduleFrequency?.map(y => toJson_ClassificationJobSpecForProviderScheduleFrequency(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClassificationJobSpecManagementPolicy
 */
export enum ClassificationJobSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClassificationJobSpecProviderConfigRef
 */
export interface ClassificationJobSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClassificationJobSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClassificationJobSpecProviderConfigRef#policy
   */
  readonly policy?: ClassificationJobSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClassificationJobSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecProviderConfigRef(obj: ClassificationJobSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClassificationJobSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClassificationJobSpecProviderRef
 */
export interface ClassificationJobSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClassificationJobSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClassificationJobSpecProviderRef#policy
   */
  readonly policy?: ClassificationJobSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClassificationJobSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecProviderRef(obj: ClassificationJobSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClassificationJobSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClassificationJobSpecPublishConnectionDetailsTo
 */
export interface ClassificationJobSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClassificationJobSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClassificationJobSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClassificationJobSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClassificationJobSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClassificationJobSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClassificationJobSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecPublishConnectionDetailsTo(obj: ClassificationJobSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClassificationJobSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClassificationJobSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClassificationJobSpecWriteConnectionSecretToRef
 */
export interface ClassificationJobSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClassificationJobSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClassificationJobSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClassificationJobSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecWriteConnectionSecretToRef(obj: ClassificationJobSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinition
 */
export interface ClassificationJobSpecForProviderS3JobDefinition {
  /**
   * The property- and tag-based conditions that determine which S3 buckets to include or exclude from the analysis. Conflicts with bucket_definitions. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinition#bucketCriteria
   */
  readonly bucketCriteria?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteria[];

  /**
   * An array of objects, one for each AWS account that owns buckets to analyze. Each object specifies the account ID for an account and one or more buckets to analyze for the account. Conflicts with bucket_criteria. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinition#bucketDefinitions
   */
  readonly bucketDefinitions?: ClassificationJobSpecForProviderS3JobDefinitionBucketDefinitions[];

  /**
   * The property- and tag-based conditions that determine which objects to include or exclude from the analysis. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinition#scoping
   */
  readonly scoping?: ClassificationJobSpecForProviderS3JobDefinitionScoping[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinition(obj: ClassificationJobSpecForProviderS3JobDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketCriteria': obj.bucketCriteria?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteria(y)),
    'bucketDefinitions': obj.bucketDefinitions?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketDefinitions(y)),
    'scoping': obj.scoping?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScoping(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderScheduleFrequency
 */
export interface ClassificationJobSpecForProviderScheduleFrequency {
  /**
   * Specifies a daily recurrence pattern for running the job.
   *
   * @schema ClassificationJobSpecForProviderScheduleFrequency#dailySchedule
   */
  readonly dailySchedule?: boolean;

  /**
   * Specifies a monthly recurrence pattern for running the job.
   *
   * @schema ClassificationJobSpecForProviderScheduleFrequency#monthlySchedule
   */
  readonly monthlySchedule?: number;

  /**
   * Specifies a weekly recurrence pattern for running the job.
   *
   * @schema ClassificationJobSpecForProviderScheduleFrequency#weeklySchedule
   */
  readonly weeklySchedule?: string;

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderScheduleFrequency' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderScheduleFrequency(obj: ClassificationJobSpecForProviderScheduleFrequency | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dailySchedule': obj.dailySchedule,
    'monthlySchedule': obj.monthlySchedule,
    'weeklySchedule': obj.weeklySchedule,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClassificationJobSpecProviderConfigRefPolicy
 */
export interface ClassificationJobSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClassificationJobSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClassificationJobSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClassificationJobSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClassificationJobSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClassificationJobSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecProviderConfigRefPolicy(obj: ClassificationJobSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClassificationJobSpecProviderRefPolicy
 */
export interface ClassificationJobSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClassificationJobSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClassificationJobSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClassificationJobSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClassificationJobSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClassificationJobSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecProviderRefPolicy(obj: ClassificationJobSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClassificationJobSpecPublishConnectionDetailsToConfigRef
 */
export interface ClassificationJobSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClassificationJobSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClassificationJobSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClassificationJobSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecPublishConnectionDetailsToConfigRef(obj: ClassificationJobSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClassificationJobSpecPublishConnectionDetailsToMetadata
 */
export interface ClassificationJobSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClassificationJobSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClassificationJobSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClassificationJobSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClassificationJobSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecPublishConnectionDetailsToMetadata(obj: ClassificationJobSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteria
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteria {
  /**
   * The property- or tag-based conditions that determine which objects to exclude from the analysis. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteria#excludes
   */
  readonly excludes?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludes[];

  /**
   * The property- or tag-based conditions that determine which objects to include in the analysis. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteria#includes
   */
  readonly includes?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludes[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteria' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteria(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteria | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludes': obj.excludes?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludes(y)),
    'includes': obj.includes?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketDefinitions
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketDefinitions {
  /**
   * The unique identifier for the AWS account that owns the buckets.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketDefinitions#accountId
   */
  readonly accountId: string;

  /**
   * An array that lists the names of the buckets.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketDefinitions#buckets
   */
  readonly buckets: string[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketDefinitions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketDefinitions(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketDefinitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'buckets': obj.buckets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScoping
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScoping {
  /**
   * The property- or tag-based conditions that determine which objects to exclude from the analysis. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScoping#excludes
   */
  readonly excludes?: ClassificationJobSpecForProviderS3JobDefinitionScopingExcludes[];

  /**
   * The property- or tag-based conditions that determine which objects to include in the analysis. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScoping#includes
   */
  readonly includes?: ClassificationJobSpecForProviderS3JobDefinitionScopingIncludes[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScoping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScoping(obj: ClassificationJobSpecForProviderS3JobDefinitionScoping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludes': obj.excludes?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingExcludes(y)),
    'includes': obj.includes?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingIncludes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClassificationJobSpecProviderConfigRefPolicyResolution
 */
export enum ClassificationJobSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClassificationJobSpecProviderConfigRefPolicyResolve
 */
export enum ClassificationJobSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClassificationJobSpecProviderRefPolicyResolution
 */
export enum ClassificationJobSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClassificationJobSpecProviderRefPolicyResolve
 */
export enum ClassificationJobSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludes
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludes {
  /**
   * An array of conditions, one for each condition that determines which objects to include or exclude from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludes#and
   */
  readonly and?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAnd[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludes(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': obj.and?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAnd(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludes
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludes {
  /**
   * An array of conditions, one for each condition that determines which objects to include or exclude from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludes#and
   */
  readonly and?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAnd[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludes(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': obj.and?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAnd(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludes
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScopingExcludes {
  /**
   * An array of conditions, one for each condition that determines which objects to include or exclude from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludes#and
   */
  readonly and?: ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAnd[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScopingExcludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingExcludes(obj: ClassificationJobSpecForProviderS3JobDefinitionScopingExcludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': obj.and?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAnd(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludes
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScopingIncludes {
  /**
   * An array of conditions, one for each condition that determines which objects to include or exclude from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludes#and
   */
  readonly and?: ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAnd[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScopingIncludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingIncludes(obj: ClassificationJobSpecForProviderS3JobDefinitionScopingIncludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': obj.and?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAnd(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClassificationJobSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAnd
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAnd {
  /**
   * A property-based condition that defines a property, operator, and one or more values for including or excluding an S3 buckets from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAnd#simpleCriterion
   */
  readonly simpleCriterion?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion[];

  /**
   * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an S3 buckets from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAnd#tagCriterion
   */
  readonly tagCriterion?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterion[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAnd(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'simpleCriterion': obj.simpleCriterion?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion(y)),
    'tagCriterion': obj.tagCriterion?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterion(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAnd
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAnd {
  /**
   * A property-based condition that defines a property, operator, and one or more values for including or excluding an S3 buckets from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAnd#simpleCriterion
   */
  readonly simpleCriterion?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion[];

  /**
   * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an S3 buckets from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAnd#tagCriterion
   */
  readonly tagCriterion?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterion[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAnd(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'simpleCriterion': obj.simpleCriterion?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion(y)),
    'tagCriterion': obj.tagCriterion?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterion(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAnd
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAnd {
  /**
   * A property-based condition that defines a property, operator, and one or more values for including or excluding an object from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAnd#simpleScopeTerm
   */
  readonly simpleScopeTerm?: ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndSimpleScopeTerm[];

  /**
   * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an object from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAnd#tagScopeTerm
   */
  readonly tagScopeTerm?: ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAnd(obj: ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'simpleScopeTerm': obj.simpleScopeTerm?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndSimpleScopeTerm(y)),
    'tagScopeTerm': obj.tagScopeTerm?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAnd
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAnd {
  /**
   * A property-based condition that defines a property, operator, and one or more values for including or excluding an object from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAnd#simpleScopeTerm
   */
  readonly simpleScopeTerm?: ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndSimpleScopeTerm[];

  /**
   * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an object from the job. (documented below)
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAnd#tagScopeTerm
   */
  readonly tagScopeTerm?: ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAnd(obj: ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'simpleScopeTerm': obj.simpleScopeTerm?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndSimpleScopeTerm(y)),
    'tagScopeTerm': obj.tagScopeTerm?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion {
  /**
   * The operator to use in a condition. Valid values are: EQ, GT, GTE, LT, LTE, NE, CONTAINS, STARTS_WITH
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion#comparator
   */
  readonly comparator?: string;

  /**
   * The object property to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion#key
   */
  readonly key?: string;

  /**
   * An array that lists the values to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparator': obj.comparator,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterion
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterion {
  /**
   * The operator to use in a condition. Valid values are: EQ, GT, GTE, LT, LTE, NE, CONTAINS, STARTS_WITH
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterion#comparator
   */
  readonly comparator?: string;

  /**
   * The tag keys or tag key and value pairs to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterion#tagValues
   */
  readonly tagValues?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValues[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterion(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparator': obj.comparator,
    'tagValues': obj.tagValues?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValues(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion {
  /**
   * The operator to use in a condition. Valid values are: EQ, GT, GTE, LT, LTE, NE, CONTAINS, STARTS_WITH
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion#comparator
   */
  readonly comparator?: string;

  /**
   * The object property to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion#key
   */
  readonly key?: string;

  /**
   * An array that lists the values to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparator': obj.comparator,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterion
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterion {
  /**
   * The operator to use in a condition. Valid values are: EQ, GT, GTE, LT, LTE, NE, CONTAINS, STARTS_WITH
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterion#comparator
   */
  readonly comparator?: string;

  /**
   * The tag keys or tag key and value pairs to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterion#tagValues
   */
  readonly tagValues?: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValues[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterion(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparator': obj.comparator,
    'tagValues': obj.tagValues?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValues(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndSimpleScopeTerm
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndSimpleScopeTerm {
  /**
   * The operator to use in a condition. Valid values are: EQ, GT, GTE, LT, LTE, NE, CONTAINS, STARTS_WITH
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndSimpleScopeTerm#comparator
   */
  readonly comparator?: string;

  /**
   * The object property to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndSimpleScopeTerm#key
   */
  readonly key?: string;

  /**
   * An array that lists the values to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndSimpleScopeTerm#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndSimpleScopeTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndSimpleScopeTerm(obj: ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndSimpleScopeTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparator': obj.comparator,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm {
  /**
   * The operator to use in a condition. Valid values are: EQ, GT, GTE, LT, LTE, NE, CONTAINS, STARTS_WITH
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm#comparator
   */
  readonly comparator?: string;

  /**
   * The object property to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm#key
   */
  readonly key?: string;

  /**
   * The tag keys or tag key and value pairs to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm#tagValues
   */
  readonly tagValues?: ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTermTagValues[];

  /**
   * The type of object to apply the condition to. The only valid value is S3_OBJECT.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm#target
   */
  readonly target?: string;

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm(obj: ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparator': obj.comparator,
    'key': obj.key,
    'tagValues': obj.tagValues?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTermTagValues(y)),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndSimpleScopeTerm
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndSimpleScopeTerm {
  /**
   * The operator to use in a condition. Valid values are: EQ, GT, GTE, LT, LTE, NE, CONTAINS, STARTS_WITH
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndSimpleScopeTerm#comparator
   */
  readonly comparator?: string;

  /**
   * The object property to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndSimpleScopeTerm#key
   */
  readonly key?: string;

  /**
   * An array that lists the values to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndSimpleScopeTerm#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndSimpleScopeTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndSimpleScopeTerm(obj: ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndSimpleScopeTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparator': obj.comparator,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm {
  /**
   * The operator to use in a condition. Valid values are: EQ, GT, GTE, LT, LTE, NE, CONTAINS, STARTS_WITH
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm#comparator
   */
  readonly comparator?: string;

  /**
   * The object property to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm#key
   */
  readonly key?: string;

  /**
   * The tag keys or tag key and value pairs to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm#tagValues
   */
  readonly tagValues?: ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTermTagValues[];

  /**
   * The type of object to apply the condition to. The only valid value is S3_OBJECT.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm#target
   */
  readonly target?: string;

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm(obj: ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparator': obj.comparator,
    'key': obj.key,
    'tagValues': obj.tagValues?.map(y => toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTermTagValues(y)),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValues
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValues {
  /**
   * The object property to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValues#key
   */
  readonly key?: string;

  /**
   * The tag value.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValues#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValues(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValues
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValues {
  /**
   * The object property to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValues#key
   */
  readonly key?: string;

  /**
   * The tag value.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValues#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValues(obj: ClassificationJobSpecForProviderS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTermTagValues
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTermTagValues {
  /**
   * The object property to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTermTagValues#key
   */
  readonly key?: string;

  /**
   * The tag value.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTermTagValues#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTermTagValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTermTagValues(obj: ClassificationJobSpecForProviderS3JobDefinitionScopingExcludesAndTagScopeTermTagValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTermTagValues
 */
export interface ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTermTagValues {
  /**
   * The object property to use in the condition.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTermTagValues#key
   */
  readonly key?: string;

  /**
   * The tag value.
   *
   * @schema ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTermTagValues#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTermTagValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTermTagValues(obj: ClassificationJobSpecForProviderS3JobDefinitionScopingIncludesAndTagScopeTermTagValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CustomDataIdentifier is the Schema for the CustomDataIdentifiers API. Provides a resource to manage an AWS Macie Custom Data Identifier.
 *
 * @schema CustomDataIdentifier
 */
export class CustomDataIdentifier extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CustomDataIdentifier"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'macie2.aws.upbound.io/v1beta1',
    kind: 'CustomDataIdentifier',
  }

  /**
   * Renders a Kubernetes manifest for "CustomDataIdentifier".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CustomDataIdentifierProps): any {
    return {
      ...CustomDataIdentifier.GVK,
      ...toJson_CustomDataIdentifierProps(props),
    };
  }

  /**
   * Defines a "CustomDataIdentifier" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CustomDataIdentifierProps) {
    super(scope, id, {
      ...CustomDataIdentifier.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CustomDataIdentifier.GVK,
      ...toJson_CustomDataIdentifierProps(resolved),
    };
  }
}

/**
 * CustomDataIdentifier is the Schema for the CustomDataIdentifiers API. Provides a resource to manage an AWS Macie Custom Data Identifier.
 *
 * @schema CustomDataIdentifier
 */
export interface CustomDataIdentifierProps {
  /**
   * @schema CustomDataIdentifier#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CustomDataIdentifierSpec defines the desired state of CustomDataIdentifier
   *
   * @schema CustomDataIdentifier#spec
   */
  readonly spec: CustomDataIdentifierSpec;

}

/**
 * Converts an object of type 'CustomDataIdentifierProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierProps(obj: CustomDataIdentifierProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CustomDataIdentifierSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomDataIdentifierSpec defines the desired state of CustomDataIdentifier
 *
 * @schema CustomDataIdentifierSpec
 */
export interface CustomDataIdentifierSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CustomDataIdentifierSpec#deletionPolicy
   */
  readonly deletionPolicy?: CustomDataIdentifierSpecDeletionPolicy;

  /**
   * @schema CustomDataIdentifierSpec#forProvider
   */
  readonly forProvider: CustomDataIdentifierSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CustomDataIdentifierSpec#managementPolicy
   */
  readonly managementPolicy?: CustomDataIdentifierSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CustomDataIdentifierSpec#providerConfigRef
   */
  readonly providerConfigRef?: CustomDataIdentifierSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CustomDataIdentifierSpec#providerRef
   */
  readonly providerRef?: CustomDataIdentifierSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CustomDataIdentifierSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CustomDataIdentifierSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CustomDataIdentifierSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CustomDataIdentifierSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CustomDataIdentifierSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpec(obj: CustomDataIdentifierSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CustomDataIdentifierSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CustomDataIdentifierSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CustomDataIdentifierSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CustomDataIdentifierSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CustomDataIdentifierSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CustomDataIdentifierSpecDeletionPolicy
 */
export enum CustomDataIdentifierSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CustomDataIdentifierSpecForProvider
 */
export interface CustomDataIdentifierSpecForProvider {
  /**
   * A custom description of the custom data identifier. The description can contain as many as 512 characters.
   *
   * @schema CustomDataIdentifierSpecForProvider#description
   */
  readonly description?: string;

  /**
   * An array that lists specific character sequences (ignore words) to exclude from the results. If the text matched by the regular expression is the same as any string in this array, Amazon Macie ignores it. The array can contain as many as 10 ignore words. Each ignore word can contain 4 - 90 characters. Ignore words are case sensitive.
   *
   * @schema CustomDataIdentifierSpecForProvider#ignoreWords
   */
  readonly ignoreWords?: string[];

  /**
   * An array that lists specific character sequences (keywords), one of which must be within proximity (maximum_match_distance) of the regular expression to match. The array can contain as many as 50 keywords. Each keyword can contain 3 - 90 characters. Keywords aren't case sensitive.
   *
   * @schema CustomDataIdentifierSpecForProvider#keywords
   */
  readonly keywords?: string[];

  /**
   * The maximum number of characters that can exist between text that matches the regex pattern and the character sequences specified by the keywords array. Macie includes or excludes a result based on the proximity of a keyword to text that matches the regex pattern. The distance can be 1 - 300 characters. The default value is 50.
   *
   * @schema CustomDataIdentifierSpecForProvider#maximumMatchDistance
   */
  readonly maximumMatchDistance?: number;

  /**
   * A custom name for the custom data identifier. The name can contain as many as 128 characters. Conflicts with name_prefix.
   *
   * @schema CustomDataIdentifierSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The regular expression (regex) that defines the pattern to match. The expression can contain as many as 512 characters.
   *
   * @schema CustomDataIdentifierSpecForProvider#regex
   */
  readonly regex?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CustomDataIdentifierSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema CustomDataIdentifierSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CustomDataIdentifierSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpecForProvider(obj: CustomDataIdentifierSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'ignoreWords': obj.ignoreWords?.map(y => y),
    'keywords': obj.keywords?.map(y => y),
    'maximumMatchDistance': obj.maximumMatchDistance,
    'name': obj.name,
    'regex': obj.regex,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CustomDataIdentifierSpecManagementPolicy
 */
export enum CustomDataIdentifierSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CustomDataIdentifierSpecProviderConfigRef
 */
export interface CustomDataIdentifierSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomDataIdentifierSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomDataIdentifierSpecProviderConfigRef#policy
   */
  readonly policy?: CustomDataIdentifierSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomDataIdentifierSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpecProviderConfigRef(obj: CustomDataIdentifierSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomDataIdentifierSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CustomDataIdentifierSpecProviderRef
 */
export interface CustomDataIdentifierSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomDataIdentifierSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomDataIdentifierSpecProviderRef#policy
   */
  readonly policy?: CustomDataIdentifierSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CustomDataIdentifierSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpecProviderRef(obj: CustomDataIdentifierSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomDataIdentifierSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CustomDataIdentifierSpecPublishConnectionDetailsTo
 */
export interface CustomDataIdentifierSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CustomDataIdentifierSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CustomDataIdentifierSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CustomDataIdentifierSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CustomDataIdentifierSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CustomDataIdentifierSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CustomDataIdentifierSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpecPublishConnectionDetailsTo(obj: CustomDataIdentifierSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CustomDataIdentifierSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CustomDataIdentifierSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CustomDataIdentifierSpecWriteConnectionSecretToRef
 */
export interface CustomDataIdentifierSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CustomDataIdentifierSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CustomDataIdentifierSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CustomDataIdentifierSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpecWriteConnectionSecretToRef(obj: CustomDataIdentifierSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomDataIdentifierSpecProviderConfigRefPolicy
 */
export interface CustomDataIdentifierSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomDataIdentifierSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CustomDataIdentifierSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomDataIdentifierSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CustomDataIdentifierSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomDataIdentifierSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpecProviderConfigRefPolicy(obj: CustomDataIdentifierSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomDataIdentifierSpecProviderRefPolicy
 */
export interface CustomDataIdentifierSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomDataIdentifierSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CustomDataIdentifierSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomDataIdentifierSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CustomDataIdentifierSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomDataIdentifierSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpecProviderRefPolicy(obj: CustomDataIdentifierSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CustomDataIdentifierSpecPublishConnectionDetailsToConfigRef
 */
export interface CustomDataIdentifierSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomDataIdentifierSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomDataIdentifierSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomDataIdentifierSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpecPublishConnectionDetailsToConfigRef(obj: CustomDataIdentifierSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CustomDataIdentifierSpecPublishConnectionDetailsToMetadata
 */
export interface CustomDataIdentifierSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomDataIdentifierSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomDataIdentifierSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CustomDataIdentifierSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomDataIdentifierSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpecPublishConnectionDetailsToMetadata(obj: CustomDataIdentifierSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomDataIdentifierSpecProviderConfigRefPolicyResolution
 */
export enum CustomDataIdentifierSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomDataIdentifierSpecProviderConfigRefPolicyResolve
 */
export enum CustomDataIdentifierSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomDataIdentifierSpecProviderRefPolicyResolution
 */
export enum CustomDataIdentifierSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomDataIdentifierSpecProviderRefPolicyResolve
 */
export enum CustomDataIdentifierSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicy(obj: CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CustomDataIdentifierSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FindingsFilter is the Schema for the FindingsFilters API. Provides a resource to manage an Amazon Macie Findings Filter.
 *
 * @schema FindingsFilter
 */
export class FindingsFilter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FindingsFilter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'macie2.aws.upbound.io/v1beta1',
    kind: 'FindingsFilter',
  }

  /**
   * Renders a Kubernetes manifest for "FindingsFilter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FindingsFilterProps): any {
    return {
      ...FindingsFilter.GVK,
      ...toJson_FindingsFilterProps(props),
    };
  }

  /**
   * Defines a "FindingsFilter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FindingsFilterProps) {
    super(scope, id, {
      ...FindingsFilter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FindingsFilter.GVK,
      ...toJson_FindingsFilterProps(resolved),
    };
  }
}

/**
 * FindingsFilter is the Schema for the FindingsFilters API. Provides a resource to manage an Amazon Macie Findings Filter.
 *
 * @schema FindingsFilter
 */
export interface FindingsFilterProps {
  /**
   * @schema FindingsFilter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FindingsFilterSpec defines the desired state of FindingsFilter
   *
   * @schema FindingsFilter#spec
   */
  readonly spec: FindingsFilterSpec;

}

/**
 * Converts an object of type 'FindingsFilterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterProps(obj: FindingsFilterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FindingsFilterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FindingsFilterSpec defines the desired state of FindingsFilter
 *
 * @schema FindingsFilterSpec
 */
export interface FindingsFilterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FindingsFilterSpec#deletionPolicy
   */
  readonly deletionPolicy?: FindingsFilterSpecDeletionPolicy;

  /**
   * @schema FindingsFilterSpec#forProvider
   */
  readonly forProvider: FindingsFilterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FindingsFilterSpec#managementPolicy
   */
  readonly managementPolicy?: FindingsFilterSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FindingsFilterSpec#providerConfigRef
   */
  readonly providerConfigRef?: FindingsFilterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FindingsFilterSpec#providerRef
   */
  readonly providerRef?: FindingsFilterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FindingsFilterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FindingsFilterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FindingsFilterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FindingsFilterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FindingsFilterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpec(obj: FindingsFilterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FindingsFilterSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_FindingsFilterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FindingsFilterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FindingsFilterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FindingsFilterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FindingsFilterSpecDeletionPolicy
 */
export enum FindingsFilterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FindingsFilterSpecForProvider
 */
export interface FindingsFilterSpecForProvider {
  /**
   * The action to perform on findings that meet the filter criteria (finding_criteria). Valid values are: ARCHIVE, suppress (automatically archive) the findings; and, NOOP, don't perform any action on the findings.
   *
   * @schema FindingsFilterSpecForProvider#action
   */
  readonly action?: string;

  /**
   * A custom description of the filter. The description can contain as many as 512 characters.
   *
   * @schema FindingsFilterSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The criteria to use to filter findings.
   *
   * @schema FindingsFilterSpecForProvider#findingCriteria
   */
  readonly findingCriteria?: FindingsFilterSpecForProviderFindingCriteria[];

  /**
   * A custom name for the filter. The name must contain at least 3 characters and can contain as many as 64 characters. Conflicts with name_prefix.
   *
   * @schema FindingsFilterSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The position of the filter in the list of saved filters on the Amazon Macie console. This value also determines the order in which the filter is applied to findings, relative to other filters that are also applied to the findings.
   *
   * @schema FindingsFilterSpecForProvider#position
   */
  readonly position?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FindingsFilterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FindingsFilterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FindingsFilterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecForProvider(obj: FindingsFilterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'description': obj.description,
    'findingCriteria': obj.findingCriteria?.map(y => toJson_FindingsFilterSpecForProviderFindingCriteria(y)),
    'name': obj.name,
    'position': obj.position,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FindingsFilterSpecManagementPolicy
 */
export enum FindingsFilterSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FindingsFilterSpecProviderConfigRef
 */
export interface FindingsFilterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FindingsFilterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FindingsFilterSpecProviderConfigRef#policy
   */
  readonly policy?: FindingsFilterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FindingsFilterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecProviderConfigRef(obj: FindingsFilterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FindingsFilterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FindingsFilterSpecProviderRef
 */
export interface FindingsFilterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FindingsFilterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FindingsFilterSpecProviderRef#policy
   */
  readonly policy?: FindingsFilterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FindingsFilterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecProviderRef(obj: FindingsFilterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FindingsFilterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FindingsFilterSpecPublishConnectionDetailsTo
 */
export interface FindingsFilterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FindingsFilterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FindingsFilterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FindingsFilterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FindingsFilterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FindingsFilterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FindingsFilterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecPublishConnectionDetailsTo(obj: FindingsFilterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FindingsFilterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FindingsFilterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FindingsFilterSpecWriteConnectionSecretToRef
 */
export interface FindingsFilterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FindingsFilterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FindingsFilterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FindingsFilterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecWriteConnectionSecretToRef(obj: FindingsFilterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FindingsFilterSpecForProviderFindingCriteria
 */
export interface FindingsFilterSpecForProviderFindingCriteria {
  /**
   * A condition that specifies the property, operator, and one or more values to use to filter the results.  (documented below)
   *
   * @schema FindingsFilterSpecForProviderFindingCriteria#criterion
   */
  readonly criterion?: FindingsFilterSpecForProviderFindingCriteriaCriterion[];

}

/**
 * Converts an object of type 'FindingsFilterSpecForProviderFindingCriteria' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecForProviderFindingCriteria(obj: FindingsFilterSpecForProviderFindingCriteria | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'criterion': obj.criterion?.map(y => toJson_FindingsFilterSpecForProviderFindingCriteriaCriterion(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FindingsFilterSpecProviderConfigRefPolicy
 */
export interface FindingsFilterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FindingsFilterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FindingsFilterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FindingsFilterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FindingsFilterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FindingsFilterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecProviderConfigRefPolicy(obj: FindingsFilterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FindingsFilterSpecProviderRefPolicy
 */
export interface FindingsFilterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FindingsFilterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FindingsFilterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FindingsFilterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FindingsFilterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FindingsFilterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecProviderRefPolicy(obj: FindingsFilterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FindingsFilterSpecPublishConnectionDetailsToConfigRef
 */
export interface FindingsFilterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FindingsFilterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FindingsFilterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FindingsFilterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecPublishConnectionDetailsToConfigRef(obj: FindingsFilterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FindingsFilterSpecPublishConnectionDetailsToMetadata
 */
export interface FindingsFilterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FindingsFilterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FindingsFilterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FindingsFilterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FindingsFilterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecPublishConnectionDetailsToMetadata(obj: FindingsFilterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FindingsFilterSpecForProviderFindingCriteriaCriterion
 */
export interface FindingsFilterSpecForProviderFindingCriteriaCriterion {
  /**
   * The value for the property matches (equals) the specified value. If you specify multiple values, Amazon Macie uses OR logic to join the values.
   *
   * @schema FindingsFilterSpecForProviderFindingCriteriaCriterion#eq
   */
  readonly eq?: string[];

  /**
   * The value for the property exclusively matches (equals an exact match for) all the specified values. If you specify multiple values, Amazon Macie uses AND logic to join the values.
   *
   * @schema FindingsFilterSpecForProviderFindingCriteriaCriterion#eqExactMatch
   */
  readonly eqExactMatch?: string[];

  /**
   * The name of the field to be evaluated.
   *
   * @schema FindingsFilterSpecForProviderFindingCriteriaCriterion#field
   */
  readonly field: string;

  /**
   * The value for the property is greater than the specified value.
   *
   * @schema FindingsFilterSpecForProviderFindingCriteriaCriterion#gt
   */
  readonly gt?: string;

  /**
   * The value for the property is greater than or equal to the specified value.
   *
   * @schema FindingsFilterSpecForProviderFindingCriteriaCriterion#gte
   */
  readonly gte?: string;

  /**
   * The value for the property is less than the specified value.
   *
   * @schema FindingsFilterSpecForProviderFindingCriteriaCriterion#lt
   */
  readonly lt?: string;

  /**
   * The value for the property is less than or equal to the specified value.
   *
   * @schema FindingsFilterSpecForProviderFindingCriteriaCriterion#lte
   */
  readonly lte?: string;

  /**
   * The value for the property doesn't match (doesn't equal) the specified value. If you specify multiple values, Amazon Macie uses OR logic to join the values.
   *
   * @schema FindingsFilterSpecForProviderFindingCriteriaCriterion#neq
   */
  readonly neq?: string[];

}

/**
 * Converts an object of type 'FindingsFilterSpecForProviderFindingCriteriaCriterion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecForProviderFindingCriteriaCriterion(obj: FindingsFilterSpecForProviderFindingCriteriaCriterion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq?.map(y => y),
    'eqExactMatch': obj.eqExactMatch?.map(y => y),
    'field': obj.field,
    'gt': obj.gt,
    'gte': obj.gte,
    'lt': obj.lt,
    'lte': obj.lte,
    'neq': obj.neq?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FindingsFilterSpecProviderConfigRefPolicyResolution
 */
export enum FindingsFilterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FindingsFilterSpecProviderConfigRefPolicyResolve
 */
export enum FindingsFilterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FindingsFilterSpecProviderRefPolicyResolution
 */
export enum FindingsFilterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FindingsFilterSpecProviderRefPolicyResolve
 */
export enum FindingsFilterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicy(obj: FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FindingsFilterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InvitationAccepter is the Schema for the InvitationAccepters API. Provides a resource to manage an Amazon Macie Invitation Accepter.
 *
 * @schema InvitationAccepter
 */
export class InvitationAccepter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InvitationAccepter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'macie2.aws.upbound.io/v1beta1',
    kind: 'InvitationAccepter',
  }

  /**
   * Renders a Kubernetes manifest for "InvitationAccepter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InvitationAccepterProps): any {
    return {
      ...InvitationAccepter.GVK,
      ...toJson_InvitationAccepterProps(props),
    };
  }

  /**
   * Defines a "InvitationAccepter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InvitationAccepterProps) {
    super(scope, id, {
      ...InvitationAccepter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InvitationAccepter.GVK,
      ...toJson_InvitationAccepterProps(resolved),
    };
  }
}

/**
 * InvitationAccepter is the Schema for the InvitationAccepters API. Provides a resource to manage an Amazon Macie Invitation Accepter.
 *
 * @schema InvitationAccepter
 */
export interface InvitationAccepterProps {
  /**
   * @schema InvitationAccepter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InvitationAccepterSpec defines the desired state of InvitationAccepter
   *
   * @schema InvitationAccepter#spec
   */
  readonly spec: InvitationAccepterSpec;

}

/**
 * Converts an object of type 'InvitationAccepterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterProps(obj: InvitationAccepterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InvitationAccepterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InvitationAccepterSpec defines the desired state of InvitationAccepter
 *
 * @schema InvitationAccepterSpec
 */
export interface InvitationAccepterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InvitationAccepterSpec#deletionPolicy
   */
  readonly deletionPolicy?: InvitationAccepterSpecDeletionPolicy;

  /**
   * @schema InvitationAccepterSpec#forProvider
   */
  readonly forProvider: InvitationAccepterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InvitationAccepterSpec#managementPolicy
   */
  readonly managementPolicy?: InvitationAccepterSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InvitationAccepterSpec#providerConfigRef
   */
  readonly providerConfigRef?: InvitationAccepterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InvitationAccepterSpec#providerRef
   */
  readonly providerRef?: InvitationAccepterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InvitationAccepterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InvitationAccepterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InvitationAccepterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InvitationAccepterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InvitationAccepterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpec(obj: InvitationAccepterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InvitationAccepterSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_InvitationAccepterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InvitationAccepterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InvitationAccepterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InvitationAccepterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InvitationAccepterSpecDeletionPolicy
 */
export enum InvitationAccepterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InvitationAccepterSpecForProvider
 */
export interface InvitationAccepterSpecForProvider {
  /**
   * The AWS account ID for the account that sent the invitation.
   *
   * @schema InvitationAccepterSpecForProvider#administratorAccountId
   */
  readonly administratorAccountId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InvitationAccepterSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'InvitationAccepterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecForProvider(obj: InvitationAccepterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'administratorAccountId': obj.administratorAccountId,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InvitationAccepterSpecManagementPolicy
 */
export enum InvitationAccepterSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InvitationAccepterSpecProviderConfigRef
 */
export interface InvitationAccepterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvitationAccepterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvitationAccepterSpecProviderConfigRef#policy
   */
  readonly policy?: InvitationAccepterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InvitationAccepterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecProviderConfigRef(obj: InvitationAccepterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvitationAccepterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InvitationAccepterSpecProviderRef
 */
export interface InvitationAccepterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvitationAccepterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvitationAccepterSpecProviderRef#policy
   */
  readonly policy?: InvitationAccepterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InvitationAccepterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecProviderRef(obj: InvitationAccepterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvitationAccepterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsTo
 */
export interface InvitationAccepterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InvitationAccepterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InvitationAccepterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InvitationAccepterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecPublishConnectionDetailsTo(obj: InvitationAccepterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InvitationAccepterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InvitationAccepterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InvitationAccepterSpecWriteConnectionSecretToRef
 */
export interface InvitationAccepterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InvitationAccepterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InvitationAccepterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InvitationAccepterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecWriteConnectionSecretToRef(obj: InvitationAccepterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InvitationAccepterSpecProviderConfigRefPolicy
 */
export interface InvitationAccepterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvitationAccepterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InvitationAccepterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvitationAccepterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InvitationAccepterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InvitationAccepterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecProviderConfigRefPolicy(obj: InvitationAccepterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InvitationAccepterSpecProviderRefPolicy
 */
export interface InvitationAccepterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvitationAccepterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InvitationAccepterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvitationAccepterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InvitationAccepterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InvitationAccepterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecProviderRefPolicy(obj: InvitationAccepterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRef
 */
export interface InvitationAccepterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InvitationAccepterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecPublishConnectionDetailsToConfigRef(obj: InvitationAccepterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsToMetadata
 */
export interface InvitationAccepterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InvitationAccepterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecPublishConnectionDetailsToMetadata(obj: InvitationAccepterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvitationAccepterSpecProviderConfigRefPolicyResolution
 */
export enum InvitationAccepterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvitationAccepterSpecProviderConfigRefPolicyResolve
 */
export enum InvitationAccepterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvitationAccepterSpecProviderRefPolicyResolution
 */
export enum InvitationAccepterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvitationAccepterSpecProviderRefPolicyResolve
 */
export enum InvitationAccepterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj: InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Member is the Schema for the Members API. Provides a resource to manage an Amazon Macie Member.
 *
 * @schema Member
 */
export class Member extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Member"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'macie2.aws.upbound.io/v1beta1',
    kind: 'Member',
  }

  /**
   * Renders a Kubernetes manifest for "Member".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MemberProps): any {
    return {
      ...Member.GVK,
      ...toJson_MemberProps(props),
    };
  }

  /**
   * Defines a "Member" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MemberProps) {
    super(scope, id, {
      ...Member.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Member.GVK,
      ...toJson_MemberProps(resolved),
    };
  }
}

/**
 * Member is the Schema for the Members API. Provides a resource to manage an Amazon Macie Member.
 *
 * @schema Member
 */
export interface MemberProps {
  /**
   * @schema Member#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MemberSpec defines the desired state of Member
   *
   * @schema Member#spec
   */
  readonly spec: MemberSpec;

}

/**
 * Converts an object of type 'MemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberProps(obj: MemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MemberSpec defines the desired state of Member
 *
 * @schema MemberSpec
 */
export interface MemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: MemberSpecDeletionPolicy;

  /**
   * @schema MemberSpec#forProvider
   */
  readonly forProvider: MemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MemberSpec#managementPolicy
   */
  readonly managementPolicy?: MemberSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: MemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MemberSpec#providerRef
   */
  readonly providerRef?: MemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpec(obj: MemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MemberSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MemberSpecDeletionPolicy
 */
export enum MemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MemberSpecForProvider
 */
export interface MemberSpecForProvider {
  /**
   * The AWS account ID for the account.
   *
   * @schema MemberSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * The email address for the account.
   *
   * @schema MemberSpecForProvider#email
   */
  readonly email?: string;

  /**
   * Specifies whether to send an email notification to the root user of each account that the invitation will be sent to. This notification is in addition to an alert that the root user receives in AWS Personal Health Dashboard. To send an email notification to the root user of each account, set this value to true.
   *
   * @schema MemberSpecForProvider#invitationDisableEmailNotification
   */
  readonly invitationDisableEmailNotification?: boolean;

  /**
   * A custom message to include in the invitation. Amazon Macie adds this message to the standard content that it sends for an invitation.
   *
   * @schema MemberSpecForProvider#invitationMessage
   */
  readonly invitationMessage?: string;

  /**
   * Send an invitation to a member
   *
   * @schema MemberSpecForProvider#invite
   */
  readonly invite?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MemberSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the status for the account. To enable Amazon Macie and start all Macie activities for the account, set this value to ENABLED. Valid values are ENABLED or PAUSED.
   *
   * @schema MemberSpecForProvider#status
   */
  readonly status?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema MemberSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'MemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProvider(obj: MemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'email': obj.email,
    'invitationDisableEmailNotification': obj.invitationDisableEmailNotification,
    'invitationMessage': obj.invitationMessage,
    'invite': obj.invite,
    'region': obj.region,
    'status': obj.status,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MemberSpecManagementPolicy
 */
export enum MemberSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MemberSpecProviderConfigRef
 */
export interface MemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecProviderConfigRef#policy
   */
  readonly policy?: MemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderConfigRef(obj: MemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MemberSpecProviderRef
 */
export interface MemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecProviderRef#policy
   */
  readonly policy?: MemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderRef(obj: MemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MemberSpecPublishConnectionDetailsTo
 */
export interface MemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsTo(obj: MemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MemberSpecWriteConnectionSecretToRef
 */
export interface MemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecWriteConnectionSecretToRef(obj: MemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecProviderConfigRefPolicy
 */
export interface MemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderConfigRefPolicy(obj: MemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecProviderRefPolicy
 */
export interface MemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderRefPolicy(obj: MemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRef
 */
export interface MemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToConfigRef(obj: MemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MemberSpecPublishConnectionDetailsToMetadata
 */
export interface MemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToMetadata(obj: MemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecProviderConfigRefPolicyResolution
 */
export enum MemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecProviderConfigRefPolicyResolve
 */
export enum MemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecProviderRefPolicyResolution
 */
export enum MemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecProviderRefPolicyResolve
 */
export enum MemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: MemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

