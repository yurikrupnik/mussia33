// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Pipeline is the Schema for the Pipelines API. Provides an Elastic Transcoder pipeline resource.
 *
 * @schema Pipeline
 */
export class Pipeline extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Pipeline"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elastictranscoder.aws.upbound.io/v1beta1',
    kind: 'Pipeline',
  }

  /**
   * Renders a Kubernetes manifest for "Pipeline".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PipelineProps): any {
    return {
      ...Pipeline.GVK,
      ...toJson_PipelineProps(props),
    };
  }

  /**
   * Defines a "Pipeline" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PipelineProps) {
    super(scope, id, {
      ...Pipeline.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Pipeline.GVK,
      ...toJson_PipelineProps(resolved),
    };
  }
}

/**
 * Pipeline is the Schema for the Pipelines API. Provides an Elastic Transcoder pipeline resource.
 *
 * @schema Pipeline
 */
export interface PipelineProps {
  /**
   * @schema Pipeline#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PipelineSpec defines the desired state of Pipeline
   *
   * @schema Pipeline#spec
   */
  readonly spec: PipelineSpec;

}

/**
 * Converts an object of type 'PipelineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineProps(obj: PipelineProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PipelineSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PipelineSpec defines the desired state of Pipeline
 *
 * @schema PipelineSpec
 */
export interface PipelineSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema PipelineSpec#deletionPolicy
   */
  readonly deletionPolicy?: PipelineSpecDeletionPolicy;

  /**
   * @schema PipelineSpec#forProvider
   */
  readonly forProvider: PipelineSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PipelineSpec#providerConfigRef
   */
  readonly providerConfigRef?: PipelineSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PipelineSpec#providerRef
   */
  readonly providerRef?: PipelineSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PipelineSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PipelineSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PipelineSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PipelineSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PipelineSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpec(obj: PipelineSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PipelineSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_PipelineSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PipelineSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PipelineSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PipelineSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema PipelineSpecDeletionPolicy
 */
export enum PipelineSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PipelineSpecForProvider
 */
export interface PipelineSpecForProvider {
  /**
   * The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.
   *
   * @schema PipelineSpecForProvider#awsKmsKeyArn
   */
  readonly awsKmsKeyArn?: string;

  /**
   * The ContentConfig object specifies information about the Amazon S3 bucket in which you want Elastic Transcoder to save transcoded files and playlists. (documented below)
   *
   * @schema PipelineSpecForProvider#contentConfig
   */
  readonly contentConfig?: PipelineSpecForProviderContentConfig[];

  /**
   * The permissions for the content_config object. (documented below)
   *
   * @schema PipelineSpecForProvider#contentConfigPermissions
   */
  readonly contentConfigPermissions?: PipelineSpecForProviderContentConfigPermissions[];

  /**
   * The Amazon S3 bucket in which you saved the media files that you want to transcode and the graphics that you want to use as watermarks.
   *
   * @schema PipelineSpecForProvider#inputBucket
   */
  readonly inputBucket?: string;

  /**
   * Reference to a Bucket in s3 to populate inputBucket.
   *
   * @schema PipelineSpecForProvider#inputBucketRef
   */
  readonly inputBucketRef?: PipelineSpecForProviderInputBucketRef;

  /**
   * Selector for a Bucket in s3 to populate inputBucket.
   *
   * @schema PipelineSpecForProvider#inputBucketSelector
   */
  readonly inputBucketSelector?: PipelineSpecForProviderInputBucketSelector;

  /**
   * The name of the pipeline. Maximum 40 characters
   *
   * @schema PipelineSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status. (documented below)
   *
   * @schema PipelineSpecForProvider#notifications
   */
  readonly notifications?: PipelineSpecForProviderNotifications[];

  /**
   * The Amazon S3 bucket in which you want Elastic Transcoder to save the transcoded files.
   *
   * @schema PipelineSpecForProvider#outputBucket
   */
  readonly outputBucket?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PipelineSpecForProvider#region
   */
  readonly region: string;

  /**
   * The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to transcode jobs for this pipeline.
   *
   * @schema PipelineSpecForProvider#role
   */
  readonly role?: string;

  /**
   * Reference to a Role in iam to populate role.
   *
   * @schema PipelineSpecForProvider#roleRef
   */
  readonly roleRef?: PipelineSpecForProviderRoleRef;

  /**
   * Selector for a Role in iam to populate role.
   *
   * @schema PipelineSpecForProvider#roleSelector
   */
  readonly roleSelector?: PipelineSpecForProviderRoleSelector;

  /**
   * The ThumbnailConfig object specifies information about the Amazon S3 bucket in which you want Elastic Transcoder to save thumbnail files. (documented below)
   *
   * @schema PipelineSpecForProvider#thumbnailConfig
   */
  readonly thumbnailConfig?: PipelineSpecForProviderThumbnailConfig[];

  /**
   * The permissions for the thumbnail_config object. (documented below)
   *
   * @schema PipelineSpecForProvider#thumbnailConfigPermissions
   */
  readonly thumbnailConfigPermissions?: PipelineSpecForProviderThumbnailConfigPermissions[];

}

/**
 * Converts an object of type 'PipelineSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProvider(obj: PipelineSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsKmsKeyArn': obj.awsKmsKeyArn,
    'contentConfig': obj.contentConfig?.map(y => toJson_PipelineSpecForProviderContentConfig(y)),
    'contentConfigPermissions': obj.contentConfigPermissions?.map(y => toJson_PipelineSpecForProviderContentConfigPermissions(y)),
    'inputBucket': obj.inputBucket,
    'inputBucketRef': toJson_PipelineSpecForProviderInputBucketRef(obj.inputBucketRef),
    'inputBucketSelector': toJson_PipelineSpecForProviderInputBucketSelector(obj.inputBucketSelector),
    'name': obj.name,
    'notifications': obj.notifications?.map(y => toJson_PipelineSpecForProviderNotifications(y)),
    'outputBucket': obj.outputBucket,
    'region': obj.region,
    'role': obj.role,
    'roleRef': toJson_PipelineSpecForProviderRoleRef(obj.roleRef),
    'roleSelector': toJson_PipelineSpecForProviderRoleSelector(obj.roleSelector),
    'thumbnailConfig': obj.thumbnailConfig?.map(y => toJson_PipelineSpecForProviderThumbnailConfig(y)),
    'thumbnailConfigPermissions': obj.thumbnailConfigPermissions?.map(y => toJson_PipelineSpecForProviderThumbnailConfigPermissions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PipelineSpecProviderConfigRef
 */
export interface PipelineSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PipelineSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PipelineSpecProviderConfigRef#policy
   */
  readonly policy?: PipelineSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PipelineSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecProviderConfigRef(obj: PipelineSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PipelineSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PipelineSpecProviderRef
 */
export interface PipelineSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PipelineSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PipelineSpecProviderRef#policy
   */
  readonly policy?: PipelineSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PipelineSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecProviderRef(obj: PipelineSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PipelineSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PipelineSpecPublishConnectionDetailsTo
 */
export interface PipelineSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PipelineSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PipelineSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PipelineSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PipelineSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PipelineSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PipelineSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecPublishConnectionDetailsTo(obj: PipelineSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PipelineSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PipelineSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PipelineSpecWriteConnectionSecretToRef
 */
export interface PipelineSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PipelineSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PipelineSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PipelineSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecWriteConnectionSecretToRef(obj: PipelineSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PipelineSpecForProviderContentConfig
 */
export interface PipelineSpecForProviderContentConfig {
  /**
   * The Amazon S3 bucket in which you want Elastic Transcoder to save transcoded files and playlists.
   *
   * @schema PipelineSpecForProviderContentConfig#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema PipelineSpecForProviderContentConfig#bucketRef
   */
  readonly bucketRef?: PipelineSpecForProviderContentConfigBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema PipelineSpecForProviderContentConfig#bucketSelector
   */
  readonly bucketSelector?: PipelineSpecForProviderContentConfigBucketSelector;

  /**
   * The Amazon S3 storage class, Standard or ReducedRedundancy, that you want Elastic Transcoder to assign to the files and playlists that it stores in your Amazon S3 bucket.
   *
   * @schema PipelineSpecForProviderContentConfig#storageClass
   */
  readonly storageClass?: string;

}

/**
 * Converts an object of type 'PipelineSpecForProviderContentConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderContentConfig(obj: PipelineSpecForProviderContentConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_PipelineSpecForProviderContentConfigBucketRef(obj.bucketRef),
    'bucketSelector': toJson_PipelineSpecForProviderContentConfigBucketSelector(obj.bucketSelector),
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PipelineSpecForProviderContentConfigPermissions
 */
export interface PipelineSpecForProviderContentConfigPermissions {
  /**
   * The permission that you want to give to the AWS user that you specified in content_config_permissions.grantee. Valid values are Read, ReadAcp, WriteAcp or FullControl.
   *
   * @schema PipelineSpecForProviderContentConfigPermissions#access
   */
  readonly access?: string[];

  /**
   * The AWS user or group that you want to have access to transcoded files and playlists.
   *
   * @schema PipelineSpecForProviderContentConfigPermissions#grantee
   */
  readonly grantee?: string;

  /**
   * Specify the type of value that appears in the content_config_permissions.grantee object. Valid values are Canonical, Email or Group.
   *
   * @schema PipelineSpecForProviderContentConfigPermissions#granteeType
   */
  readonly granteeType?: string;

}

/**
 * Converts an object of type 'PipelineSpecForProviderContentConfigPermissions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderContentConfigPermissions(obj: PipelineSpecForProviderContentConfigPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'access': obj.access?.map(y => y),
    'grantee': obj.grantee,
    'granteeType': obj.granteeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate inputBucket.
 *
 * @schema PipelineSpecForProviderInputBucketRef
 */
export interface PipelineSpecForProviderInputBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema PipelineSpecForProviderInputBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PipelineSpecForProviderInputBucketRef#policy
   */
  readonly policy?: PipelineSpecForProviderInputBucketRefPolicy;

}

/**
 * Converts an object of type 'PipelineSpecForProviderInputBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderInputBucketRef(obj: PipelineSpecForProviderInputBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PipelineSpecForProviderInputBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate inputBucket.
 *
 * @schema PipelineSpecForProviderInputBucketSelector
 */
export interface PipelineSpecForProviderInputBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PipelineSpecForProviderInputBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PipelineSpecForProviderInputBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PipelineSpecForProviderInputBucketSelector#policy
   */
  readonly policy?: PipelineSpecForProviderInputBucketSelectorPolicy;

}

/**
 * Converts an object of type 'PipelineSpecForProviderInputBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderInputBucketSelector(obj: PipelineSpecForProviderInputBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PipelineSpecForProviderInputBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PipelineSpecForProviderNotifications
 */
export interface PipelineSpecForProviderNotifications {
  /**
   * The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder has finished processing a job in this pipeline.
   *
   * @schema PipelineSpecForProviderNotifications#completed
   */
  readonly completed?: string;

  /**
   * The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder encounters an error condition while processing a job in this pipeline.
   *
   * @schema PipelineSpecForProviderNotifications#error
   */
  readonly error?: string;

  /**
   * The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify when Elastic Transcoder has started to process a job in this pipeline.
   *
   * @schema PipelineSpecForProviderNotifications#progressing
   */
  readonly progressing?: string;

  /**
   * The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder encounters a warning condition while processing a job in this pipeline.
   *
   * @schema PipelineSpecForProviderNotifications#warning
   */
  readonly warning?: string;

}

/**
 * Converts an object of type 'PipelineSpecForProviderNotifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderNotifications(obj: PipelineSpecForProviderNotifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'completed': obj.completed,
    'error': obj.error,
    'progressing': obj.progressing,
    'warning': obj.warning,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate role.
 *
 * @schema PipelineSpecForProviderRoleRef
 */
export interface PipelineSpecForProviderRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema PipelineSpecForProviderRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PipelineSpecForProviderRoleRef#policy
   */
  readonly policy?: PipelineSpecForProviderRoleRefPolicy;

}

/**
 * Converts an object of type 'PipelineSpecForProviderRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderRoleRef(obj: PipelineSpecForProviderRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PipelineSpecForProviderRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate role.
 *
 * @schema PipelineSpecForProviderRoleSelector
 */
export interface PipelineSpecForProviderRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PipelineSpecForProviderRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PipelineSpecForProviderRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PipelineSpecForProviderRoleSelector#policy
   */
  readonly policy?: PipelineSpecForProviderRoleSelectorPolicy;

}

/**
 * Converts an object of type 'PipelineSpecForProviderRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderRoleSelector(obj: PipelineSpecForProviderRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PipelineSpecForProviderRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PipelineSpecForProviderThumbnailConfig
 */
export interface PipelineSpecForProviderThumbnailConfig {
  /**
   * The Amazon S3 bucket in which you want Elastic Transcoder to save transcoded files and playlists.
   *
   * @schema PipelineSpecForProviderThumbnailConfig#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema PipelineSpecForProviderThumbnailConfig#bucketRef
   */
  readonly bucketRef?: PipelineSpecForProviderThumbnailConfigBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema PipelineSpecForProviderThumbnailConfig#bucketSelector
   */
  readonly bucketSelector?: PipelineSpecForProviderThumbnailConfigBucketSelector;

  /**
   * The Amazon S3 storage class, Standard or ReducedRedundancy, that you want Elastic Transcoder to assign to the files and playlists that it stores in your Amazon S3 bucket.
   *
   * @schema PipelineSpecForProviderThumbnailConfig#storageClass
   */
  readonly storageClass?: string;

}

/**
 * Converts an object of type 'PipelineSpecForProviderThumbnailConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderThumbnailConfig(obj: PipelineSpecForProviderThumbnailConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_PipelineSpecForProviderThumbnailConfigBucketRef(obj.bucketRef),
    'bucketSelector': toJson_PipelineSpecForProviderThumbnailConfigBucketSelector(obj.bucketSelector),
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PipelineSpecForProviderThumbnailConfigPermissions
 */
export interface PipelineSpecForProviderThumbnailConfigPermissions {
  /**
   * The permission that you want to give to the AWS user that you specified in content_config_permissions.grantee. Valid values are Read, ReadAcp, WriteAcp or FullControl.
   *
   * @schema PipelineSpecForProviderThumbnailConfigPermissions#access
   */
  readonly access?: string[];

  /**
   * The AWS user or group that you want to have access to transcoded files and playlists.
   *
   * @schema PipelineSpecForProviderThumbnailConfigPermissions#grantee
   */
  readonly grantee?: string;

  /**
   * Specify the type of value that appears in the content_config_permissions.grantee object. Valid values are Canonical, Email or Group.
   *
   * @schema PipelineSpecForProviderThumbnailConfigPermissions#granteeType
   */
  readonly granteeType?: string;

}

/**
 * Converts an object of type 'PipelineSpecForProviderThumbnailConfigPermissions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderThumbnailConfigPermissions(obj: PipelineSpecForProviderThumbnailConfigPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'access': obj.access?.map(y => y),
    'grantee': obj.grantee,
    'granteeType': obj.granteeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PipelineSpecProviderConfigRefPolicy
 */
export interface PipelineSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PipelineSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PipelineSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecProviderConfigRefPolicy(obj: PipelineSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PipelineSpecProviderRefPolicy
 */
export interface PipelineSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PipelineSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PipelineSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecProviderRefPolicy(obj: PipelineSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PipelineSpecPublishConnectionDetailsToConfigRef
 */
export interface PipelineSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PipelineSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PipelineSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PipelineSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PipelineSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecPublishConnectionDetailsToConfigRef(obj: PipelineSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PipelineSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PipelineSpecPublishConnectionDetailsToMetadata
 */
export interface PipelineSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PipelineSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PipelineSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PipelineSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PipelineSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecPublishConnectionDetailsToMetadata(obj: PipelineSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema PipelineSpecForProviderContentConfigBucketRef
 */
export interface PipelineSpecForProviderContentConfigBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema PipelineSpecForProviderContentConfigBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PipelineSpecForProviderContentConfigBucketRef#policy
   */
  readonly policy?: PipelineSpecForProviderContentConfigBucketRefPolicy;

}

/**
 * Converts an object of type 'PipelineSpecForProviderContentConfigBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderContentConfigBucketRef(obj: PipelineSpecForProviderContentConfigBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PipelineSpecForProviderContentConfigBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema PipelineSpecForProviderContentConfigBucketSelector
 */
export interface PipelineSpecForProviderContentConfigBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PipelineSpecForProviderContentConfigBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PipelineSpecForProviderContentConfigBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PipelineSpecForProviderContentConfigBucketSelector#policy
   */
  readonly policy?: PipelineSpecForProviderContentConfigBucketSelectorPolicy;

}

/**
 * Converts an object of type 'PipelineSpecForProviderContentConfigBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderContentConfigBucketSelector(obj: PipelineSpecForProviderContentConfigBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PipelineSpecForProviderContentConfigBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PipelineSpecForProviderInputBucketRefPolicy
 */
export interface PipelineSpecForProviderInputBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecForProviderInputBucketRefPolicy#resolution
   */
  readonly resolution?: PipelineSpecForProviderInputBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecForProviderInputBucketRefPolicy#resolve
   */
  readonly resolve?: PipelineSpecForProviderInputBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecForProviderInputBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderInputBucketRefPolicy(obj: PipelineSpecForProviderInputBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PipelineSpecForProviderInputBucketSelectorPolicy
 */
export interface PipelineSpecForProviderInputBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecForProviderInputBucketSelectorPolicy#resolution
   */
  readonly resolution?: PipelineSpecForProviderInputBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecForProviderInputBucketSelectorPolicy#resolve
   */
  readonly resolve?: PipelineSpecForProviderInputBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecForProviderInputBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderInputBucketSelectorPolicy(obj: PipelineSpecForProviderInputBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PipelineSpecForProviderRoleRefPolicy
 */
export interface PipelineSpecForProviderRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecForProviderRoleRefPolicy#resolution
   */
  readonly resolution?: PipelineSpecForProviderRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecForProviderRoleRefPolicy#resolve
   */
  readonly resolve?: PipelineSpecForProviderRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecForProviderRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderRoleRefPolicy(obj: PipelineSpecForProviderRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PipelineSpecForProviderRoleSelectorPolicy
 */
export interface PipelineSpecForProviderRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecForProviderRoleSelectorPolicy#resolution
   */
  readonly resolution?: PipelineSpecForProviderRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecForProviderRoleSelectorPolicy#resolve
   */
  readonly resolve?: PipelineSpecForProviderRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecForProviderRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderRoleSelectorPolicy(obj: PipelineSpecForProviderRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema PipelineSpecForProviderThumbnailConfigBucketRef
 */
export interface PipelineSpecForProviderThumbnailConfigBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema PipelineSpecForProviderThumbnailConfigBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PipelineSpecForProviderThumbnailConfigBucketRef#policy
   */
  readonly policy?: PipelineSpecForProviderThumbnailConfigBucketRefPolicy;

}

/**
 * Converts an object of type 'PipelineSpecForProviderThumbnailConfigBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderThumbnailConfigBucketRef(obj: PipelineSpecForProviderThumbnailConfigBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PipelineSpecForProviderThumbnailConfigBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema PipelineSpecForProviderThumbnailConfigBucketSelector
 */
export interface PipelineSpecForProviderThumbnailConfigBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PipelineSpecForProviderThumbnailConfigBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PipelineSpecForProviderThumbnailConfigBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PipelineSpecForProviderThumbnailConfigBucketSelector#policy
   */
  readonly policy?: PipelineSpecForProviderThumbnailConfigBucketSelectorPolicy;

}

/**
 * Converts an object of type 'PipelineSpecForProviderThumbnailConfigBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderThumbnailConfigBucketSelector(obj: PipelineSpecForProviderThumbnailConfigBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PipelineSpecForProviderThumbnailConfigBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecProviderConfigRefPolicyResolution
 */
export enum PipelineSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecProviderConfigRefPolicyResolve
 */
export enum PipelineSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecProviderRefPolicyResolution
 */
export enum PipelineSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecProviderRefPolicyResolve
 */
export enum PipelineSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PipelineSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PipelineSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecPublishConnectionDetailsToConfigRefPolicy(obj: PipelineSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PipelineSpecForProviderContentConfigBucketRefPolicy
 */
export interface PipelineSpecForProviderContentConfigBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecForProviderContentConfigBucketRefPolicy#resolution
   */
  readonly resolution?: PipelineSpecForProviderContentConfigBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecForProviderContentConfigBucketRefPolicy#resolve
   */
  readonly resolve?: PipelineSpecForProviderContentConfigBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecForProviderContentConfigBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderContentConfigBucketRefPolicy(obj: PipelineSpecForProviderContentConfigBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PipelineSpecForProviderContentConfigBucketSelectorPolicy
 */
export interface PipelineSpecForProviderContentConfigBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecForProviderContentConfigBucketSelectorPolicy#resolution
   */
  readonly resolution?: PipelineSpecForProviderContentConfigBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecForProviderContentConfigBucketSelectorPolicy#resolve
   */
  readonly resolve?: PipelineSpecForProviderContentConfigBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecForProviderContentConfigBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderContentConfigBucketSelectorPolicy(obj: PipelineSpecForProviderContentConfigBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecForProviderInputBucketRefPolicyResolution
 */
export enum PipelineSpecForProviderInputBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecForProviderInputBucketRefPolicyResolve
 */
export enum PipelineSpecForProviderInputBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecForProviderInputBucketSelectorPolicyResolution
 */
export enum PipelineSpecForProviderInputBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecForProviderInputBucketSelectorPolicyResolve
 */
export enum PipelineSpecForProviderInputBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecForProviderRoleRefPolicyResolution
 */
export enum PipelineSpecForProviderRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecForProviderRoleRefPolicyResolve
 */
export enum PipelineSpecForProviderRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecForProviderRoleSelectorPolicyResolution
 */
export enum PipelineSpecForProviderRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecForProviderRoleSelectorPolicyResolve
 */
export enum PipelineSpecForProviderRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PipelineSpecForProviderThumbnailConfigBucketRefPolicy
 */
export interface PipelineSpecForProviderThumbnailConfigBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecForProviderThumbnailConfigBucketRefPolicy#resolution
   */
  readonly resolution?: PipelineSpecForProviderThumbnailConfigBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecForProviderThumbnailConfigBucketRefPolicy#resolve
   */
  readonly resolve?: PipelineSpecForProviderThumbnailConfigBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecForProviderThumbnailConfigBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderThumbnailConfigBucketRefPolicy(obj: PipelineSpecForProviderThumbnailConfigBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PipelineSpecForProviderThumbnailConfigBucketSelectorPolicy
 */
export interface PipelineSpecForProviderThumbnailConfigBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PipelineSpecForProviderThumbnailConfigBucketSelectorPolicy#resolution
   */
  readonly resolution?: PipelineSpecForProviderThumbnailConfigBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PipelineSpecForProviderThumbnailConfigBucketSelectorPolicy#resolve
   */
  readonly resolve?: PipelineSpecForProviderThumbnailConfigBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PipelineSpecForProviderThumbnailConfigBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PipelineSpecForProviderThumbnailConfigBucketSelectorPolicy(obj: PipelineSpecForProviderThumbnailConfigBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecForProviderContentConfigBucketRefPolicyResolution
 */
export enum PipelineSpecForProviderContentConfigBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecForProviderContentConfigBucketRefPolicyResolve
 */
export enum PipelineSpecForProviderContentConfigBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecForProviderContentConfigBucketSelectorPolicyResolution
 */
export enum PipelineSpecForProviderContentConfigBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecForProviderContentConfigBucketSelectorPolicyResolve
 */
export enum PipelineSpecForProviderContentConfigBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecForProviderThumbnailConfigBucketRefPolicyResolution
 */
export enum PipelineSpecForProviderThumbnailConfigBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecForProviderThumbnailConfigBucketRefPolicyResolve
 */
export enum PipelineSpecForProviderThumbnailConfigBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PipelineSpecForProviderThumbnailConfigBucketSelectorPolicyResolution
 */
export enum PipelineSpecForProviderThumbnailConfigBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PipelineSpecForProviderThumbnailConfigBucketSelectorPolicyResolve
 */
export enum PipelineSpecForProviderThumbnailConfigBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Preset is the Schema for the Presets API. Provides an Elastic Transcoder preset resource.
 *
 * @schema Preset
 */
export class Preset extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Preset"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elastictranscoder.aws.upbound.io/v1beta1',
    kind: 'Preset',
  }

  /**
   * Renders a Kubernetes manifest for "Preset".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PresetProps): any {
    return {
      ...Preset.GVK,
      ...toJson_PresetProps(props),
    };
  }

  /**
   * Defines a "Preset" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PresetProps) {
    super(scope, id, {
      ...Preset.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Preset.GVK,
      ...toJson_PresetProps(resolved),
    };
  }
}

/**
 * Preset is the Schema for the Presets API. Provides an Elastic Transcoder preset resource.
 *
 * @schema Preset
 */
export interface PresetProps {
  /**
   * @schema Preset#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PresetSpec defines the desired state of Preset
   *
   * @schema Preset#spec
   */
  readonly spec: PresetSpec;

}

/**
 * Converts an object of type 'PresetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetProps(obj: PresetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PresetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PresetSpec defines the desired state of Preset
 *
 * @schema PresetSpec
 */
export interface PresetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema PresetSpec#deletionPolicy
   */
  readonly deletionPolicy?: PresetSpecDeletionPolicy;

  /**
   * @schema PresetSpec#forProvider
   */
  readonly forProvider: PresetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PresetSpec#providerConfigRef
   */
  readonly providerConfigRef?: PresetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PresetSpec#providerRef
   */
  readonly providerRef?: PresetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PresetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PresetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PresetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PresetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PresetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpec(obj: PresetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PresetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_PresetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PresetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PresetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PresetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema PresetSpecDeletionPolicy
 */
export enum PresetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PresetSpecForProvider
 */
export interface PresetSpecForProvider {
  /**
   * Audio parameters object (documented below).
   *
   * @schema PresetSpecForProvider#audio
   */
  readonly audio?: PresetSpecForProviderAudio[];

  /**
   * Codec options for the audio parameters (documented below)
   *
   * @schema PresetSpecForProvider#audioCodecOptions
   */
  readonly audioCodecOptions?: PresetSpecForProviderAudioCodecOptions[];

  /**
   * The container type for the output file. Valid values are flac, flv, fmp4, gif, mp3, mp4, mpg, mxf, oga, ogg, ts, and webm.
   *
   * @schema PresetSpecForProvider#container
   */
  readonly container: string;

  /**
   * A description of the preset (maximum 255 characters)
   *
   * @schema PresetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the preset. (maximum 40 characters)
   *
   * @schema PresetSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PresetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Thumbnail parameters object (documented below)
   *
   * @schema PresetSpecForProvider#thumbnails
   */
  readonly thumbnails?: PresetSpecForProviderThumbnails[];

  /**
   * @schema PresetSpecForProvider#type
   */
  readonly type?: string;

  /**
   * Video parameters object (documented below)
   *
   * @schema PresetSpecForProvider#video
   */
  readonly video?: PresetSpecForProviderVideo[];

  /**
   * Codec options for the video parameters
   *
   * @schema PresetSpecForProvider#videoCodecOptions
   */
  readonly videoCodecOptions?: { [key: string]: string };

  /**
   * Watermark parameters for the video parameters (documented below)
   *
   * @schema PresetSpecForProvider#videoWatermarks
   */
  readonly videoWatermarks?: PresetSpecForProviderVideoWatermarks[];

}

/**
 * Converts an object of type 'PresetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecForProvider(obj: PresetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audio': obj.audio?.map(y => toJson_PresetSpecForProviderAudio(y)),
    'audioCodecOptions': obj.audioCodecOptions?.map(y => toJson_PresetSpecForProviderAudioCodecOptions(y)),
    'container': obj.container,
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'thumbnails': obj.thumbnails?.map(y => toJson_PresetSpecForProviderThumbnails(y)),
    'type': obj.type,
    'video': obj.video?.map(y => toJson_PresetSpecForProviderVideo(y)),
    'videoCodecOptions': ((obj.videoCodecOptions) === undefined) ? undefined : (Object.entries(obj.videoCodecOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'videoWatermarks': obj.videoWatermarks?.map(y => toJson_PresetSpecForProviderVideoWatermarks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PresetSpecProviderConfigRef
 */
export interface PresetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PresetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PresetSpecProviderConfigRef#policy
   */
  readonly policy?: PresetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PresetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecProviderConfigRef(obj: PresetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PresetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PresetSpecProviderRef
 */
export interface PresetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PresetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PresetSpecProviderRef#policy
   */
  readonly policy?: PresetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PresetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecProviderRef(obj: PresetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PresetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PresetSpecPublishConnectionDetailsTo
 */
export interface PresetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PresetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PresetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PresetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PresetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PresetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PresetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecPublishConnectionDetailsTo(obj: PresetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PresetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PresetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PresetSpecWriteConnectionSecretToRef
 */
export interface PresetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PresetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PresetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PresetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecWriteConnectionSecretToRef(obj: PresetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PresetSpecForProviderAudio
 */
export interface PresetSpecForProviderAudio {
  /**
   * The method of organizing audio channels and tracks. Use Audio:Channels to specify the number of channels in your output, and Audio:AudioPackingMode to specify the number of tracks and their relation to the channels. If you do not specify an Audio:AudioPackingMode, Elastic Transcoder uses SingleTrack.
   *
   * @schema PresetSpecForProviderAudio#audioPackingMode
   */
  readonly audioPackingMode?: string;

  /**
   * The bit rate of the audio stream in the output file, in kilobits/second. Enter an integer between 64 and 320, inclusive.
   *
   * @schema PresetSpecForProviderAudio#bitRate
   */
  readonly bitRate?: string;

  /**
   * The number of audio channels in the output file
   *
   * @schema PresetSpecForProviderAudio#channels
   */
  readonly channels?: string;

  /**
   * The audio codec for the output file. Valid values are AAC, flac, mp2, mp3, pcm, and vorbis.
   *
   * @schema PresetSpecForProviderAudio#codec
   */
  readonly codec?: string;

  /**
   * The sample rate of the audio stream in the output file, in hertz. Valid values are: auto, 22050, 32000, 44100, 48000, 96000
   *
   * @schema PresetSpecForProviderAudio#sampleRate
   */
  readonly sampleRate?: string;

}

/**
 * Converts an object of type 'PresetSpecForProviderAudio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecForProviderAudio(obj: PresetSpecForProviderAudio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioPackingMode': obj.audioPackingMode,
    'bitRate': obj.bitRate,
    'channels': obj.channels,
    'codec': obj.codec,
    'sampleRate': obj.sampleRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PresetSpecForProviderAudioCodecOptions
 */
export interface PresetSpecForProviderAudioCodecOptions {
  /**
   * The bit depth of a sample is how many bits of information are included in the audio samples. Valid values are 16 and 24. (FLAC/PCM Only)
   *
   * @schema PresetSpecForProviderAudioCodecOptions#bitDepth
   */
  readonly bitDepth?: string;

  /**
   * The order the bits of a PCM sample are stored in. The supported value is LittleEndian. (PCM Only)
   *
   * @schema PresetSpecForProviderAudioCodecOptions#bitOrder
   */
  readonly bitOrder?: string;

  /**
   * If you specified AAC for Audio:Codec, choose the AAC profile for the output file.
   *
   * @schema PresetSpecForProviderAudioCodecOptions#profile
   */
  readonly profile?: string;

  /**
   * Whether audio samples are represented with negative and positive numbers (signed) or only positive numbers (unsigned). The supported value is Signed. (PCM Only)
   *
   * @schema PresetSpecForProviderAudioCodecOptions#signed
   */
  readonly signed?: string;

}

/**
 * Converts an object of type 'PresetSpecForProviderAudioCodecOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecForProviderAudioCodecOptions(obj: PresetSpecForProviderAudioCodecOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bitDepth': obj.bitDepth,
    'bitOrder': obj.bitOrder,
    'profile': obj.profile,
    'signed': obj.signed,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PresetSpecForProviderThumbnails
 */
export interface PresetSpecForProviderThumbnails {
  /**
   * The aspect ratio of thumbnails. The following values are valid: auto, 1:1, 4:3, 3:2, 16:9
   *
   * @schema PresetSpecForProviderThumbnails#aspectRatio
   */
  readonly aspectRatio?: string;

  /**
   * The format of thumbnails, if any. Valid formats are jpg and png.
   *
   * @schema PresetSpecForProviderThumbnails#format
   */
  readonly format?: string;

  /**
   * The approximate number of seconds between thumbnails. The value must be an integer. The actual interval can vary by several seconds from one thumbnail to the next.
   *
   * @schema PresetSpecForProviderThumbnails#interval
   */
  readonly interval?: string;

  /**
   * The maximum height of thumbnails, in pixels. If you specify auto, Elastic Transcoder uses 1080 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 32 and 3072, inclusive.
   *
   * @schema PresetSpecForProviderThumbnails#maxHeight
   */
  readonly maxHeight?: string;

  /**
   * The maximum width of thumbnails, in pixels. If you specify auto, Elastic Transcoder uses 1920 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 32 and 4096, inclusive.
   *
   * @schema PresetSpecForProviderThumbnails#maxWidth
   */
  readonly maxWidth?: string;

  /**
   * When you set PaddingPolicy to Pad, Elastic Transcoder might add black bars to the top and bottom and/or left and right sides of thumbnails to make the total size of the thumbnails match the values that you specified for thumbnail MaxWidth and MaxHeight settings.
   *
   * @schema PresetSpecForProviderThumbnails#paddingPolicy
   */
  readonly paddingPolicy?: string;

  /**
   * The width and height of thumbnail files in pixels, in the format WidthxHeight, where both values are even integers. The values cannot exceed the width and height that you specified in the Video:Resolution object. (To better control resolution and aspect ratio of thumbnails, we recommend that you use the thumbnail values max_width, max_height, sizing_policy, and padding_policy instead of resolution and aspect_ratio. The two groups of settings are mutually exclusive. Do not use them together)
   *
   * @schema PresetSpecForProviderThumbnails#resolution
   */
  readonly resolution?: string;

  /**
   * A value that controls scaling of thumbnails. Valid values are: Fit, Fill, Stretch, Keep, ShrinkToFit, and ShrinkToFill.
   *
   * @schema PresetSpecForProviderThumbnails#sizingPolicy
   */
  readonly sizingPolicy?: string;

}

/**
 * Converts an object of type 'PresetSpecForProviderThumbnails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecForProviderThumbnails(obj: PresetSpecForProviderThumbnails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aspectRatio': obj.aspectRatio,
    'format': obj.format,
    'interval': obj.interval,
    'maxHeight': obj.maxHeight,
    'maxWidth': obj.maxWidth,
    'paddingPolicy': obj.paddingPolicy,
    'resolution': obj.resolution,
    'sizingPolicy': obj.sizingPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PresetSpecForProviderVideo
 */
export interface PresetSpecForProviderVideo {
  /**
   * The aspect ratio of thumbnails. The following values are valid: auto, 1:1, 4:3, 3:2, 16:9
   *
   * @schema PresetSpecForProviderVideo#aspectRatio
   */
  readonly aspectRatio?: string;

  /**
   * The bit rate of the audio stream in the output file, in kilobits/second. Enter an integer between 64 and 320, inclusive.
   *
   * @schema PresetSpecForProviderVideo#bitRate
   */
  readonly bitRate?: string;

  /**
   * The audio codec for the output file. Valid values are AAC, flac, mp2, mp3, pcm, and vorbis.
   *
   * @schema PresetSpecForProviderVideo#codec
   */
  readonly codec?: string;

  /**
   * The value that Elastic Transcoder adds to the metadata in the output file. If you set DisplayAspectRatio to auto, Elastic Transcoder chooses an aspect ratio that ensures square pixels. If you specify another option, Elastic Transcoder sets that value in the output file.
   *
   * @schema PresetSpecForProviderVideo#displayAspectRatio
   */
  readonly displayAspectRatio?: string;

  /**
   * Whether to use a fixed value for Video:FixedGOP. Not applicable for containers of type gif. Valid values are true and false. Also known as, Fixed Number of Frames Between Keyframes.
   *
   * @schema PresetSpecForProviderVideo#fixedGop
   */
  readonly fixedGop?: string;

  /**
   * The frames per second for the video stream in the output file. The following values are valid: auto, 10, 15, 23.97, 24, 25, 29.97, 30, 50, 60.
   *
   * @schema PresetSpecForProviderVideo#frameRate
   */
  readonly frameRate?: string;

  /**
   * The maximum number of frames between key frames. Not applicable for containers of type gif.
   *
   * @schema PresetSpecForProviderVideo#keyframesMaxDist
   */
  readonly keyframesMaxDist?: string;

  /**
   * If you specify auto for FrameRate, Elastic Transcoder uses the frame rate of the input video for the frame rate of the output video, up to the maximum frame rate. If you do not specify a MaxFrameRate, Elastic Transcoder will use a default of 30.
   *
   * @schema PresetSpecForProviderVideo#maxFrameRate
   */
  readonly maxFrameRate?: string;

  /**
   * The maximum height of thumbnails, in pixels. If you specify auto, Elastic Transcoder uses 1080 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 32 and 3072, inclusive.
   *
   * @schema PresetSpecForProviderVideo#maxHeight
   */
  readonly maxHeight?: string;

  /**
   * The maximum width of thumbnails, in pixels. If you specify auto, Elastic Transcoder uses 1920 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 32 and 4096, inclusive.
   *
   * @schema PresetSpecForProviderVideo#maxWidth
   */
  readonly maxWidth?: string;

  /**
   * When you set PaddingPolicy to Pad, Elastic Transcoder might add black bars to the top and bottom and/or left and right sides of thumbnails to make the total size of the thumbnails match the values that you specified for thumbnail MaxWidth and MaxHeight settings.
   *
   * @schema PresetSpecForProviderVideo#paddingPolicy
   */
  readonly paddingPolicy?: string;

  /**
   * The width and height of thumbnail files in pixels, in the format WidthxHeight, where both values are even integers. The values cannot exceed the width and height that you specified in the Video:Resolution object. (To better control resolution and aspect ratio of thumbnails, we recommend that you use the thumbnail values max_width, max_height, sizing_policy, and padding_policy instead of resolution and aspect_ratio. The two groups of settings are mutually exclusive. Do not use them together)
   *
   * @schema PresetSpecForProviderVideo#resolution
   */
  readonly resolution?: string;

  /**
   * A value that controls scaling of thumbnails. Valid values are: Fit, Fill, Stretch, Keep, ShrinkToFit, and ShrinkToFill.
   *
   * @schema PresetSpecForProviderVideo#sizingPolicy
   */
  readonly sizingPolicy?: string;

}

/**
 * Converts an object of type 'PresetSpecForProviderVideo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecForProviderVideo(obj: PresetSpecForProviderVideo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aspectRatio': obj.aspectRatio,
    'bitRate': obj.bitRate,
    'codec': obj.codec,
    'displayAspectRatio': obj.displayAspectRatio,
    'fixedGop': obj.fixedGop,
    'frameRate': obj.frameRate,
    'keyframesMaxDist': obj.keyframesMaxDist,
    'maxFrameRate': obj.maxFrameRate,
    'maxHeight': obj.maxHeight,
    'maxWidth': obj.maxWidth,
    'paddingPolicy': obj.paddingPolicy,
    'resolution': obj.resolution,
    'sizingPolicy': obj.sizingPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PresetSpecForProviderVideoWatermarks
 */
export interface PresetSpecForProviderVideoWatermarks {
  /**
   * The horizontal position of the watermark unless you specify a nonzero value for horzontal_offset.
   *
   * @schema PresetSpecForProviderVideoWatermarks#horizontalAlign
   */
  readonly horizontalAlign?: string;

  /**
   * The amount by which you want the horizontal position of the watermark to be offset from the position specified by horizontal_align.
   *
   * @schema PresetSpecForProviderVideoWatermarks#horizontalOffset
   */
  readonly horizontalOffset?: string;

  /**
   * A unique identifier for the settings for one watermark. The value of Id can be up to 40 characters long. You can specify settings for up to four watermarks.
   *
   * @schema PresetSpecForProviderVideoWatermarks#id
   */
  readonly id?: string;

  /**
   * The maximum height of thumbnails, in pixels. If you specify auto, Elastic Transcoder uses 1080 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 32 and 3072, inclusive.
   *
   * @schema PresetSpecForProviderVideoWatermarks#maxHeight
   */
  readonly maxHeight?: string;

  /**
   * The maximum width of thumbnails, in pixels. If you specify auto, Elastic Transcoder uses 1920 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 32 and 4096, inclusive.
   *
   * @schema PresetSpecForProviderVideoWatermarks#maxWidth
   */
  readonly maxWidth?: string;

  /**
   * A percentage that indicates how much you want a watermark to obscure the video in the location where it appears.
   *
   * @schema PresetSpecForProviderVideoWatermarks#opacity
   */
  readonly opacity?: string;

  /**
   * A value that controls scaling of thumbnails. Valid values are: Fit, Fill, Stretch, Keep, ShrinkToFit, and ShrinkToFill.
   *
   * @schema PresetSpecForProviderVideoWatermarks#sizingPolicy
   */
  readonly sizingPolicy?: string;

  /**
   * A value that determines how Elastic Transcoder interprets values that you specified for video_watermarks.horizontal_offset, video_watermarks.vertical_offset, video_watermarks.max_width, and video_watermarks.max_height. Valid values are Content and Frame.
   *
   * @schema PresetSpecForProviderVideoWatermarks#target
   */
  readonly target?: string;

  /**
   * The vertical position of the watermark unless you specify a nonzero value for vertical_align. Valid values are Top, Bottom, Center.
   *
   * @schema PresetSpecForProviderVideoWatermarks#verticalAlign
   */
  readonly verticalAlign?: string;

  /**
   * The amount by which you want the vertical position of the watermark to be offset from the position specified by vertical_align
   *
   * @schema PresetSpecForProviderVideoWatermarks#verticalOffset
   */
  readonly verticalOffset?: string;

}

/**
 * Converts an object of type 'PresetSpecForProviderVideoWatermarks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecForProviderVideoWatermarks(obj: PresetSpecForProviderVideoWatermarks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'horizontalAlign': obj.horizontalAlign,
    'horizontalOffset': obj.horizontalOffset,
    'id': obj.id,
    'maxHeight': obj.maxHeight,
    'maxWidth': obj.maxWidth,
    'opacity': obj.opacity,
    'sizingPolicy': obj.sizingPolicy,
    'target': obj.target,
    'verticalAlign': obj.verticalAlign,
    'verticalOffset': obj.verticalOffset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PresetSpecProviderConfigRefPolicy
 */
export interface PresetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PresetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PresetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PresetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PresetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PresetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecProviderConfigRefPolicy(obj: PresetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PresetSpecProviderRefPolicy
 */
export interface PresetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PresetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PresetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PresetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PresetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PresetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecProviderRefPolicy(obj: PresetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PresetSpecPublishConnectionDetailsToConfigRef
 */
export interface PresetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PresetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PresetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PresetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PresetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecPublishConnectionDetailsToConfigRef(obj: PresetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PresetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PresetSpecPublishConnectionDetailsToMetadata
 */
export interface PresetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PresetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PresetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PresetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PresetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecPublishConnectionDetailsToMetadata(obj: PresetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PresetSpecProviderConfigRefPolicyResolution
 */
export enum PresetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PresetSpecProviderConfigRefPolicyResolve
 */
export enum PresetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PresetSpecProviderRefPolicyResolution
 */
export enum PresetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PresetSpecProviderRefPolicyResolve
 */
export enum PresetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PresetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PresetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PresetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PresetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PresetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PresetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PresetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PresetSpecPublishConnectionDetailsToConfigRefPolicy(obj: PresetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PresetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PresetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PresetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PresetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

