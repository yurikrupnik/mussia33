// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * NotificationRule is the Schema for the NotificationRules API. Provides a CodeStar Notifications Rule
 *
 * @schema NotificationRule
 */
export class NotificationRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NotificationRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codestarnotifications.aws.upbound.io/v1beta1',
    kind: 'NotificationRule',
  }

  /**
   * Renders a Kubernetes manifest for "NotificationRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NotificationRuleProps): any {
    return {
      ...NotificationRule.GVK,
      ...toJson_NotificationRuleProps(props),
    };
  }

  /**
   * Defines a "NotificationRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NotificationRuleProps) {
    super(scope, id, {
      ...NotificationRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NotificationRule.GVK,
      ...toJson_NotificationRuleProps(resolved),
    };
  }
}

/**
 * NotificationRule is the Schema for the NotificationRules API. Provides a CodeStar Notifications Rule
 *
 * @schema NotificationRule
 */
export interface NotificationRuleProps {
  /**
   * @schema NotificationRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NotificationRuleSpec defines the desired state of NotificationRule
   *
   * @schema NotificationRule#spec
   */
  readonly spec: NotificationRuleSpec;

}

/**
 * Converts an object of type 'NotificationRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleProps(obj: NotificationRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NotificationRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NotificationRuleSpec defines the desired state of NotificationRule
 *
 * @schema NotificationRuleSpec
 */
export interface NotificationRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema NotificationRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: NotificationRuleSpecDeletionPolicy;

  /**
   * @schema NotificationRuleSpec#forProvider
   */
  readonly forProvider: NotificationRuleSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NotificationRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: NotificationRuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema NotificationRuleSpec#providerRef
   */
  readonly providerRef?: NotificationRuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NotificationRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NotificationRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NotificationRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NotificationRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NotificationRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpec(obj: NotificationRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NotificationRuleSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_NotificationRuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_NotificationRuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_NotificationRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NotificationRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema NotificationRuleSpecDeletionPolicy
 */
export enum NotificationRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NotificationRuleSpecForProvider
 */
export interface NotificationRuleSpecForProvider {
  /**
   * The level of detail to include in the notifications for this resource. Possible values are BASIC and FULL.
   *
   * @schema NotificationRuleSpecForProvider#detailType
   */
  readonly detailType: string;

  /**
   * A list of event types associated with this notification rule. For list of allowed events see here.
   *
   * @schema NotificationRuleSpecForProvider#eventTypeIds
   */
  readonly eventTypeIds: string[];

  /**
   * The name of notification rule.
   *
   * @schema NotificationRuleSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema NotificationRuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the resource to associate with the notification rule.
   *
   * @schema NotificationRuleSpecForProvider#resource
   */
  readonly resource?: string;

  /**
   * Reference to a Repository in codecommit to populate resource.
   *
   * @schema NotificationRuleSpecForProvider#resourceRef
   */
  readonly resourceRef?: NotificationRuleSpecForProviderResourceRef;

  /**
   * Selector for a Repository in codecommit to populate resource.
   *
   * @schema NotificationRuleSpecForProvider#resourceSelector
   */
  readonly resourceSelector?: NotificationRuleSpecForProviderResourceSelector;

  /**
   * The status of the notification rule. Possible values are ENABLED and DISABLED, default is ENABLED.
   *
   * @schema NotificationRuleSpecForProvider#status
   */
  readonly status?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema NotificationRuleSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration blocks containing notification target information. Can be specified multiple times. At least one target must be specified on creation.
   *
   * @schema NotificationRuleSpecForProvider#target
   */
  readonly target?: NotificationRuleSpecForProviderTarget[];

}

/**
 * Converts an object of type 'NotificationRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecForProvider(obj: NotificationRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'detailType': obj.detailType,
    'eventTypeIds': obj.eventTypeIds?.map(y => y),
    'name': obj.name,
    'region': obj.region,
    'resource': obj.resource,
    'resourceRef': toJson_NotificationRuleSpecForProviderResourceRef(obj.resourceRef),
    'resourceSelector': toJson_NotificationRuleSpecForProviderResourceSelector(obj.resourceSelector),
    'status': obj.status,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'target': obj.target?.map(y => toJson_NotificationRuleSpecForProviderTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NotificationRuleSpecProviderConfigRef
 */
export interface NotificationRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationRuleSpecProviderConfigRef#policy
   */
  readonly policy?: NotificationRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NotificationRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecProviderConfigRef(obj: NotificationRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema NotificationRuleSpecProviderRef
 */
export interface NotificationRuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationRuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationRuleSpecProviderRef#policy
   */
  readonly policy?: NotificationRuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'NotificationRuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecProviderRef(obj: NotificationRuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationRuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NotificationRuleSpecPublishConnectionDetailsTo
 */
export interface NotificationRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NotificationRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NotificationRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NotificationRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NotificationRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NotificationRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NotificationRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecPublishConnectionDetailsTo(obj: NotificationRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NotificationRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NotificationRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NotificationRuleSpecWriteConnectionSecretToRef
 */
export interface NotificationRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NotificationRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NotificationRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NotificationRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecWriteConnectionSecretToRef(obj: NotificationRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Repository in codecommit to populate resource.
 *
 * @schema NotificationRuleSpecForProviderResourceRef
 */
export interface NotificationRuleSpecForProviderResourceRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationRuleSpecForProviderResourceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationRuleSpecForProviderResourceRef#policy
   */
  readonly policy?: NotificationRuleSpecForProviderResourceRefPolicy;

}

/**
 * Converts an object of type 'NotificationRuleSpecForProviderResourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecForProviderResourceRef(obj: NotificationRuleSpecForProviderResourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationRuleSpecForProviderResourceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Repository in codecommit to populate resource.
 *
 * @schema NotificationRuleSpecForProviderResourceSelector
 */
export interface NotificationRuleSpecForProviderResourceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NotificationRuleSpecForProviderResourceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NotificationRuleSpecForProviderResourceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NotificationRuleSpecForProviderResourceSelector#policy
   */
  readonly policy?: NotificationRuleSpecForProviderResourceSelectorPolicy;

}

/**
 * Converts an object of type 'NotificationRuleSpecForProviderResourceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecForProviderResourceSelector(obj: NotificationRuleSpecForProviderResourceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NotificationRuleSpecForProviderResourceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NotificationRuleSpecForProviderTarget
 */
export interface NotificationRuleSpecForProviderTarget {
  /**
   * The ARN of notification rule target. For example, a SNS Topic ARN.
   *
   * @schema NotificationRuleSpecForProviderTarget#address
   */
  readonly address?: string;

  /**
   * Reference to a Topic in sns to populate address.
   *
   * @schema NotificationRuleSpecForProviderTarget#addressRef
   */
  readonly addressRef?: NotificationRuleSpecForProviderTargetAddressRef;

  /**
   * Selector for a Topic in sns to populate address.
   *
   * @schema NotificationRuleSpecForProviderTarget#addressSelector
   */
  readonly addressSelector?: NotificationRuleSpecForProviderTargetAddressSelector;

  /**
   * The type of the notification target. Default value is SNS.
   *
   * @schema NotificationRuleSpecForProviderTarget#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NotificationRuleSpecForProviderTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecForProviderTarget(obj: NotificationRuleSpecForProviderTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'addressRef': toJson_NotificationRuleSpecForProviderTargetAddressRef(obj.addressRef),
    'addressSelector': toJson_NotificationRuleSpecForProviderTargetAddressSelector(obj.addressSelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotificationRuleSpecProviderConfigRefPolicy
 */
export interface NotificationRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NotificationRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NotificationRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecProviderConfigRefPolicy(obj: NotificationRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotificationRuleSpecProviderRefPolicy
 */
export interface NotificationRuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationRuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: NotificationRuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationRuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: NotificationRuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationRuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecProviderRefPolicy(obj: NotificationRuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NotificationRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface NotificationRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NotificationRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecPublishConnectionDetailsToConfigRef(obj: NotificationRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NotificationRuleSpecPublishConnectionDetailsToMetadata
 */
export interface NotificationRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotificationRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotificationRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NotificationRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NotificationRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecPublishConnectionDetailsToMetadata(obj: NotificationRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotificationRuleSpecForProviderResourceRefPolicy
 */
export interface NotificationRuleSpecForProviderResourceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationRuleSpecForProviderResourceRefPolicy#resolution
   */
  readonly resolution?: NotificationRuleSpecForProviderResourceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationRuleSpecForProviderResourceRefPolicy#resolve
   */
  readonly resolve?: NotificationRuleSpecForProviderResourceRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationRuleSpecForProviderResourceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecForProviderResourceRefPolicy(obj: NotificationRuleSpecForProviderResourceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NotificationRuleSpecForProviderResourceSelectorPolicy
 */
export interface NotificationRuleSpecForProviderResourceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationRuleSpecForProviderResourceSelectorPolicy#resolution
   */
  readonly resolution?: NotificationRuleSpecForProviderResourceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationRuleSpecForProviderResourceSelectorPolicy#resolve
   */
  readonly resolve?: NotificationRuleSpecForProviderResourceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NotificationRuleSpecForProviderResourceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecForProviderResourceSelectorPolicy(obj: NotificationRuleSpecForProviderResourceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate address.
 *
 * @schema NotificationRuleSpecForProviderTargetAddressRef
 */
export interface NotificationRuleSpecForProviderTargetAddressRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationRuleSpecForProviderTargetAddressRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationRuleSpecForProviderTargetAddressRef#policy
   */
  readonly policy?: NotificationRuleSpecForProviderTargetAddressRefPolicy;

}

/**
 * Converts an object of type 'NotificationRuleSpecForProviderTargetAddressRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecForProviderTargetAddressRef(obj: NotificationRuleSpecForProviderTargetAddressRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationRuleSpecForProviderTargetAddressRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate address.
 *
 * @schema NotificationRuleSpecForProviderTargetAddressSelector
 */
export interface NotificationRuleSpecForProviderTargetAddressSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NotificationRuleSpecForProviderTargetAddressSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NotificationRuleSpecForProviderTargetAddressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NotificationRuleSpecForProviderTargetAddressSelector#policy
   */
  readonly policy?: NotificationRuleSpecForProviderTargetAddressSelectorPolicy;

}

/**
 * Converts an object of type 'NotificationRuleSpecForProviderTargetAddressSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecForProviderTargetAddressSelector(obj: NotificationRuleSpecForProviderTargetAddressSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NotificationRuleSpecForProviderTargetAddressSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationRuleSpecProviderConfigRefPolicyResolution
 */
export enum NotificationRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationRuleSpecProviderConfigRefPolicyResolve
 */
export enum NotificationRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationRuleSpecProviderRefPolicyResolution
 */
export enum NotificationRuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationRuleSpecProviderRefPolicyResolve
 */
export enum NotificationRuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationRuleSpecForProviderResourceRefPolicyResolution
 */
export enum NotificationRuleSpecForProviderResourceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationRuleSpecForProviderResourceRefPolicyResolve
 */
export enum NotificationRuleSpecForProviderResourceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationRuleSpecForProviderResourceSelectorPolicyResolution
 */
export enum NotificationRuleSpecForProviderResourceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationRuleSpecForProviderResourceSelectorPolicyResolve
 */
export enum NotificationRuleSpecForProviderResourceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NotificationRuleSpecForProviderTargetAddressRefPolicy
 */
export interface NotificationRuleSpecForProviderTargetAddressRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationRuleSpecForProviderTargetAddressRefPolicy#resolution
   */
  readonly resolution?: NotificationRuleSpecForProviderTargetAddressRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationRuleSpecForProviderTargetAddressRefPolicy#resolve
   */
  readonly resolve?: NotificationRuleSpecForProviderTargetAddressRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationRuleSpecForProviderTargetAddressRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecForProviderTargetAddressRefPolicy(obj: NotificationRuleSpecForProviderTargetAddressRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NotificationRuleSpecForProviderTargetAddressSelectorPolicy
 */
export interface NotificationRuleSpecForProviderTargetAddressSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationRuleSpecForProviderTargetAddressSelectorPolicy#resolution
   */
  readonly resolution?: NotificationRuleSpecForProviderTargetAddressSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationRuleSpecForProviderTargetAddressSelectorPolicy#resolve
   */
  readonly resolve?: NotificationRuleSpecForProviderTargetAddressSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NotificationRuleSpecForProviderTargetAddressSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationRuleSpecForProviderTargetAddressSelectorPolicy(obj: NotificationRuleSpecForProviderTargetAddressSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NotificationRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationRuleSpecForProviderTargetAddressRefPolicyResolution
 */
export enum NotificationRuleSpecForProviderTargetAddressRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationRuleSpecForProviderTargetAddressRefPolicyResolve
 */
export enum NotificationRuleSpecForProviderTargetAddressRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationRuleSpecForProviderTargetAddressSelectorPolicyResolution
 */
export enum NotificationRuleSpecForProviderTargetAddressSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationRuleSpecForProviderTargetAddressSelectorPolicyResolve
 */
export enum NotificationRuleSpecForProviderTargetAddressSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

