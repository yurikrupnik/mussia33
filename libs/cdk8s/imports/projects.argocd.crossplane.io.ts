// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A Project is a managed resource that represents an ArgoCD Git Project
 *
 * @schema Project
 */
export class Project extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Project"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projects.argocd.crossplane.io/v1alpha1',
    kind: 'Project',
  }

  /**
   * Renders a Kubernetes manifest for "Project".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectProps): any {
    return {
      ...Project.GVK,
      ...toJson_ProjectProps(props),
    };
  }

  /**
   * Defines a "Project" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectProps) {
    super(scope, id, {
      ...Project.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Project.GVK,
      ...toJson_ProjectProps(resolved),
    };
  }
}

/**
 * A Project is a managed resource that represents an ArgoCD Git Project
 *
 * @schema Project
 */
export interface ProjectProps {
  /**
   * @schema Project#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ProjectSpec defines the desired state of an ArgoCD Project.
   *
   * @schema Project#spec
   */
  readonly spec: ProjectSpec;

}

/**
 * Converts an object of type 'ProjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectProps(obj: ProjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ProjectSpec defines the desired state of an ArgoCD Project.
 *
 * @schema ProjectSpec
 */
export interface ProjectSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ProjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectSpecDeletionPolicy;

  /**
   * ProjectParameters define the desired state of an ArgoCD Git Project
   *
   * @schema ProjectSpec#forProvider
   */
  readonly forProvider: ProjectSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ProjectSpec#providerRef
   */
  readonly providerRef?: ProjectSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpec(obj: ProjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ProjectSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ProjectSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ProjectSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ProjectSpecDeletionPolicy
 */
export enum ProjectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ProjectParameters define the desired state of an ArgoCD Git Project
 *
 * @schema ProjectSpecForProvider
 */
export interface ProjectSpecForProvider {
  /**
   * ClusterResourceBlacklist contains list of blacklisted cluster level resources
   *
   * @schema ProjectSpecForProvider#clusterResourceBlacklist
   */
  readonly clusterResourceBlacklist?: ProjectSpecForProviderClusterResourceBlacklist[];

  /**
   * ClusterResourceWhitelist contains list of whitelisted cluster level resources
   *
   * @schema ProjectSpecForProvider#clusterResourceWhitelist
   */
  readonly clusterResourceWhitelist?: ProjectSpecForProviderClusterResourceWhitelist[];

  /**
   * Description contains optional project description
   *
   * @schema ProjectSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Destinations contains list of destinations available for deployment
   *
   * @schema ProjectSpecForProvider#destinations
   */
  readonly destinations?: ProjectSpecForProviderDestinations[];

  /**
   * NamespaceResourceBlacklist contains list of blacklisted namespace level resources
   *
   * @schema ProjectSpecForProvider#namespaceResourceBlacklist
   */
  readonly namespaceResourceBlacklist?: ProjectSpecForProviderNamespaceResourceBlacklist[];

  /**
   * NamespaceResourceWhitelist contains list of whitelisted namespace level resources
   *
   * @schema ProjectSpecForProvider#namespaceResourceWhitelist
   */
  readonly namespaceResourceWhitelist?: ProjectSpecForProviderNamespaceResourceWhitelist[];

  /**
   * OrphanedResources specifies if controller should monitor orphaned resources of apps in this project
   *
   * @schema ProjectSpecForProvider#orphanedResources
   */
  readonly orphanedResources?: ProjectSpecForProviderOrphanedResources;

  /**
   * Roles are user defined RBAC roles associated with this project
   *
   * @schema ProjectSpecForProvider#roles
   */
  readonly roles?: ProjectSpecForProviderRoles[];

  /**
   * SignatureKeys contains a list of PGP key IDs that commits in Git must be signed with in order to be allowed for sync
   *
   * @schema ProjectSpecForProvider#signatureKeys
   */
  readonly signatureKeys?: ProjectSpecForProviderSignatureKeys[];

  /**
   * SourceRepos contains list of repository URLs which can be used for deployment
   *
   * @schema ProjectSpecForProvider#sourceRepos
   */
  readonly sourceRepos?: string[];

  /**
   * SourceReposRefs is a reference to an array of Repository used to set SourceRepos
   *
   * @schema ProjectSpecForProvider#sourceReposRefs
   */
  readonly sourceReposRefs?: ProjectSpecForProviderSourceReposRefs[];

  /**
   * SourceReposSelector selects references to Repositories used to set SourceRepos
   *
   * @schema ProjectSpecForProvider#sourceReposSelector
   */
  readonly sourceReposSelector?: ProjectSpecForProviderSourceReposSelector;

  /**
   * SyncWindows controls when syncs can be run for apps in this project
   *
   * @schema ProjectSpecForProvider#syncWindows
   */
  readonly syncWindows?: ProjectSpecForProviderSyncWindows[];

}

/**
 * Converts an object of type 'ProjectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProvider(obj: ProjectSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterResourceBlacklist': obj.clusterResourceBlacklist?.map(y => toJson_ProjectSpecForProviderClusterResourceBlacklist(y)),
    'clusterResourceWhitelist': obj.clusterResourceWhitelist?.map(y => toJson_ProjectSpecForProviderClusterResourceWhitelist(y)),
    'description': obj.description,
    'destinations': obj.destinations?.map(y => toJson_ProjectSpecForProviderDestinations(y)),
    'namespaceResourceBlacklist': obj.namespaceResourceBlacklist?.map(y => toJson_ProjectSpecForProviderNamespaceResourceBlacklist(y)),
    'namespaceResourceWhitelist': obj.namespaceResourceWhitelist?.map(y => toJson_ProjectSpecForProviderNamespaceResourceWhitelist(y)),
    'orphanedResources': toJson_ProjectSpecForProviderOrphanedResources(obj.orphanedResources),
    'roles': obj.roles?.map(y => toJson_ProjectSpecForProviderRoles(y)),
    'signatureKeys': obj.signatureKeys?.map(y => toJson_ProjectSpecForProviderSignatureKeys(y)),
    'sourceRepos': obj.sourceRepos?.map(y => y),
    'sourceReposRefs': obj.sourceReposRefs?.map(y => toJson_ProjectSpecForProviderSourceReposRefs(y)),
    'sourceReposSelector': toJson_ProjectSpecForProviderSourceReposSelector(obj.sourceReposSelector),
    'syncWindows': obj.syncWindows?.map(y => toJson_ProjectSpecForProviderSyncWindows(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectSpecProviderConfigRef
 */
export interface ProjectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderConfigRef(obj: ProjectSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ProjectSpecProviderRef
 */
export interface ProjectSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecProviderRef#policy
   */
  readonly policy?: ProjectSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderRef(obj: ProjectSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectSpecPublishConnectionDetailsTo
 */
export interface ProjectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsTo(obj: ProjectSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectSpecWriteConnectionSecretToRef
 */
export interface ProjectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecWriteConnectionSecretToRef(obj: ProjectSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying concepts during lookup stages without having partially valid types
 *
 * @schema ProjectSpecForProviderClusterResourceBlacklist
 */
export interface ProjectSpecForProviderClusterResourceBlacklist {
  /**
   * @schema ProjectSpecForProviderClusterResourceBlacklist#group
   */
  readonly group: string;

  /**
   * @schema ProjectSpecForProviderClusterResourceBlacklist#kind
   */
  readonly kind: string;

}

/**
 * Converts an object of type 'ProjectSpecForProviderClusterResourceBlacklist' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderClusterResourceBlacklist(obj: ProjectSpecForProviderClusterResourceBlacklist | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying concepts during lookup stages without having partially valid types
 *
 * @schema ProjectSpecForProviderClusterResourceWhitelist
 */
export interface ProjectSpecForProviderClusterResourceWhitelist {
  /**
   * @schema ProjectSpecForProviderClusterResourceWhitelist#group
   */
  readonly group: string;

  /**
   * @schema ProjectSpecForProviderClusterResourceWhitelist#kind
   */
  readonly kind: string;

}

/**
 * Converts an object of type 'ProjectSpecForProviderClusterResourceWhitelist' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderClusterResourceWhitelist(obj: ProjectSpecForProviderClusterResourceWhitelist | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationDestination holds information about the application's destination
 *
 * @schema ProjectSpecForProviderDestinations
 */
export interface ProjectSpecForProviderDestinations {
  /**
   * Name is an alternate way of specifying the target cluster by its symbolic name
   *
   * @schema ProjectSpecForProviderDestinations#name
   */
  readonly name?: string;

  /**
   * Namespace specifies the target namespace for the application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace
   *
   * @schema ProjectSpecForProviderDestinations#namespace
   */
  readonly namespace?: string;

  /**
   * Server specifies the URL of the target cluster and must be set to the Kubernetes control plane API
   *
   * @schema ProjectSpecForProviderDestinations#server
   */
  readonly server?: string;

  /**
   * ServerRef is a reference to an Cluster used to set Server
   *
   * @schema ProjectSpecForProviderDestinations#serverRef
   */
  readonly serverRef?: ProjectSpecForProviderDestinationsServerRef;

  /**
   * SourceReposSelector selects references to Repositories used to set SourceRepos
   *
   * @schema ProjectSpecForProviderDestinations#serverSelector
   */
  readonly serverSelector?: ProjectSpecForProviderDestinationsServerSelector;

}

/**
 * Converts an object of type 'ProjectSpecForProviderDestinations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderDestinations(obj: ProjectSpecForProviderDestinations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'server': obj.server,
    'serverRef': toJson_ProjectSpecForProviderDestinationsServerRef(obj.serverRef),
    'serverSelector': toJson_ProjectSpecForProviderDestinationsServerSelector(obj.serverSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying concepts during lookup stages without having partially valid types
 *
 * @schema ProjectSpecForProviderNamespaceResourceBlacklist
 */
export interface ProjectSpecForProviderNamespaceResourceBlacklist {
  /**
   * @schema ProjectSpecForProviderNamespaceResourceBlacklist#group
   */
  readonly group: string;

  /**
   * @schema ProjectSpecForProviderNamespaceResourceBlacklist#kind
   */
  readonly kind: string;

}

/**
 * Converts an object of type 'ProjectSpecForProviderNamespaceResourceBlacklist' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderNamespaceResourceBlacklist(obj: ProjectSpecForProviderNamespaceResourceBlacklist | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying concepts during lookup stages without having partially valid types
 *
 * @schema ProjectSpecForProviderNamespaceResourceWhitelist
 */
export interface ProjectSpecForProviderNamespaceResourceWhitelist {
  /**
   * @schema ProjectSpecForProviderNamespaceResourceWhitelist#group
   */
  readonly group: string;

  /**
   * @schema ProjectSpecForProviderNamespaceResourceWhitelist#kind
   */
  readonly kind: string;

}

/**
 * Converts an object of type 'ProjectSpecForProviderNamespaceResourceWhitelist' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderNamespaceResourceWhitelist(obj: ProjectSpecForProviderNamespaceResourceWhitelist | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrphanedResources specifies if controller should monitor orphaned resources of apps in this project
 *
 * @schema ProjectSpecForProviderOrphanedResources
 */
export interface ProjectSpecForProviderOrphanedResources {
  /**
   * Ignore contains a list of resources that are to be excluded from orphaned resources monitoring
   *
   * @schema ProjectSpecForProviderOrphanedResources#ignore
   */
  readonly ignore?: ProjectSpecForProviderOrphanedResourcesIgnore[];

  /**
   * Warn indicates if warning condition should be created for apps which have orphaned resources
   *
   * @schema ProjectSpecForProviderOrphanedResources#warn
   */
  readonly warn?: boolean;

}

/**
 * Converts an object of type 'ProjectSpecForProviderOrphanedResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderOrphanedResources(obj: ProjectSpecForProviderOrphanedResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignore': obj.ignore?.map(y => toJson_ProjectSpecForProviderOrphanedResourcesIgnore(y)),
    'warn': obj.warn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectRole represents a role that has access to a project
 *
 * @schema ProjectSpecForProviderRoles
 */
export interface ProjectSpecForProviderRoles {
  /**
   * Description is a description of the role
   *
   * @schema ProjectSpecForProviderRoles#description
   */
  readonly description?: string;

  /**
   * Groups are a list of OIDC group claims bound to this role
   *
   * @schema ProjectSpecForProviderRoles#groups
   */
  readonly groups?: string[];

  /**
   * JWTTokens are a list of generated JWT tokens bound to this role
   *
   * @schema ProjectSpecForProviderRoles#jwtTokens
   */
  readonly jwtTokens?: ProjectSpecForProviderRolesJwtTokens[];

  /**
   * Name is a name for this role
   *
   * @schema ProjectSpecForProviderRoles#name
   */
  readonly name: string;

  /**
   * Policies Stores a list of casbin formated strings that define access policies for the role in the project
   *
   * @schema ProjectSpecForProviderRoles#policies
   */
  readonly policies?: string[];

}

/**
 * Converts an object of type 'ProjectSpecForProviderRoles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderRoles(obj: ProjectSpecForProviderRoles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'groups': obj.groups?.map(y => y),
    'jwtTokens': obj.jwtTokens?.map(y => toJson_ProjectSpecForProviderRolesJwtTokens(y)),
    'name': obj.name,
    'policies': obj.policies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SignatureKey is the specification of a key required to verify commit signatures with
 *
 * @schema ProjectSpecForProviderSignatureKeys
 */
export interface ProjectSpecForProviderSignatureKeys {
  /**
   * The ID of the key in hexadecimal notation
   *
   * @schema ProjectSpecForProviderSignatureKeys#keyID
   */
  readonly keyId: string;

}

/**
 * Converts an object of type 'ProjectSpecForProviderSignatureKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderSignatureKeys(obj: ProjectSpecForProviderSignatureKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyID': obj.keyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ProjectSpecForProviderSourceReposRefs
 */
export interface ProjectSpecForProviderSourceReposRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecForProviderSourceReposRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecForProviderSourceReposRefs#policy
   */
  readonly policy?: ProjectSpecForProviderSourceReposRefsPolicy;

}

/**
 * Converts an object of type 'ProjectSpecForProviderSourceReposRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderSourceReposRefs(obj: ProjectSpecForProviderSourceReposRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecForProviderSourceReposRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceReposSelector selects references to Repositories used to set SourceRepos
 *
 * @schema ProjectSpecForProviderSourceReposSelector
 */
export interface ProjectSpecForProviderSourceReposSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectSpecForProviderSourceReposSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectSpecForProviderSourceReposSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectSpecForProviderSourceReposSelector#policy
   */
  readonly policy?: ProjectSpecForProviderSourceReposSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectSpecForProviderSourceReposSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderSourceReposSelector(obj: ProjectSpecForProviderSourceReposSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectSpecForProviderSourceReposSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SyncWindow contains the kind, time, duration and attributes that are used to assign the syncWindows to apps
 *
 * @schema ProjectSpecForProviderSyncWindows
 */
export interface ProjectSpecForProviderSyncWindows {
  /**
   * Applications contains a list of applications that the window will apply to
   *
   * @schema ProjectSpecForProviderSyncWindows#applications
   */
  readonly applications?: string[];

  /**
   * Clusters contains a list of clusters that the window will apply to
   *
   * @schema ProjectSpecForProviderSyncWindows#clusters
   */
  readonly clusters?: string[];

  /**
   * Duration is the amount of time the sync window will be open
   *
   * @schema ProjectSpecForProviderSyncWindows#duration
   */
  readonly duration?: string;

  /**
   * Kind defines if the window allows or blocks syncs
   *
   * @schema ProjectSpecForProviderSyncWindows#kind
   */
  readonly kind?: string;

  /**
   * ManualSync enables manual syncs when they would otherwise be blocked
   *
   * @schema ProjectSpecForProviderSyncWindows#manualSync
   */
  readonly manualSync?: boolean;

  /**
   * Namespaces contains a list of namespaces that the window will apply to
   *
   * @schema ProjectSpecForProviderSyncWindows#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Schedule is the time the window will begin, specified in cron format
   *
   * @schema ProjectSpecForProviderSyncWindows#schedule
   */
  readonly schedule?: string;

}

/**
 * Converts an object of type 'ProjectSpecForProviderSyncWindows' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderSyncWindows(obj: ProjectSpecForProviderSyncWindows | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applications': obj.applications?.map(y => y),
    'clusters': obj.clusters?.map(y => y),
    'duration': obj.duration,
    'kind': obj.kind,
    'manualSync': obj.manualSync,
    'namespaces': obj.namespaces?.map(y => y),
    'schedule': obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecProviderConfigRefPolicy
 */
export interface ProjectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderConfigRefPolicy(obj: ProjectSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecProviderRefPolicy
 */
export interface ProjectSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderRefPolicy(obj: ProjectSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToConfigRef(obj: ProjectSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToMetadata(obj: ProjectSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServerRef is a reference to an Cluster used to set Server
 *
 * @schema ProjectSpecForProviderDestinationsServerRef
 */
export interface ProjectSpecForProviderDestinationsServerRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecForProviderDestinationsServerRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecForProviderDestinationsServerRef#policy
   */
  readonly policy?: ProjectSpecForProviderDestinationsServerRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecForProviderDestinationsServerRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderDestinationsServerRef(obj: ProjectSpecForProviderDestinationsServerRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecForProviderDestinationsServerRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceReposSelector selects references to Repositories used to set SourceRepos
 *
 * @schema ProjectSpecForProviderDestinationsServerSelector
 */
export interface ProjectSpecForProviderDestinationsServerSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectSpecForProviderDestinationsServerSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectSpecForProviderDestinationsServerSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectSpecForProviderDestinationsServerSelector#policy
   */
  readonly policy?: ProjectSpecForProviderDestinationsServerSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectSpecForProviderDestinationsServerSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderDestinationsServerSelector(obj: ProjectSpecForProviderDestinationsServerSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectSpecForProviderDestinationsServerSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrphanedResourceKey is a reference to a resource to be ignored from
 *
 * @schema ProjectSpecForProviderOrphanedResourcesIgnore
 */
export interface ProjectSpecForProviderOrphanedResourcesIgnore {
  /**
   * @schema ProjectSpecForProviderOrphanedResourcesIgnore#group
   */
  readonly group?: string;

  /**
   * @schema ProjectSpecForProviderOrphanedResourcesIgnore#kind
   */
  readonly kind?: string;

  /**
   * @schema ProjectSpecForProviderOrphanedResourcesIgnore#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectSpecForProviderOrphanedResourcesIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderOrphanedResourcesIgnore(obj: ProjectSpecForProviderOrphanedResourcesIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JWTToken holds the issuedAt and expiresAt values of a token
 *
 * @schema ProjectSpecForProviderRolesJwtTokens
 */
export interface ProjectSpecForProviderRolesJwtTokens {
  /**
   * @schema ProjectSpecForProviderRolesJwtTokens#exp
   */
  readonly exp?: number;

  /**
   * @schema ProjectSpecForProviderRolesJwtTokens#iat
   */
  readonly iat: number;

  /**
   * @schema ProjectSpecForProviderRolesJwtTokens#id
   */
  readonly id?: string;

}

/**
 * Converts an object of type 'ProjectSpecForProviderRolesJwtTokens' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderRolesJwtTokens(obj: ProjectSpecForProviderRolesJwtTokens | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exp': obj.exp,
    'iat': obj.iat,
    'id': obj.id,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecForProviderSourceReposRefsPolicy
 */
export interface ProjectSpecForProviderSourceReposRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecForProviderSourceReposRefsPolicy#resolution
   */
  readonly resolution?: ProjectSpecForProviderSourceReposRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecForProviderSourceReposRefsPolicy#resolve
   */
  readonly resolve?: ProjectSpecForProviderSourceReposRefsPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecForProviderSourceReposRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderSourceReposRefsPolicy(obj: ProjectSpecForProviderSourceReposRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectSpecForProviderSourceReposSelectorPolicy
 */
export interface ProjectSpecForProviderSourceReposSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecForProviderSourceReposSelectorPolicy#resolution
   */
  readonly resolution?: ProjectSpecForProviderSourceReposSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecForProviderSourceReposSelectorPolicy#resolve
   */
  readonly resolve?: ProjectSpecForProviderSourceReposSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecForProviderSourceReposSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderSourceReposSelectorPolicy(obj: ProjectSpecForProviderSourceReposSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecProviderConfigRefPolicyResolution
 */
export enum ProjectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecProviderConfigRefPolicyResolve
 */
export enum ProjectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecProviderRefPolicyResolution
 */
export enum ProjectSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecProviderRefPolicyResolve
 */
export enum ProjectSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecForProviderDestinationsServerRefPolicy
 */
export interface ProjectSpecForProviderDestinationsServerRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecForProviderDestinationsServerRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecForProviderDestinationsServerRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecForProviderDestinationsServerRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecForProviderDestinationsServerRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecForProviderDestinationsServerRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderDestinationsServerRefPolicy(obj: ProjectSpecForProviderDestinationsServerRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectSpecForProviderDestinationsServerSelectorPolicy
 */
export interface ProjectSpecForProviderDestinationsServerSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecForProviderDestinationsServerSelectorPolicy#resolution
   */
  readonly resolution?: ProjectSpecForProviderDestinationsServerSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecForProviderDestinationsServerSelectorPolicy#resolve
   */
  readonly resolve?: ProjectSpecForProviderDestinationsServerSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecForProviderDestinationsServerSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderDestinationsServerSelectorPolicy(obj: ProjectSpecForProviderDestinationsServerSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecForProviderSourceReposRefsPolicyResolution
 */
export enum ProjectSpecForProviderSourceReposRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecForProviderSourceReposRefsPolicyResolve
 */
export enum ProjectSpecForProviderSourceReposRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecForProviderSourceReposSelectorPolicyResolution
 */
export enum ProjectSpecForProviderSourceReposSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecForProviderSourceReposSelectorPolicyResolve
 */
export enum ProjectSpecForProviderSourceReposSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecForProviderDestinationsServerRefPolicyResolution
 */
export enum ProjectSpecForProviderDestinationsServerRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecForProviderDestinationsServerRefPolicyResolve
 */
export enum ProjectSpecForProviderDestinationsServerRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecForProviderDestinationsServerSelectorPolicyResolution
 */
export enum ProjectSpecForProviderDestinationsServerSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecForProviderDestinationsServerSelectorPolicyResolve
 */
export enum ProjectSpecForProviderDestinationsServerSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

