// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * GeofenceCollection is the Schema for the GeofenceCollections API.
 *
 * @schema GeofenceCollection
 */
export class GeofenceCollection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GeofenceCollection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'location.aws.upbound.io/v1beta1',
    kind: 'GeofenceCollection',
  }

  /**
   * Renders a Kubernetes manifest for "GeofenceCollection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GeofenceCollectionProps): any {
    return {
      ...GeofenceCollection.GVK,
      ...toJson_GeofenceCollectionProps(props),
    };
  }

  /**
   * Defines a "GeofenceCollection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GeofenceCollectionProps) {
    super(scope, id, {
      ...GeofenceCollection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GeofenceCollection.GVK,
      ...toJson_GeofenceCollectionProps(resolved),
    };
  }
}

/**
 * GeofenceCollection is the Schema for the GeofenceCollections API.
 *
 * @schema GeofenceCollection
 */
export interface GeofenceCollectionProps {
  /**
   * @schema GeofenceCollection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GeofenceCollectionSpec defines the desired state of GeofenceCollection
   *
   * @schema GeofenceCollection#spec
   */
  readonly spec: GeofenceCollectionSpec;

}

/**
 * Converts an object of type 'GeofenceCollectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionProps(obj: GeofenceCollectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GeofenceCollectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GeofenceCollectionSpec defines the desired state of GeofenceCollection
 *
 * @schema GeofenceCollectionSpec
 */
export interface GeofenceCollectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GeofenceCollectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: GeofenceCollectionSpecDeletionPolicy;

  /**
   * @schema GeofenceCollectionSpec#forProvider
   */
  readonly forProvider: GeofenceCollectionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema GeofenceCollectionSpec#initProvider
   */
  readonly initProvider?: GeofenceCollectionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GeofenceCollectionSpec#managementPolicies
   */
  readonly managementPolicies?: GeofenceCollectionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GeofenceCollectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: GeofenceCollectionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GeofenceCollectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GeofenceCollectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GeofenceCollectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GeofenceCollectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GeofenceCollectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpec(obj: GeofenceCollectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GeofenceCollectionSpecForProvider(obj.forProvider),
    'initProvider': toJson_GeofenceCollectionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GeofenceCollectionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GeofenceCollectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GeofenceCollectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GeofenceCollectionSpecDeletionPolicy
 */
export enum GeofenceCollectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GeofenceCollectionSpecForProvider
 */
export interface GeofenceCollectionSpecForProvider {
  /**
   * The optional description for the geofence collection.
   *
   * @schema GeofenceCollectionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A key identifier for an AWS KMS customer managed key assigned to the Amazon Location resource.
   *
   * @schema GeofenceCollectionSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema GeofenceCollectionSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: GeofenceCollectionSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema GeofenceCollectionSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: GeofenceCollectionSpecForProviderKmsKeyIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GeofenceCollectionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema GeofenceCollectionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'GeofenceCollectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecForProvider(obj: GeofenceCollectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_GeofenceCollectionSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_GeofenceCollectionSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema GeofenceCollectionSpecInitProvider
 */
export interface GeofenceCollectionSpecInitProvider {
  /**
   * The optional description for the geofence collection.
   *
   * @schema GeofenceCollectionSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema GeofenceCollectionSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'GeofenceCollectionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecInitProvider(obj: GeofenceCollectionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GeofenceCollectionSpecManagementPolicies
 */
export enum GeofenceCollectionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GeofenceCollectionSpecProviderConfigRef
 */
export interface GeofenceCollectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GeofenceCollectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GeofenceCollectionSpecProviderConfigRef#policy
   */
  readonly policy?: GeofenceCollectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecProviderConfigRef(obj: GeofenceCollectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GeofenceCollectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsTo
 */
export interface GeofenceCollectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GeofenceCollectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GeofenceCollectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecPublishConnectionDetailsTo(obj: GeofenceCollectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GeofenceCollectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GeofenceCollectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GeofenceCollectionSpecWriteConnectionSecretToRef
 */
export interface GeofenceCollectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GeofenceCollectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GeofenceCollectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecWriteConnectionSecretToRef(obj: GeofenceCollectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdRef
 */
export interface GeofenceCollectionSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecForProviderKmsKeyIdRef(obj: GeofenceCollectionSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelector
 */
export interface GeofenceCollectionSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecForProviderKmsKeyIdSelector(obj: GeofenceCollectionSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GeofenceCollectionSpecProviderConfigRefPolicy
 */
export interface GeofenceCollectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeofenceCollectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GeofenceCollectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeofenceCollectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GeofenceCollectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecProviderConfigRefPolicy(obj: GeofenceCollectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRef
 */
export interface GeofenceCollectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecPublishConnectionDetailsToConfigRef(obj: GeofenceCollectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsToMetadata
 */
export interface GeofenceCollectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecPublishConnectionDetailsToMetadata(obj: GeofenceCollectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy
 */
export interface GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy(obj: GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy(obj: GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeofenceCollectionSpecProviderConfigRefPolicyResolution
 */
export enum GeofenceCollectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeofenceCollectionSpecProviderConfigRefPolicyResolve
 */
export enum GeofenceCollectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PlaceIndex is the Schema for the PlaceIndexs API. Provides a Location Service Place Index.
 *
 * @schema PlaceIndex
 */
export class PlaceIndex extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PlaceIndex"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'location.aws.upbound.io/v1beta1',
    kind: 'PlaceIndex',
  }

  /**
   * Renders a Kubernetes manifest for "PlaceIndex".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PlaceIndexProps): any {
    return {
      ...PlaceIndex.GVK,
      ...toJson_PlaceIndexProps(props),
    };
  }

  /**
   * Defines a "PlaceIndex" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PlaceIndexProps) {
    super(scope, id, {
      ...PlaceIndex.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PlaceIndex.GVK,
      ...toJson_PlaceIndexProps(resolved),
    };
  }
}

/**
 * PlaceIndex is the Schema for the PlaceIndexs API. Provides a Location Service Place Index.
 *
 * @schema PlaceIndex
 */
export interface PlaceIndexProps {
  /**
   * @schema PlaceIndex#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PlaceIndexSpec defines the desired state of PlaceIndex
   *
   * @schema PlaceIndex#spec
   */
  readonly spec: PlaceIndexSpec;

}

/**
 * Converts an object of type 'PlaceIndexProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexProps(obj: PlaceIndexProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PlaceIndexSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PlaceIndexSpec defines the desired state of PlaceIndex
 *
 * @schema PlaceIndexSpec
 */
export interface PlaceIndexSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PlaceIndexSpec#deletionPolicy
   */
  readonly deletionPolicy?: PlaceIndexSpecDeletionPolicy;

  /**
   * @schema PlaceIndexSpec#forProvider
   */
  readonly forProvider: PlaceIndexSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PlaceIndexSpec#initProvider
   */
  readonly initProvider?: PlaceIndexSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PlaceIndexSpec#managementPolicies
   */
  readonly managementPolicies?: PlaceIndexSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PlaceIndexSpec#providerConfigRef
   */
  readonly providerConfigRef?: PlaceIndexSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PlaceIndexSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PlaceIndexSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PlaceIndexSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PlaceIndexSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PlaceIndexSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpec(obj: PlaceIndexSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PlaceIndexSpecForProvider(obj.forProvider),
    'initProvider': toJson_PlaceIndexSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PlaceIndexSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PlaceIndexSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PlaceIndexSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PlaceIndexSpecDeletionPolicy
 */
export enum PlaceIndexSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PlaceIndexSpecForProvider
 */
export interface PlaceIndexSpecForProvider {
  /**
   * Specifies the geospatial data provider for the new place index.
   *
   * @schema PlaceIndexSpecForProvider#dataSource
   */
  readonly dataSource?: string;

  /**
   * Configuration block with the data storage option chosen for requesting Places. Detailed below.
   *
   * @schema PlaceIndexSpecForProvider#dataSourceConfiguration
   */
  readonly dataSourceConfiguration?: PlaceIndexSpecForProviderDataSourceConfiguration[];

  /**
   * The optional description for the place index resource.
   *
   * @schema PlaceIndexSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PlaceIndexSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PlaceIndexSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PlaceIndexSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecForProvider(obj: PlaceIndexSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataSource': obj.dataSource,
    'dataSourceConfiguration': obj.dataSourceConfiguration?.map(y => toJson_PlaceIndexSpecForProviderDataSourceConfiguration(y)),
    'description': obj.description,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PlaceIndexSpecInitProvider
 */
export interface PlaceIndexSpecInitProvider {
  /**
   * Specifies the geospatial data provider for the new place index.
   *
   * @schema PlaceIndexSpecInitProvider#dataSource
   */
  readonly dataSource?: string;

  /**
   * Configuration block with the data storage option chosen for requesting Places. Detailed below.
   *
   * @schema PlaceIndexSpecInitProvider#dataSourceConfiguration
   */
  readonly dataSourceConfiguration?: PlaceIndexSpecInitProviderDataSourceConfiguration[];

  /**
   * The optional description for the place index resource.
   *
   * @schema PlaceIndexSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PlaceIndexSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PlaceIndexSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecInitProvider(obj: PlaceIndexSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataSource': obj.dataSource,
    'dataSourceConfiguration': obj.dataSourceConfiguration?.map(y => toJson_PlaceIndexSpecInitProviderDataSourceConfiguration(y)),
    'description': obj.description,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PlaceIndexSpecManagementPolicies
 */
export enum PlaceIndexSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PlaceIndexSpecProviderConfigRef
 */
export interface PlaceIndexSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlaceIndexSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlaceIndexSpecProviderConfigRef#policy
   */
  readonly policy?: PlaceIndexSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PlaceIndexSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecProviderConfigRef(obj: PlaceIndexSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlaceIndexSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsTo
 */
export interface PlaceIndexSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PlaceIndexSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PlaceIndexSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PlaceIndexSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecPublishConnectionDetailsTo(obj: PlaceIndexSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PlaceIndexSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PlaceIndexSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PlaceIndexSpecWriteConnectionSecretToRef
 */
export interface PlaceIndexSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PlaceIndexSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PlaceIndexSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PlaceIndexSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecWriteConnectionSecretToRef(obj: PlaceIndexSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlaceIndexSpecForProviderDataSourceConfiguration
 */
export interface PlaceIndexSpecForProviderDataSourceConfiguration {
  /**
   * Specifies how the results of an operation will be stored by the caller. Valid values: SingleUse, Storage. Default: SingleUse.
   *
   * @schema PlaceIndexSpecForProviderDataSourceConfiguration#intendedUse
   */
  readonly intendedUse?: string;

}

/**
 * Converts an object of type 'PlaceIndexSpecForProviderDataSourceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecForProviderDataSourceConfiguration(obj: PlaceIndexSpecForProviderDataSourceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'intendedUse': obj.intendedUse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlaceIndexSpecInitProviderDataSourceConfiguration
 */
export interface PlaceIndexSpecInitProviderDataSourceConfiguration {
  /**
   * Specifies how the results of an operation will be stored by the caller. Valid values: SingleUse, Storage. Default: SingleUse.
   *
   * @schema PlaceIndexSpecInitProviderDataSourceConfiguration#intendedUse
   */
  readonly intendedUse?: string;

}

/**
 * Converts an object of type 'PlaceIndexSpecInitProviderDataSourceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecInitProviderDataSourceConfiguration(obj: PlaceIndexSpecInitProviderDataSourceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'intendedUse': obj.intendedUse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PlaceIndexSpecProviderConfigRefPolicy
 */
export interface PlaceIndexSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlaceIndexSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PlaceIndexSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlaceIndexSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PlaceIndexSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PlaceIndexSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecProviderConfigRefPolicy(obj: PlaceIndexSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRef
 */
export interface PlaceIndexSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PlaceIndexSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecPublishConnectionDetailsToConfigRef(obj: PlaceIndexSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsToMetadata
 */
export interface PlaceIndexSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PlaceIndexSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecPublishConnectionDetailsToMetadata(obj: PlaceIndexSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlaceIndexSpecProviderConfigRefPolicyResolution
 */
export enum PlaceIndexSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlaceIndexSpecProviderConfigRefPolicyResolve
 */
export enum PlaceIndexSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy(obj: PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RouteCalculator is the Schema for the RouteCalculators API. Provides a Location Service Route Calculator.
 *
 * @schema RouteCalculator
 */
export class RouteCalculator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RouteCalculator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'location.aws.upbound.io/v1beta1',
    kind: 'RouteCalculator',
  }

  /**
   * Renders a Kubernetes manifest for "RouteCalculator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RouteCalculatorProps): any {
    return {
      ...RouteCalculator.GVK,
      ...toJson_RouteCalculatorProps(props),
    };
  }

  /**
   * Defines a "RouteCalculator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RouteCalculatorProps) {
    super(scope, id, {
      ...RouteCalculator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RouteCalculator.GVK,
      ...toJson_RouteCalculatorProps(resolved),
    };
  }
}

/**
 * RouteCalculator is the Schema for the RouteCalculators API. Provides a Location Service Route Calculator.
 *
 * @schema RouteCalculator
 */
export interface RouteCalculatorProps {
  /**
   * @schema RouteCalculator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RouteCalculatorSpec defines the desired state of RouteCalculator
   *
   * @schema RouteCalculator#spec
   */
  readonly spec: RouteCalculatorSpec;

}

/**
 * Converts an object of type 'RouteCalculatorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorProps(obj: RouteCalculatorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RouteCalculatorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteCalculatorSpec defines the desired state of RouteCalculator
 *
 * @schema RouteCalculatorSpec
 */
export interface RouteCalculatorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RouteCalculatorSpec#deletionPolicy
   */
  readonly deletionPolicy?: RouteCalculatorSpecDeletionPolicy;

  /**
   * @schema RouteCalculatorSpec#forProvider
   */
  readonly forProvider: RouteCalculatorSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RouteCalculatorSpec#initProvider
   */
  readonly initProvider?: RouteCalculatorSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RouteCalculatorSpec#managementPolicies
   */
  readonly managementPolicies?: RouteCalculatorSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RouteCalculatorSpec#providerConfigRef
   */
  readonly providerConfigRef?: RouteCalculatorSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RouteCalculatorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RouteCalculatorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RouteCalculatorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RouteCalculatorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RouteCalculatorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpec(obj: RouteCalculatorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RouteCalculatorSpecForProvider(obj.forProvider),
    'initProvider': toJson_RouteCalculatorSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RouteCalculatorSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RouteCalculatorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RouteCalculatorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RouteCalculatorSpecDeletionPolicy
 */
export enum RouteCalculatorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RouteCalculatorSpecForProvider
 */
export interface RouteCalculatorSpecForProvider {
  /**
   * Specifies the data provider of traffic and road network data.
   *
   * @schema RouteCalculatorSpecForProvider#dataSource
   */
  readonly dataSource?: string;

  /**
   * The optional description for the route calculator resource.
   *
   * @schema RouteCalculatorSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RouteCalculatorSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RouteCalculatorSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RouteCalculatorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecForProvider(obj: RouteCalculatorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataSource': obj.dataSource,
    'description': obj.description,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RouteCalculatorSpecInitProvider
 */
export interface RouteCalculatorSpecInitProvider {
  /**
   * Specifies the data provider of traffic and road network data.
   *
   * @schema RouteCalculatorSpecInitProvider#dataSource
   */
  readonly dataSource?: string;

  /**
   * The optional description for the route calculator resource.
   *
   * @schema RouteCalculatorSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RouteCalculatorSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RouteCalculatorSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecInitProvider(obj: RouteCalculatorSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataSource': obj.dataSource,
    'description': obj.description,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RouteCalculatorSpecManagementPolicies
 */
export enum RouteCalculatorSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RouteCalculatorSpecProviderConfigRef
 */
export interface RouteCalculatorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteCalculatorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteCalculatorSpecProviderConfigRef#policy
   */
  readonly policy?: RouteCalculatorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteCalculatorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecProviderConfigRef(obj: RouteCalculatorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteCalculatorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsTo
 */
export interface RouteCalculatorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RouteCalculatorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RouteCalculatorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RouteCalculatorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecPublishConnectionDetailsTo(obj: RouteCalculatorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RouteCalculatorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RouteCalculatorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RouteCalculatorSpecWriteConnectionSecretToRef
 */
export interface RouteCalculatorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RouteCalculatorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RouteCalculatorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RouteCalculatorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecWriteConnectionSecretToRef(obj: RouteCalculatorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteCalculatorSpecProviderConfigRefPolicy
 */
export interface RouteCalculatorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteCalculatorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RouteCalculatorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteCalculatorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RouteCalculatorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteCalculatorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecProviderConfigRefPolicy(obj: RouteCalculatorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRef
 */
export interface RouteCalculatorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteCalculatorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecPublishConnectionDetailsToConfigRef(obj: RouteCalculatorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsToMetadata
 */
export interface RouteCalculatorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RouteCalculatorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecPublishConnectionDetailsToMetadata(obj: RouteCalculatorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteCalculatorSpecProviderConfigRefPolicyResolution
 */
export enum RouteCalculatorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteCalculatorSpecProviderConfigRefPolicyResolve
 */
export enum RouteCalculatorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy(obj: RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Tracker is the Schema for the Trackers API. Provides a Location Service Tracker.
 *
 * @schema Tracker
 */
export class Tracker extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Tracker"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'location.aws.upbound.io/v1beta1',
    kind: 'Tracker',
  }

  /**
   * Renders a Kubernetes manifest for "Tracker".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TrackerProps): any {
    return {
      ...Tracker.GVK,
      ...toJson_TrackerProps(props),
    };
  }

  /**
   * Defines a "Tracker" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TrackerProps) {
    super(scope, id, {
      ...Tracker.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Tracker.GVK,
      ...toJson_TrackerProps(resolved),
    };
  }
}

/**
 * Tracker is the Schema for the Trackers API. Provides a Location Service Tracker.
 *
 * @schema Tracker
 */
export interface TrackerProps {
  /**
   * @schema Tracker#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TrackerSpec defines the desired state of Tracker
   *
   * @schema Tracker#spec
   */
  readonly spec: TrackerSpec;

}

/**
 * Converts an object of type 'TrackerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerProps(obj: TrackerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TrackerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TrackerSpec defines the desired state of Tracker
 *
 * @schema TrackerSpec
 */
export interface TrackerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TrackerSpec#deletionPolicy
   */
  readonly deletionPolicy?: TrackerSpecDeletionPolicy;

  /**
   * @schema TrackerSpec#forProvider
   */
  readonly forProvider: TrackerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TrackerSpec#initProvider
   */
  readonly initProvider?: TrackerSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TrackerSpec#managementPolicies
   */
  readonly managementPolicies?: TrackerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TrackerSpec#providerConfigRef
   */
  readonly providerConfigRef?: TrackerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TrackerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TrackerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TrackerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TrackerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TrackerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpec(obj: TrackerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TrackerSpecForProvider(obj.forProvider),
    'initProvider': toJson_TrackerSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TrackerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TrackerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TrackerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TrackerSpecDeletionPolicy
 */
export enum TrackerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TrackerSpecForProvider
 */
export interface TrackerSpecForProvider {
  /**
   * The optional description for the tracker resource.
   *
   * @schema TrackerSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A key identifier for an AWS KMS customer managed key assigned to the Amazon Location resource.
   *
   * @schema TrackerSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema TrackerSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: TrackerSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema TrackerSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: TrackerSpecForProviderKmsKeyIdSelector;

  /**
   * The position filtering method of the tracker resource. Valid values: TimeBased, DistanceBased, AccuracyBased. Default: TimeBased.
   *
   * @schema TrackerSpecForProvider#positionFiltering
   */
  readonly positionFiltering?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TrackerSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TrackerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TrackerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecForProvider(obj: TrackerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_TrackerSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_TrackerSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'positionFiltering': obj.positionFiltering,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TrackerSpecInitProvider
 */
export interface TrackerSpecInitProvider {
  /**
   * The optional description for the tracker resource.
   *
   * @schema TrackerSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The position filtering method of the tracker resource. Valid values: TimeBased, DistanceBased, AccuracyBased. Default: TimeBased.
   *
   * @schema TrackerSpecInitProvider#positionFiltering
   */
  readonly positionFiltering?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TrackerSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TrackerSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecInitProvider(obj: TrackerSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'positionFiltering': obj.positionFiltering,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TrackerSpecManagementPolicies
 */
export enum TrackerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TrackerSpecProviderConfigRef
 */
export interface TrackerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerSpecProviderConfigRef#policy
   */
  readonly policy?: TrackerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TrackerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecProviderConfigRef(obj: TrackerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TrackerSpecPublishConnectionDetailsTo
 */
export interface TrackerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TrackerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TrackerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TrackerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TrackerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TrackerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TrackerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecPublishConnectionDetailsTo(obj: TrackerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TrackerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TrackerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TrackerSpecWriteConnectionSecretToRef
 */
export interface TrackerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TrackerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TrackerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TrackerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecWriteConnectionSecretToRef(obj: TrackerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema TrackerSpecForProviderKmsKeyIdRef
 */
export interface TrackerSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: TrackerSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'TrackerSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecForProviderKmsKeyIdRef(obj: TrackerSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema TrackerSpecForProviderKmsKeyIdSelector
 */
export interface TrackerSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrackerSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrackerSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrackerSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: TrackerSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'TrackerSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecForProviderKmsKeyIdSelector(obj: TrackerSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrackerSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerSpecProviderConfigRefPolicy
 */
export interface TrackerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TrackerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TrackerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecProviderConfigRefPolicy(obj: TrackerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TrackerSpecPublishConnectionDetailsToConfigRef
 */
export interface TrackerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TrackerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TrackerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecPublishConnectionDetailsToConfigRef(obj: TrackerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TrackerSpecPublishConnectionDetailsToMetadata
 */
export interface TrackerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrackerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrackerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TrackerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TrackerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecPublishConnectionDetailsToMetadata(obj: TrackerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerSpecForProviderKmsKeyIdRefPolicy
 */
export interface TrackerSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: TrackerSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: TrackerSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecForProviderKmsKeyIdRefPolicy(obj: TrackerSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrackerSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface TrackerSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: TrackerSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: TrackerSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrackerSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecForProviderKmsKeyIdSelectorPolicy(obj: TrackerSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerSpecProviderConfigRefPolicyResolution
 */
export enum TrackerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerSpecProviderConfigRefPolicyResolve
 */
export enum TrackerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TrackerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TrackerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecPublishConnectionDetailsToConfigRefPolicy(obj: TrackerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum TrackerSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum TrackerSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum TrackerSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum TrackerSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TrackerAssociation is the Schema for the TrackerAssociations API.
 *
 * @schema TrackerAssociation
 */
export class TrackerAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TrackerAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'location.aws.upbound.io/v1beta1',
    kind: 'TrackerAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "TrackerAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TrackerAssociationProps): any {
    return {
      ...TrackerAssociation.GVK,
      ...toJson_TrackerAssociationProps(props),
    };
  }

  /**
   * Defines a "TrackerAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TrackerAssociationProps) {
    super(scope, id, {
      ...TrackerAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TrackerAssociation.GVK,
      ...toJson_TrackerAssociationProps(resolved),
    };
  }
}

/**
 * TrackerAssociation is the Schema for the TrackerAssociations API.
 *
 * @schema TrackerAssociation
 */
export interface TrackerAssociationProps {
  /**
   * @schema TrackerAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TrackerAssociationSpec defines the desired state of TrackerAssociation
   *
   * @schema TrackerAssociation#spec
   */
  readonly spec: TrackerAssociationSpec;

}

/**
 * Converts an object of type 'TrackerAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationProps(obj: TrackerAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TrackerAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TrackerAssociationSpec defines the desired state of TrackerAssociation
 *
 * @schema TrackerAssociationSpec
 */
export interface TrackerAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TrackerAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: TrackerAssociationSpecDeletionPolicy;

  /**
   * @schema TrackerAssociationSpec#forProvider
   */
  readonly forProvider: TrackerAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TrackerAssociationSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TrackerAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: TrackerAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TrackerAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: TrackerAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TrackerAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TrackerAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TrackerAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TrackerAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TrackerAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpec(obj: TrackerAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TrackerAssociationSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TrackerAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TrackerAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TrackerAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TrackerAssociationSpecDeletionPolicy
 */
export enum TrackerAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TrackerAssociationSpecForProvider
 */
export interface TrackerAssociationSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all AWS.
   *
   * @schema TrackerAssociationSpecForProvider#consumerArn
   */
  readonly consumerArn?: string;

  /**
   * Reference to a GeofenceCollection in location to populate consumerArn.
   *
   * @schema TrackerAssociationSpecForProvider#consumerArnRef
   */
  readonly consumerArnRef?: TrackerAssociationSpecForProviderConsumerArnRef;

  /**
   * Selector for a GeofenceCollection in location to populate consumerArn.
   *
   * @schema TrackerAssociationSpecForProvider#consumerArnSelector
   */
  readonly consumerArnSelector?: TrackerAssociationSpecForProviderConsumerArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TrackerAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the tracker resource to be associated with a geofence collection.
   *
   * @schema TrackerAssociationSpecForProvider#trackerName
   */
  readonly trackerName?: string;

  /**
   * Reference to a Tracker in location to populate trackerName.
   *
   * @schema TrackerAssociationSpecForProvider#trackerNameRef
   */
  readonly trackerNameRef?: TrackerAssociationSpecForProviderTrackerNameRef;

  /**
   * Selector for a Tracker in location to populate trackerName.
   *
   * @schema TrackerAssociationSpecForProvider#trackerNameSelector
   */
  readonly trackerNameSelector?: TrackerAssociationSpecForProviderTrackerNameSelector;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProvider(obj: TrackerAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumerArn': obj.consumerArn,
    'consumerArnRef': toJson_TrackerAssociationSpecForProviderConsumerArnRef(obj.consumerArnRef),
    'consumerArnSelector': toJson_TrackerAssociationSpecForProviderConsumerArnSelector(obj.consumerArnSelector),
    'region': obj.region,
    'trackerName': obj.trackerName,
    'trackerNameRef': toJson_TrackerAssociationSpecForProviderTrackerNameRef(obj.trackerNameRef),
    'trackerNameSelector': toJson_TrackerAssociationSpecForProviderTrackerNameSelector(obj.trackerNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TrackerAssociationSpecManagementPolicies
 */
export enum TrackerAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TrackerAssociationSpecProviderConfigRef
 */
export interface TrackerAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: TrackerAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecProviderConfigRef(obj: TrackerAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsTo
 */
export interface TrackerAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TrackerAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TrackerAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TrackerAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecPublishConnectionDetailsTo(obj: TrackerAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TrackerAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TrackerAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TrackerAssociationSpecWriteConnectionSecretToRef
 */
export interface TrackerAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TrackerAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TrackerAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TrackerAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecWriteConnectionSecretToRef(obj: TrackerAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GeofenceCollection in location to populate consumerArn.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnRef
 */
export interface TrackerAssociationSpecForProviderConsumerArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnRef#policy
   */
  readonly policy?: TrackerAssociationSpecForProviderConsumerArnRefPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderConsumerArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderConsumerArnRef(obj: TrackerAssociationSpecForProviderConsumerArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerAssociationSpecForProviderConsumerArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GeofenceCollection in location to populate consumerArn.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnSelector
 */
export interface TrackerAssociationSpecForProviderConsumerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnSelector#policy
   */
  readonly policy?: TrackerAssociationSpecForProviderConsumerArnSelectorPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderConsumerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderConsumerArnSelector(obj: TrackerAssociationSpecForProviderConsumerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrackerAssociationSpecForProviderConsumerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Tracker in location to populate trackerName.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameRef
 */
export interface TrackerAssociationSpecForProviderTrackerNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameRef#policy
   */
  readonly policy?: TrackerAssociationSpecForProviderTrackerNameRefPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderTrackerNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderTrackerNameRef(obj: TrackerAssociationSpecForProviderTrackerNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerAssociationSpecForProviderTrackerNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Tracker in location to populate trackerName.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameSelector
 */
export interface TrackerAssociationSpecForProviderTrackerNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameSelector#policy
   */
  readonly policy?: TrackerAssociationSpecForProviderTrackerNameSelectorPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderTrackerNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderTrackerNameSelector(obj: TrackerAssociationSpecForProviderTrackerNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrackerAssociationSpecForProviderTrackerNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerAssociationSpecProviderConfigRefPolicy
 */
export interface TrackerAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecProviderConfigRefPolicy(obj: TrackerAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface TrackerAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecPublishConnectionDetailsToConfigRef(obj: TrackerAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface TrackerAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TrackerAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecPublishConnectionDetailsToMetadata(obj: TrackerAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnRefPolicy
 */
export interface TrackerAssociationSpecForProviderConsumerArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnRefPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecForProviderConsumerArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnRefPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecForProviderConsumerArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderConsumerArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderConsumerArnRefPolicy(obj: TrackerAssociationSpecForProviderConsumerArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnSelectorPolicy
 */
export interface TrackerAssociationSpecForProviderConsumerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnSelectorPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnSelectorPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderConsumerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderConsumerArnSelectorPolicy(obj: TrackerAssociationSpecForProviderConsumerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameRefPolicy
 */
export interface TrackerAssociationSpecForProviderTrackerNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameRefPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecForProviderTrackerNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameRefPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecForProviderTrackerNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderTrackerNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderTrackerNameRefPolicy(obj: TrackerAssociationSpecForProviderTrackerNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameSelectorPolicy
 */
export interface TrackerAssociationSpecForProviderTrackerNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameSelectorPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameSelectorPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderTrackerNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderTrackerNameSelectorPolicy(obj: TrackerAssociationSpecForProviderTrackerNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecProviderConfigRefPolicyResolution
 */
export enum TrackerAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecProviderConfigRefPolicyResolve
 */
export enum TrackerAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnRefPolicyResolution
 */
export enum TrackerAssociationSpecForProviderConsumerArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnRefPolicyResolve
 */
export enum TrackerAssociationSpecForProviderConsumerArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolution
 */
export enum TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolve
 */
export enum TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameRefPolicyResolution
 */
export enum TrackerAssociationSpecForProviderTrackerNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameRefPolicyResolve
 */
export enum TrackerAssociationSpecForProviderTrackerNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolution
 */
export enum TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolve
 */
export enum TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

