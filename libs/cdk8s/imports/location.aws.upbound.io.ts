// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * GeofenceCollection is the Schema for the GeofenceCollections API.
 *
 * @schema GeofenceCollection
 */
export class GeofenceCollection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GeofenceCollection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'location.aws.upbound.io/v1beta1',
    kind: 'GeofenceCollection',
  }

  /**
   * Renders a Kubernetes manifest for "GeofenceCollection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GeofenceCollectionProps): any {
    return {
      ...GeofenceCollection.GVK,
      ...toJson_GeofenceCollectionProps(props),
    };
  }

  /**
   * Defines a "GeofenceCollection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GeofenceCollectionProps) {
    super(scope, id, {
      ...GeofenceCollection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GeofenceCollection.GVK,
      ...toJson_GeofenceCollectionProps(resolved),
    };
  }
}

/**
 * GeofenceCollection is the Schema for the GeofenceCollections API.
 *
 * @schema GeofenceCollection
 */
export interface GeofenceCollectionProps {
  /**
   * @schema GeofenceCollection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GeofenceCollectionSpec defines the desired state of GeofenceCollection
   *
   * @schema GeofenceCollection#spec
   */
  readonly spec: GeofenceCollectionSpec;

}

/**
 * Converts an object of type 'GeofenceCollectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionProps(obj: GeofenceCollectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GeofenceCollectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GeofenceCollectionSpec defines the desired state of GeofenceCollection
 *
 * @schema GeofenceCollectionSpec
 */
export interface GeofenceCollectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema GeofenceCollectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: GeofenceCollectionSpecDeletionPolicy;

  /**
   * @schema GeofenceCollectionSpec#forProvider
   */
  readonly forProvider: GeofenceCollectionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GeofenceCollectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: GeofenceCollectionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GeofenceCollectionSpec#providerRef
   */
  readonly providerRef?: GeofenceCollectionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GeofenceCollectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GeofenceCollectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GeofenceCollectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GeofenceCollectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GeofenceCollectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpec(obj: GeofenceCollectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GeofenceCollectionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_GeofenceCollectionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GeofenceCollectionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GeofenceCollectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GeofenceCollectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema GeofenceCollectionSpecDeletionPolicy
 */
export enum GeofenceCollectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GeofenceCollectionSpecForProvider
 */
export interface GeofenceCollectionSpecForProvider {
  /**
   * The optional description for the geofence collection.
   *
   * @schema GeofenceCollectionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A key identifier for an AWS KMS customer managed key assigned to the Amazon Location resource.
   *
   * @schema GeofenceCollectionSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema GeofenceCollectionSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: GeofenceCollectionSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema GeofenceCollectionSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: GeofenceCollectionSpecForProviderKmsKeyIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GeofenceCollectionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema GeofenceCollectionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'GeofenceCollectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecForProvider(obj: GeofenceCollectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_GeofenceCollectionSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_GeofenceCollectionSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GeofenceCollectionSpecProviderConfigRef
 */
export interface GeofenceCollectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GeofenceCollectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GeofenceCollectionSpecProviderConfigRef#policy
   */
  readonly policy?: GeofenceCollectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecProviderConfigRef(obj: GeofenceCollectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GeofenceCollectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GeofenceCollectionSpecProviderRef
 */
export interface GeofenceCollectionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GeofenceCollectionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GeofenceCollectionSpecProviderRef#policy
   */
  readonly policy?: GeofenceCollectionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecProviderRef(obj: GeofenceCollectionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GeofenceCollectionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsTo
 */
export interface GeofenceCollectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GeofenceCollectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GeofenceCollectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecPublishConnectionDetailsTo(obj: GeofenceCollectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GeofenceCollectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GeofenceCollectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GeofenceCollectionSpecWriteConnectionSecretToRef
 */
export interface GeofenceCollectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GeofenceCollectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GeofenceCollectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecWriteConnectionSecretToRef(obj: GeofenceCollectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdRef
 */
export interface GeofenceCollectionSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecForProviderKmsKeyIdRef(obj: GeofenceCollectionSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelector
 */
export interface GeofenceCollectionSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecForProviderKmsKeyIdSelector(obj: GeofenceCollectionSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GeofenceCollectionSpecProviderConfigRefPolicy
 */
export interface GeofenceCollectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeofenceCollectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GeofenceCollectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeofenceCollectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GeofenceCollectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecProviderConfigRefPolicy(obj: GeofenceCollectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GeofenceCollectionSpecProviderRefPolicy
 */
export interface GeofenceCollectionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeofenceCollectionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GeofenceCollectionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeofenceCollectionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GeofenceCollectionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecProviderRefPolicy(obj: GeofenceCollectionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRef
 */
export interface GeofenceCollectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecPublishConnectionDetailsToConfigRef(obj: GeofenceCollectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsToMetadata
 */
export interface GeofenceCollectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecPublishConnectionDetailsToMetadata(obj: GeofenceCollectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy
 */
export interface GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy(obj: GeofenceCollectionSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy(obj: GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeofenceCollectionSpecProviderConfigRefPolicyResolution
 */
export enum GeofenceCollectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeofenceCollectionSpecProviderConfigRefPolicyResolve
 */
export enum GeofenceCollectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeofenceCollectionSpecProviderRefPolicyResolution
 */
export enum GeofenceCollectionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeofenceCollectionSpecProviderRefPolicyResolve
 */
export enum GeofenceCollectionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum GeofenceCollectionSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum GeofenceCollectionSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GeofenceCollectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PlaceIndex is the Schema for the PlaceIndexs API. Provides a Location Service Place Index.
 *
 * @schema PlaceIndex
 */
export class PlaceIndex extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PlaceIndex"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'location.aws.upbound.io/v1beta1',
    kind: 'PlaceIndex',
  }

  /**
   * Renders a Kubernetes manifest for "PlaceIndex".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PlaceIndexProps): any {
    return {
      ...PlaceIndex.GVK,
      ...toJson_PlaceIndexProps(props),
    };
  }

  /**
   * Defines a "PlaceIndex" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PlaceIndexProps) {
    super(scope, id, {
      ...PlaceIndex.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PlaceIndex.GVK,
      ...toJson_PlaceIndexProps(resolved),
    };
  }
}

/**
 * PlaceIndex is the Schema for the PlaceIndexs API. Provides a Location Service Place Index.
 *
 * @schema PlaceIndex
 */
export interface PlaceIndexProps {
  /**
   * @schema PlaceIndex#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PlaceIndexSpec defines the desired state of PlaceIndex
   *
   * @schema PlaceIndex#spec
   */
  readonly spec: PlaceIndexSpec;

}

/**
 * Converts an object of type 'PlaceIndexProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexProps(obj: PlaceIndexProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PlaceIndexSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PlaceIndexSpec defines the desired state of PlaceIndex
 *
 * @schema PlaceIndexSpec
 */
export interface PlaceIndexSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema PlaceIndexSpec#deletionPolicy
   */
  readonly deletionPolicy?: PlaceIndexSpecDeletionPolicy;

  /**
   * @schema PlaceIndexSpec#forProvider
   */
  readonly forProvider: PlaceIndexSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PlaceIndexSpec#providerConfigRef
   */
  readonly providerConfigRef?: PlaceIndexSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PlaceIndexSpec#providerRef
   */
  readonly providerRef?: PlaceIndexSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PlaceIndexSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PlaceIndexSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PlaceIndexSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PlaceIndexSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PlaceIndexSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpec(obj: PlaceIndexSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PlaceIndexSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_PlaceIndexSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PlaceIndexSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PlaceIndexSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PlaceIndexSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema PlaceIndexSpecDeletionPolicy
 */
export enum PlaceIndexSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PlaceIndexSpecForProvider
 */
export interface PlaceIndexSpecForProvider {
  /**
   * Specifies the geospatial data provider for the new place index.
   *
   * @schema PlaceIndexSpecForProvider#dataSource
   */
  readonly dataSource: string;

  /**
   * Configuration block with the data storage option chosen for requesting Places. Detailed below.
   *
   * @schema PlaceIndexSpecForProvider#dataSourceConfiguration
   */
  readonly dataSourceConfiguration?: PlaceIndexSpecForProviderDataSourceConfiguration[];

  /**
   * The optional description for the place index resource.
   *
   * @schema PlaceIndexSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PlaceIndexSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PlaceIndexSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PlaceIndexSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecForProvider(obj: PlaceIndexSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataSource': obj.dataSource,
    'dataSourceConfiguration': obj.dataSourceConfiguration?.map(y => toJson_PlaceIndexSpecForProviderDataSourceConfiguration(y)),
    'description': obj.description,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PlaceIndexSpecProviderConfigRef
 */
export interface PlaceIndexSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlaceIndexSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlaceIndexSpecProviderConfigRef#policy
   */
  readonly policy?: PlaceIndexSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PlaceIndexSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecProviderConfigRef(obj: PlaceIndexSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlaceIndexSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PlaceIndexSpecProviderRef
 */
export interface PlaceIndexSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlaceIndexSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlaceIndexSpecProviderRef#policy
   */
  readonly policy?: PlaceIndexSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PlaceIndexSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecProviderRef(obj: PlaceIndexSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlaceIndexSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsTo
 */
export interface PlaceIndexSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PlaceIndexSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PlaceIndexSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PlaceIndexSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecPublishConnectionDetailsTo(obj: PlaceIndexSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PlaceIndexSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PlaceIndexSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PlaceIndexSpecWriteConnectionSecretToRef
 */
export interface PlaceIndexSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PlaceIndexSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PlaceIndexSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PlaceIndexSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecWriteConnectionSecretToRef(obj: PlaceIndexSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlaceIndexSpecForProviderDataSourceConfiguration
 */
export interface PlaceIndexSpecForProviderDataSourceConfiguration {
  /**
   * Specifies how the results of an operation will be stored by the caller. Valid values: SingleUse, Storage. Default: SingleUse.
   *
   * @schema PlaceIndexSpecForProviderDataSourceConfiguration#intendedUse
   */
  readonly intendedUse?: string;

}

/**
 * Converts an object of type 'PlaceIndexSpecForProviderDataSourceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecForProviderDataSourceConfiguration(obj: PlaceIndexSpecForProviderDataSourceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'intendedUse': obj.intendedUse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PlaceIndexSpecProviderConfigRefPolicy
 */
export interface PlaceIndexSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlaceIndexSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PlaceIndexSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlaceIndexSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PlaceIndexSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PlaceIndexSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecProviderConfigRefPolicy(obj: PlaceIndexSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PlaceIndexSpecProviderRefPolicy
 */
export interface PlaceIndexSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlaceIndexSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PlaceIndexSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlaceIndexSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PlaceIndexSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PlaceIndexSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecProviderRefPolicy(obj: PlaceIndexSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRef
 */
export interface PlaceIndexSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PlaceIndexSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecPublishConnectionDetailsToConfigRef(obj: PlaceIndexSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsToMetadata
 */
export interface PlaceIndexSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PlaceIndexSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecPublishConnectionDetailsToMetadata(obj: PlaceIndexSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlaceIndexSpecProviderConfigRefPolicyResolution
 */
export enum PlaceIndexSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlaceIndexSpecProviderConfigRefPolicyResolve
 */
export enum PlaceIndexSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlaceIndexSpecProviderRefPolicyResolution
 */
export enum PlaceIndexSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlaceIndexSpecProviderRefPolicyResolve
 */
export enum PlaceIndexSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy(obj: PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PlaceIndexSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RouteCalculator is the Schema for the RouteCalculators API. Provides a Location Service Route Calculator.
 *
 * @schema RouteCalculator
 */
export class RouteCalculator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RouteCalculator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'location.aws.upbound.io/v1beta1',
    kind: 'RouteCalculator',
  }

  /**
   * Renders a Kubernetes manifest for "RouteCalculator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RouteCalculatorProps): any {
    return {
      ...RouteCalculator.GVK,
      ...toJson_RouteCalculatorProps(props),
    };
  }

  /**
   * Defines a "RouteCalculator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RouteCalculatorProps) {
    super(scope, id, {
      ...RouteCalculator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RouteCalculator.GVK,
      ...toJson_RouteCalculatorProps(resolved),
    };
  }
}

/**
 * RouteCalculator is the Schema for the RouteCalculators API. Provides a Location Service Route Calculator.
 *
 * @schema RouteCalculator
 */
export interface RouteCalculatorProps {
  /**
   * @schema RouteCalculator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RouteCalculatorSpec defines the desired state of RouteCalculator
   *
   * @schema RouteCalculator#spec
   */
  readonly spec: RouteCalculatorSpec;

}

/**
 * Converts an object of type 'RouteCalculatorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorProps(obj: RouteCalculatorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RouteCalculatorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteCalculatorSpec defines the desired state of RouteCalculator
 *
 * @schema RouteCalculatorSpec
 */
export interface RouteCalculatorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RouteCalculatorSpec#deletionPolicy
   */
  readonly deletionPolicy?: RouteCalculatorSpecDeletionPolicy;

  /**
   * @schema RouteCalculatorSpec#forProvider
   */
  readonly forProvider: RouteCalculatorSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RouteCalculatorSpec#providerConfigRef
   */
  readonly providerConfigRef?: RouteCalculatorSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RouteCalculatorSpec#providerRef
   */
  readonly providerRef?: RouteCalculatorSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RouteCalculatorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RouteCalculatorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RouteCalculatorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RouteCalculatorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RouteCalculatorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpec(obj: RouteCalculatorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RouteCalculatorSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RouteCalculatorSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RouteCalculatorSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RouteCalculatorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RouteCalculatorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RouteCalculatorSpecDeletionPolicy
 */
export enum RouteCalculatorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RouteCalculatorSpecForProvider
 */
export interface RouteCalculatorSpecForProvider {
  /**
   * Specifies the data provider of traffic and road network data.
   *
   * @schema RouteCalculatorSpecForProvider#dataSource
   */
  readonly dataSource: string;

  /**
   * The optional description for the route calculator resource.
   *
   * @schema RouteCalculatorSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RouteCalculatorSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RouteCalculatorSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RouteCalculatorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecForProvider(obj: RouteCalculatorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataSource': obj.dataSource,
    'description': obj.description,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RouteCalculatorSpecProviderConfigRef
 */
export interface RouteCalculatorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteCalculatorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteCalculatorSpecProviderConfigRef#policy
   */
  readonly policy?: RouteCalculatorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteCalculatorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecProviderConfigRef(obj: RouteCalculatorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteCalculatorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RouteCalculatorSpecProviderRef
 */
export interface RouteCalculatorSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteCalculatorSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteCalculatorSpecProviderRef#policy
   */
  readonly policy?: RouteCalculatorSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RouteCalculatorSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecProviderRef(obj: RouteCalculatorSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteCalculatorSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsTo
 */
export interface RouteCalculatorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RouteCalculatorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RouteCalculatorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RouteCalculatorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecPublishConnectionDetailsTo(obj: RouteCalculatorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RouteCalculatorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RouteCalculatorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RouteCalculatorSpecWriteConnectionSecretToRef
 */
export interface RouteCalculatorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RouteCalculatorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RouteCalculatorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RouteCalculatorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecWriteConnectionSecretToRef(obj: RouteCalculatorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteCalculatorSpecProviderConfigRefPolicy
 */
export interface RouteCalculatorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteCalculatorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RouteCalculatorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteCalculatorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RouteCalculatorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteCalculatorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecProviderConfigRefPolicy(obj: RouteCalculatorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteCalculatorSpecProviderRefPolicy
 */
export interface RouteCalculatorSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteCalculatorSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RouteCalculatorSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteCalculatorSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RouteCalculatorSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteCalculatorSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecProviderRefPolicy(obj: RouteCalculatorSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRef
 */
export interface RouteCalculatorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteCalculatorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecPublishConnectionDetailsToConfigRef(obj: RouteCalculatorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsToMetadata
 */
export interface RouteCalculatorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RouteCalculatorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecPublishConnectionDetailsToMetadata(obj: RouteCalculatorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteCalculatorSpecProviderConfigRefPolicyResolution
 */
export enum RouteCalculatorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteCalculatorSpecProviderConfigRefPolicyResolve
 */
export enum RouteCalculatorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteCalculatorSpecProviderRefPolicyResolution
 */
export enum RouteCalculatorSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteCalculatorSpecProviderRefPolicyResolve
 */
export enum RouteCalculatorSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy(obj: RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RouteCalculatorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Tracker is the Schema for the Trackers API. Provides a Location Service Tracker.
 *
 * @schema Tracker
 */
export class Tracker extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Tracker"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'location.aws.upbound.io/v1beta1',
    kind: 'Tracker',
  }

  /**
   * Renders a Kubernetes manifest for "Tracker".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TrackerProps): any {
    return {
      ...Tracker.GVK,
      ...toJson_TrackerProps(props),
    };
  }

  /**
   * Defines a "Tracker" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TrackerProps) {
    super(scope, id, {
      ...Tracker.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Tracker.GVK,
      ...toJson_TrackerProps(resolved),
    };
  }
}

/**
 * Tracker is the Schema for the Trackers API. Provides a Location Service Tracker.
 *
 * @schema Tracker
 */
export interface TrackerProps {
  /**
   * @schema Tracker#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TrackerSpec defines the desired state of Tracker
   *
   * @schema Tracker#spec
   */
  readonly spec: TrackerSpec;

}

/**
 * Converts an object of type 'TrackerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerProps(obj: TrackerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TrackerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TrackerSpec defines the desired state of Tracker
 *
 * @schema TrackerSpec
 */
export interface TrackerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TrackerSpec#deletionPolicy
   */
  readonly deletionPolicy?: TrackerSpecDeletionPolicy;

  /**
   * @schema TrackerSpec#forProvider
   */
  readonly forProvider: TrackerSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TrackerSpec#providerConfigRef
   */
  readonly providerConfigRef?: TrackerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TrackerSpec#providerRef
   */
  readonly providerRef?: TrackerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TrackerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TrackerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TrackerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TrackerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TrackerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpec(obj: TrackerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TrackerSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TrackerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TrackerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TrackerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TrackerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TrackerSpecDeletionPolicy
 */
export enum TrackerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TrackerSpecForProvider
 */
export interface TrackerSpecForProvider {
  /**
   * The optional description for the tracker resource.
   *
   * @schema TrackerSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A key identifier for an AWS KMS customer managed key assigned to the Amazon Location resource.
   *
   * @schema TrackerSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema TrackerSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: TrackerSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema TrackerSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: TrackerSpecForProviderKmsKeyIdSelector;

  /**
   * The position filtering method of the tracker resource. Valid values: TimeBased, DistanceBased, AccuracyBased. Default: TimeBased.
   *
   * @schema TrackerSpecForProvider#positionFiltering
   */
  readonly positionFiltering?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TrackerSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TrackerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TrackerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecForProvider(obj: TrackerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_TrackerSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_TrackerSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'positionFiltering': obj.positionFiltering,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TrackerSpecProviderConfigRef
 */
export interface TrackerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerSpecProviderConfigRef#policy
   */
  readonly policy?: TrackerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TrackerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecProviderConfigRef(obj: TrackerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TrackerSpecProviderRef
 */
export interface TrackerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerSpecProviderRef#policy
   */
  readonly policy?: TrackerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TrackerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecProviderRef(obj: TrackerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TrackerSpecPublishConnectionDetailsTo
 */
export interface TrackerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TrackerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TrackerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TrackerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TrackerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TrackerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TrackerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecPublishConnectionDetailsTo(obj: TrackerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TrackerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TrackerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TrackerSpecWriteConnectionSecretToRef
 */
export interface TrackerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TrackerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TrackerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TrackerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecWriteConnectionSecretToRef(obj: TrackerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema TrackerSpecForProviderKmsKeyIdRef
 */
export interface TrackerSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: TrackerSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'TrackerSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecForProviderKmsKeyIdRef(obj: TrackerSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema TrackerSpecForProviderKmsKeyIdSelector
 */
export interface TrackerSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrackerSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrackerSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrackerSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: TrackerSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'TrackerSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecForProviderKmsKeyIdSelector(obj: TrackerSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrackerSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerSpecProviderConfigRefPolicy
 */
export interface TrackerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TrackerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TrackerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecProviderConfigRefPolicy(obj: TrackerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerSpecProviderRefPolicy
 */
export interface TrackerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TrackerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TrackerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecProviderRefPolicy(obj: TrackerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TrackerSpecPublishConnectionDetailsToConfigRef
 */
export interface TrackerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TrackerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TrackerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecPublishConnectionDetailsToConfigRef(obj: TrackerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TrackerSpecPublishConnectionDetailsToMetadata
 */
export interface TrackerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrackerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrackerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TrackerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TrackerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecPublishConnectionDetailsToMetadata(obj: TrackerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerSpecForProviderKmsKeyIdRefPolicy
 */
export interface TrackerSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: TrackerSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: TrackerSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecForProviderKmsKeyIdRefPolicy(obj: TrackerSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrackerSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface TrackerSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: TrackerSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: TrackerSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrackerSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecForProviderKmsKeyIdSelectorPolicy(obj: TrackerSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerSpecProviderConfigRefPolicyResolution
 */
export enum TrackerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerSpecProviderConfigRefPolicyResolve
 */
export enum TrackerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerSpecProviderRefPolicyResolution
 */
export enum TrackerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerSpecProviderRefPolicyResolve
 */
export enum TrackerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TrackerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TrackerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerSpecPublishConnectionDetailsToConfigRefPolicy(obj: TrackerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum TrackerSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum TrackerSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum TrackerSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum TrackerSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TrackerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TrackerAssociation is the Schema for the TrackerAssociations API.
 *
 * @schema TrackerAssociation
 */
export class TrackerAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TrackerAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'location.aws.upbound.io/v1beta1',
    kind: 'TrackerAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "TrackerAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TrackerAssociationProps): any {
    return {
      ...TrackerAssociation.GVK,
      ...toJson_TrackerAssociationProps(props),
    };
  }

  /**
   * Defines a "TrackerAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TrackerAssociationProps) {
    super(scope, id, {
      ...TrackerAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TrackerAssociation.GVK,
      ...toJson_TrackerAssociationProps(resolved),
    };
  }
}

/**
 * TrackerAssociation is the Schema for the TrackerAssociations API.
 *
 * @schema TrackerAssociation
 */
export interface TrackerAssociationProps {
  /**
   * @schema TrackerAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TrackerAssociationSpec defines the desired state of TrackerAssociation
   *
   * @schema TrackerAssociation#spec
   */
  readonly spec: TrackerAssociationSpec;

}

/**
 * Converts an object of type 'TrackerAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationProps(obj: TrackerAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TrackerAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TrackerAssociationSpec defines the desired state of TrackerAssociation
 *
 * @schema TrackerAssociationSpec
 */
export interface TrackerAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TrackerAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: TrackerAssociationSpecDeletionPolicy;

  /**
   * @schema TrackerAssociationSpec#forProvider
   */
  readonly forProvider: TrackerAssociationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TrackerAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: TrackerAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TrackerAssociationSpec#providerRef
   */
  readonly providerRef?: TrackerAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TrackerAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TrackerAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TrackerAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TrackerAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TrackerAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpec(obj: TrackerAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TrackerAssociationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TrackerAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TrackerAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TrackerAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TrackerAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TrackerAssociationSpecDeletionPolicy
 */
export enum TrackerAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TrackerAssociationSpecForProvider
 */
export interface TrackerAssociationSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all AWS.
   *
   * @schema TrackerAssociationSpecForProvider#consumerArn
   */
  readonly consumerArn?: string;

  /**
   * Reference to a GeofenceCollection in location to populate consumerArn.
   *
   * @schema TrackerAssociationSpecForProvider#consumerArnRef
   */
  readonly consumerArnRef?: TrackerAssociationSpecForProviderConsumerArnRef;

  /**
   * Selector for a GeofenceCollection in location to populate consumerArn.
   *
   * @schema TrackerAssociationSpecForProvider#consumerArnSelector
   */
  readonly consumerArnSelector?: TrackerAssociationSpecForProviderConsumerArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TrackerAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the tracker resource to be associated with a geofence collection.
   *
   * @schema TrackerAssociationSpecForProvider#trackerName
   */
  readonly trackerName?: string;

  /**
   * Reference to a Tracker in location to populate trackerName.
   *
   * @schema TrackerAssociationSpecForProvider#trackerNameRef
   */
  readonly trackerNameRef?: TrackerAssociationSpecForProviderTrackerNameRef;

  /**
   * Selector for a Tracker in location to populate trackerName.
   *
   * @schema TrackerAssociationSpecForProvider#trackerNameSelector
   */
  readonly trackerNameSelector?: TrackerAssociationSpecForProviderTrackerNameSelector;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProvider(obj: TrackerAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumerArn': obj.consumerArn,
    'consumerArnRef': toJson_TrackerAssociationSpecForProviderConsumerArnRef(obj.consumerArnRef),
    'consumerArnSelector': toJson_TrackerAssociationSpecForProviderConsumerArnSelector(obj.consumerArnSelector),
    'region': obj.region,
    'trackerName': obj.trackerName,
    'trackerNameRef': toJson_TrackerAssociationSpecForProviderTrackerNameRef(obj.trackerNameRef),
    'trackerNameSelector': toJson_TrackerAssociationSpecForProviderTrackerNameSelector(obj.trackerNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TrackerAssociationSpecProviderConfigRef
 */
export interface TrackerAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: TrackerAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecProviderConfigRef(obj: TrackerAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TrackerAssociationSpecProviderRef
 */
export interface TrackerAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerAssociationSpecProviderRef#policy
   */
  readonly policy?: TrackerAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecProviderRef(obj: TrackerAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsTo
 */
export interface TrackerAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TrackerAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TrackerAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TrackerAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecPublishConnectionDetailsTo(obj: TrackerAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TrackerAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TrackerAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TrackerAssociationSpecWriteConnectionSecretToRef
 */
export interface TrackerAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TrackerAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TrackerAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TrackerAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecWriteConnectionSecretToRef(obj: TrackerAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GeofenceCollection in location to populate consumerArn.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnRef
 */
export interface TrackerAssociationSpecForProviderConsumerArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnRef#policy
   */
  readonly policy?: TrackerAssociationSpecForProviderConsumerArnRefPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderConsumerArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderConsumerArnRef(obj: TrackerAssociationSpecForProviderConsumerArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerAssociationSpecForProviderConsumerArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GeofenceCollection in location to populate consumerArn.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnSelector
 */
export interface TrackerAssociationSpecForProviderConsumerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnSelector#policy
   */
  readonly policy?: TrackerAssociationSpecForProviderConsumerArnSelectorPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderConsumerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderConsumerArnSelector(obj: TrackerAssociationSpecForProviderConsumerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrackerAssociationSpecForProviderConsumerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Tracker in location to populate trackerName.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameRef
 */
export interface TrackerAssociationSpecForProviderTrackerNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameRef#policy
   */
  readonly policy?: TrackerAssociationSpecForProviderTrackerNameRefPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderTrackerNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderTrackerNameRef(obj: TrackerAssociationSpecForProviderTrackerNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerAssociationSpecForProviderTrackerNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Tracker in location to populate trackerName.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameSelector
 */
export interface TrackerAssociationSpecForProviderTrackerNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameSelector#policy
   */
  readonly policy?: TrackerAssociationSpecForProviderTrackerNameSelectorPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderTrackerNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderTrackerNameSelector(obj: TrackerAssociationSpecForProviderTrackerNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrackerAssociationSpecForProviderTrackerNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerAssociationSpecProviderConfigRefPolicy
 */
export interface TrackerAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecProviderConfigRefPolicy(obj: TrackerAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerAssociationSpecProviderRefPolicy
 */
export interface TrackerAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecProviderRefPolicy(obj: TrackerAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface TrackerAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TrackerAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecPublishConnectionDetailsToConfigRef(obj: TrackerAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface TrackerAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TrackerAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecPublishConnectionDetailsToMetadata(obj: TrackerAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnRefPolicy
 */
export interface TrackerAssociationSpecForProviderConsumerArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnRefPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecForProviderConsumerArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnRefPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecForProviderConsumerArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderConsumerArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderConsumerArnRefPolicy(obj: TrackerAssociationSpecForProviderConsumerArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnSelectorPolicy
 */
export interface TrackerAssociationSpecForProviderConsumerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnSelectorPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecForProviderConsumerArnSelectorPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderConsumerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderConsumerArnSelectorPolicy(obj: TrackerAssociationSpecForProviderConsumerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameRefPolicy
 */
export interface TrackerAssociationSpecForProviderTrackerNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameRefPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecForProviderTrackerNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameRefPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecForProviderTrackerNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderTrackerNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderTrackerNameRefPolicy(obj: TrackerAssociationSpecForProviderTrackerNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameSelectorPolicy
 */
export interface TrackerAssociationSpecForProviderTrackerNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameSelectorPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecForProviderTrackerNameSelectorPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecForProviderTrackerNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecForProviderTrackerNameSelectorPolicy(obj: TrackerAssociationSpecForProviderTrackerNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecProviderConfigRefPolicyResolution
 */
export enum TrackerAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecProviderConfigRefPolicyResolve
 */
export enum TrackerAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecProviderRefPolicyResolution
 */
export enum TrackerAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecProviderRefPolicyResolve
 */
export enum TrackerAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnRefPolicyResolution
 */
export enum TrackerAssociationSpecForProviderConsumerArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnRefPolicyResolve
 */
export enum TrackerAssociationSpecForProviderConsumerArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolution
 */
export enum TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolve
 */
export enum TrackerAssociationSpecForProviderConsumerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameRefPolicyResolution
 */
export enum TrackerAssociationSpecForProviderTrackerNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameRefPolicyResolve
 */
export enum TrackerAssociationSpecForProviderTrackerNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolution
 */
export enum TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolve
 */
export enum TrackerAssociationSpecForProviderTrackerNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TrackerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

