// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * BGPPeer is the Schema for the BGPPeers API. Provides a Direct Connect BGP peer resource.
 *
 * @schema BGPPeer
 */
export class BgpPeer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BGPPeer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'BGPPeer',
  }

  /**
   * Renders a Kubernetes manifest for "BGPPeer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BgpPeerProps): any {
    return {
      ...BgpPeer.GVK,
      ...toJson_BgpPeerProps(props),
    };
  }

  /**
   * Defines a "BGPPeer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BgpPeerProps) {
    super(scope, id, {
      ...BgpPeer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BgpPeer.GVK,
      ...toJson_BgpPeerProps(resolved),
    };
  }
}

/**
 * BGPPeer is the Schema for the BGPPeers API. Provides a Direct Connect BGP peer resource.
 *
 * @schema BGPPeer
 */
export interface BgpPeerProps {
  /**
   * @schema BGPPeer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BGPPeerSpec defines the desired state of BGPPeer
   *
   * @schema BGPPeer#spec
   */
  readonly spec: BgpPeerSpec;

}

/**
 * Converts an object of type 'BgpPeerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerProps(obj: BgpPeerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BgpPeerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BGPPeerSpec defines the desired state of BGPPeer
 *
 * @schema BgpPeerSpec
 */
export interface BgpPeerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BgpPeerSpec#deletionPolicy
   */
  readonly deletionPolicy?: BgpPeerSpecDeletionPolicy;

  /**
   * @schema BgpPeerSpec#forProvider
   */
  readonly forProvider: BgpPeerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema BgpPeerSpec#initProvider
   */
  readonly initProvider?: BgpPeerSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BgpPeerSpec#managementPolicies
   */
  readonly managementPolicies?: BgpPeerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BgpPeerSpec#providerConfigRef
   */
  readonly providerConfigRef?: BgpPeerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BgpPeerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BgpPeerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BgpPeerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BgpPeerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BgpPeerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpec(obj: BgpPeerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BgpPeerSpecForProvider(obj.forProvider),
    'initProvider': toJson_BgpPeerSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BgpPeerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BgpPeerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BgpPeerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BgpPeerSpecDeletionPolicy
 */
export enum BgpPeerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BgpPeerSpecForProvider
 */
export interface BgpPeerSpecForProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema BgpPeerSpecForProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers on public virtual interfaces.
   *
   * @schema BgpPeerSpecForProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema BgpPeerSpecForProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema BgpPeerSpecForProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers on public virtual interfaces.
   *
   * @schema BgpPeerSpecForProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BgpPeerSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the Direct Connect virtual interface on which to create the BGP peer.
   *
   * @schema BgpPeerSpecForProvider#virtualInterfaceId
   */
  readonly virtualInterfaceId?: string;

  /**
   * Reference to a PrivateVirtualInterface in directconnect to populate virtualInterfaceId.
   *
   * @schema BgpPeerSpecForProvider#virtualInterfaceIdRef
   */
  readonly virtualInterfaceIdRef?: BgpPeerSpecForProviderVirtualInterfaceIdRef;

  /**
   * Selector for a PrivateVirtualInterface in directconnect to populate virtualInterfaceId.
   *
   * @schema BgpPeerSpecForProvider#virtualInterfaceIdSelector
   */
  readonly virtualInterfaceIdSelector?: BgpPeerSpecForProviderVirtualInterfaceIdSelector;

}

/**
 * Converts an object of type 'BgpPeerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecForProvider(obj: BgpPeerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'customerAddress': obj.customerAddress,
    'region': obj.region,
    'virtualInterfaceId': obj.virtualInterfaceId,
    'virtualInterfaceIdRef': toJson_BgpPeerSpecForProviderVirtualInterfaceIdRef(obj.virtualInterfaceIdRef),
    'virtualInterfaceIdSelector': toJson_BgpPeerSpecForProviderVirtualInterfaceIdSelector(obj.virtualInterfaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema BgpPeerSpecInitProvider
 */
export interface BgpPeerSpecInitProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema BgpPeerSpecInitProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers on public virtual interfaces.
   *
   * @schema BgpPeerSpecInitProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema BgpPeerSpecInitProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema BgpPeerSpecInitProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers on public virtual interfaces.
   *
   * @schema BgpPeerSpecInitProvider#customerAddress
   */
  readonly customerAddress?: string;

}

/**
 * Converts an object of type 'BgpPeerSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecInitProvider(obj: BgpPeerSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'customerAddress': obj.customerAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BgpPeerSpecManagementPolicies
 */
export enum BgpPeerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BgpPeerSpecProviderConfigRef
 */
export interface BgpPeerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BgpPeerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BgpPeerSpecProviderConfigRef#policy
   */
  readonly policy?: BgpPeerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BgpPeerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecProviderConfigRef(obj: BgpPeerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BgpPeerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BgpPeerSpecPublishConnectionDetailsTo
 */
export interface BgpPeerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BgpPeerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BgpPeerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BgpPeerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BgpPeerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BgpPeerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BgpPeerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecPublishConnectionDetailsTo(obj: BgpPeerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BgpPeerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BgpPeerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BgpPeerSpecWriteConnectionSecretToRef
 */
export interface BgpPeerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BgpPeerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BgpPeerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BgpPeerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecWriteConnectionSecretToRef(obj: BgpPeerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PrivateVirtualInterface in directconnect to populate virtualInterfaceId.
 *
 * @schema BgpPeerSpecForProviderVirtualInterfaceIdRef
 */
export interface BgpPeerSpecForProviderVirtualInterfaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BgpPeerSpecForProviderVirtualInterfaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BgpPeerSpecForProviderVirtualInterfaceIdRef#policy
   */
  readonly policy?: BgpPeerSpecForProviderVirtualInterfaceIdRefPolicy;

}

/**
 * Converts an object of type 'BgpPeerSpecForProviderVirtualInterfaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecForProviderVirtualInterfaceIdRef(obj: BgpPeerSpecForProviderVirtualInterfaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BgpPeerSpecForProviderVirtualInterfaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PrivateVirtualInterface in directconnect to populate virtualInterfaceId.
 *
 * @schema BgpPeerSpecForProviderVirtualInterfaceIdSelector
 */
export interface BgpPeerSpecForProviderVirtualInterfaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BgpPeerSpecForProviderVirtualInterfaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BgpPeerSpecForProviderVirtualInterfaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BgpPeerSpecForProviderVirtualInterfaceIdSelector#policy
   */
  readonly policy?: BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'BgpPeerSpecForProviderVirtualInterfaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecForProviderVirtualInterfaceIdSelector(obj: BgpPeerSpecForProviderVirtualInterfaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BgpPeerSpecProviderConfigRefPolicy
 */
export interface BgpPeerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BgpPeerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BgpPeerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BgpPeerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BgpPeerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BgpPeerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecProviderConfigRefPolicy(obj: BgpPeerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BgpPeerSpecPublishConnectionDetailsToConfigRef
 */
export interface BgpPeerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BgpPeerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BgpPeerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BgpPeerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BgpPeerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecPublishConnectionDetailsToConfigRef(obj: BgpPeerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BgpPeerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BgpPeerSpecPublishConnectionDetailsToMetadata
 */
export interface BgpPeerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BgpPeerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BgpPeerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BgpPeerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BgpPeerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecPublishConnectionDetailsToMetadata(obj: BgpPeerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BgpPeerSpecForProviderVirtualInterfaceIdRefPolicy
 */
export interface BgpPeerSpecForProviderVirtualInterfaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BgpPeerSpecForProviderVirtualInterfaceIdRefPolicy#resolution
   */
  readonly resolution?: BgpPeerSpecForProviderVirtualInterfaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BgpPeerSpecForProviderVirtualInterfaceIdRefPolicy#resolve
   */
  readonly resolve?: BgpPeerSpecForProviderVirtualInterfaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BgpPeerSpecForProviderVirtualInterfaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecForProviderVirtualInterfaceIdRefPolicy(obj: BgpPeerSpecForProviderVirtualInterfaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicy
 */
export interface BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicy#resolution
   */
  readonly resolution?: BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicy#resolve
   */
  readonly resolve?: BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicy(obj: BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BgpPeerSpecProviderConfigRefPolicyResolution
 */
export enum BgpPeerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BgpPeerSpecProviderConfigRefPolicyResolve
 */
export enum BgpPeerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BgpPeerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BgpPeerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BgpPeerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BgpPeerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BgpPeerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BgpPeerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BgpPeerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecPublishConnectionDetailsToConfigRefPolicy(obj: BgpPeerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BgpPeerSpecForProviderVirtualInterfaceIdRefPolicyResolution
 */
export enum BgpPeerSpecForProviderVirtualInterfaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BgpPeerSpecForProviderVirtualInterfaceIdRefPolicyResolve
 */
export enum BgpPeerSpecForProviderVirtualInterfaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicyResolution
 */
export enum BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicyResolve
 */
export enum BgpPeerSpecForProviderVirtualInterfaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BgpPeerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BgpPeerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BgpPeerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BgpPeerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Connection is the Schema for the Connections API. Provides a Connection of Direct Connect.
 *
 * @schema Connection
 */
export class Connection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Connection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'Connection',
  }

  /**
   * Renders a Kubernetes manifest for "Connection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectionProps): any {
    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(props),
    };
  }

  /**
   * Defines a "Connection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectionProps) {
    super(scope, id, {
      ...Connection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(resolved),
    };
  }
}

/**
 * Connection is the Schema for the Connections API. Provides a Connection of Direct Connect.
 *
 * @schema Connection
 */
export interface ConnectionProps {
  /**
   * @schema Connection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectionSpec defines the desired state of Connection
   *
   * @schema Connection#spec
   */
  readonly spec: ConnectionSpec;

}

/**
 * Converts an object of type 'ConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProps(obj: ConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionSpec defines the desired state of Connection
 *
 * @schema ConnectionSpec
 */
export interface ConnectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectionSpecDeletionPolicy;

  /**
   * @schema ConnectionSpec#forProvider
   */
  readonly forProvider: ConnectionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ConnectionSpec#initProvider
   */
  readonly initProvider?: ConnectionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConnectionSpec#managementPolicies
   */
  readonly managementPolicies?: ConnectionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpec(obj: ConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectionSpecForProvider(obj.forProvider),
    'initProvider': toJson_ConnectionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConnectionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConnectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectionSpecDeletionPolicy
 */
export enum ConnectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConnectionSpecForProvider
 */
export interface ConnectionSpecForProvider {
  /**
   * The bandwidth of the connection. Valid values for dedicated connections: 1Gbps, 10Gbps. Valid values for hosted connections: 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, 10Gbps and 100Gbps. Case sensitive.
   *
   * @schema ConnectionSpecForProvider#bandwidth
   */
  readonly bandwidth?: string;

  /**
   * The connection MAC Security (MACsec) encryption mode. MAC Security (MACsec) is only available on dedicated connections. Valid values are no_encrypt, should_encrypt, and must_encrypt.
   *
   * @schema ConnectionSpecForProvider#encryptionMode
   */
  readonly encryptionMode?: string;

  /**
   * The AWS Direct Connect location where the connection is located. See DescribeLocations for the list of AWS Direct Connect locations. Use locationCode.
   *
   * @schema ConnectionSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The name of the connection.
   *
   * @schema ConnectionSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The name of the service provider associated with the connection.
   *
   * @schema ConnectionSpecForProvider#providerName
   */
  readonly providerName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConnectionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Boolean value indicating whether you want the connection to support MAC Security (MACsec). MAC Security (MACsec) is only available on dedicated connections. See MACsec prerequisites for more information about MAC Security (MACsec) prerequisites. Default value: false.
   *
   * @schema ConnectionSpecForProvider#requestMacsec
   */
  readonly requestMacsec?: boolean;

  /**
   * @schema ConnectionSpecForProvider#skipDestroy
   */
  readonly skipDestroy?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConnectionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConnectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProvider(obj: ConnectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bandwidth': obj.bandwidth,
    'encryptionMode': obj.encryptionMode,
    'location': obj.location,
    'name': obj.name,
    'providerName': obj.providerName,
    'region': obj.region,
    'requestMacsec': obj.requestMacsec,
    'skipDestroy': obj.skipDestroy,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ConnectionSpecInitProvider
 */
export interface ConnectionSpecInitProvider {
  /**
   * The bandwidth of the connection. Valid values for dedicated connections: 1Gbps, 10Gbps. Valid values for hosted connections: 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, 10Gbps and 100Gbps. Case sensitive.
   *
   * @schema ConnectionSpecInitProvider#bandwidth
   */
  readonly bandwidth?: string;

  /**
   * The connection MAC Security (MACsec) encryption mode. MAC Security (MACsec) is only available on dedicated connections. Valid values are no_encrypt, should_encrypt, and must_encrypt.
   *
   * @schema ConnectionSpecInitProvider#encryptionMode
   */
  readonly encryptionMode?: string;

  /**
   * The AWS Direct Connect location where the connection is located. See DescribeLocations for the list of AWS Direct Connect locations. Use locationCode.
   *
   * @schema ConnectionSpecInitProvider#location
   */
  readonly location?: string;

  /**
   * The name of the connection.
   *
   * @schema ConnectionSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The name of the service provider associated with the connection.
   *
   * @schema ConnectionSpecInitProvider#providerName
   */
  readonly providerName?: string;

  /**
   * Boolean value indicating whether you want the connection to support MAC Security (MACsec). MAC Security (MACsec) is only available on dedicated connections. See MACsec prerequisites for more information about MAC Security (MACsec) prerequisites. Default value: false.
   *
   * @schema ConnectionSpecInitProvider#requestMacsec
   */
  readonly requestMacsec?: boolean;

  /**
   * @schema ConnectionSpecInitProvider#skipDestroy
   */
  readonly skipDestroy?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConnectionSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConnectionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecInitProvider(obj: ConnectionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bandwidth': obj.bandwidth,
    'encryptionMode': obj.encryptionMode,
    'location': obj.location,
    'name': obj.name,
    'providerName': obj.providerName,
    'requestMacsec': obj.requestMacsec,
    'skipDestroy': obj.skipDestroy,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConnectionSpecManagementPolicies
 */
export enum ConnectionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectionSpecProviderConfigRef
 */
export interface ConnectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRef(obj: ConnectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectionSpecPublishConnectionDetailsTo
 */
export interface ConnectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsTo(obj: ConnectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectionSpecWriteConnectionSecretToRef
 */
export interface ConnectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecWriteConnectionSecretToRef(obj: ConnectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecProviderConfigRefPolicy
 */
export interface ConnectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRefPolicy(obj: ConnectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj: ConnectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj: ConnectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolution
 */
export enum ConnectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolve
 */
export enum ConnectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ConnectionAssociation is the Schema for the ConnectionAssociations API. Associates a Direct Connect Connection with a LAG.
 *
 * @schema ConnectionAssociation
 */
export class ConnectionAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConnectionAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'ConnectionAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "ConnectionAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectionAssociationProps): any {
    return {
      ...ConnectionAssociation.GVK,
      ...toJson_ConnectionAssociationProps(props),
    };
  }

  /**
   * Defines a "ConnectionAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectionAssociationProps) {
    super(scope, id, {
      ...ConnectionAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConnectionAssociation.GVK,
      ...toJson_ConnectionAssociationProps(resolved),
    };
  }
}

/**
 * ConnectionAssociation is the Schema for the ConnectionAssociations API. Associates a Direct Connect Connection with a LAG.
 *
 * @schema ConnectionAssociation
 */
export interface ConnectionAssociationProps {
  /**
   * @schema ConnectionAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectionAssociationSpec defines the desired state of ConnectionAssociation
   *
   * @schema ConnectionAssociation#spec
   */
  readonly spec: ConnectionAssociationSpec;

}

/**
 * Converts an object of type 'ConnectionAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationProps(obj: ConnectionAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectionAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionAssociationSpec defines the desired state of ConnectionAssociation
 *
 * @schema ConnectionAssociationSpec
 */
export interface ConnectionAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectionAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectionAssociationSpecDeletionPolicy;

  /**
   * @schema ConnectionAssociationSpec#forProvider
   */
  readonly forProvider: ConnectionAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ConnectionAssociationSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConnectionAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: ConnectionAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectionAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectionAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectionAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectionAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectionAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectionAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectionAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpec(obj: ConnectionAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectionAssociationSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConnectionAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConnectionAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectionAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectionAssociationSpecDeletionPolicy
 */
export enum ConnectionAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConnectionAssociationSpecForProvider
 */
export interface ConnectionAssociationSpecForProvider {
  /**
   * The ID of the connection.
   *
   * @schema ConnectionAssociationSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * Reference to a Connection in directconnect to populate connectionId.
   *
   * @schema ConnectionAssociationSpecForProvider#connectionIdRef
   */
  readonly connectionIdRef?: ConnectionAssociationSpecForProviderConnectionIdRef;

  /**
   * Selector for a Connection in directconnect to populate connectionId.
   *
   * @schema ConnectionAssociationSpecForProvider#connectionIdSelector
   */
  readonly connectionIdSelector?: ConnectionAssociationSpecForProviderConnectionIdSelector;

  /**
   * The ID of the LAG with which to associate the connection.
   *
   * @schema ConnectionAssociationSpecForProvider#lagId
   */
  readonly lagId?: string;

  /**
   * Reference to a Lag in directconnect to populate lagId.
   *
   * @schema ConnectionAssociationSpecForProvider#lagIdRef
   */
  readonly lagIdRef?: ConnectionAssociationSpecForProviderLagIdRef;

  /**
   * Selector for a Lag in directconnect to populate lagId.
   *
   * @schema ConnectionAssociationSpecForProvider#lagIdSelector
   */
  readonly lagIdSelector?: ConnectionAssociationSpecForProviderLagIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConnectionAssociationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecForProvider(obj: ConnectionAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionId': obj.connectionId,
    'connectionIdRef': toJson_ConnectionAssociationSpecForProviderConnectionIdRef(obj.connectionIdRef),
    'connectionIdSelector': toJson_ConnectionAssociationSpecForProviderConnectionIdSelector(obj.connectionIdSelector),
    'lagId': obj.lagId,
    'lagIdRef': toJson_ConnectionAssociationSpecForProviderLagIdRef(obj.lagIdRef),
    'lagIdSelector': toJson_ConnectionAssociationSpecForProviderLagIdSelector(obj.lagIdSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConnectionAssociationSpecManagementPolicies
 */
export enum ConnectionAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectionAssociationSpecProviderConfigRef
 */
export interface ConnectionAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectionAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecProviderConfigRef(obj: ConnectionAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectionAssociationSpecPublishConnectionDetailsTo
 */
export interface ConnectionAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectionAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectionAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectionAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectionAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectionAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecPublishConnectionDetailsTo(obj: ConnectionAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectionAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectionAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectionAssociationSpecWriteConnectionSecretToRef
 */
export interface ConnectionAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectionAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecWriteConnectionSecretToRef(obj: ConnectionAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection in directconnect to populate connectionId.
 *
 * @schema ConnectionAssociationSpecForProviderConnectionIdRef
 */
export interface ConnectionAssociationSpecForProviderConnectionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionAssociationSpecForProviderConnectionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionAssociationSpecForProviderConnectionIdRef#policy
   */
  readonly policy?: ConnectionAssociationSpecForProviderConnectionIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecForProviderConnectionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecForProviderConnectionIdRef(obj: ConnectionAssociationSpecForProviderConnectionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionAssociationSpecForProviderConnectionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection in directconnect to populate connectionId.
 *
 * @schema ConnectionAssociationSpecForProviderConnectionIdSelector
 */
export interface ConnectionAssociationSpecForProviderConnectionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionAssociationSpecForProviderConnectionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionAssociationSpecForProviderConnectionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionAssociationSpecForProviderConnectionIdSelector#policy
   */
  readonly policy?: ConnectionAssociationSpecForProviderConnectionIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecForProviderConnectionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecForProviderConnectionIdSelector(obj: ConnectionAssociationSpecForProviderConnectionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionAssociationSpecForProviderConnectionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Lag in directconnect to populate lagId.
 *
 * @schema ConnectionAssociationSpecForProviderLagIdRef
 */
export interface ConnectionAssociationSpecForProviderLagIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionAssociationSpecForProviderLagIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionAssociationSpecForProviderLagIdRef#policy
   */
  readonly policy?: ConnectionAssociationSpecForProviderLagIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecForProviderLagIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecForProviderLagIdRef(obj: ConnectionAssociationSpecForProviderLagIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionAssociationSpecForProviderLagIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Lag in directconnect to populate lagId.
 *
 * @schema ConnectionAssociationSpecForProviderLagIdSelector
 */
export interface ConnectionAssociationSpecForProviderLagIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionAssociationSpecForProviderLagIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionAssociationSpecForProviderLagIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionAssociationSpecForProviderLagIdSelector#policy
   */
  readonly policy?: ConnectionAssociationSpecForProviderLagIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecForProviderLagIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecForProviderLagIdSelector(obj: ConnectionAssociationSpecForProviderLagIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionAssociationSpecForProviderLagIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionAssociationSpecProviderConfigRefPolicy
 */
export interface ConnectionAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecProviderConfigRefPolicy(obj: ConnectionAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectionAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectionAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecPublishConnectionDetailsToConfigRef(obj: ConnectionAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectionAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectionAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectionAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecPublishConnectionDetailsToMetadata(obj: ConnectionAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionAssociationSpecForProviderConnectionIdRefPolicy
 */
export interface ConnectionAssociationSpecForProviderConnectionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionAssociationSpecForProviderConnectionIdRefPolicy#resolution
   */
  readonly resolution?: ConnectionAssociationSpecForProviderConnectionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionAssociationSpecForProviderConnectionIdRefPolicy#resolve
   */
  readonly resolve?: ConnectionAssociationSpecForProviderConnectionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecForProviderConnectionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecForProviderConnectionIdRefPolicy(obj: ConnectionAssociationSpecForProviderConnectionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionAssociationSpecForProviderConnectionIdSelectorPolicy
 */
export interface ConnectionAssociationSpecForProviderConnectionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionAssociationSpecForProviderConnectionIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionAssociationSpecForProviderConnectionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionAssociationSpecForProviderConnectionIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionAssociationSpecForProviderConnectionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecForProviderConnectionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecForProviderConnectionIdSelectorPolicy(obj: ConnectionAssociationSpecForProviderConnectionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionAssociationSpecForProviderLagIdRefPolicy
 */
export interface ConnectionAssociationSpecForProviderLagIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionAssociationSpecForProviderLagIdRefPolicy#resolution
   */
  readonly resolution?: ConnectionAssociationSpecForProviderLagIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionAssociationSpecForProviderLagIdRefPolicy#resolve
   */
  readonly resolve?: ConnectionAssociationSpecForProviderLagIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecForProviderLagIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecForProviderLagIdRefPolicy(obj: ConnectionAssociationSpecForProviderLagIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionAssociationSpecForProviderLagIdSelectorPolicy
 */
export interface ConnectionAssociationSpecForProviderLagIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionAssociationSpecForProviderLagIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionAssociationSpecForProviderLagIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionAssociationSpecForProviderLagIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionAssociationSpecForProviderLagIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecForProviderLagIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecForProviderLagIdSelectorPolicy(obj: ConnectionAssociationSpecForProviderLagIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionAssociationSpecProviderConfigRefPolicyResolution
 */
export enum ConnectionAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionAssociationSpecProviderConfigRefPolicyResolve
 */
export enum ConnectionAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionAssociationSpecForProviderConnectionIdRefPolicyResolution
 */
export enum ConnectionAssociationSpecForProviderConnectionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionAssociationSpecForProviderConnectionIdRefPolicyResolve
 */
export enum ConnectionAssociationSpecForProviderConnectionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionAssociationSpecForProviderConnectionIdSelectorPolicyResolution
 */
export enum ConnectionAssociationSpecForProviderConnectionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionAssociationSpecForProviderConnectionIdSelectorPolicyResolve
 */
export enum ConnectionAssociationSpecForProviderConnectionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionAssociationSpecForProviderLagIdRefPolicyResolution
 */
export enum ConnectionAssociationSpecForProviderLagIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionAssociationSpecForProviderLagIdRefPolicyResolve
 */
export enum ConnectionAssociationSpecForProviderLagIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionAssociationSpecForProviderLagIdSelectorPolicyResolution
 */
export enum ConnectionAssociationSpecForProviderLagIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionAssociationSpecForProviderLagIdSelectorPolicyResolve
 */
export enum ConnectionAssociationSpecForProviderLagIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Gateway is the Schema for the Gateways API. Provides a Direct Connect Gateway.
 *
 * @schema Gateway
 */
export class Gateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Gateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'Gateway',
  }

  /**
   * Renders a Kubernetes manifest for "Gateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GatewayProps): any {
    return {
      ...Gateway.GVK,
      ...toJson_GatewayProps(props),
    };
  }

  /**
   * Defines a "Gateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GatewayProps) {
    super(scope, id, {
      ...Gateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Gateway.GVK,
      ...toJson_GatewayProps(resolved),
    };
  }
}

/**
 * Gateway is the Schema for the Gateways API. Provides a Direct Connect Gateway.
 *
 * @schema Gateway
 */
export interface GatewayProps {
  /**
   * @schema Gateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GatewaySpec defines the desired state of Gateway
   *
   * @schema Gateway#spec
   */
  readonly spec: GatewaySpec;

}

/**
 * Converts an object of type 'GatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayProps(obj: GatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewaySpec defines the desired state of Gateway
 *
 * @schema GatewaySpec
 */
export interface GatewaySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GatewaySpec#deletionPolicy
   */
  readonly deletionPolicy?: GatewaySpecDeletionPolicy;

  /**
   * @schema GatewaySpec#forProvider
   */
  readonly forProvider: GatewaySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema GatewaySpec#initProvider
   */
  readonly initProvider?: GatewaySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GatewaySpec#managementPolicies
   */
  readonly managementPolicies?: GatewaySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GatewaySpec#providerConfigRef
   */
  readonly providerConfigRef?: GatewaySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GatewaySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GatewaySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GatewaySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GatewaySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpec(obj: GatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GatewaySpecForProvider(obj.forProvider),
    'initProvider': toJson_GatewaySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GatewaySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GatewaySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GatewaySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GatewaySpecDeletionPolicy
 */
export enum GatewaySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GatewaySpecForProvider
 */
export interface GatewaySpecForProvider {
  /**
   * The ASN to be configured on the Amazon side of the connection. The ASN must be in the private range of 64,512 to 65,534 or 4,200,000,000 to 4,294,967,294.
   *
   * @schema GatewaySpecForProvider#amazonSideAsn
   */
  readonly amazonSideAsn?: string;

  /**
   * The name of the connection.
   *
   * @schema GatewaySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GatewaySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'GatewaySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecForProvider(obj: GatewaySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonSideAsn': obj.amazonSideAsn,
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema GatewaySpecInitProvider
 */
export interface GatewaySpecInitProvider {
  /**
   * The ASN to be configured on the Amazon side of the connection. The ASN must be in the private range of 64,512 to 65,534 or 4,200,000,000 to 4,294,967,294.
   *
   * @schema GatewaySpecInitProvider#amazonSideAsn
   */
  readonly amazonSideAsn?: string;

  /**
   * The name of the connection.
   *
   * @schema GatewaySpecInitProvider#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GatewaySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecInitProvider(obj: GatewaySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonSideAsn': obj.amazonSideAsn,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GatewaySpecManagementPolicies
 */
export enum GatewaySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GatewaySpecProviderConfigRef
 */
export interface GatewaySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewaySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewaySpecProviderConfigRef#policy
   */
  readonly policy?: GatewaySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewaySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecProviderConfigRef(obj: GatewaySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewaySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GatewaySpecPublishConnectionDetailsTo
 */
export interface GatewaySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GatewaySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GatewaySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GatewaySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GatewaySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GatewaySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GatewaySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecPublishConnectionDetailsTo(obj: GatewaySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GatewaySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GatewaySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GatewaySpecWriteConnectionSecretToRef
 */
export interface GatewaySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GatewaySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GatewaySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GatewaySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecWriteConnectionSecretToRef(obj: GatewaySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewaySpecProviderConfigRefPolicy
 */
export interface GatewaySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewaySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GatewaySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewaySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GatewaySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewaySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecProviderConfigRefPolicy(obj: GatewaySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GatewaySpecPublishConnectionDetailsToConfigRef
 */
export interface GatewaySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewaySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewaySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GatewaySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewaySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecPublishConnectionDetailsToConfigRef(obj: GatewaySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GatewaySpecPublishConnectionDetailsToMetadata
 */
export interface GatewaySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewaySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewaySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GatewaySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GatewaySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecPublishConnectionDetailsToMetadata(obj: GatewaySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewaySpecProviderConfigRefPolicyResolution
 */
export enum GatewaySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewaySpecProviderConfigRefPolicyResolve
 */
export enum GatewaySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GatewaySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GatewaySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewaySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj: GatewaySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GatewayAssociation is the Schema for the GatewayAssociations API. Associates a Direct Connect Gateway with a VGW or transit gateway.
 *
 * @schema GatewayAssociation
 */
export class GatewayAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GatewayAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'GatewayAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "GatewayAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GatewayAssociationProps): any {
    return {
      ...GatewayAssociation.GVK,
      ...toJson_GatewayAssociationProps(props),
    };
  }

  /**
   * Defines a "GatewayAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GatewayAssociationProps) {
    super(scope, id, {
      ...GatewayAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GatewayAssociation.GVK,
      ...toJson_GatewayAssociationProps(resolved),
    };
  }
}

/**
 * GatewayAssociation is the Schema for the GatewayAssociations API. Associates a Direct Connect Gateway with a VGW or transit gateway.
 *
 * @schema GatewayAssociation
 */
export interface GatewayAssociationProps {
  /**
   * @schema GatewayAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GatewayAssociationSpec defines the desired state of GatewayAssociation
   *
   * @schema GatewayAssociation#spec
   */
  readonly spec: GatewayAssociationSpec;

}

/**
 * Converts an object of type 'GatewayAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProps(obj: GatewayAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GatewayAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayAssociationSpec defines the desired state of GatewayAssociation
 *
 * @schema GatewayAssociationSpec
 */
export interface GatewayAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GatewayAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: GatewayAssociationSpecDeletionPolicy;

  /**
   * @schema GatewayAssociationSpec#forProvider
   */
  readonly forProvider: GatewayAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema GatewayAssociationSpec#initProvider
   */
  readonly initProvider?: GatewayAssociationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GatewayAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: GatewayAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GatewayAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: GatewayAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GatewayAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GatewayAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GatewayAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GatewayAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GatewayAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpec(obj: GatewayAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GatewayAssociationSpecForProvider(obj.forProvider),
    'initProvider': toJson_GatewayAssociationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GatewayAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GatewayAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GatewayAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GatewayAssociationSpecDeletionPolicy
 */
export enum GatewayAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GatewayAssociationSpecForProvider
 */
export interface GatewayAssociationSpecForProvider {
  /**
   * VPC prefixes (CIDRs) to advertise to the Direct Connect gateway. Defaults to the CIDR block of the VPC associated with the Virtual Gateway. To enable drift detection, must be configured.
   *
   * @default the CIDR block of the VPC associated with the Virtual Gateway. To enable drift detection, must be configured.
   * @schema GatewayAssociationSpecForProvider#allowedPrefixes
   */
  readonly allowedPrefixes?: string[];

  /**
   * The ID of the VGW or transit gateway with which to associate the Direct Connect gateway. Used for single account Direct Connect gateway associations.
   *
   * @schema GatewayAssociationSpecForProvider#associatedGatewayId
   */
  readonly associatedGatewayId?: string;

  /**
   * Reference to a VPNGateway in ec2 to populate associatedGatewayId.
   *
   * @schema GatewayAssociationSpecForProvider#associatedGatewayIdRef
   */
  readonly associatedGatewayIdRef?: GatewayAssociationSpecForProviderAssociatedGatewayIdRef;

  /**
   * Selector for a VPNGateway in ec2 to populate associatedGatewayId.
   *
   * @schema GatewayAssociationSpecForProvider#associatedGatewayIdSelector
   */
  readonly associatedGatewayIdSelector?: GatewayAssociationSpecForProviderAssociatedGatewayIdSelector;

  /**
   * The ID of the AWS account that owns the VGW or transit gateway with which to associate the Direct Connect gateway. Used for cross-account Direct Connect gateway associations.
   *
   * @schema GatewayAssociationSpecForProvider#associatedGatewayOwnerAccountId
   */
  readonly associatedGatewayOwnerAccountId?: string;

  /**
   * The ID of the Direct Connect gateway.
   *
   * @schema GatewayAssociationSpecForProvider#dxGatewayId
   */
  readonly dxGatewayId?: string;

  /**
   * Reference to a Gateway in directconnect to populate dxGatewayId.
   *
   * @schema GatewayAssociationSpecForProvider#dxGatewayIdRef
   */
  readonly dxGatewayIdRef?: GatewayAssociationSpecForProviderDxGatewayIdRef;

  /**
   * Selector for a Gateway in directconnect to populate dxGatewayId.
   *
   * @schema GatewayAssociationSpecForProvider#dxGatewayIdSelector
   */
  readonly dxGatewayIdSelector?: GatewayAssociationSpecForProviderDxGatewayIdSelector;

  /**
   * The ID of the Direct Connect gateway association proposal. Used for cross-account Direct Connect gateway associations.
   *
   * @schema GatewayAssociationSpecForProvider#proposalId
   */
  readonly proposalId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GatewayAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the Direct Connect gateway association resource.
   *
   * @schema GatewayAssociationSpecForProvider#vpnGatewayId
   */
  readonly vpnGatewayId?: string;

}

/**
 * Converts an object of type 'GatewayAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecForProvider(obj: GatewayAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedPrefixes': obj.allowedPrefixes?.map(y => y),
    'associatedGatewayId': obj.associatedGatewayId,
    'associatedGatewayIdRef': toJson_GatewayAssociationSpecForProviderAssociatedGatewayIdRef(obj.associatedGatewayIdRef),
    'associatedGatewayIdSelector': toJson_GatewayAssociationSpecForProviderAssociatedGatewayIdSelector(obj.associatedGatewayIdSelector),
    'associatedGatewayOwnerAccountId': obj.associatedGatewayOwnerAccountId,
    'dxGatewayId': obj.dxGatewayId,
    'dxGatewayIdRef': toJson_GatewayAssociationSpecForProviderDxGatewayIdRef(obj.dxGatewayIdRef),
    'dxGatewayIdSelector': toJson_GatewayAssociationSpecForProviderDxGatewayIdSelector(obj.dxGatewayIdSelector),
    'proposalId': obj.proposalId,
    'region': obj.region,
    'vpnGatewayId': obj.vpnGatewayId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema GatewayAssociationSpecInitProvider
 */
export interface GatewayAssociationSpecInitProvider {
  /**
   * VPC prefixes (CIDRs) to advertise to the Direct Connect gateway. Defaults to the CIDR block of the VPC associated with the Virtual Gateway. To enable drift detection, must be configured.
   *
   * @default the CIDR block of the VPC associated with the Virtual Gateway. To enable drift detection, must be configured.
   * @schema GatewayAssociationSpecInitProvider#allowedPrefixes
   */
  readonly allowedPrefixes?: string[];

  /**
   * The ID of the AWS account that owns the VGW or transit gateway with which to associate the Direct Connect gateway. Used for cross-account Direct Connect gateway associations.
   *
   * @schema GatewayAssociationSpecInitProvider#associatedGatewayOwnerAccountId
   */
  readonly associatedGatewayOwnerAccountId?: string;

  /**
   * The ID of the Direct Connect gateway association proposal. Used for cross-account Direct Connect gateway associations.
   *
   * @schema GatewayAssociationSpecInitProvider#proposalId
   */
  readonly proposalId?: string;

  /**
   * The ID of the Direct Connect gateway association resource.
   *
   * @schema GatewayAssociationSpecInitProvider#vpnGatewayId
   */
  readonly vpnGatewayId?: string;

}

/**
 * Converts an object of type 'GatewayAssociationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecInitProvider(obj: GatewayAssociationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedPrefixes': obj.allowedPrefixes?.map(y => y),
    'associatedGatewayOwnerAccountId': obj.associatedGatewayOwnerAccountId,
    'proposalId': obj.proposalId,
    'vpnGatewayId': obj.vpnGatewayId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GatewayAssociationSpecManagementPolicies
 */
export enum GatewayAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GatewayAssociationSpecProviderConfigRef
 */
export interface GatewayAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: GatewayAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecProviderConfigRef(obj: GatewayAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GatewayAssociationSpecPublishConnectionDetailsTo
 */
export interface GatewayAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GatewayAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GatewayAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GatewayAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GatewayAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GatewayAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GatewayAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecPublishConnectionDetailsTo(obj: GatewayAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GatewayAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GatewayAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GatewayAssociationSpecWriteConnectionSecretToRef
 */
export interface GatewayAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GatewayAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GatewayAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GatewayAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecWriteConnectionSecretToRef(obj: GatewayAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPNGateway in ec2 to populate associatedGatewayId.
 *
 * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdRef
 */
export interface GatewayAssociationSpecForProviderAssociatedGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdRef#policy
   */
  readonly policy?: GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationSpecForProviderAssociatedGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecForProviderAssociatedGatewayIdRef(obj: GatewayAssociationSpecForProviderAssociatedGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPNGateway in ec2 to populate associatedGatewayId.
 *
 * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdSelector
 */
export interface GatewayAssociationSpecForProviderAssociatedGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdSelector#policy
   */
  readonly policy?: GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationSpecForProviderAssociatedGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecForProviderAssociatedGatewayIdSelector(obj: GatewayAssociationSpecForProviderAssociatedGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Gateway in directconnect to populate dxGatewayId.
 *
 * @schema GatewayAssociationSpecForProviderDxGatewayIdRef
 */
export interface GatewayAssociationSpecForProviderDxGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayAssociationSpecForProviderDxGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayAssociationSpecForProviderDxGatewayIdRef#policy
   */
  readonly policy?: GatewayAssociationSpecForProviderDxGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationSpecForProviderDxGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecForProviderDxGatewayIdRef(obj: GatewayAssociationSpecForProviderDxGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayAssociationSpecForProviderDxGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Gateway in directconnect to populate dxGatewayId.
 *
 * @schema GatewayAssociationSpecForProviderDxGatewayIdSelector
 */
export interface GatewayAssociationSpecForProviderDxGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GatewayAssociationSpecForProviderDxGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GatewayAssociationSpecForProviderDxGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GatewayAssociationSpecForProviderDxGatewayIdSelector#policy
   */
  readonly policy?: GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationSpecForProviderDxGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecForProviderDxGatewayIdSelector(obj: GatewayAssociationSpecForProviderDxGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayAssociationSpecProviderConfigRefPolicy
 */
export interface GatewayAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GatewayAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GatewayAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecProviderConfigRefPolicy(obj: GatewayAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GatewayAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface GatewayAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecPublishConnectionDetailsToConfigRef(obj: GatewayAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GatewayAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface GatewayAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewayAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewayAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GatewayAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GatewayAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecPublishConnectionDetailsToMetadata(obj: GatewayAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicy
 */
export interface GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicy#resolution
   */
  readonly resolution?: GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicy#resolve
   */
  readonly resolve?: GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicy(obj: GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicy
 */
export interface GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicy(obj: GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayAssociationSpecForProviderDxGatewayIdRefPolicy
 */
export interface GatewayAssociationSpecForProviderDxGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationSpecForProviderDxGatewayIdRefPolicy#resolution
   */
  readonly resolution?: GatewayAssociationSpecForProviderDxGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationSpecForProviderDxGatewayIdRefPolicy#resolve
   */
  readonly resolve?: GatewayAssociationSpecForProviderDxGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationSpecForProviderDxGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecForProviderDxGatewayIdRefPolicy(obj: GatewayAssociationSpecForProviderDxGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicy
 */
export interface GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicy(obj: GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationSpecProviderConfigRefPolicyResolution
 */
export enum GatewayAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationSpecProviderConfigRefPolicyResolve
 */
export enum GatewayAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicyResolution
 */
export enum GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicyResolve
 */
export enum GatewayAssociationSpecForProviderAssociatedGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicyResolution
 */
export enum GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicyResolve
 */
export enum GatewayAssociationSpecForProviderAssociatedGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationSpecForProviderDxGatewayIdRefPolicyResolution
 */
export enum GatewayAssociationSpecForProviderDxGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationSpecForProviderDxGatewayIdRefPolicyResolve
 */
export enum GatewayAssociationSpecForProviderDxGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicyResolution
 */
export enum GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicyResolve
 */
export enum GatewayAssociationSpecForProviderDxGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GatewayAssociationProposal is the Schema for the GatewayAssociationProposals API. Manages a Direct Connect Gateway Association Proposal.
 *
 * @schema GatewayAssociationProposal
 */
export class GatewayAssociationProposal extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GatewayAssociationProposal"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'GatewayAssociationProposal',
  }

  /**
   * Renders a Kubernetes manifest for "GatewayAssociationProposal".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GatewayAssociationProposalProps): any {
    return {
      ...GatewayAssociationProposal.GVK,
      ...toJson_GatewayAssociationProposalProps(props),
    };
  }

  /**
   * Defines a "GatewayAssociationProposal" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GatewayAssociationProposalProps) {
    super(scope, id, {
      ...GatewayAssociationProposal.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GatewayAssociationProposal.GVK,
      ...toJson_GatewayAssociationProposalProps(resolved),
    };
  }
}

/**
 * GatewayAssociationProposal is the Schema for the GatewayAssociationProposals API. Manages a Direct Connect Gateway Association Proposal.
 *
 * @schema GatewayAssociationProposal
 */
export interface GatewayAssociationProposalProps {
  /**
   * @schema GatewayAssociationProposal#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GatewayAssociationProposalSpec defines the desired state of GatewayAssociationProposal
   *
   * @schema GatewayAssociationProposal#spec
   */
  readonly spec: GatewayAssociationProposalSpec;

}

/**
 * Converts an object of type 'GatewayAssociationProposalProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalProps(obj: GatewayAssociationProposalProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GatewayAssociationProposalSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayAssociationProposalSpec defines the desired state of GatewayAssociationProposal
 *
 * @schema GatewayAssociationProposalSpec
 */
export interface GatewayAssociationProposalSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GatewayAssociationProposalSpec#deletionPolicy
   */
  readonly deletionPolicy?: GatewayAssociationProposalSpecDeletionPolicy;

  /**
   * @schema GatewayAssociationProposalSpec#forProvider
   */
  readonly forProvider: GatewayAssociationProposalSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema GatewayAssociationProposalSpec#initProvider
   */
  readonly initProvider?: GatewayAssociationProposalSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GatewayAssociationProposalSpec#managementPolicies
   */
  readonly managementPolicies?: GatewayAssociationProposalSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GatewayAssociationProposalSpec#providerConfigRef
   */
  readonly providerConfigRef?: GatewayAssociationProposalSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GatewayAssociationProposalSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GatewayAssociationProposalSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GatewayAssociationProposalSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GatewayAssociationProposalSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpec(obj: GatewayAssociationProposalSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GatewayAssociationProposalSpecForProvider(obj.forProvider),
    'initProvider': toJson_GatewayAssociationProposalSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GatewayAssociationProposalSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GatewayAssociationProposalSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GatewayAssociationProposalSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GatewayAssociationProposalSpecDeletionPolicy
 */
export enum GatewayAssociationProposalSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GatewayAssociationProposalSpecForProvider
 */
export interface GatewayAssociationProposalSpecForProvider {
  /**
   * VPC prefixes (CIDRs) to advertise to the Direct Connect gateway. Defaults to the CIDR block of the VPC associated with the Virtual Gateway. To enable drift detection, must be configured.
   *
   * @default the CIDR block of the VPC associated with the Virtual Gateway. To enable drift detection, must be configured.
   * @schema GatewayAssociationProposalSpecForProvider#allowedPrefixes
   */
  readonly allowedPrefixes?: string[];

  /**
   * The ID of the VGW or transit gateway with which to associate the Direct Connect gateway.
   *
   * @schema GatewayAssociationProposalSpecForProvider#associatedGatewayId
   */
  readonly associatedGatewayId?: string;

  /**
   * Reference to a VPNGateway in ec2 to populate associatedGatewayId.
   *
   * @schema GatewayAssociationProposalSpecForProvider#associatedGatewayIdRef
   */
  readonly associatedGatewayIdRef?: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRef;

  /**
   * Selector for a VPNGateway in ec2 to populate associatedGatewayId.
   *
   * @schema GatewayAssociationProposalSpecForProvider#associatedGatewayIdSelector
   */
  readonly associatedGatewayIdSelector?: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelector;

  /**
   * Direct Connect Gateway identifier.
   *
   * @schema GatewayAssociationProposalSpecForProvider#dxGatewayId
   */
  readonly dxGatewayId?: string;

  /**
   * Reference to a Gateway in directconnect to populate dxGatewayId.
   *
   * @schema GatewayAssociationProposalSpecForProvider#dxGatewayIdRef
   */
  readonly dxGatewayIdRef?: GatewayAssociationProposalSpecForProviderDxGatewayIdRef;

  /**
   * Selector for a Gateway in directconnect to populate dxGatewayId.
   *
   * @schema GatewayAssociationProposalSpecForProvider#dxGatewayIdSelector
   */
  readonly dxGatewayIdSelector?: GatewayAssociationProposalSpecForProviderDxGatewayIdSelector;

  /**
   * AWS Account identifier of the Direct Connect Gateway's owner.
   *
   * @schema GatewayAssociationProposalSpecForProvider#dxGatewayOwnerAccountId
   */
  readonly dxGatewayOwnerAccountId?: string;

  /**
   * Reference to a Gateway in directconnect to populate dxGatewayOwnerAccountId.
   *
   * @schema GatewayAssociationProposalSpecForProvider#dxGatewayOwnerAccountIdRef
   */
  readonly dxGatewayOwnerAccountIdRef?: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRef;

  /**
   * Selector for a Gateway in directconnect to populate dxGatewayOwnerAccountId.
   *
   * @schema GatewayAssociationProposalSpecForProvider#dxGatewayOwnerAccountIdSelector
   */
  readonly dxGatewayOwnerAccountIdSelector?: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GatewayAssociationProposalSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProvider(obj: GatewayAssociationProposalSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedPrefixes': obj.allowedPrefixes?.map(y => y),
    'associatedGatewayId': obj.associatedGatewayId,
    'associatedGatewayIdRef': toJson_GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRef(obj.associatedGatewayIdRef),
    'associatedGatewayIdSelector': toJson_GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelector(obj.associatedGatewayIdSelector),
    'dxGatewayId': obj.dxGatewayId,
    'dxGatewayIdRef': toJson_GatewayAssociationProposalSpecForProviderDxGatewayIdRef(obj.dxGatewayIdRef),
    'dxGatewayIdSelector': toJson_GatewayAssociationProposalSpecForProviderDxGatewayIdSelector(obj.dxGatewayIdSelector),
    'dxGatewayOwnerAccountId': obj.dxGatewayOwnerAccountId,
    'dxGatewayOwnerAccountIdRef': toJson_GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRef(obj.dxGatewayOwnerAccountIdRef),
    'dxGatewayOwnerAccountIdSelector': toJson_GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelector(obj.dxGatewayOwnerAccountIdSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema GatewayAssociationProposalSpecInitProvider
 */
export interface GatewayAssociationProposalSpecInitProvider {
  /**
   * VPC prefixes (CIDRs) to advertise to the Direct Connect gateway. Defaults to the CIDR block of the VPC associated with the Virtual Gateway. To enable drift detection, must be configured.
   *
   * @default the CIDR block of the VPC associated with the Virtual Gateway. To enable drift detection, must be configured.
   * @schema GatewayAssociationProposalSpecInitProvider#allowedPrefixes
   */
  readonly allowedPrefixes?: string[];

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecInitProvider(obj: GatewayAssociationProposalSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedPrefixes': obj.allowedPrefixes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GatewayAssociationProposalSpecManagementPolicies
 */
export enum GatewayAssociationProposalSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GatewayAssociationProposalSpecProviderConfigRef
 */
export interface GatewayAssociationProposalSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayAssociationProposalSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayAssociationProposalSpecProviderConfigRef#policy
   */
  readonly policy?: GatewayAssociationProposalSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecProviderConfigRef(obj: GatewayAssociationProposalSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayAssociationProposalSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GatewayAssociationProposalSpecPublishConnectionDetailsTo
 */
export interface GatewayAssociationProposalSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GatewayAssociationProposalSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GatewayAssociationProposalSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GatewayAssociationProposalSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GatewayAssociationProposalSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecPublishConnectionDetailsTo(obj: GatewayAssociationProposalSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GatewayAssociationProposalSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GatewayAssociationProposalSpecWriteConnectionSecretToRef
 */
export interface GatewayAssociationProposalSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GatewayAssociationProposalSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GatewayAssociationProposalSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecWriteConnectionSecretToRef(obj: GatewayAssociationProposalSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPNGateway in ec2 to populate associatedGatewayId.
 *
 * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRef
 */
export interface GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRef#policy
   */
  readonly policy?: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRef(obj: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPNGateway in ec2 to populate associatedGatewayId.
 *
 * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelector
 */
export interface GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelector#policy
   */
  readonly policy?: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelector(obj: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Gateway in directconnect to populate dxGatewayId.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdRef
 */
export interface GatewayAssociationProposalSpecForProviderDxGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdRef#policy
   */
  readonly policy?: GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderDxGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderDxGatewayIdRef(obj: GatewayAssociationProposalSpecForProviderDxGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Gateway in directconnect to populate dxGatewayId.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdSelector
 */
export interface GatewayAssociationProposalSpecForProviderDxGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdSelector#policy
   */
  readonly policy?: GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderDxGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderDxGatewayIdSelector(obj: GatewayAssociationProposalSpecForProviderDxGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Gateway in directconnect to populate dxGatewayOwnerAccountId.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRef
 */
export interface GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRef#policy
   */
  readonly policy?: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRef(obj: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Gateway in directconnect to populate dxGatewayOwnerAccountId.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelector
 */
export interface GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelector#policy
   */
  readonly policy?: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelector(obj: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayAssociationProposalSpecProviderConfigRefPolicy
 */
export interface GatewayAssociationProposalSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationProposalSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GatewayAssociationProposalSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationProposalSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GatewayAssociationProposalSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecProviderConfigRefPolicy(obj: GatewayAssociationProposalSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRef
 */
export interface GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRef(obj: GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToMetadata
 */
export interface GatewayAssociationProposalSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecPublishConnectionDetailsToMetadata(obj: GatewayAssociationProposalSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicy
 */
export interface GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicy#resolution
   */
  readonly resolution?: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicy#resolve
   */
  readonly resolve?: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicy(obj: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicy
 */
export interface GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicy(obj: GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicy
 */
export interface GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicy#resolution
   */
  readonly resolution?: GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicy#resolve
   */
  readonly resolve?: GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicy(obj: GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicy
 */
export interface GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicy(obj: GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicy
 */
export interface GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicy#resolution
   */
  readonly resolution?: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicy#resolve
   */
  readonly resolve?: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicy(obj: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicy
 */
export interface GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicy(obj: GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationProposalSpecProviderConfigRefPolicyResolution
 */
export enum GatewayAssociationProposalSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationProposalSpecProviderConfigRefPolicyResolve
 */
export enum GatewayAssociationProposalSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicy(obj: GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicyResolution
 */
export enum GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicyResolve
 */
export enum GatewayAssociationProposalSpecForProviderAssociatedGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicyResolution
 */
export enum GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicyResolve
 */
export enum GatewayAssociationProposalSpecForProviderAssociatedGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicyResolution
 */
export enum GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicyResolve
 */
export enum GatewayAssociationProposalSpecForProviderDxGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicyResolution
 */
export enum GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicyResolve
 */
export enum GatewayAssociationProposalSpecForProviderDxGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicyResolution
 */
export enum GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicyResolve
 */
export enum GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicyResolution
 */
export enum GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicyResolve
 */
export enum GatewayAssociationProposalSpecForProviderDxGatewayOwnerAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GatewayAssociationProposalSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HostedPrivateVirtualInterface is the Schema for the HostedPrivateVirtualInterfaces API. Provides a Direct Connect hosted private virtual interface resource.
 *
 * @schema HostedPrivateVirtualInterface
 */
export class HostedPrivateVirtualInterface extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HostedPrivateVirtualInterface"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'HostedPrivateVirtualInterface',
  }

  /**
   * Renders a Kubernetes manifest for "HostedPrivateVirtualInterface".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HostedPrivateVirtualInterfaceProps): any {
    return {
      ...HostedPrivateVirtualInterface.GVK,
      ...toJson_HostedPrivateVirtualInterfaceProps(props),
    };
  }

  /**
   * Defines a "HostedPrivateVirtualInterface" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HostedPrivateVirtualInterfaceProps) {
    super(scope, id, {
      ...HostedPrivateVirtualInterface.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HostedPrivateVirtualInterface.GVK,
      ...toJson_HostedPrivateVirtualInterfaceProps(resolved),
    };
  }
}

/**
 * HostedPrivateVirtualInterface is the Schema for the HostedPrivateVirtualInterfaces API. Provides a Direct Connect hosted private virtual interface resource.
 *
 * @schema HostedPrivateVirtualInterface
 */
export interface HostedPrivateVirtualInterfaceProps {
  /**
   * @schema HostedPrivateVirtualInterface#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HostedPrivateVirtualInterfaceSpec defines the desired state of HostedPrivateVirtualInterface
   *
   * @schema HostedPrivateVirtualInterface#spec
   */
  readonly spec: HostedPrivateVirtualInterfaceSpec;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceProps(obj: HostedPrivateVirtualInterfaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HostedPrivateVirtualInterfaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostedPrivateVirtualInterfaceSpec defines the desired state of HostedPrivateVirtualInterface
 *
 * @schema HostedPrivateVirtualInterfaceSpec
 */
export interface HostedPrivateVirtualInterfaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedPrivateVirtualInterfaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: HostedPrivateVirtualInterfaceSpecDeletionPolicy;

  /**
   * @schema HostedPrivateVirtualInterfaceSpec#forProvider
   */
  readonly forProvider: HostedPrivateVirtualInterfaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema HostedPrivateVirtualInterfaceSpec#initProvider
   */
  readonly initProvider?: HostedPrivateVirtualInterfaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema HostedPrivateVirtualInterfaceSpec#managementPolicies
   */
  readonly managementPolicies?: HostedPrivateVirtualInterfaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HostedPrivateVirtualInterfaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: HostedPrivateVirtualInterfaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HostedPrivateVirtualInterfaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HostedPrivateVirtualInterfaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HostedPrivateVirtualInterfaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpec(obj: HostedPrivateVirtualInterfaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HostedPrivateVirtualInterfaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_HostedPrivateVirtualInterfaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_HostedPrivateVirtualInterfaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HostedPrivateVirtualInterfaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedPrivateVirtualInterfaceSpecDeletionPolicy
 */
export enum HostedPrivateVirtualInterfaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HostedPrivateVirtualInterfaceSpecForProvider
 */
export interface HostedPrivateVirtualInterfaceSpecForProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The ID of the Direct Connect connection (or LAG) on which to create the virtual interface.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * Reference to a Connection to populate connectionId.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#connectionIdRef
   */
  readonly connectionIdRef?: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRef;

  /**
   * Selector for a Connection to populate connectionId.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#connectionIdSelector
   */
  readonly connectionIdSelector?: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelector;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The maximum transmission unit (MTU) is the size, in bytes, of the largest permissible packet that can be passed over the connection. The MTU of a virtual private interface can be either 1500 or 9001 (jumbo frames). Default is 1500.
   *
   * @default 1500.
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#mtu
   */
  readonly mtu?: number;

  /**
   * The name for the virtual interface.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The AWS account that will own the new virtual interface.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#ownerAccountId
   */
  readonly ownerAccountId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The VLAN ID.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecForProvider(obj: HostedPrivateVirtualInterfaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'connectionId': obj.connectionId,
    'connectionIdRef': toJson_HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRef(obj.connectionIdRef),
    'connectionIdSelector': toJson_HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelector(obj.connectionIdSelector),
    'customerAddress': obj.customerAddress,
    'mtu': obj.mtu,
    'name': obj.name,
    'ownerAccountId': obj.ownerAccountId,
    'region': obj.region,
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema HostedPrivateVirtualInterfaceSpecInitProvider
 */
export interface HostedPrivateVirtualInterfaceSpecInitProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema HostedPrivateVirtualInterfaceSpecInitProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema HostedPrivateVirtualInterfaceSpecInitProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema HostedPrivateVirtualInterfaceSpecInitProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema HostedPrivateVirtualInterfaceSpecInitProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema HostedPrivateVirtualInterfaceSpecInitProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The maximum transmission unit (MTU) is the size, in bytes, of the largest permissible packet that can be passed over the connection. The MTU of a virtual private interface can be either 1500 or 9001 (jumbo frames). Default is 1500.
   *
   * @default 1500.
   * @schema HostedPrivateVirtualInterfaceSpecInitProvider#mtu
   */
  readonly mtu?: number;

  /**
   * The name for the virtual interface.
   *
   * @schema HostedPrivateVirtualInterfaceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The AWS account that will own the new virtual interface.
   *
   * @schema HostedPrivateVirtualInterfaceSpecInitProvider#ownerAccountId
   */
  readonly ownerAccountId?: string;

  /**
   * The VLAN ID.
   *
   * @schema HostedPrivateVirtualInterfaceSpecInitProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecInitProvider(obj: HostedPrivateVirtualInterfaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'customerAddress': obj.customerAddress,
    'mtu': obj.mtu,
    'name': obj.name,
    'ownerAccountId': obj.ownerAccountId,
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema HostedPrivateVirtualInterfaceSpecManagementPolicies
 */
export enum HostedPrivateVirtualInterfaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HostedPrivateVirtualInterfaceSpecProviderConfigRef
 */
export interface HostedPrivateVirtualInterfaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPrivateVirtualInterfaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPrivateVirtualInterfaceSpecProviderConfigRef#policy
   */
  readonly policy?: HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecProviderConfigRef(obj: HostedPrivateVirtualInterfaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsTo
 */
export interface HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsTo(obj: HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HostedPrivateVirtualInterfaceSpecWriteConnectionSecretToRef
 */
export interface HostedPrivateVirtualInterfaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HostedPrivateVirtualInterfaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HostedPrivateVirtualInterfaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecWriteConnectionSecretToRef(obj: HostedPrivateVirtualInterfaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection to populate connectionId.
 *
 * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRef
 */
export interface HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRef#policy
   */
  readonly policy?: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRef(obj: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection to populate connectionId.
 *
 * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelector
 */
export interface HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelector#policy
   */
  readonly policy?: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelector(obj: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicy
 */
export interface HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicy(obj: HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef
 */
export interface HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj: HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata
 */
export interface HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj: HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy
 */
export interface HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolution
   */
  readonly resolution?: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolve
   */
  readonly resolve?: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy
 */
export interface HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj: HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicyResolution
 */
export enum HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicyResolve
 */
export enum HostedPrivateVirtualInterfaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution
 */
export enum HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve
 */
export enum HostedPrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution
 */
export enum HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve
 */
export enum HostedPrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HostedPrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HostedPrivateVirtualInterfaceAccepter is the Schema for the HostedPrivateVirtualInterfaceAccepters API. Provides a resource to manage the accepter's side of a Direct Connect hosted private virtual interface.
 *
 * @schema HostedPrivateVirtualInterfaceAccepter
 */
export class HostedPrivateVirtualInterfaceAccepter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HostedPrivateVirtualInterfaceAccepter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'HostedPrivateVirtualInterfaceAccepter',
  }

  /**
   * Renders a Kubernetes manifest for "HostedPrivateVirtualInterfaceAccepter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HostedPrivateVirtualInterfaceAccepterProps): any {
    return {
      ...HostedPrivateVirtualInterfaceAccepter.GVK,
      ...toJson_HostedPrivateVirtualInterfaceAccepterProps(props),
    };
  }

  /**
   * Defines a "HostedPrivateVirtualInterfaceAccepter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HostedPrivateVirtualInterfaceAccepterProps) {
    super(scope, id, {
      ...HostedPrivateVirtualInterfaceAccepter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HostedPrivateVirtualInterfaceAccepter.GVK,
      ...toJson_HostedPrivateVirtualInterfaceAccepterProps(resolved),
    };
  }
}

/**
 * HostedPrivateVirtualInterfaceAccepter is the Schema for the HostedPrivateVirtualInterfaceAccepters API. Provides a resource to manage the accepter's side of a Direct Connect hosted private virtual interface.
 *
 * @schema HostedPrivateVirtualInterfaceAccepter
 */
export interface HostedPrivateVirtualInterfaceAccepterProps {
  /**
   * @schema HostedPrivateVirtualInterfaceAccepter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HostedPrivateVirtualInterfaceAccepterSpec defines the desired state of HostedPrivateVirtualInterfaceAccepter
   *
   * @schema HostedPrivateVirtualInterfaceAccepter#spec
   */
  readonly spec: HostedPrivateVirtualInterfaceAccepterSpec;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterProps(obj: HostedPrivateVirtualInterfaceAccepterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HostedPrivateVirtualInterfaceAccepterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostedPrivateVirtualInterfaceAccepterSpec defines the desired state of HostedPrivateVirtualInterfaceAccepter
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpec
 */
export interface HostedPrivateVirtualInterfaceAccepterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpec#deletionPolicy
   */
  readonly deletionPolicy?: HostedPrivateVirtualInterfaceAccepterSpecDeletionPolicy;

  /**
   * @schema HostedPrivateVirtualInterfaceAccepterSpec#forProvider
   */
  readonly forProvider: HostedPrivateVirtualInterfaceAccepterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpec#initProvider
   */
  readonly initProvider?: HostedPrivateVirtualInterfaceAccepterSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpec#managementPolicies
   */
  readonly managementPolicies?: HostedPrivateVirtualInterfaceAccepterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpec#providerConfigRef
   */
  readonly providerConfigRef?: HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HostedPrivateVirtualInterfaceAccepterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpec(obj: HostedPrivateVirtualInterfaceAccepterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HostedPrivateVirtualInterfaceAccepterSpecForProvider(obj.forProvider),
    'initProvider': toJson_HostedPrivateVirtualInterfaceAccepterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HostedPrivateVirtualInterfaceAccepterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecDeletionPolicy
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProvider
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecForProvider {
  /**
   * The ID of the Direct Connect gateway to which to connect the virtual interface.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProvider#dxGatewayId
   */
  readonly dxGatewayId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The ID of the Direct Connect virtual interface to accept.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProvider#virtualInterfaceId
   */
  readonly virtualInterfaceId?: string;

  /**
   * Reference to a HostedPrivateVirtualInterface to populate virtualInterfaceId.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProvider#virtualInterfaceIdRef
   */
  readonly virtualInterfaceIdRef?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef;

  /**
   * Selector for a HostedPrivateVirtualInterface to populate virtualInterfaceId.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProvider#virtualInterfaceIdSelector
   */
  readonly virtualInterfaceIdSelector?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector;

  /**
   * The ID of the virtual private gateway to which to connect the virtual interface.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProvider#vpnGatewayId
   */
  readonly vpnGatewayId?: string;

  /**
   * Reference to a VPNGateway in ec2 to populate vpnGatewayId.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProvider#vpnGatewayIdRef
   */
  readonly vpnGatewayIdRef?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRef;

  /**
   * Selector for a VPNGateway in ec2 to populate vpnGatewayId.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProvider#vpnGatewayIdSelector
   */
  readonly vpnGatewayIdSelector?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelector;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecForProvider(obj: HostedPrivateVirtualInterfaceAccepterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dxGatewayId': obj.dxGatewayId,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'virtualInterfaceId': obj.virtualInterfaceId,
    'virtualInterfaceIdRef': toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef(obj.virtualInterfaceIdRef),
    'virtualInterfaceIdSelector': toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector(obj.virtualInterfaceIdSelector),
    'vpnGatewayId': obj.vpnGatewayId,
    'vpnGatewayIdRef': toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRef(obj.vpnGatewayIdRef),
    'vpnGatewayIdSelector': toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelector(obj.vpnGatewayIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecInitProvider
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecInitProvider {
  /**
   * The ID of the Direct Connect gateway to which to connect the virtual interface.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecInitProvider#dxGatewayId
   */
  readonly dxGatewayId?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecInitProvider(obj: HostedPrivateVirtualInterfaceAccepterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dxGatewayId': obj.dxGatewayId,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecManagementPolicies
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRef
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRef#policy
   */
  readonly policy?: HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRef(obj: HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsTo
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsTo(obj: HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecWriteConnectionSecretToRef
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecWriteConnectionSecretToRef(obj: HostedPrivateVirtualInterfaceAccepterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HostedPrivateVirtualInterface to populate virtualInterfaceId.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef#policy
   */
  readonly policy?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef(obj: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HostedPrivateVirtualInterface to populate virtualInterfaceId.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector#policy
   */
  readonly policy?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector(obj: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPNGateway in ec2 to populate vpnGatewayId.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRef
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRef#policy
   */
  readonly policy?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRef(obj: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPNGateway in ec2 to populate vpnGatewayId.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelector
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelector#policy
   */
  readonly policy?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelector(obj: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicy
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicy(obj: HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef(obj: HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata(obj: HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy#resolution
   */
  readonly resolution?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy#resolve
   */
  readonly resolve?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy(obj: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy(obj: HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicy
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicy#resolution
   */
  readonly resolution?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicy#resolve
   */
  readonly resolve?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicy(obj: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicy
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicy(obj: HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolution
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolve
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj: HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolution
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolve
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolution
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolve
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicyResolution
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicyResolve
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicyResolution
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicyResolve
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecForProviderVpnGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HostedPrivateVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HostedPublicVirtualInterface is the Schema for the HostedPublicVirtualInterfaces API. Provides a Direct Connect hosted public virtual interface resource.
 *
 * @schema HostedPublicVirtualInterface
 */
export class HostedPublicVirtualInterface extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HostedPublicVirtualInterface"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'HostedPublicVirtualInterface',
  }

  /**
   * Renders a Kubernetes manifest for "HostedPublicVirtualInterface".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HostedPublicVirtualInterfaceProps): any {
    return {
      ...HostedPublicVirtualInterface.GVK,
      ...toJson_HostedPublicVirtualInterfaceProps(props),
    };
  }

  /**
   * Defines a "HostedPublicVirtualInterface" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HostedPublicVirtualInterfaceProps) {
    super(scope, id, {
      ...HostedPublicVirtualInterface.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HostedPublicVirtualInterface.GVK,
      ...toJson_HostedPublicVirtualInterfaceProps(resolved),
    };
  }
}

/**
 * HostedPublicVirtualInterface is the Schema for the HostedPublicVirtualInterfaces API. Provides a Direct Connect hosted public virtual interface resource.
 *
 * @schema HostedPublicVirtualInterface
 */
export interface HostedPublicVirtualInterfaceProps {
  /**
   * @schema HostedPublicVirtualInterface#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HostedPublicVirtualInterfaceSpec defines the desired state of HostedPublicVirtualInterface
   *
   * @schema HostedPublicVirtualInterface#spec
   */
  readonly spec: HostedPublicVirtualInterfaceSpec;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceProps(obj: HostedPublicVirtualInterfaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HostedPublicVirtualInterfaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostedPublicVirtualInterfaceSpec defines the desired state of HostedPublicVirtualInterface
 *
 * @schema HostedPublicVirtualInterfaceSpec
 */
export interface HostedPublicVirtualInterfaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedPublicVirtualInterfaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: HostedPublicVirtualInterfaceSpecDeletionPolicy;

  /**
   * @schema HostedPublicVirtualInterfaceSpec#forProvider
   */
  readonly forProvider: HostedPublicVirtualInterfaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema HostedPublicVirtualInterfaceSpec#initProvider
   */
  readonly initProvider?: HostedPublicVirtualInterfaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema HostedPublicVirtualInterfaceSpec#managementPolicies
   */
  readonly managementPolicies?: HostedPublicVirtualInterfaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HostedPublicVirtualInterfaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: HostedPublicVirtualInterfaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HostedPublicVirtualInterfaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HostedPublicVirtualInterfaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HostedPublicVirtualInterfaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HostedPublicVirtualInterfaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpec(obj: HostedPublicVirtualInterfaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HostedPublicVirtualInterfaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_HostedPublicVirtualInterfaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_HostedPublicVirtualInterfaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_HostedPublicVirtualInterfaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HostedPublicVirtualInterfaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedPublicVirtualInterfaceSpecDeletionPolicy
 */
export enum HostedPublicVirtualInterfaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HostedPublicVirtualInterfaceSpecForProvider
 */
export interface HostedPublicVirtualInterfaceSpecForProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The ID of the Direct Connect connection (or LAG) on which to create the virtual interface.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * Reference to a Connection to populate connectionId.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#connectionIdRef
   */
  readonly connectionIdRef?: HostedPublicVirtualInterfaceSpecForProviderConnectionIdRef;

  /**
   * Selector for a Connection to populate connectionId.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#connectionIdSelector
   */
  readonly connectionIdSelector?: HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelector;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The name for the virtual interface.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The AWS account that will own the new virtual interface.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#ownerAccountId
   */
  readonly ownerAccountId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of routes to be advertised to the AWS network in this region.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#routeFilterPrefixes
   */
  readonly routeFilterPrefixes?: string[];

  /**
   * The VLAN ID.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecForProvider(obj: HostedPublicVirtualInterfaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'connectionId': obj.connectionId,
    'connectionIdRef': toJson_HostedPublicVirtualInterfaceSpecForProviderConnectionIdRef(obj.connectionIdRef),
    'connectionIdSelector': toJson_HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelector(obj.connectionIdSelector),
    'customerAddress': obj.customerAddress,
    'name': obj.name,
    'ownerAccountId': obj.ownerAccountId,
    'region': obj.region,
    'routeFilterPrefixes': obj.routeFilterPrefixes?.map(y => y),
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema HostedPublicVirtualInterfaceSpecInitProvider
 */
export interface HostedPublicVirtualInterfaceSpecInitProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema HostedPublicVirtualInterfaceSpecInitProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema HostedPublicVirtualInterfaceSpecInitProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema HostedPublicVirtualInterfaceSpecInitProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema HostedPublicVirtualInterfaceSpecInitProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema HostedPublicVirtualInterfaceSpecInitProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The name for the virtual interface.
   *
   * @schema HostedPublicVirtualInterfaceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The AWS account that will own the new virtual interface.
   *
   * @schema HostedPublicVirtualInterfaceSpecInitProvider#ownerAccountId
   */
  readonly ownerAccountId?: string;

  /**
   * A list of routes to be advertised to the AWS network in this region.
   *
   * @schema HostedPublicVirtualInterfaceSpecInitProvider#routeFilterPrefixes
   */
  readonly routeFilterPrefixes?: string[];

  /**
   * The VLAN ID.
   *
   * @schema HostedPublicVirtualInterfaceSpecInitProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecInitProvider(obj: HostedPublicVirtualInterfaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'customerAddress': obj.customerAddress,
    'name': obj.name,
    'ownerAccountId': obj.ownerAccountId,
    'routeFilterPrefixes': obj.routeFilterPrefixes?.map(y => y),
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema HostedPublicVirtualInterfaceSpecManagementPolicies
 */
export enum HostedPublicVirtualInterfaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HostedPublicVirtualInterfaceSpecProviderConfigRef
 */
export interface HostedPublicVirtualInterfaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPublicVirtualInterfaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPublicVirtualInterfaceSpecProviderConfigRef#policy
   */
  readonly policy?: HostedPublicVirtualInterfaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecProviderConfigRef(obj: HostedPublicVirtualInterfaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPublicVirtualInterfaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsTo
 */
export interface HostedPublicVirtualInterfaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecPublishConnectionDetailsTo(obj: HostedPublicVirtualInterfaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HostedPublicVirtualInterfaceSpecWriteConnectionSecretToRef
 */
export interface HostedPublicVirtualInterfaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HostedPublicVirtualInterfaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HostedPublicVirtualInterfaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecWriteConnectionSecretToRef(obj: HostedPublicVirtualInterfaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection to populate connectionId.
 *
 * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdRef
 */
export interface HostedPublicVirtualInterfaceSpecForProviderConnectionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdRef#policy
   */
  readonly policy?: HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecForProviderConnectionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecForProviderConnectionIdRef(obj: HostedPublicVirtualInterfaceSpecForProviderConnectionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection to populate connectionId.
 *
 * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelector
 */
export interface HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelector#policy
   */
  readonly policy?: HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelector(obj: HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedPublicVirtualInterfaceSpecProviderConfigRefPolicy
 */
export interface HostedPublicVirtualInterfaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPublicVirtualInterfaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HostedPublicVirtualInterfaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPublicVirtualInterfaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HostedPublicVirtualInterfaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecProviderConfigRefPolicy(obj: HostedPublicVirtualInterfaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef
 */
export interface HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj: HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata
 */
export interface HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj: HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy
 */
export interface HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolution
   */
  readonly resolution?: HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolve
   */
  readonly resolve?: HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj: HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy
 */
export interface HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj: HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPublicVirtualInterfaceSpecProviderConfigRefPolicyResolution
 */
export enum HostedPublicVirtualInterfaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPublicVirtualInterfaceSpecProviderConfigRefPolicyResolve
 */
export enum HostedPublicVirtualInterfaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution
 */
export enum HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve
 */
export enum HostedPublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution
 */
export enum HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve
 */
export enum HostedPublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HostedPublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HostedPublicVirtualInterfaceAccepter is the Schema for the HostedPublicVirtualInterfaceAccepters API. Provides a resource to manage the accepter's side of a Direct Connect hosted public virtual interface.
 *
 * @schema HostedPublicVirtualInterfaceAccepter
 */
export class HostedPublicVirtualInterfaceAccepter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HostedPublicVirtualInterfaceAccepter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'HostedPublicVirtualInterfaceAccepter',
  }

  /**
   * Renders a Kubernetes manifest for "HostedPublicVirtualInterfaceAccepter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HostedPublicVirtualInterfaceAccepterProps): any {
    return {
      ...HostedPublicVirtualInterfaceAccepter.GVK,
      ...toJson_HostedPublicVirtualInterfaceAccepterProps(props),
    };
  }

  /**
   * Defines a "HostedPublicVirtualInterfaceAccepter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HostedPublicVirtualInterfaceAccepterProps) {
    super(scope, id, {
      ...HostedPublicVirtualInterfaceAccepter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HostedPublicVirtualInterfaceAccepter.GVK,
      ...toJson_HostedPublicVirtualInterfaceAccepterProps(resolved),
    };
  }
}

/**
 * HostedPublicVirtualInterfaceAccepter is the Schema for the HostedPublicVirtualInterfaceAccepters API. Provides a resource to manage the accepter's side of a Direct Connect hosted public virtual interface.
 *
 * @schema HostedPublicVirtualInterfaceAccepter
 */
export interface HostedPublicVirtualInterfaceAccepterProps {
  /**
   * @schema HostedPublicVirtualInterfaceAccepter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HostedPublicVirtualInterfaceAccepterSpec defines the desired state of HostedPublicVirtualInterfaceAccepter
   *
   * @schema HostedPublicVirtualInterfaceAccepter#spec
   */
  readonly spec: HostedPublicVirtualInterfaceAccepterSpec;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterProps(obj: HostedPublicVirtualInterfaceAccepterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HostedPublicVirtualInterfaceAccepterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostedPublicVirtualInterfaceAccepterSpec defines the desired state of HostedPublicVirtualInterfaceAccepter
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpec
 */
export interface HostedPublicVirtualInterfaceAccepterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpec#deletionPolicy
   */
  readonly deletionPolicy?: HostedPublicVirtualInterfaceAccepterSpecDeletionPolicy;

  /**
   * @schema HostedPublicVirtualInterfaceAccepterSpec#forProvider
   */
  readonly forProvider: HostedPublicVirtualInterfaceAccepterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpec#initProvider
   */
  readonly initProvider?: HostedPublicVirtualInterfaceAccepterSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpec#managementPolicies
   */
  readonly managementPolicies?: HostedPublicVirtualInterfaceAccepterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpec#providerConfigRef
   */
  readonly providerConfigRef?: HostedPublicVirtualInterfaceAccepterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HostedPublicVirtualInterfaceAccepterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpec(obj: HostedPublicVirtualInterfaceAccepterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HostedPublicVirtualInterfaceAccepterSpecForProvider(obj.forProvider),
    'initProvider': toJson_HostedPublicVirtualInterfaceAccepterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_HostedPublicVirtualInterfaceAccepterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HostedPublicVirtualInterfaceAccepterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecDeletionPolicy
 */
export enum HostedPublicVirtualInterfaceAccepterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HostedPublicVirtualInterfaceAccepterSpecForProvider
 */
export interface HostedPublicVirtualInterfaceAccepterSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The ID of the Direct Connect virtual interface to accept.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProvider#virtualInterfaceId
   */
  readonly virtualInterfaceId?: string;

  /**
   * Reference to a HostedPublicVirtualInterface to populate virtualInterfaceId.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProvider#virtualInterfaceIdRef
   */
  readonly virtualInterfaceIdRef?: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef;

  /**
   * Selector for a HostedPublicVirtualInterface to populate virtualInterfaceId.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProvider#virtualInterfaceIdSelector
   */
  readonly virtualInterfaceIdSelector?: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecForProvider(obj: HostedPublicVirtualInterfaceAccepterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'virtualInterfaceId': obj.virtualInterfaceId,
    'virtualInterfaceIdRef': toJson_HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef(obj.virtualInterfaceIdRef),
    'virtualInterfaceIdSelector': toJson_HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector(obj.virtualInterfaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecInitProvider
 */
export interface HostedPublicVirtualInterfaceAccepterSpecInitProvider {
  /**
   * Key-value map of resource tags.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecInitProvider(obj: HostedPublicVirtualInterfaceAccepterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecManagementPolicies
 */
export enum HostedPublicVirtualInterfaceAccepterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecProviderConfigRef
 */
export interface HostedPublicVirtualInterfaceAccepterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecProviderConfigRef#policy
   */
  readonly policy?: HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecProviderConfigRef(obj: HostedPublicVirtualInterfaceAccepterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsTo
 */
export interface HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsTo(obj: HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecWriteConnectionSecretToRef
 */
export interface HostedPublicVirtualInterfaceAccepterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecWriteConnectionSecretToRef(obj: HostedPublicVirtualInterfaceAccepterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HostedPublicVirtualInterface to populate virtualInterfaceId.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef
 */
export interface HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef#policy
   */
  readonly policy?: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef(obj: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HostedPublicVirtualInterface to populate virtualInterfaceId.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector
 */
export interface HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector#policy
   */
  readonly policy?: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector(obj: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicy
 */
export interface HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicy(obj: HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef
 */
export interface HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef(obj: HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata
 */
export interface HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata(obj: HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy
 */
export interface HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy#resolution
   */
  readonly resolution?: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy#resolve
   */
  readonly resolve?: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy(obj: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy
 */
export interface HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy(obj: HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolution
 */
export enum HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolve
 */
export enum HostedPublicVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj: HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolution
 */
export enum HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolve
 */
export enum HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolution
 */
export enum HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolve
 */
export enum HostedPublicVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HostedPublicVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HostedTransitVirtualInterface is the Schema for the HostedTransitVirtualInterfaces API. Provides a Direct Connect hosted transit virtual interface resource.
 *
 * @schema HostedTransitVirtualInterface
 */
export class HostedTransitVirtualInterface extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HostedTransitVirtualInterface"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'HostedTransitVirtualInterface',
  }

  /**
   * Renders a Kubernetes manifest for "HostedTransitVirtualInterface".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HostedTransitVirtualInterfaceProps): any {
    return {
      ...HostedTransitVirtualInterface.GVK,
      ...toJson_HostedTransitVirtualInterfaceProps(props),
    };
  }

  /**
   * Defines a "HostedTransitVirtualInterface" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HostedTransitVirtualInterfaceProps) {
    super(scope, id, {
      ...HostedTransitVirtualInterface.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HostedTransitVirtualInterface.GVK,
      ...toJson_HostedTransitVirtualInterfaceProps(resolved),
    };
  }
}

/**
 * HostedTransitVirtualInterface is the Schema for the HostedTransitVirtualInterfaces API. Provides a Direct Connect hosted transit virtual interface resource.
 *
 * @schema HostedTransitVirtualInterface
 */
export interface HostedTransitVirtualInterfaceProps {
  /**
   * @schema HostedTransitVirtualInterface#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HostedTransitVirtualInterfaceSpec defines the desired state of HostedTransitVirtualInterface
   *
   * @schema HostedTransitVirtualInterface#spec
   */
  readonly spec: HostedTransitVirtualInterfaceSpec;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceProps(obj: HostedTransitVirtualInterfaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HostedTransitVirtualInterfaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostedTransitVirtualInterfaceSpec defines the desired state of HostedTransitVirtualInterface
 *
 * @schema HostedTransitVirtualInterfaceSpec
 */
export interface HostedTransitVirtualInterfaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedTransitVirtualInterfaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: HostedTransitVirtualInterfaceSpecDeletionPolicy;

  /**
   * @schema HostedTransitVirtualInterfaceSpec#forProvider
   */
  readonly forProvider: HostedTransitVirtualInterfaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema HostedTransitVirtualInterfaceSpec#initProvider
   */
  readonly initProvider?: HostedTransitVirtualInterfaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema HostedTransitVirtualInterfaceSpec#managementPolicies
   */
  readonly managementPolicies?: HostedTransitVirtualInterfaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HostedTransitVirtualInterfaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: HostedTransitVirtualInterfaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HostedTransitVirtualInterfaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HostedTransitVirtualInterfaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HostedTransitVirtualInterfaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HostedTransitVirtualInterfaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpec(obj: HostedTransitVirtualInterfaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HostedTransitVirtualInterfaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_HostedTransitVirtualInterfaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_HostedTransitVirtualInterfaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_HostedTransitVirtualInterfaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HostedTransitVirtualInterfaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedTransitVirtualInterfaceSpecDeletionPolicy
 */
export enum HostedTransitVirtualInterfaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HostedTransitVirtualInterfaceSpecForProvider
 */
export interface HostedTransitVirtualInterfaceSpecForProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The ID of the Direct Connect connection (or LAG) on which to create the virtual interface.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * Reference to a Connection to populate connectionId.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#connectionIdRef
   */
  readonly connectionIdRef?: HostedTransitVirtualInterfaceSpecForProviderConnectionIdRef;

  /**
   * Selector for a Connection to populate connectionId.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#connectionIdSelector
   */
  readonly connectionIdSelector?: HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelector;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The maximum transmission unit (MTU) is the size, in bytes, of the largest permissible packet that can be passed over the connection. The MTU of a virtual transit interface can be either 1500 or 8500 (jumbo frames). Default is 1500.
   *
   * @default 1500.
   * @schema HostedTransitVirtualInterfaceSpecForProvider#mtu
   */
  readonly mtu?: number;

  /**
   * The name for the virtual interface.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The AWS account that will own the new virtual interface.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#ownerAccountId
   */
  readonly ownerAccountId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The VLAN ID.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecForProvider(obj: HostedTransitVirtualInterfaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'connectionId': obj.connectionId,
    'connectionIdRef': toJson_HostedTransitVirtualInterfaceSpecForProviderConnectionIdRef(obj.connectionIdRef),
    'connectionIdSelector': toJson_HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelector(obj.connectionIdSelector),
    'customerAddress': obj.customerAddress,
    'mtu': obj.mtu,
    'name': obj.name,
    'ownerAccountId': obj.ownerAccountId,
    'region': obj.region,
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema HostedTransitVirtualInterfaceSpecInitProvider
 */
export interface HostedTransitVirtualInterfaceSpecInitProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema HostedTransitVirtualInterfaceSpecInitProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema HostedTransitVirtualInterfaceSpecInitProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema HostedTransitVirtualInterfaceSpecInitProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema HostedTransitVirtualInterfaceSpecInitProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema HostedTransitVirtualInterfaceSpecInitProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The maximum transmission unit (MTU) is the size, in bytes, of the largest permissible packet that can be passed over the connection. The MTU of a virtual transit interface can be either 1500 or 8500 (jumbo frames). Default is 1500.
   *
   * @default 1500.
   * @schema HostedTransitVirtualInterfaceSpecInitProvider#mtu
   */
  readonly mtu?: number;

  /**
   * The name for the virtual interface.
   *
   * @schema HostedTransitVirtualInterfaceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The AWS account that will own the new virtual interface.
   *
   * @schema HostedTransitVirtualInterfaceSpecInitProvider#ownerAccountId
   */
  readonly ownerAccountId?: string;

  /**
   * The VLAN ID.
   *
   * @schema HostedTransitVirtualInterfaceSpecInitProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecInitProvider(obj: HostedTransitVirtualInterfaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'customerAddress': obj.customerAddress,
    'mtu': obj.mtu,
    'name': obj.name,
    'ownerAccountId': obj.ownerAccountId,
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema HostedTransitVirtualInterfaceSpecManagementPolicies
 */
export enum HostedTransitVirtualInterfaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HostedTransitVirtualInterfaceSpecProviderConfigRef
 */
export interface HostedTransitVirtualInterfaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedTransitVirtualInterfaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedTransitVirtualInterfaceSpecProviderConfigRef#policy
   */
  readonly policy?: HostedTransitVirtualInterfaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecProviderConfigRef(obj: HostedTransitVirtualInterfaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedTransitVirtualInterfaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsTo
 */
export interface HostedTransitVirtualInterfaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecPublishConnectionDetailsTo(obj: HostedTransitVirtualInterfaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HostedTransitVirtualInterfaceSpecWriteConnectionSecretToRef
 */
export interface HostedTransitVirtualInterfaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HostedTransitVirtualInterfaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HostedTransitVirtualInterfaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecWriteConnectionSecretToRef(obj: HostedTransitVirtualInterfaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection to populate connectionId.
 *
 * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdRef
 */
export interface HostedTransitVirtualInterfaceSpecForProviderConnectionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdRef#policy
   */
  readonly policy?: HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecForProviderConnectionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecForProviderConnectionIdRef(obj: HostedTransitVirtualInterfaceSpecForProviderConnectionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection to populate connectionId.
 *
 * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelector
 */
export interface HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelector#policy
   */
  readonly policy?: HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelector(obj: HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedTransitVirtualInterfaceSpecProviderConfigRefPolicy
 */
export interface HostedTransitVirtualInterfaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedTransitVirtualInterfaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HostedTransitVirtualInterfaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedTransitVirtualInterfaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HostedTransitVirtualInterfaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecProviderConfigRefPolicy(obj: HostedTransitVirtualInterfaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef
 */
export interface HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj: HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata
 */
export interface HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj: HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy
 */
export interface HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolution
   */
  readonly resolution?: HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolve
   */
  readonly resolve?: HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj: HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy
 */
export interface HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj: HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedTransitVirtualInterfaceSpecProviderConfigRefPolicyResolution
 */
export enum HostedTransitVirtualInterfaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedTransitVirtualInterfaceSpecProviderConfigRefPolicyResolve
 */
export enum HostedTransitVirtualInterfaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution
 */
export enum HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve
 */
export enum HostedTransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution
 */
export enum HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve
 */
export enum HostedTransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HostedTransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HostedTransitVirtualInterfaceAccepter is the Schema for the HostedTransitVirtualInterfaceAccepters API. Provides a resource to manage the accepter's side of a Direct Connect hosted transit virtual interface.
 *
 * @schema HostedTransitVirtualInterfaceAccepter
 */
export class HostedTransitVirtualInterfaceAccepter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HostedTransitVirtualInterfaceAccepter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'HostedTransitVirtualInterfaceAccepter',
  }

  /**
   * Renders a Kubernetes manifest for "HostedTransitVirtualInterfaceAccepter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HostedTransitVirtualInterfaceAccepterProps): any {
    return {
      ...HostedTransitVirtualInterfaceAccepter.GVK,
      ...toJson_HostedTransitVirtualInterfaceAccepterProps(props),
    };
  }

  /**
   * Defines a "HostedTransitVirtualInterfaceAccepter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HostedTransitVirtualInterfaceAccepterProps) {
    super(scope, id, {
      ...HostedTransitVirtualInterfaceAccepter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HostedTransitVirtualInterfaceAccepter.GVK,
      ...toJson_HostedTransitVirtualInterfaceAccepterProps(resolved),
    };
  }
}

/**
 * HostedTransitVirtualInterfaceAccepter is the Schema for the HostedTransitVirtualInterfaceAccepters API. Provides a resource to manage the accepter's side of a Direct Connect hosted transit virtual interface.
 *
 * @schema HostedTransitVirtualInterfaceAccepter
 */
export interface HostedTransitVirtualInterfaceAccepterProps {
  /**
   * @schema HostedTransitVirtualInterfaceAccepter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HostedTransitVirtualInterfaceAccepterSpec defines the desired state of HostedTransitVirtualInterfaceAccepter
   *
   * @schema HostedTransitVirtualInterfaceAccepter#spec
   */
  readonly spec: HostedTransitVirtualInterfaceAccepterSpec;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterProps(obj: HostedTransitVirtualInterfaceAccepterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HostedTransitVirtualInterfaceAccepterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostedTransitVirtualInterfaceAccepterSpec defines the desired state of HostedTransitVirtualInterfaceAccepter
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpec
 */
export interface HostedTransitVirtualInterfaceAccepterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpec#deletionPolicy
   */
  readonly deletionPolicy?: HostedTransitVirtualInterfaceAccepterSpecDeletionPolicy;

  /**
   * @schema HostedTransitVirtualInterfaceAccepterSpec#forProvider
   */
  readonly forProvider: HostedTransitVirtualInterfaceAccepterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpec#initProvider
   */
  readonly initProvider?: HostedTransitVirtualInterfaceAccepterSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpec#managementPolicies
   */
  readonly managementPolicies?: HostedTransitVirtualInterfaceAccepterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpec#providerConfigRef
   */
  readonly providerConfigRef?: HostedTransitVirtualInterfaceAccepterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HostedTransitVirtualInterfaceAccepterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpec(obj: HostedTransitVirtualInterfaceAccepterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HostedTransitVirtualInterfaceAccepterSpecForProvider(obj.forProvider),
    'initProvider': toJson_HostedTransitVirtualInterfaceAccepterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_HostedTransitVirtualInterfaceAccepterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HostedTransitVirtualInterfaceAccepterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecDeletionPolicy
 */
export enum HostedTransitVirtualInterfaceAccepterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProvider
 */
export interface HostedTransitVirtualInterfaceAccepterSpecForProvider {
  /**
   * The ID of the Direct Connect gateway to which to connect the virtual interface.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProvider#dxGatewayId
   */
  readonly dxGatewayId?: string;

  /**
   * Reference to a Gateway in directconnect to populate dxGatewayId.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProvider#dxGatewayIdRef
   */
  readonly dxGatewayIdRef?: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRef;

  /**
   * Selector for a Gateway in directconnect to populate dxGatewayId.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProvider#dxGatewayIdSelector
   */
  readonly dxGatewayIdSelector?: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The ID of the Direct Connect virtual interface to accept.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProvider#virtualInterfaceId
   */
  readonly virtualInterfaceId?: string;

  /**
   * Reference to a HostedTransitVirtualInterface to populate virtualInterfaceId.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProvider#virtualInterfaceIdRef
   */
  readonly virtualInterfaceIdRef?: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef;

  /**
   * Selector for a HostedTransitVirtualInterface to populate virtualInterfaceId.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProvider#virtualInterfaceIdSelector
   */
  readonly virtualInterfaceIdSelector?: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecForProvider(obj: HostedTransitVirtualInterfaceAccepterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dxGatewayId': obj.dxGatewayId,
    'dxGatewayIdRef': toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRef(obj.dxGatewayIdRef),
    'dxGatewayIdSelector': toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelector(obj.dxGatewayIdSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'virtualInterfaceId': obj.virtualInterfaceId,
    'virtualInterfaceIdRef': toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef(obj.virtualInterfaceIdRef),
    'virtualInterfaceIdSelector': toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector(obj.virtualInterfaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecInitProvider
 */
export interface HostedTransitVirtualInterfaceAccepterSpecInitProvider {
  /**
   * Key-value map of resource tags.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecInitProvider(obj: HostedTransitVirtualInterfaceAccepterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecManagementPolicies
 */
export enum HostedTransitVirtualInterfaceAccepterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecProviderConfigRef
 */
export interface HostedTransitVirtualInterfaceAccepterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecProviderConfigRef#policy
   */
  readonly policy?: HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecProviderConfigRef(obj: HostedTransitVirtualInterfaceAccepterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsTo
 */
export interface HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsTo(obj: HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecWriteConnectionSecretToRef
 */
export interface HostedTransitVirtualInterfaceAccepterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecWriteConnectionSecretToRef(obj: HostedTransitVirtualInterfaceAccepterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Gateway in directconnect to populate dxGatewayId.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRef
 */
export interface HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRef#policy
   */
  readonly policy?: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRef(obj: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Gateway in directconnect to populate dxGatewayId.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelector
 */
export interface HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelector#policy
   */
  readonly policy?: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelector(obj: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HostedTransitVirtualInterface to populate virtualInterfaceId.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef
 */
export interface HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef#policy
   */
  readonly policy?: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef(obj: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HostedTransitVirtualInterface to populate virtualInterfaceId.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector
 */
export interface HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector#policy
   */
  readonly policy?: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector(obj: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicy
 */
export interface HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicy(obj: HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef
 */
export interface HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef(obj: HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata
 */
export interface HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata(obj: HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicy
 */
export interface HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicy#resolution
   */
  readonly resolution?: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicy#resolve
   */
  readonly resolve?: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicy(obj: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicy
 */
export interface HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicy(obj: HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy
 */
export interface HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy#resolution
   */
  readonly resolution?: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy#resolve
   */
  readonly resolve?: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy(obj: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy
 */
export interface HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy(obj: HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolution
 */
export enum HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolve
 */
export enum HostedTransitVirtualInterfaceAccepterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj: HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicyResolution
 */
export enum HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicyResolve
 */
export enum HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicyResolution
 */
export enum HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicyResolve
 */
export enum HostedTransitVirtualInterfaceAccepterSpecForProviderDxGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolution
 */
export enum HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolve
 */
export enum HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolution
 */
export enum HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolve
 */
export enum HostedTransitVirtualInterfaceAccepterSpecForProviderVirtualInterfaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HostedTransitVirtualInterfaceAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Lag is the Schema for the Lags API. Provides a Direct Connect LAG.
 *
 * @schema Lag
 */
export class Lag extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Lag"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'Lag',
  }

  /**
   * Renders a Kubernetes manifest for "Lag".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LagProps): any {
    return {
      ...Lag.GVK,
      ...toJson_LagProps(props),
    };
  }

  /**
   * Defines a "Lag" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LagProps) {
    super(scope, id, {
      ...Lag.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Lag.GVK,
      ...toJson_LagProps(resolved),
    };
  }
}

/**
 * Lag is the Schema for the Lags API. Provides a Direct Connect LAG.
 *
 * @schema Lag
 */
export interface LagProps {
  /**
   * @schema Lag#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LagSpec defines the desired state of Lag
   *
   * @schema Lag#spec
   */
  readonly spec: LagSpec;

}

/**
 * Converts an object of type 'LagProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagProps(obj: LagProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LagSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LagSpec defines the desired state of Lag
 *
 * @schema LagSpec
 */
export interface LagSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LagSpec#deletionPolicy
   */
  readonly deletionPolicy?: LagSpecDeletionPolicy;

  /**
   * @schema LagSpec#forProvider
   */
  readonly forProvider: LagSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema LagSpec#initProvider
   */
  readonly initProvider?: LagSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LagSpec#managementPolicies
   */
  readonly managementPolicies?: LagSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LagSpec#providerConfigRef
   */
  readonly providerConfigRef?: LagSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LagSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LagSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LagSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LagSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LagSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagSpec(obj: LagSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LagSpecForProvider(obj.forProvider),
    'initProvider': toJson_LagSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LagSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LagSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LagSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LagSpecDeletionPolicy
 */
export enum LagSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LagSpecForProvider
 */
export interface LagSpecForProvider {
  /**
   * The ID of an existing dedicated connection to migrate to the LAG.
   *
   * @schema LagSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * The bandwidth of the individual physical connections bundled by the LAG. Valid values: 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, 10Gbps and 100Gbps. Case sensitive.
   *
   * @schema LagSpecForProvider#connectionsBandwidth
   */
  readonly connectionsBandwidth?: string;

  /**
   * A boolean that indicates all connections associated with the LAG should be deleted so that the LAG can be destroyed without error. These objects are not recoverable.
   *
   * @schema LagSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The AWS Direct Connect location in which the LAG should be allocated. See DescribeLocations for the list of AWS Direct Connect locations. Use locationCode.
   *
   * @schema LagSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The name of the LAG.
   *
   * @schema LagSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The name of the service provider associated with the LAG.
   *
   * @schema LagSpecForProvider#providerName
   */
  readonly providerName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LagSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LagSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LagSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagSpecForProvider(obj: LagSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionId': obj.connectionId,
    'connectionsBandwidth': obj.connectionsBandwidth,
    'forceDestroy': obj.forceDestroy,
    'location': obj.location,
    'name': obj.name,
    'providerName': obj.providerName,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema LagSpecInitProvider
 */
export interface LagSpecInitProvider {
  /**
   * The ID of an existing dedicated connection to migrate to the LAG.
   *
   * @schema LagSpecInitProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * The bandwidth of the individual physical connections bundled by the LAG. Valid values: 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, 10Gbps and 100Gbps. Case sensitive.
   *
   * @schema LagSpecInitProvider#connectionsBandwidth
   */
  readonly connectionsBandwidth?: string;

  /**
   * A boolean that indicates all connections associated with the LAG should be deleted so that the LAG can be destroyed without error. These objects are not recoverable.
   *
   * @schema LagSpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The AWS Direct Connect location in which the LAG should be allocated. See DescribeLocations for the list of AWS Direct Connect locations. Use locationCode.
   *
   * @schema LagSpecInitProvider#location
   */
  readonly location?: string;

  /**
   * The name of the LAG.
   *
   * @schema LagSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The name of the service provider associated with the LAG.
   *
   * @schema LagSpecInitProvider#providerName
   */
  readonly providerName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LagSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LagSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagSpecInitProvider(obj: LagSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionId': obj.connectionId,
    'connectionsBandwidth': obj.connectionsBandwidth,
    'forceDestroy': obj.forceDestroy,
    'location': obj.location,
    'name': obj.name,
    'providerName': obj.providerName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LagSpecManagementPolicies
 */
export enum LagSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LagSpecProviderConfigRef
 */
export interface LagSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LagSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LagSpecProviderConfigRef#policy
   */
  readonly policy?: LagSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LagSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagSpecProviderConfigRef(obj: LagSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LagSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LagSpecPublishConnectionDetailsTo
 */
export interface LagSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LagSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LagSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LagSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LagSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LagSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LagSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagSpecPublishConnectionDetailsTo(obj: LagSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LagSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LagSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LagSpecWriteConnectionSecretToRef
 */
export interface LagSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LagSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LagSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LagSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagSpecWriteConnectionSecretToRef(obj: LagSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LagSpecProviderConfigRefPolicy
 */
export interface LagSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LagSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LagSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LagSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LagSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LagSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagSpecProviderConfigRefPolicy(obj: LagSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LagSpecPublishConnectionDetailsToConfigRef
 */
export interface LagSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LagSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LagSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LagSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LagSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagSpecPublishConnectionDetailsToConfigRef(obj: LagSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LagSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LagSpecPublishConnectionDetailsToMetadata
 */
export interface LagSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LagSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LagSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LagSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LagSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagSpecPublishConnectionDetailsToMetadata(obj: LagSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LagSpecProviderConfigRefPolicyResolution
 */
export enum LagSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LagSpecProviderConfigRefPolicyResolve
 */
export enum LagSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LagSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LagSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LagSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LagSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LagSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LagSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LagSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LagSpecPublishConnectionDetailsToConfigRefPolicy(obj: LagSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LagSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LagSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LagSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LagSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PrivateVirtualInterface is the Schema for the PrivateVirtualInterfaces API. Provides a Direct Connect private virtual interface resource.
 *
 * @schema PrivateVirtualInterface
 */
export class PrivateVirtualInterface extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PrivateVirtualInterface"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'PrivateVirtualInterface',
  }

  /**
   * Renders a Kubernetes manifest for "PrivateVirtualInterface".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PrivateVirtualInterfaceProps): any {
    return {
      ...PrivateVirtualInterface.GVK,
      ...toJson_PrivateVirtualInterfaceProps(props),
    };
  }

  /**
   * Defines a "PrivateVirtualInterface" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PrivateVirtualInterfaceProps) {
    super(scope, id, {
      ...PrivateVirtualInterface.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PrivateVirtualInterface.GVK,
      ...toJson_PrivateVirtualInterfaceProps(resolved),
    };
  }
}

/**
 * PrivateVirtualInterface is the Schema for the PrivateVirtualInterfaces API. Provides a Direct Connect private virtual interface resource.
 *
 * @schema PrivateVirtualInterface
 */
export interface PrivateVirtualInterfaceProps {
  /**
   * @schema PrivateVirtualInterface#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PrivateVirtualInterfaceSpec defines the desired state of PrivateVirtualInterface
   *
   * @schema PrivateVirtualInterface#spec
   */
  readonly spec: PrivateVirtualInterfaceSpec;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceProps(obj: PrivateVirtualInterfaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PrivateVirtualInterfaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrivateVirtualInterfaceSpec defines the desired state of PrivateVirtualInterface
 *
 * @schema PrivateVirtualInterfaceSpec
 */
export interface PrivateVirtualInterfaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PrivateVirtualInterfaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: PrivateVirtualInterfaceSpecDeletionPolicy;

  /**
   * @schema PrivateVirtualInterfaceSpec#forProvider
   */
  readonly forProvider: PrivateVirtualInterfaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PrivateVirtualInterfaceSpec#initProvider
   */
  readonly initProvider?: PrivateVirtualInterfaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PrivateVirtualInterfaceSpec#managementPolicies
   */
  readonly managementPolicies?: PrivateVirtualInterfaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PrivateVirtualInterfaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: PrivateVirtualInterfaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PrivateVirtualInterfaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PrivateVirtualInterfaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PrivateVirtualInterfaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PrivateVirtualInterfaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpec(obj: PrivateVirtualInterfaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PrivateVirtualInterfaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_PrivateVirtualInterfaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PrivateVirtualInterfaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PrivateVirtualInterfaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PrivateVirtualInterfaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PrivateVirtualInterfaceSpecDeletionPolicy
 */
export enum PrivateVirtualInterfaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PrivateVirtualInterfaceSpecForProvider
 */
export interface PrivateVirtualInterfaceSpecForProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The ID of the Direct Connect connection (or LAG) on which to create the virtual interface.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * Reference to a Connection to populate connectionId.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#connectionIdRef
   */
  readonly connectionIdRef?: PrivateVirtualInterfaceSpecForProviderConnectionIdRef;

  /**
   * Selector for a Connection to populate connectionId.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#connectionIdSelector
   */
  readonly connectionIdSelector?: PrivateVirtualInterfaceSpecForProviderConnectionIdSelector;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The ID of the Direct Connect gateway to which to connect the virtual interface.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#dxGatewayId
   */
  readonly dxGatewayId?: string;

  /**
   * The maximum transmission unit (MTU) is the size, in bytes, of the largest permissible packet that can be passed over the connection. The MTU of a virtual private interface can be either 1500 or 9001 (jumbo frames). Default is 1500.
   *
   * @default 1500.
   * @schema PrivateVirtualInterfaceSpecForProvider#mtu
   */
  readonly mtu?: number;

  /**
   * The name for the virtual interface.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Indicates whether to enable or disable SiteLink.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#sitelinkEnabled
   */
  readonly sitelinkEnabled?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The VLAN ID.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#vlan
   */
  readonly vlan?: number;

  /**
   * The ID of the virtual private gateway to which to connect the virtual interface.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#vpnGatewayId
   */
  readonly vpnGatewayId?: string;

  /**
   * Reference to a VPNGateway in ec2 to populate vpnGatewayId.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#vpnGatewayIdRef
   */
  readonly vpnGatewayIdRef?: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRef;

  /**
   * Selector for a VPNGateway in ec2 to populate vpnGatewayId.
   *
   * @schema PrivateVirtualInterfaceSpecForProvider#vpnGatewayIdSelector
   */
  readonly vpnGatewayIdSelector?: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelector;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecForProvider(obj: PrivateVirtualInterfaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'connectionId': obj.connectionId,
    'connectionIdRef': toJson_PrivateVirtualInterfaceSpecForProviderConnectionIdRef(obj.connectionIdRef),
    'connectionIdSelector': toJson_PrivateVirtualInterfaceSpecForProviderConnectionIdSelector(obj.connectionIdSelector),
    'customerAddress': obj.customerAddress,
    'dxGatewayId': obj.dxGatewayId,
    'mtu': obj.mtu,
    'name': obj.name,
    'region': obj.region,
    'sitelinkEnabled': obj.sitelinkEnabled,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vlan': obj.vlan,
    'vpnGatewayId': obj.vpnGatewayId,
    'vpnGatewayIdRef': toJson_PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRef(obj.vpnGatewayIdRef),
    'vpnGatewayIdSelector': toJson_PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelector(obj.vpnGatewayIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PrivateVirtualInterfaceSpecInitProvider
 */
export interface PrivateVirtualInterfaceSpecInitProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema PrivateVirtualInterfaceSpecInitProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema PrivateVirtualInterfaceSpecInitProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema PrivateVirtualInterfaceSpecInitProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema PrivateVirtualInterfaceSpecInitProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema PrivateVirtualInterfaceSpecInitProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The ID of the Direct Connect gateway to which to connect the virtual interface.
   *
   * @schema PrivateVirtualInterfaceSpecInitProvider#dxGatewayId
   */
  readonly dxGatewayId?: string;

  /**
   * The maximum transmission unit (MTU) is the size, in bytes, of the largest permissible packet that can be passed over the connection. The MTU of a virtual private interface can be either 1500 or 9001 (jumbo frames). Default is 1500.
   *
   * @default 1500.
   * @schema PrivateVirtualInterfaceSpecInitProvider#mtu
   */
  readonly mtu?: number;

  /**
   * The name for the virtual interface.
   *
   * @schema PrivateVirtualInterfaceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Indicates whether to enable or disable SiteLink.
   *
   * @schema PrivateVirtualInterfaceSpecInitProvider#sitelinkEnabled
   */
  readonly sitelinkEnabled?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema PrivateVirtualInterfaceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The VLAN ID.
   *
   * @schema PrivateVirtualInterfaceSpecInitProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecInitProvider(obj: PrivateVirtualInterfaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'customerAddress': obj.customerAddress,
    'dxGatewayId': obj.dxGatewayId,
    'mtu': obj.mtu,
    'name': obj.name,
    'sitelinkEnabled': obj.sitelinkEnabled,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PrivateVirtualInterfaceSpecManagementPolicies
 */
export enum PrivateVirtualInterfaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PrivateVirtualInterfaceSpecProviderConfigRef
 */
export interface PrivateVirtualInterfaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateVirtualInterfaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateVirtualInterfaceSpecProviderConfigRef#policy
   */
  readonly policy?: PrivateVirtualInterfaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecProviderConfigRef(obj: PrivateVirtualInterfaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateVirtualInterfaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsTo
 */
export interface PrivateVirtualInterfaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecPublishConnectionDetailsTo(obj: PrivateVirtualInterfaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PrivateVirtualInterfaceSpecWriteConnectionSecretToRef
 */
export interface PrivateVirtualInterfaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PrivateVirtualInterfaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PrivateVirtualInterfaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecWriteConnectionSecretToRef(obj: PrivateVirtualInterfaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection to populate connectionId.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdRef
 */
export interface PrivateVirtualInterfaceSpecForProviderConnectionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdRef#policy
   */
  readonly policy?: PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecForProviderConnectionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecForProviderConnectionIdRef(obj: PrivateVirtualInterfaceSpecForProviderConnectionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection to populate connectionId.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdSelector
 */
export interface PrivateVirtualInterfaceSpecForProviderConnectionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdSelector#policy
   */
  readonly policy?: PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecForProviderConnectionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecForProviderConnectionIdSelector(obj: PrivateVirtualInterfaceSpecForProviderConnectionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPNGateway in ec2 to populate vpnGatewayId.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRef
 */
export interface PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRef#policy
   */
  readonly policy?: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRef(obj: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPNGateway in ec2 to populate vpnGatewayId.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelector
 */
export interface PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelector#policy
   */
  readonly policy?: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelector(obj: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrivateVirtualInterfaceSpecProviderConfigRefPolicy
 */
export interface PrivateVirtualInterfaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateVirtualInterfaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PrivateVirtualInterfaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateVirtualInterfaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PrivateVirtualInterfaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecProviderConfigRefPolicy(obj: PrivateVirtualInterfaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef
 */
export interface PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj: PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata
 */
export interface PrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj: PrivateVirtualInterfaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy
 */
export interface PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolution
   */
  readonly resolution?: PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolve
   */
  readonly resolve?: PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj: PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy
 */
export interface PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolution
   */
  readonly resolution?: PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolve
   */
  readonly resolve?: PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj: PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicy
 */
export interface PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicy#resolution
   */
  readonly resolution?: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicy#resolve
   */
  readonly resolve?: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicy(obj: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicy
 */
export interface PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicy(obj: PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateVirtualInterfaceSpecProviderConfigRefPolicyResolution
 */
export enum PrivateVirtualInterfaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateVirtualInterfaceSpecProviderConfigRefPolicyResolve
 */
export enum PrivateVirtualInterfaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution
 */
export enum PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve
 */
export enum PrivateVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution
 */
export enum PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve
 */
export enum PrivateVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicyResolution
 */
export enum PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicyResolve
 */
export enum PrivateVirtualInterfaceSpecForProviderVpnGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicyResolution
 */
export enum PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicyResolve
 */
export enum PrivateVirtualInterfaceSpecForProviderVpnGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PrivateVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PublicVirtualInterface is the Schema for the PublicVirtualInterfaces API. Provides a Direct Connect public virtual interface resource.
 *
 * @schema PublicVirtualInterface
 */
export class PublicVirtualInterface extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PublicVirtualInterface"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'PublicVirtualInterface',
  }

  /**
   * Renders a Kubernetes manifest for "PublicVirtualInterface".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PublicVirtualInterfaceProps): any {
    return {
      ...PublicVirtualInterface.GVK,
      ...toJson_PublicVirtualInterfaceProps(props),
    };
  }

  /**
   * Defines a "PublicVirtualInterface" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PublicVirtualInterfaceProps) {
    super(scope, id, {
      ...PublicVirtualInterface.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PublicVirtualInterface.GVK,
      ...toJson_PublicVirtualInterfaceProps(resolved),
    };
  }
}

/**
 * PublicVirtualInterface is the Schema for the PublicVirtualInterfaces API. Provides a Direct Connect public virtual interface resource.
 *
 * @schema PublicVirtualInterface
 */
export interface PublicVirtualInterfaceProps {
  /**
   * @schema PublicVirtualInterface#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PublicVirtualInterfaceSpec defines the desired state of PublicVirtualInterface
   *
   * @schema PublicVirtualInterface#spec
   */
  readonly spec: PublicVirtualInterfaceSpec;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceProps(obj: PublicVirtualInterfaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PublicVirtualInterfaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublicVirtualInterfaceSpec defines the desired state of PublicVirtualInterface
 *
 * @schema PublicVirtualInterfaceSpec
 */
export interface PublicVirtualInterfaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PublicVirtualInterfaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: PublicVirtualInterfaceSpecDeletionPolicy;

  /**
   * @schema PublicVirtualInterfaceSpec#forProvider
   */
  readonly forProvider: PublicVirtualInterfaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PublicVirtualInterfaceSpec#initProvider
   */
  readonly initProvider?: PublicVirtualInterfaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PublicVirtualInterfaceSpec#managementPolicies
   */
  readonly managementPolicies?: PublicVirtualInterfaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PublicVirtualInterfaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: PublicVirtualInterfaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PublicVirtualInterfaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PublicVirtualInterfaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PublicVirtualInterfaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PublicVirtualInterfaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpec(obj: PublicVirtualInterfaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PublicVirtualInterfaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_PublicVirtualInterfaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PublicVirtualInterfaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PublicVirtualInterfaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PublicVirtualInterfaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PublicVirtualInterfaceSpecDeletionPolicy
 */
export enum PublicVirtualInterfaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PublicVirtualInterfaceSpecForProvider
 */
export interface PublicVirtualInterfaceSpecForProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The ID of the Direct Connect connection (or LAG) on which to create the virtual interface.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * Reference to a Connection to populate connectionId.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#connectionIdRef
   */
  readonly connectionIdRef?: PublicVirtualInterfaceSpecForProviderConnectionIdRef;

  /**
   * Selector for a Connection to populate connectionId.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#connectionIdSelector
   */
  readonly connectionIdSelector?: PublicVirtualInterfaceSpecForProviderConnectionIdSelector;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The name for the virtual interface.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of routes to be advertised to the AWS network in this region.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#routeFilterPrefixes
   */
  readonly routeFilterPrefixes?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The VLAN ID.
   *
   * @schema PublicVirtualInterfaceSpecForProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecForProvider(obj: PublicVirtualInterfaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'connectionId': obj.connectionId,
    'connectionIdRef': toJson_PublicVirtualInterfaceSpecForProviderConnectionIdRef(obj.connectionIdRef),
    'connectionIdSelector': toJson_PublicVirtualInterfaceSpecForProviderConnectionIdSelector(obj.connectionIdSelector),
    'customerAddress': obj.customerAddress,
    'name': obj.name,
    'region': obj.region,
    'routeFilterPrefixes': obj.routeFilterPrefixes?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PublicVirtualInterfaceSpecInitProvider
 */
export interface PublicVirtualInterfaceSpecInitProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema PublicVirtualInterfaceSpecInitProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema PublicVirtualInterfaceSpecInitProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema PublicVirtualInterfaceSpecInitProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema PublicVirtualInterfaceSpecInitProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema PublicVirtualInterfaceSpecInitProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The name for the virtual interface.
   *
   * @schema PublicVirtualInterfaceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * A list of routes to be advertised to the AWS network in this region.
   *
   * @schema PublicVirtualInterfaceSpecInitProvider#routeFilterPrefixes
   */
  readonly routeFilterPrefixes?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema PublicVirtualInterfaceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The VLAN ID.
   *
   * @schema PublicVirtualInterfaceSpecInitProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecInitProvider(obj: PublicVirtualInterfaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'customerAddress': obj.customerAddress,
    'name': obj.name,
    'routeFilterPrefixes': obj.routeFilterPrefixes?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PublicVirtualInterfaceSpecManagementPolicies
 */
export enum PublicVirtualInterfaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PublicVirtualInterfaceSpecProviderConfigRef
 */
export interface PublicVirtualInterfaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PublicVirtualInterfaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PublicVirtualInterfaceSpecProviderConfigRef#policy
   */
  readonly policy?: PublicVirtualInterfaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecProviderConfigRef(obj: PublicVirtualInterfaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PublicVirtualInterfaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsTo
 */
export interface PublicVirtualInterfaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecPublishConnectionDetailsTo(obj: PublicVirtualInterfaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PublicVirtualInterfaceSpecWriteConnectionSecretToRef
 */
export interface PublicVirtualInterfaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PublicVirtualInterfaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PublicVirtualInterfaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecWriteConnectionSecretToRef(obj: PublicVirtualInterfaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection to populate connectionId.
 *
 * @schema PublicVirtualInterfaceSpecForProviderConnectionIdRef
 */
export interface PublicVirtualInterfaceSpecForProviderConnectionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PublicVirtualInterfaceSpecForProviderConnectionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PublicVirtualInterfaceSpecForProviderConnectionIdRef#policy
   */
  readonly policy?: PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecForProviderConnectionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecForProviderConnectionIdRef(obj: PublicVirtualInterfaceSpecForProviderConnectionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection to populate connectionId.
 *
 * @schema PublicVirtualInterfaceSpecForProviderConnectionIdSelector
 */
export interface PublicVirtualInterfaceSpecForProviderConnectionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PublicVirtualInterfaceSpecForProviderConnectionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PublicVirtualInterfaceSpecForProviderConnectionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PublicVirtualInterfaceSpecForProviderConnectionIdSelector#policy
   */
  readonly policy?: PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecForProviderConnectionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecForProviderConnectionIdSelector(obj: PublicVirtualInterfaceSpecForProviderConnectionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PublicVirtualInterfaceSpecProviderConfigRefPolicy
 */
export interface PublicVirtualInterfaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PublicVirtualInterfaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PublicVirtualInterfaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PublicVirtualInterfaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PublicVirtualInterfaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecProviderConfigRefPolicy(obj: PublicVirtualInterfaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef
 */
export interface PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj: PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata
 */
export interface PublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj: PublicVirtualInterfaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy
 */
export interface PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolution
   */
  readonly resolution?: PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolve
   */
  readonly resolve?: PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj: PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy
 */
export interface PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolution
   */
  readonly resolution?: PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolve
   */
  readonly resolve?: PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj: PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PublicVirtualInterfaceSpecProviderConfigRefPolicyResolution
 */
export enum PublicVirtualInterfaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PublicVirtualInterfaceSpecProviderConfigRefPolicyResolve
 */
export enum PublicVirtualInterfaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution
 */
export enum PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve
 */
export enum PublicVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution
 */
export enum PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve
 */
export enum PublicVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PublicVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TransitVirtualInterface is the Schema for the TransitVirtualInterfaces API. Provides a Direct Connect transit virtual interface resource.
 *
 * @schema TransitVirtualInterface
 */
export class TransitVirtualInterface extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TransitVirtualInterface"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'directconnect.aws.upbound.io/v1beta1',
    kind: 'TransitVirtualInterface',
  }

  /**
   * Renders a Kubernetes manifest for "TransitVirtualInterface".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TransitVirtualInterfaceProps): any {
    return {
      ...TransitVirtualInterface.GVK,
      ...toJson_TransitVirtualInterfaceProps(props),
    };
  }

  /**
   * Defines a "TransitVirtualInterface" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TransitVirtualInterfaceProps) {
    super(scope, id, {
      ...TransitVirtualInterface.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TransitVirtualInterface.GVK,
      ...toJson_TransitVirtualInterfaceProps(resolved),
    };
  }
}

/**
 * TransitVirtualInterface is the Schema for the TransitVirtualInterfaces API. Provides a Direct Connect transit virtual interface resource.
 *
 * @schema TransitVirtualInterface
 */
export interface TransitVirtualInterfaceProps {
  /**
   * @schema TransitVirtualInterface#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TransitVirtualInterfaceSpec defines the desired state of TransitVirtualInterface
   *
   * @schema TransitVirtualInterface#spec
   */
  readonly spec: TransitVirtualInterfaceSpec;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceProps(obj: TransitVirtualInterfaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TransitVirtualInterfaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitVirtualInterfaceSpec defines the desired state of TransitVirtualInterface
 *
 * @schema TransitVirtualInterfaceSpec
 */
export interface TransitVirtualInterfaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TransitVirtualInterfaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: TransitVirtualInterfaceSpecDeletionPolicy;

  /**
   * @schema TransitVirtualInterfaceSpec#forProvider
   */
  readonly forProvider: TransitVirtualInterfaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TransitVirtualInterfaceSpec#initProvider
   */
  readonly initProvider?: TransitVirtualInterfaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TransitVirtualInterfaceSpec#managementPolicies
   */
  readonly managementPolicies?: TransitVirtualInterfaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TransitVirtualInterfaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: TransitVirtualInterfaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TransitVirtualInterfaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TransitVirtualInterfaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TransitVirtualInterfaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TransitVirtualInterfaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpec(obj: TransitVirtualInterfaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TransitVirtualInterfaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_TransitVirtualInterfaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TransitVirtualInterfaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TransitVirtualInterfaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TransitVirtualInterfaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TransitVirtualInterfaceSpecDeletionPolicy
 */
export enum TransitVirtualInterfaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TransitVirtualInterfaceSpecForProvider
 */
export interface TransitVirtualInterfaceSpecForProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The ID of the Direct Connect connection (or LAG) on which to create the virtual interface.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * Reference to a Connection in directconnect to populate connectionId.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#connectionIdRef
   */
  readonly connectionIdRef?: TransitVirtualInterfaceSpecForProviderConnectionIdRef;

  /**
   * Selector for a Connection in directconnect to populate connectionId.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#connectionIdSelector
   */
  readonly connectionIdSelector?: TransitVirtualInterfaceSpecForProviderConnectionIdSelector;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The ID of the Direct Connect gateway to which to connect the virtual interface.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#dxGatewayId
   */
  readonly dxGatewayId?: string;

  /**
   * Reference to a Gateway in directconnect to populate dxGatewayId.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#dxGatewayIdRef
   */
  readonly dxGatewayIdRef?: TransitVirtualInterfaceSpecForProviderDxGatewayIdRef;

  /**
   * Selector for a Gateway in directconnect to populate dxGatewayId.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#dxGatewayIdSelector
   */
  readonly dxGatewayIdSelector?: TransitVirtualInterfaceSpecForProviderDxGatewayIdSelector;

  /**
   * The maximum transmission unit (MTU) is the size, in bytes, of the largest permissible packet that can be passed over the connection. The MTU of a virtual transit interface can be either 1500 or 8500 (jumbo frames). Default is 1500.
   *
   * @default 1500.
   * @schema TransitVirtualInterfaceSpecForProvider#mtu
   */
  readonly mtu?: number;

  /**
   * The name for the virtual interface.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Indicates whether to enable or disable SiteLink.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#sitelinkEnabled
   */
  readonly sitelinkEnabled?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The VLAN ID.
   *
   * @schema TransitVirtualInterfaceSpecForProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecForProvider(obj: TransitVirtualInterfaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'connectionId': obj.connectionId,
    'connectionIdRef': toJson_TransitVirtualInterfaceSpecForProviderConnectionIdRef(obj.connectionIdRef),
    'connectionIdSelector': toJson_TransitVirtualInterfaceSpecForProviderConnectionIdSelector(obj.connectionIdSelector),
    'customerAddress': obj.customerAddress,
    'dxGatewayId': obj.dxGatewayId,
    'dxGatewayIdRef': toJson_TransitVirtualInterfaceSpecForProviderDxGatewayIdRef(obj.dxGatewayIdRef),
    'dxGatewayIdSelector': toJson_TransitVirtualInterfaceSpecForProviderDxGatewayIdSelector(obj.dxGatewayIdSelector),
    'mtu': obj.mtu,
    'name': obj.name,
    'region': obj.region,
    'sitelinkEnabled': obj.sitelinkEnabled,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TransitVirtualInterfaceSpecInitProvider
 */
export interface TransitVirtualInterfaceSpecInitProvider {
  /**
   * The address family for the BGP peer. ipv4  or ipv6.
   *
   * @schema TransitVirtualInterfaceSpecInitProvider#addressFamily
   */
  readonly addressFamily?: string;

  /**
   * The IPv4 CIDR address to use to send traffic to Amazon. Required for IPv4 BGP peers.
   *
   * @schema TransitVirtualInterfaceSpecInitProvider#amazonAddress
   */
  readonly amazonAddress?: string;

  /**
   * The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
   *
   * @schema TransitVirtualInterfaceSpecInitProvider#bgpAsn
   */
  readonly bgpAsn?: number;

  /**
   * The authentication key for BGP configuration.
   *
   * @schema TransitVirtualInterfaceSpecInitProvider#bgpAuthKey
   */
  readonly bgpAuthKey?: string;

  /**
   * The IPv4 CIDR destination address to which Amazon should send traffic. Required for IPv4 BGP peers.
   *
   * @schema TransitVirtualInterfaceSpecInitProvider#customerAddress
   */
  readonly customerAddress?: string;

  /**
   * The maximum transmission unit (MTU) is the size, in bytes, of the largest permissible packet that can be passed over the connection. The MTU of a virtual transit interface can be either 1500 or 8500 (jumbo frames). Default is 1500.
   *
   * @default 1500.
   * @schema TransitVirtualInterfaceSpecInitProvider#mtu
   */
  readonly mtu?: number;

  /**
   * The name for the virtual interface.
   *
   * @schema TransitVirtualInterfaceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Indicates whether to enable or disable SiteLink.
   *
   * @schema TransitVirtualInterfaceSpecInitProvider#sitelinkEnabled
   */
  readonly sitelinkEnabled?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema TransitVirtualInterfaceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The VLAN ID.
   *
   * @schema TransitVirtualInterfaceSpecInitProvider#vlan
   */
  readonly vlan?: number;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecInitProvider(obj: TransitVirtualInterfaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressFamily': obj.addressFamily,
    'amazonAddress': obj.amazonAddress,
    'bgpAsn': obj.bgpAsn,
    'bgpAuthKey': obj.bgpAuthKey,
    'customerAddress': obj.customerAddress,
    'mtu': obj.mtu,
    'name': obj.name,
    'sitelinkEnabled': obj.sitelinkEnabled,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vlan': obj.vlan,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TransitVirtualInterfaceSpecManagementPolicies
 */
export enum TransitVirtualInterfaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TransitVirtualInterfaceSpecProviderConfigRef
 */
export interface TransitVirtualInterfaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitVirtualInterfaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitVirtualInterfaceSpecProviderConfigRef#policy
   */
  readonly policy?: TransitVirtualInterfaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecProviderConfigRef(obj: TransitVirtualInterfaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitVirtualInterfaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsTo
 */
export interface TransitVirtualInterfaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecPublishConnectionDetailsTo(obj: TransitVirtualInterfaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TransitVirtualInterfaceSpecWriteConnectionSecretToRef
 */
export interface TransitVirtualInterfaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TransitVirtualInterfaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TransitVirtualInterfaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecWriteConnectionSecretToRef(obj: TransitVirtualInterfaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection in directconnect to populate connectionId.
 *
 * @schema TransitVirtualInterfaceSpecForProviderConnectionIdRef
 */
export interface TransitVirtualInterfaceSpecForProviderConnectionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitVirtualInterfaceSpecForProviderConnectionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitVirtualInterfaceSpecForProviderConnectionIdRef#policy
   */
  readonly policy?: TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecForProviderConnectionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecForProviderConnectionIdRef(obj: TransitVirtualInterfaceSpecForProviderConnectionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection in directconnect to populate connectionId.
 *
 * @schema TransitVirtualInterfaceSpecForProviderConnectionIdSelector
 */
export interface TransitVirtualInterfaceSpecForProviderConnectionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitVirtualInterfaceSpecForProviderConnectionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitVirtualInterfaceSpecForProviderConnectionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitVirtualInterfaceSpecForProviderConnectionIdSelector#policy
   */
  readonly policy?: TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecForProviderConnectionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecForProviderConnectionIdSelector(obj: TransitVirtualInterfaceSpecForProviderConnectionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Gateway in directconnect to populate dxGatewayId.
 *
 * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdRef
 */
export interface TransitVirtualInterfaceSpecForProviderDxGatewayIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdRef#policy
   */
  readonly policy?: TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicy;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecForProviderDxGatewayIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecForProviderDxGatewayIdRef(obj: TransitVirtualInterfaceSpecForProviderDxGatewayIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Gateway in directconnect to populate dxGatewayId.
 *
 * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdSelector
 */
export interface TransitVirtualInterfaceSpecForProviderDxGatewayIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdSelector#policy
   */
  readonly policy?: TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecForProviderDxGatewayIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecForProviderDxGatewayIdSelector(obj: TransitVirtualInterfaceSpecForProviderDxGatewayIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitVirtualInterfaceSpecProviderConfigRefPolicy
 */
export interface TransitVirtualInterfaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitVirtualInterfaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TransitVirtualInterfaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitVirtualInterfaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TransitVirtualInterfaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecProviderConfigRefPolicy(obj: TransitVirtualInterfaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef
 */
export interface TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef(obj: TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata
 */
export interface TransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata(obj: TransitVirtualInterfaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy
 */
export interface TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolution
   */
  readonly resolution?: TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy#resolve
   */
  readonly resolve?: TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy(obj: TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy
 */
export interface TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy(obj: TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicy
 */
export interface TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicy#resolution
   */
  readonly resolution?: TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicy#resolve
   */
  readonly resolve?: TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicy(obj: TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicy
 */
export interface TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicy(obj: TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitVirtualInterfaceSpecProviderConfigRefPolicyResolution
 */
export enum TransitVirtualInterfaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitVirtualInterfaceSpecProviderConfigRefPolicyResolve
 */
export enum TransitVirtualInterfaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution
 */
export enum TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve
 */
export enum TransitVirtualInterfaceSpecForProviderConnectionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution
 */
export enum TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve
 */
export enum TransitVirtualInterfaceSpecForProviderConnectionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicyResolution
 */
export enum TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicyResolve
 */
export enum TransitVirtualInterfaceSpecForProviderDxGatewayIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicyResolution
 */
export enum TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicyResolve
 */
export enum TransitVirtualInterfaceSpecForProviderDxGatewayIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TransitVirtualInterfaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

