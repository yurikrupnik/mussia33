// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Dataset is the Schema for the Datasets API. A collection of DataItems and Annotations on them.
 *
 * @schema Dataset
 */
export class Dataset extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Dataset"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'vertexai.gcp.upbound.io/v1beta1',
    kind: 'Dataset',
  }

  /**
   * Renders a Kubernetes manifest for "Dataset".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatasetProps): any {
    return {
      ...Dataset.GVK,
      ...toJson_DatasetProps(props),
    };
  }

  /**
   * Defines a "Dataset" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatasetProps) {
    super(scope, id, {
      ...Dataset.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Dataset.GVK,
      ...toJson_DatasetProps(resolved),
    };
  }
}

/**
 * Dataset is the Schema for the Datasets API. A collection of DataItems and Annotations on them.
 *
 * @schema Dataset
 */
export interface DatasetProps {
  /**
   * @schema Dataset#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatasetSpec defines the desired state of Dataset
   *
   * @schema Dataset#spec
   */
  readonly spec: DatasetSpec;

}

/**
 * Converts an object of type 'DatasetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetProps(obj: DatasetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatasetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatasetSpec defines the desired state of Dataset
 *
 * @schema DatasetSpec
 */
export interface DatasetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DatasetSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatasetSpecDeletionPolicy;

  /**
   * @schema DatasetSpec#forProvider
   */
  readonly forProvider: DatasetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DatasetSpec#initProvider
   */
  readonly initProvider?: DatasetSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DatasetSpec#managementPolicies
   */
  readonly managementPolicies?: DatasetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatasetSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatasetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatasetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatasetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatasetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatasetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatasetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpec(obj: DatasetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatasetSpecForProvider(obj.forProvider),
    'initProvider': toJson_DatasetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DatasetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DatasetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatasetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DatasetSpecDeletionPolicy
 */
export enum DatasetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatasetSpecForProvider
 */
export interface DatasetSpecForProvider {
  /**
   * The user-defined name of the Dataset. The name can be up to 128 characters long and can be consist of any UTF-8 characters.
   *
   * @schema DatasetSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Customer-managed encryption key spec for a Dataset. If set, this Dataset and all sub-resources of this Dataset will be secured by this key. Structure is documented below.
   *
   * @schema DatasetSpecForProvider#encryptionSpec
   */
  readonly encryptionSpec?: DatasetSpecForProviderEncryptionSpec[];

  /**
   * A set of key/value label pairs to assign to this Workflow.
   *
   * @schema DatasetSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Points to a YAML file stored on Google Cloud Storage describing additional information about the Dataset. The schema is defined as an OpenAPI 3.0.2 Schema Object. The schema files that can be used here are found in gs://google-cloud-aiplatform/schema/dataset/metadata/.
   *
   * @schema DatasetSpecForProvider#metadataSchemaUri
   */
  readonly metadataSchemaUri?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DatasetSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the dataset. eg us-central1
   *
   * @schema DatasetSpecForProvider#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'DatasetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProvider(obj: DatasetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'encryptionSpec': obj.encryptionSpec?.map(y => toJson_DatasetSpecForProviderEncryptionSpec(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metadataSchemaUri': obj.metadataSchemaUri,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DatasetSpecInitProvider
 */
export interface DatasetSpecInitProvider {
  /**
   * The user-defined name of the Dataset. The name can be up to 128 characters long and can be consist of any UTF-8 characters.
   *
   * @schema DatasetSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Customer-managed encryption key spec for a Dataset. If set, this Dataset and all sub-resources of this Dataset will be secured by this key. Structure is documented below.
   *
   * @schema DatasetSpecInitProvider#encryptionSpec
   */
  readonly encryptionSpec?: DatasetSpecInitProviderEncryptionSpec[];

  /**
   * A set of key/value label pairs to assign to this Workflow.
   *
   * @schema DatasetSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Points to a YAML file stored on Google Cloud Storage describing additional information about the Dataset. The schema is defined as an OpenAPI 3.0.2 Schema Object. The schema files that can be used here are found in gs://google-cloud-aiplatform/schema/dataset/metadata/.
   *
   * @schema DatasetSpecInitProvider#metadataSchemaUri
   */
  readonly metadataSchemaUri?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DatasetSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The region of the dataset. eg us-central1
   *
   * @schema DatasetSpecInitProvider#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'DatasetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecInitProvider(obj: DatasetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'encryptionSpec': obj.encryptionSpec?.map(y => toJson_DatasetSpecInitProviderEncryptionSpec(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metadataSchemaUri': obj.metadataSchemaUri,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DatasetSpecManagementPolicies
 */
export enum DatasetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatasetSpecProviderConfigRef
 */
export interface DatasetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecProviderConfigRef#policy
   */
  readonly policy?: DatasetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecProviderConfigRef(obj: DatasetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatasetSpecPublishConnectionDetailsTo
 */
export interface DatasetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatasetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatasetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatasetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatasetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatasetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsTo(obj: DatasetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatasetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatasetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatasetSpecWriteConnectionSecretToRef
 */
export interface DatasetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatasetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatasetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatasetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecWriteConnectionSecretToRef(obj: DatasetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetSpecForProviderEncryptionSpec
 */
export interface DatasetSpecForProviderEncryptionSpec {
  /**
   * Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the resource is created.
   *
   * @schema DatasetSpecForProviderEncryptionSpec#kmsKeyName
   */
  readonly kmsKeyName?: string;

}

/**
 * Converts an object of type 'DatasetSpecForProviderEncryptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProviderEncryptionSpec(obj: DatasetSpecForProviderEncryptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetSpecInitProviderEncryptionSpec
 */
export interface DatasetSpecInitProviderEncryptionSpec {
  /**
   * Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the resource is created.
   *
   * @schema DatasetSpecInitProviderEncryptionSpec#kmsKeyName
   */
  readonly kmsKeyName?: string;

}

/**
 * Converts an object of type 'DatasetSpecInitProviderEncryptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecInitProviderEncryptionSpec(obj: DatasetSpecInitProviderEncryptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecProviderConfigRefPolicy
 */
export interface DatasetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecProviderConfigRefPolicy(obj: DatasetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRef
 */
export interface DatasetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatasetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsToConfigRef(obj: DatasetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatasetSpecPublishConnectionDetailsToMetadata
 */
export interface DatasetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatasetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsToMetadata(obj: DatasetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecProviderConfigRefPolicyResolution
 */
export enum DatasetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecProviderConfigRefPolicyResolve
 */
export enum DatasetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatasetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatasetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Featurestore is the Schema for the Featurestores API. A collection of DataItems and Annotations on them.
 *
 * @schema Featurestore
 */
export class Featurestore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Featurestore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'vertexai.gcp.upbound.io/v1beta1',
    kind: 'Featurestore',
  }

  /**
   * Renders a Kubernetes manifest for "Featurestore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FeaturestoreProps): any {
    return {
      ...Featurestore.GVK,
      ...toJson_FeaturestoreProps(props),
    };
  }

  /**
   * Defines a "Featurestore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FeaturestoreProps) {
    super(scope, id, {
      ...Featurestore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Featurestore.GVK,
      ...toJson_FeaturestoreProps(resolved),
    };
  }
}

/**
 * Featurestore is the Schema for the Featurestores API. A collection of DataItems and Annotations on them.
 *
 * @schema Featurestore
 */
export interface FeaturestoreProps {
  /**
   * @schema Featurestore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FeaturestoreSpec defines the desired state of Featurestore
   *
   * @schema Featurestore#spec
   */
  readonly spec: FeaturestoreSpec;

}

/**
 * Converts an object of type 'FeaturestoreProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreProps(obj: FeaturestoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FeaturestoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FeaturestoreSpec defines the desired state of Featurestore
 *
 * @schema FeaturestoreSpec
 */
export interface FeaturestoreSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FeaturestoreSpec#deletionPolicy
   */
  readonly deletionPolicy?: FeaturestoreSpecDeletionPolicy;

  /**
   * @schema FeaturestoreSpec#forProvider
   */
  readonly forProvider: FeaturestoreSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FeaturestoreSpec#initProvider
   */
  readonly initProvider?: FeaturestoreSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FeaturestoreSpec#managementPolicies
   */
  readonly managementPolicies?: FeaturestoreSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FeaturestoreSpec#providerConfigRef
   */
  readonly providerConfigRef?: FeaturestoreSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FeaturestoreSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FeaturestoreSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FeaturestoreSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FeaturestoreSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FeaturestoreSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpec(obj: FeaturestoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FeaturestoreSpecForProvider(obj.forProvider),
    'initProvider': toJson_FeaturestoreSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FeaturestoreSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FeaturestoreSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FeaturestoreSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FeaturestoreSpecDeletionPolicy
 */
export enum FeaturestoreSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FeaturestoreSpecForProvider
 */
export interface FeaturestoreSpecForProvider {
  /**
   * If set, both of the online and offline data storage will be secured by this key. Structure is documented below.
   *
   * @schema FeaturestoreSpecForProvider#encryptionSpec
   */
  readonly encryptionSpec?: FeaturestoreSpecForProviderEncryptionSpec[];

  /**
   * If set to true, any EntityTypes and Features for this Featurestore will also be deleted
   *
   * @schema FeaturestoreSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * A set of key/value label pairs to assign to this Featurestore.
   *
   * @schema FeaturestoreSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of the Featurestore. This value may be up to 60 characters, and valid characters are [a-z0-9_]. The first character cannot be a number.
   *
   * @schema FeaturestoreSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Config for online serving resources. Structure is documented below.
   *
   * @schema FeaturestoreSpecForProvider#onlineServingConfig
   */
  readonly onlineServingConfig?: FeaturestoreSpecForProviderOnlineServingConfig[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema FeaturestoreSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the dataset. eg us-central1
   *
   * @schema FeaturestoreSpecForProvider#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'FeaturestoreSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecForProvider(obj: FeaturestoreSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionSpec': obj.encryptionSpec?.map(y => toJson_FeaturestoreSpecForProviderEncryptionSpec(y)),
    'forceDestroy': obj.forceDestroy,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'onlineServingConfig': obj.onlineServingConfig?.map(y => toJson_FeaturestoreSpecForProviderOnlineServingConfig(y)),
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FeaturestoreSpecInitProvider
 */
export interface FeaturestoreSpecInitProvider {
  /**
   * If set, both of the online and offline data storage will be secured by this key. Structure is documented below.
   *
   * @schema FeaturestoreSpecInitProvider#encryptionSpec
   */
  readonly encryptionSpec?: FeaturestoreSpecInitProviderEncryptionSpec[];

  /**
   * If set to true, any EntityTypes and Features for this Featurestore will also be deleted
   *
   * @schema FeaturestoreSpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * A set of key/value label pairs to assign to this Featurestore.
   *
   * @schema FeaturestoreSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of the Featurestore. This value may be up to 60 characters, and valid characters are [a-z0-9_]. The first character cannot be a number.
   *
   * @schema FeaturestoreSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Config for online serving resources. Structure is documented below.
   *
   * @schema FeaturestoreSpecInitProvider#onlineServingConfig
   */
  readonly onlineServingConfig?: FeaturestoreSpecInitProviderOnlineServingConfig[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema FeaturestoreSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The region of the dataset. eg us-central1
   *
   * @schema FeaturestoreSpecInitProvider#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'FeaturestoreSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecInitProvider(obj: FeaturestoreSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionSpec': obj.encryptionSpec?.map(y => toJson_FeaturestoreSpecInitProviderEncryptionSpec(y)),
    'forceDestroy': obj.forceDestroy,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'onlineServingConfig': obj.onlineServingConfig?.map(y => toJson_FeaturestoreSpecInitProviderOnlineServingConfig(y)),
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FeaturestoreSpecManagementPolicies
 */
export enum FeaturestoreSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FeaturestoreSpecProviderConfigRef
 */
export interface FeaturestoreSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeaturestoreSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeaturestoreSpecProviderConfigRef#policy
   */
  readonly policy?: FeaturestoreSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FeaturestoreSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecProviderConfigRef(obj: FeaturestoreSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeaturestoreSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FeaturestoreSpecPublishConnectionDetailsTo
 */
export interface FeaturestoreSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FeaturestoreSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FeaturestoreSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FeaturestoreSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FeaturestoreSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FeaturestoreSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FeaturestoreSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecPublishConnectionDetailsTo(obj: FeaturestoreSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FeaturestoreSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FeaturestoreSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FeaturestoreSpecWriteConnectionSecretToRef
 */
export interface FeaturestoreSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FeaturestoreSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FeaturestoreSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FeaturestoreSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecWriteConnectionSecretToRef(obj: FeaturestoreSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreSpecForProviderEncryptionSpec
 */
export interface FeaturestoreSpecForProviderEncryptionSpec {
  /**
   * The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the compute resource is created.
   *
   * @schema FeaturestoreSpecForProviderEncryptionSpec#kmsKeyName
   */
  readonly kmsKeyName?: string;

}

/**
 * Converts an object of type 'FeaturestoreSpecForProviderEncryptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecForProviderEncryptionSpec(obj: FeaturestoreSpecForProviderEncryptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreSpecForProviderOnlineServingConfig
 */
export interface FeaturestoreSpecForProviderOnlineServingConfig {
  /**
   * The number of nodes for each cluster. The number of nodes will not scale automatically but can be scaled manually by providing different values when updating.
   *
   * @schema FeaturestoreSpecForProviderOnlineServingConfig#fixedNodeCount
   */
  readonly fixedNodeCount?: number;

  /**
   * Online serving scaling configuration. Only one of fixedNodeCount and scaling can be set. Setting one will reset the other. Structure is documented below.
   *
   * @schema FeaturestoreSpecForProviderOnlineServingConfig#scaling
   */
  readonly scaling?: FeaturestoreSpecForProviderOnlineServingConfigScaling[];

}

/**
 * Converts an object of type 'FeaturestoreSpecForProviderOnlineServingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecForProviderOnlineServingConfig(obj: FeaturestoreSpecForProviderOnlineServingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedNodeCount': obj.fixedNodeCount,
    'scaling': obj.scaling?.map(y => toJson_FeaturestoreSpecForProviderOnlineServingConfigScaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreSpecInitProviderEncryptionSpec
 */
export interface FeaturestoreSpecInitProviderEncryptionSpec {
  /**
   * The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the compute resource is created.
   *
   * @schema FeaturestoreSpecInitProviderEncryptionSpec#kmsKeyName
   */
  readonly kmsKeyName?: string;

}

/**
 * Converts an object of type 'FeaturestoreSpecInitProviderEncryptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecInitProviderEncryptionSpec(obj: FeaturestoreSpecInitProviderEncryptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreSpecInitProviderOnlineServingConfig
 */
export interface FeaturestoreSpecInitProviderOnlineServingConfig {
  /**
   * The number of nodes for each cluster. The number of nodes will not scale automatically but can be scaled manually by providing different values when updating.
   *
   * @schema FeaturestoreSpecInitProviderOnlineServingConfig#fixedNodeCount
   */
  readonly fixedNodeCount?: number;

  /**
   * Online serving scaling configuration. Only one of fixedNodeCount and scaling can be set. Setting one will reset the other. Structure is documented below.
   *
   * @schema FeaturestoreSpecInitProviderOnlineServingConfig#scaling
   */
  readonly scaling?: FeaturestoreSpecInitProviderOnlineServingConfigScaling[];

}

/**
 * Converts an object of type 'FeaturestoreSpecInitProviderOnlineServingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecInitProviderOnlineServingConfig(obj: FeaturestoreSpecInitProviderOnlineServingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedNodeCount': obj.fixedNodeCount,
    'scaling': obj.scaling?.map(y => toJson_FeaturestoreSpecInitProviderOnlineServingConfigScaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FeaturestoreSpecProviderConfigRefPolicy
 */
export interface FeaturestoreSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeaturestoreSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FeaturestoreSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeaturestoreSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FeaturestoreSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FeaturestoreSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecProviderConfigRefPolicy(obj: FeaturestoreSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FeaturestoreSpecPublishConnectionDetailsToConfigRef
 */
export interface FeaturestoreSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeaturestoreSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeaturestoreSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FeaturestoreSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecPublishConnectionDetailsToConfigRef(obj: FeaturestoreSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FeaturestoreSpecPublishConnectionDetailsToMetadata
 */
export interface FeaturestoreSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FeaturestoreSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FeaturestoreSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FeaturestoreSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FeaturestoreSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecPublishConnectionDetailsToMetadata(obj: FeaturestoreSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreSpecForProviderOnlineServingConfigScaling
 */
export interface FeaturestoreSpecForProviderOnlineServingConfigScaling {
  /**
   * The maximum number of nodes to scale up to. Must be greater than minNodeCount, and less than or equal to 10 times of 'minNodeCount'.
   *
   * @schema FeaturestoreSpecForProviderOnlineServingConfigScaling#maxNodeCount
   */
  readonly maxNodeCount?: number;

  /**
   * The minimum number of nodes to scale down to. Must be greater than or equal to 1.
   *
   * @schema FeaturestoreSpecForProviderOnlineServingConfigScaling#minNodeCount
   */
  readonly minNodeCount?: number;

}

/**
 * Converts an object of type 'FeaturestoreSpecForProviderOnlineServingConfigScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecForProviderOnlineServingConfigScaling(obj: FeaturestoreSpecForProviderOnlineServingConfigScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxNodeCount': obj.maxNodeCount,
    'minNodeCount': obj.minNodeCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreSpecInitProviderOnlineServingConfigScaling
 */
export interface FeaturestoreSpecInitProviderOnlineServingConfigScaling {
  /**
   * The maximum number of nodes to scale up to. Must be greater than minNodeCount, and less than or equal to 10 times of 'minNodeCount'.
   *
   * @schema FeaturestoreSpecInitProviderOnlineServingConfigScaling#maxNodeCount
   */
  readonly maxNodeCount?: number;

  /**
   * The minimum number of nodes to scale down to. Must be greater than or equal to 1.
   *
   * @schema FeaturestoreSpecInitProviderOnlineServingConfigScaling#minNodeCount
   */
  readonly minNodeCount?: number;

}

/**
 * Converts an object of type 'FeaturestoreSpecInitProviderOnlineServingConfigScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecInitProviderOnlineServingConfigScaling(obj: FeaturestoreSpecInitProviderOnlineServingConfigScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxNodeCount': obj.maxNodeCount,
    'minNodeCount': obj.minNodeCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeaturestoreSpecProviderConfigRefPolicyResolution
 */
export enum FeaturestoreSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeaturestoreSpecProviderConfigRefPolicyResolve
 */
export enum FeaturestoreSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicy(obj: FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FeaturestoreSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FeaturestoreEntitytype is the Schema for the FeaturestoreEntitytypes API. An entity type is a type of object in a system that needs to be modeled and have stored information about.
 *
 * @schema FeaturestoreEntitytype
 */
export class FeaturestoreEntitytype extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FeaturestoreEntitytype"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'vertexai.gcp.upbound.io/v1beta1',
    kind: 'FeaturestoreEntitytype',
  }

  /**
   * Renders a Kubernetes manifest for "FeaturestoreEntitytype".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FeaturestoreEntitytypeProps): any {
    return {
      ...FeaturestoreEntitytype.GVK,
      ...toJson_FeaturestoreEntitytypeProps(props),
    };
  }

  /**
   * Defines a "FeaturestoreEntitytype" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FeaturestoreEntitytypeProps) {
    super(scope, id, {
      ...FeaturestoreEntitytype.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FeaturestoreEntitytype.GVK,
      ...toJson_FeaturestoreEntitytypeProps(resolved),
    };
  }
}

/**
 * FeaturestoreEntitytype is the Schema for the FeaturestoreEntitytypes API. An entity type is a type of object in a system that needs to be modeled and have stored information about.
 *
 * @schema FeaturestoreEntitytype
 */
export interface FeaturestoreEntitytypeProps {
  /**
   * @schema FeaturestoreEntitytype#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FeaturestoreEntitytypeSpec defines the desired state of FeaturestoreEntitytype
   *
   * @schema FeaturestoreEntitytype#spec
   */
  readonly spec: FeaturestoreEntitytypeSpec;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeProps(obj: FeaturestoreEntitytypeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FeaturestoreEntitytypeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FeaturestoreEntitytypeSpec defines the desired state of FeaturestoreEntitytype
 *
 * @schema FeaturestoreEntitytypeSpec
 */
export interface FeaturestoreEntitytypeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FeaturestoreEntitytypeSpec#deletionPolicy
   */
  readonly deletionPolicy?: FeaturestoreEntitytypeSpecDeletionPolicy;

  /**
   * @schema FeaturestoreEntitytypeSpec#forProvider
   */
  readonly forProvider: FeaturestoreEntitytypeSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FeaturestoreEntitytypeSpec#initProvider
   */
  readonly initProvider?: FeaturestoreEntitytypeSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FeaturestoreEntitytypeSpec#managementPolicies
   */
  readonly managementPolicies?: FeaturestoreEntitytypeSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FeaturestoreEntitytypeSpec#providerConfigRef
   */
  readonly providerConfigRef?: FeaturestoreEntitytypeSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FeaturestoreEntitytypeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FeaturestoreEntitytypeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FeaturestoreEntitytypeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FeaturestoreEntitytypeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpec(obj: FeaturestoreEntitytypeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FeaturestoreEntitytypeSpecForProvider(obj.forProvider),
    'initProvider': toJson_FeaturestoreEntitytypeSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FeaturestoreEntitytypeSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FeaturestoreEntitytypeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FeaturestoreEntitytypeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FeaturestoreEntitytypeSpecDeletionPolicy
 */
export enum FeaturestoreEntitytypeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FeaturestoreEntitytypeSpecForProvider
 */
export interface FeaturestoreEntitytypeSpecForProvider {
  /**
   * Optional. Description of the EntityType.
   *
   * @schema FeaturestoreEntitytypeSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the Featurestore to use, in the format projects/{project}/locations/{location}/featurestores/{featurestore}.
   *
   * @schema FeaturestoreEntitytypeSpecForProvider#featurestore
   */
  readonly featurestore?: string;

  /**
   * Reference to a Featurestore in vertexai to populate featurestore.
   *
   * @schema FeaturestoreEntitytypeSpecForProvider#featurestoreRef
   */
  readonly featurestoreRef?: FeaturestoreEntitytypeSpecForProviderFeaturestoreRef;

  /**
   * Selector for a Featurestore in vertexai to populate featurestore.
   *
   * @schema FeaturestoreEntitytypeSpecForProvider#featurestoreSelector
   */
  readonly featurestoreSelector?: FeaturestoreEntitytypeSpecForProviderFeaturestoreSelector;

  /**
   * A set of key/value label pairs to assign to this EntityType.
   *
   * @schema FeaturestoreEntitytypeSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The default monitoring configuration for all Features under this EntityType. If this is populated with [FeaturestoreMonitoringConfig.monitoring_interval] specified, snapshot analysis monitoring is enabled. Otherwise, snapshot analysis monitoring is disabled. Structure is documented below.
   *
   * @schema FeaturestoreEntitytypeSpecForProvider#monitoringConfig
   */
  readonly monitoringConfig?: FeaturestoreEntitytypeSpecForProviderMonitoringConfig[];

  /**
   * The name of the EntityType. This value may be up to 60 characters, and valid characters are [a-z0-9_]. The first character cannot be a number.
   *
   * @schema FeaturestoreEntitytypeSpecForProvider#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecForProvider(obj: FeaturestoreEntitytypeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'featurestore': obj.featurestore,
    'featurestoreRef': toJson_FeaturestoreEntitytypeSpecForProviderFeaturestoreRef(obj.featurestoreRef),
    'featurestoreSelector': toJson_FeaturestoreEntitytypeSpecForProviderFeaturestoreSelector(obj.featurestoreSelector),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'monitoringConfig': obj.monitoringConfig?.map(y => toJson_FeaturestoreEntitytypeSpecForProviderMonitoringConfig(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FeaturestoreEntitytypeSpecInitProvider
 */
export interface FeaturestoreEntitytypeSpecInitProvider {
  /**
   * Optional. Description of the EntityType.
   *
   * @schema FeaturestoreEntitytypeSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * A set of key/value label pairs to assign to this EntityType.
   *
   * @schema FeaturestoreEntitytypeSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The default monitoring configuration for all Features under this EntityType. If this is populated with [FeaturestoreMonitoringConfig.monitoring_interval] specified, snapshot analysis monitoring is enabled. Otherwise, snapshot analysis monitoring is disabled. Structure is documented below.
   *
   * @schema FeaturestoreEntitytypeSpecInitProvider#monitoringConfig
   */
  readonly monitoringConfig?: FeaturestoreEntitytypeSpecInitProviderMonitoringConfig[];

  /**
   * The name of the EntityType. This value may be up to 60 characters, and valid characters are [a-z0-9_]. The first character cannot be a number.
   *
   * @schema FeaturestoreEntitytypeSpecInitProvider#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecInitProvider(obj: FeaturestoreEntitytypeSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'monitoringConfig': obj.monitoringConfig?.map(y => toJson_FeaturestoreEntitytypeSpecInitProviderMonitoringConfig(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FeaturestoreEntitytypeSpecManagementPolicies
 */
export enum FeaturestoreEntitytypeSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FeaturestoreEntitytypeSpecProviderConfigRef
 */
export interface FeaturestoreEntitytypeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeaturestoreEntitytypeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeaturestoreEntitytypeSpecProviderConfigRef#policy
   */
  readonly policy?: FeaturestoreEntitytypeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecProviderConfigRef(obj: FeaturestoreEntitytypeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeaturestoreEntitytypeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsTo
 */
export interface FeaturestoreEntitytypeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FeaturestoreEntitytypeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecPublishConnectionDetailsTo(obj: FeaturestoreEntitytypeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FeaturestoreEntitytypeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FeaturestoreEntitytypeSpecWriteConnectionSecretToRef
 */
export interface FeaturestoreEntitytypeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FeaturestoreEntitytypeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FeaturestoreEntitytypeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecWriteConnectionSecretToRef(obj: FeaturestoreEntitytypeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Featurestore in vertexai to populate featurestore.
 *
 * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreRef
 */
export interface FeaturestoreEntitytypeSpecForProviderFeaturestoreRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreRef#policy
   */
  readonly policy?: FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicy;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecForProviderFeaturestoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecForProviderFeaturestoreRef(obj: FeaturestoreEntitytypeSpecForProviderFeaturestoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Featurestore in vertexai to populate featurestore.
 *
 * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreSelector
 */
export interface FeaturestoreEntitytypeSpecForProviderFeaturestoreSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreSelector#policy
   */
  readonly policy?: FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicy;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecForProviderFeaturestoreSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecForProviderFeaturestoreSelector(obj: FeaturestoreEntitytypeSpecForProviderFeaturestoreSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfig
 */
export interface FeaturestoreEntitytypeSpecForProviderMonitoringConfig {
  /**
   * Threshold for categorical features of anomaly detection. This is shared by all types of Featurestore Monitoring for categorical features (i.e. Features with type (Feature.ValueType) BOOL or STRING). Structure is documented below.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfig#categoricalThresholdConfig
   */
  readonly categoricalThresholdConfig?: FeaturestoreEntitytypeSpecForProviderMonitoringConfigCategoricalThresholdConfig[];

  /**
   * The config for ImportFeatures Analysis Based Feature Monitoring. Structure is documented below.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfig#importFeaturesAnalysis
   */
  readonly importFeaturesAnalysis?: FeaturestoreEntitytypeSpecForProviderMonitoringConfigImportFeaturesAnalysis[];

  /**
   * Threshold for numerical features of anomaly detection. This is shared by all objectives of Featurestore Monitoring for numerical features (i.e. Features with type (Feature.ValueType) DOUBLE or INT64). Structure is documented below.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfig#numericalThresholdConfig
   */
  readonly numericalThresholdConfig?: FeaturestoreEntitytypeSpecForProviderMonitoringConfigNumericalThresholdConfig[];

  /**
   * The config for Snapshot Analysis Based Feature Monitoring. Structure is documented below.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfig#snapshotAnalysis
   */
  readonly snapshotAnalysis?: FeaturestoreEntitytypeSpecForProviderMonitoringConfigSnapshotAnalysis[];

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecForProviderMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecForProviderMonitoringConfig(obj: FeaturestoreEntitytypeSpecForProviderMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categoricalThresholdConfig': obj.categoricalThresholdConfig?.map(y => toJson_FeaturestoreEntitytypeSpecForProviderMonitoringConfigCategoricalThresholdConfig(y)),
    'importFeaturesAnalysis': obj.importFeaturesAnalysis?.map(y => toJson_FeaturestoreEntitytypeSpecForProviderMonitoringConfigImportFeaturesAnalysis(y)),
    'numericalThresholdConfig': obj.numericalThresholdConfig?.map(y => toJson_FeaturestoreEntitytypeSpecForProviderMonitoringConfigNumericalThresholdConfig(y)),
    'snapshotAnalysis': obj.snapshotAnalysis?.map(y => toJson_FeaturestoreEntitytypeSpecForProviderMonitoringConfigSnapshotAnalysis(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfig
 */
export interface FeaturestoreEntitytypeSpecInitProviderMonitoringConfig {
  /**
   * Threshold for categorical features of anomaly detection. This is shared by all types of Featurestore Monitoring for categorical features (i.e. Features with type (Feature.ValueType) BOOL or STRING). Structure is documented below.
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfig#categoricalThresholdConfig
   */
  readonly categoricalThresholdConfig?: FeaturestoreEntitytypeSpecInitProviderMonitoringConfigCategoricalThresholdConfig[];

  /**
   * The config for ImportFeatures Analysis Based Feature Monitoring. Structure is documented below.
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfig#importFeaturesAnalysis
   */
  readonly importFeaturesAnalysis?: FeaturestoreEntitytypeSpecInitProviderMonitoringConfigImportFeaturesAnalysis[];

  /**
   * Threshold for numerical features of anomaly detection. This is shared by all objectives of Featurestore Monitoring for numerical features (i.e. Features with type (Feature.ValueType) DOUBLE or INT64). Structure is documented below.
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfig#numericalThresholdConfig
   */
  readonly numericalThresholdConfig?: FeaturestoreEntitytypeSpecInitProviderMonitoringConfigNumericalThresholdConfig[];

  /**
   * The config for Snapshot Analysis Based Feature Monitoring. Structure is documented below.
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfig#snapshotAnalysis
   */
  readonly snapshotAnalysis?: FeaturestoreEntitytypeSpecInitProviderMonitoringConfigSnapshotAnalysis[];

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecInitProviderMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecInitProviderMonitoringConfig(obj: FeaturestoreEntitytypeSpecInitProviderMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categoricalThresholdConfig': obj.categoricalThresholdConfig?.map(y => toJson_FeaturestoreEntitytypeSpecInitProviderMonitoringConfigCategoricalThresholdConfig(y)),
    'importFeaturesAnalysis': obj.importFeaturesAnalysis?.map(y => toJson_FeaturestoreEntitytypeSpecInitProviderMonitoringConfigImportFeaturesAnalysis(y)),
    'numericalThresholdConfig': obj.numericalThresholdConfig?.map(y => toJson_FeaturestoreEntitytypeSpecInitProviderMonitoringConfigNumericalThresholdConfig(y)),
    'snapshotAnalysis': obj.snapshotAnalysis?.map(y => toJson_FeaturestoreEntitytypeSpecInitProviderMonitoringConfigSnapshotAnalysis(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FeaturestoreEntitytypeSpecProviderConfigRefPolicy
 */
export interface FeaturestoreEntitytypeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeaturestoreEntitytypeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FeaturestoreEntitytypeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeaturestoreEntitytypeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FeaturestoreEntitytypeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecProviderConfigRefPolicy(obj: FeaturestoreEntitytypeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRef
 */
export interface FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRef(obj: FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToMetadata
 */
export interface FeaturestoreEntitytypeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecPublishConnectionDetailsToMetadata(obj: FeaturestoreEntitytypeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicy
 */
export interface FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicy#resolution
   */
  readonly resolution?: FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicy#resolve
   */
  readonly resolve?: FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicyResolve;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicy(obj: FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicy
 */
export interface FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicy#resolution
   */
  readonly resolution?: FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicy#resolve
   */
  readonly resolve?: FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicy(obj: FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigCategoricalThresholdConfig
 */
export interface FeaturestoreEntitytypeSpecForProviderMonitoringConfigCategoricalThresholdConfig {
  /**
   * Specify a threshold value that can trigger the alert. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature. The default value is 0.3.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigCategoricalThresholdConfig#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecForProviderMonitoringConfigCategoricalThresholdConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecForProviderMonitoringConfigCategoricalThresholdConfig(obj: FeaturestoreEntitytypeSpecForProviderMonitoringConfigCategoricalThresholdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigImportFeaturesAnalysis
 */
export interface FeaturestoreEntitytypeSpecForProviderMonitoringConfigImportFeaturesAnalysis {
  /**
   * Defines the baseline to do anomaly detection for feature values imported by each [entityTypes.importFeatureValues][] operation. The value must be one of the values below:
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigImportFeaturesAnalysis#anomalyDetectionBaseline
   */
  readonly anomalyDetectionBaseline?: string;

  /**
   * Whether to enable / disable / inherite default hebavior for import features analysis. The value must be one of the values below:
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigImportFeaturesAnalysis#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecForProviderMonitoringConfigImportFeaturesAnalysis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecForProviderMonitoringConfigImportFeaturesAnalysis(obj: FeaturestoreEntitytypeSpecForProviderMonitoringConfigImportFeaturesAnalysis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'anomalyDetectionBaseline': obj.anomalyDetectionBaseline,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigNumericalThresholdConfig
 */
export interface FeaturestoreEntitytypeSpecForProviderMonitoringConfigNumericalThresholdConfig {
  /**
   * Specify a threshold value that can trigger the alert. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature. The default value is 0.3.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigNumericalThresholdConfig#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecForProviderMonitoringConfigNumericalThresholdConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecForProviderMonitoringConfigNumericalThresholdConfig(obj: FeaturestoreEntitytypeSpecForProviderMonitoringConfigNumericalThresholdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigSnapshotAnalysis
 */
export interface FeaturestoreEntitytypeSpecForProviderMonitoringConfigSnapshotAnalysis {
  /**
   * The monitoring schedule for snapshot analysis. For EntityType-level config: unset / disabled = true indicates disabled by default for Features under it; otherwise by default enable snapshot analysis monitoring with monitoringInterval for Features under it.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigSnapshotAnalysis#disabled
   */
  readonly disabled?: boolean;

  /**
   * Configuration of the snapshot analysis based monitoring pipeline running interval. The value indicates number of days. The default value is 1. If both FeaturestoreMonitoringConfig.SnapshotAnalysis.monitoring_interval_days and [FeaturestoreMonitoringConfig.SnapshotAnalysis.monitoring_interval][] are set when creating/updating EntityTypes/Features, FeaturestoreMonitoringConfig.SnapshotAnalysis.monitoring_interval_days will be used.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigSnapshotAnalysis#monitoringIntervalDays
   */
  readonly monitoringIntervalDays?: number;

  /**
   * Customized export features time window for snapshot analysis. Unit is one day. The default value is 21 days. Minimum value is 1 day. Maximum value is 4000 days.
   *
   * @schema FeaturestoreEntitytypeSpecForProviderMonitoringConfigSnapshotAnalysis#stalenessDays
   */
  readonly stalenessDays?: number;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecForProviderMonitoringConfigSnapshotAnalysis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecForProviderMonitoringConfigSnapshotAnalysis(obj: FeaturestoreEntitytypeSpecForProviderMonitoringConfigSnapshotAnalysis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'monitoringIntervalDays': obj.monitoringIntervalDays,
    'stalenessDays': obj.stalenessDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigCategoricalThresholdConfig
 */
export interface FeaturestoreEntitytypeSpecInitProviderMonitoringConfigCategoricalThresholdConfig {
  /**
   * Specify a threshold value that can trigger the alert. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature. The default value is 0.3.
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigCategoricalThresholdConfig#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecInitProviderMonitoringConfigCategoricalThresholdConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecInitProviderMonitoringConfigCategoricalThresholdConfig(obj: FeaturestoreEntitytypeSpecInitProviderMonitoringConfigCategoricalThresholdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigImportFeaturesAnalysis
 */
export interface FeaturestoreEntitytypeSpecInitProviderMonitoringConfigImportFeaturesAnalysis {
  /**
   * Defines the baseline to do anomaly detection for feature values imported by each [entityTypes.importFeatureValues][] operation. The value must be one of the values below:
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigImportFeaturesAnalysis#anomalyDetectionBaseline
   */
  readonly anomalyDetectionBaseline?: string;

  /**
   * Whether to enable / disable / inherite default hebavior for import features analysis. The value must be one of the values below:
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigImportFeaturesAnalysis#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecInitProviderMonitoringConfigImportFeaturesAnalysis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecInitProviderMonitoringConfigImportFeaturesAnalysis(obj: FeaturestoreEntitytypeSpecInitProviderMonitoringConfigImportFeaturesAnalysis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'anomalyDetectionBaseline': obj.anomalyDetectionBaseline,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigNumericalThresholdConfig
 */
export interface FeaturestoreEntitytypeSpecInitProviderMonitoringConfigNumericalThresholdConfig {
  /**
   * Specify a threshold value that can trigger the alert. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature. The default value is 0.3.
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigNumericalThresholdConfig#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecInitProviderMonitoringConfigNumericalThresholdConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecInitProviderMonitoringConfigNumericalThresholdConfig(obj: FeaturestoreEntitytypeSpecInitProviderMonitoringConfigNumericalThresholdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigSnapshotAnalysis
 */
export interface FeaturestoreEntitytypeSpecInitProviderMonitoringConfigSnapshotAnalysis {
  /**
   * The monitoring schedule for snapshot analysis. For EntityType-level config: unset / disabled = true indicates disabled by default for Features under it; otherwise by default enable snapshot analysis monitoring with monitoringInterval for Features under it.
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigSnapshotAnalysis#disabled
   */
  readonly disabled?: boolean;

  /**
   * Configuration of the snapshot analysis based monitoring pipeline running interval. The value indicates number of days. The default value is 1. If both FeaturestoreMonitoringConfig.SnapshotAnalysis.monitoring_interval_days and [FeaturestoreMonitoringConfig.SnapshotAnalysis.monitoring_interval][] are set when creating/updating EntityTypes/Features, FeaturestoreMonitoringConfig.SnapshotAnalysis.monitoring_interval_days will be used.
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigSnapshotAnalysis#monitoringIntervalDays
   */
  readonly monitoringIntervalDays?: number;

  /**
   * Customized export features time window for snapshot analysis. Unit is one day. The default value is 21 days. Minimum value is 1 day. Maximum value is 4000 days.
   *
   * @schema FeaturestoreEntitytypeSpecInitProviderMonitoringConfigSnapshotAnalysis#stalenessDays
   */
  readonly stalenessDays?: number;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecInitProviderMonitoringConfigSnapshotAnalysis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecInitProviderMonitoringConfigSnapshotAnalysis(obj: FeaturestoreEntitytypeSpecInitProviderMonitoringConfigSnapshotAnalysis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'monitoringIntervalDays': obj.monitoringIntervalDays,
    'stalenessDays': obj.stalenessDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeaturestoreEntitytypeSpecProviderConfigRefPolicyResolution
 */
export enum FeaturestoreEntitytypeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeaturestoreEntitytypeSpecProviderConfigRefPolicyResolve
 */
export enum FeaturestoreEntitytypeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicy(obj: FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicyResolution
 */
export enum FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicyResolve
 */
export enum FeaturestoreEntitytypeSpecForProviderFeaturestoreRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicyResolution
 */
export enum FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicyResolve
 */
export enum FeaturestoreEntitytypeSpecForProviderFeaturestoreSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FeaturestoreEntitytypeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Tensorboard is the Schema for the Tensorboards API. Tensorboard is a physical database that stores users' training metrics.
 *
 * @schema Tensorboard
 */
export class Tensorboard extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Tensorboard"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'vertexai.gcp.upbound.io/v1beta1',
    kind: 'Tensorboard',
  }

  /**
   * Renders a Kubernetes manifest for "Tensorboard".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TensorboardProps): any {
    return {
      ...Tensorboard.GVK,
      ...toJson_TensorboardProps(props),
    };
  }

  /**
   * Defines a "Tensorboard" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TensorboardProps) {
    super(scope, id, {
      ...Tensorboard.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Tensorboard.GVK,
      ...toJson_TensorboardProps(resolved),
    };
  }
}

/**
 * Tensorboard is the Schema for the Tensorboards API. Tensorboard is a physical database that stores users' training metrics.
 *
 * @schema Tensorboard
 */
export interface TensorboardProps {
  /**
   * @schema Tensorboard#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TensorboardSpec defines the desired state of Tensorboard
   *
   * @schema Tensorboard#spec
   */
  readonly spec: TensorboardSpec;

}

/**
 * Converts an object of type 'TensorboardProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardProps(obj: TensorboardProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TensorboardSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TensorboardSpec defines the desired state of Tensorboard
 *
 * @schema TensorboardSpec
 */
export interface TensorboardSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TensorboardSpec#deletionPolicy
   */
  readonly deletionPolicy?: TensorboardSpecDeletionPolicy;

  /**
   * @schema TensorboardSpec#forProvider
   */
  readonly forProvider: TensorboardSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TensorboardSpec#initProvider
   */
  readonly initProvider?: TensorboardSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TensorboardSpec#managementPolicies
   */
  readonly managementPolicies?: TensorboardSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TensorboardSpec#providerConfigRef
   */
  readonly providerConfigRef?: TensorboardSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TensorboardSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TensorboardSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TensorboardSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TensorboardSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TensorboardSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpec(obj: TensorboardSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TensorboardSpecForProvider(obj.forProvider),
    'initProvider': toJson_TensorboardSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TensorboardSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TensorboardSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TensorboardSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TensorboardSpecDeletionPolicy
 */
export enum TensorboardSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TensorboardSpecForProvider
 */
export interface TensorboardSpecForProvider {
  /**
   * Description of this Tensorboard.
   *
   * @schema TensorboardSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Customer-managed encryption key spec for a Tensorboard. If set, this Tensorboard and all sub-resources of this Tensorboard will be secured by this key. Structure is documented below.
   *
   * @schema TensorboardSpecForProvider#encryptionSpec
   */
  readonly encryptionSpec?: TensorboardSpecForProviderEncryptionSpec[];

  /**
   * The labels with user-defined metadata to organize your Tensorboards.
   *
   * @schema TensorboardSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema TensorboardSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the tensorboard. eg us-central1
   *
   * @schema TensorboardSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'TensorboardSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecForProvider(obj: TensorboardSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'encryptionSpec': obj.encryptionSpec?.map(y => toJson_TensorboardSpecForProviderEncryptionSpec(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TensorboardSpecInitProvider
 */
export interface TensorboardSpecInitProvider {
  /**
   * Description of this Tensorboard.
   *
   * @schema TensorboardSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Customer-managed encryption key spec for a Tensorboard. If set, this Tensorboard and all sub-resources of this Tensorboard will be secured by this key. Structure is documented below.
   *
   * @schema TensorboardSpecInitProvider#encryptionSpec
   */
  readonly encryptionSpec?: TensorboardSpecInitProviderEncryptionSpec[];

  /**
   * The labels with user-defined metadata to organize your Tensorboards.
   *
   * @schema TensorboardSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema TensorboardSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'TensorboardSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecInitProvider(obj: TensorboardSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'encryptionSpec': obj.encryptionSpec?.map(y => toJson_TensorboardSpecInitProviderEncryptionSpec(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TensorboardSpecManagementPolicies
 */
export enum TensorboardSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TensorboardSpecProviderConfigRef
 */
export interface TensorboardSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TensorboardSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TensorboardSpecProviderConfigRef#policy
   */
  readonly policy?: TensorboardSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TensorboardSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecProviderConfigRef(obj: TensorboardSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TensorboardSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TensorboardSpecPublishConnectionDetailsTo
 */
export interface TensorboardSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TensorboardSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TensorboardSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TensorboardSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TensorboardSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TensorboardSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TensorboardSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecPublishConnectionDetailsTo(obj: TensorboardSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TensorboardSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TensorboardSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TensorboardSpecWriteConnectionSecretToRef
 */
export interface TensorboardSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TensorboardSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TensorboardSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TensorboardSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecWriteConnectionSecretToRef(obj: TensorboardSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TensorboardSpecForProviderEncryptionSpec
 */
export interface TensorboardSpecForProviderEncryptionSpec {
  /**
   * The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the resource is created.
   *
   * @schema TensorboardSpecForProviderEncryptionSpec#kmsKeyName
   */
  readonly kmsKeyName?: string;

}

/**
 * Converts an object of type 'TensorboardSpecForProviderEncryptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecForProviderEncryptionSpec(obj: TensorboardSpecForProviderEncryptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TensorboardSpecInitProviderEncryptionSpec
 */
export interface TensorboardSpecInitProviderEncryptionSpec {
  /**
   * The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the resource is created.
   *
   * @schema TensorboardSpecInitProviderEncryptionSpec#kmsKeyName
   */
  readonly kmsKeyName?: string;

}

/**
 * Converts an object of type 'TensorboardSpecInitProviderEncryptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecInitProviderEncryptionSpec(obj: TensorboardSpecInitProviderEncryptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TensorboardSpecProviderConfigRefPolicy
 */
export interface TensorboardSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TensorboardSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TensorboardSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TensorboardSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TensorboardSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TensorboardSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecProviderConfigRefPolicy(obj: TensorboardSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TensorboardSpecPublishConnectionDetailsToConfigRef
 */
export interface TensorboardSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TensorboardSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TensorboardSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TensorboardSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TensorboardSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecPublishConnectionDetailsToConfigRef(obj: TensorboardSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TensorboardSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TensorboardSpecPublishConnectionDetailsToMetadata
 */
export interface TensorboardSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TensorboardSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TensorboardSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TensorboardSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TensorboardSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecPublishConnectionDetailsToMetadata(obj: TensorboardSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TensorboardSpecProviderConfigRefPolicyResolution
 */
export enum TensorboardSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TensorboardSpecProviderConfigRefPolicyResolve
 */
export enum TensorboardSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TensorboardSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TensorboardSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TensorboardSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TensorboardSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TensorboardSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TensorboardSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TensorboardSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TensorboardSpecPublishConnectionDetailsToConfigRefPolicy(obj: TensorboardSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TensorboardSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TensorboardSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TensorboardSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TensorboardSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

