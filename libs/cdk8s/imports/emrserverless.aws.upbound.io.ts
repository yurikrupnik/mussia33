// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Application is the Schema for the Applications API. Manages an EMR Serverless Application
 *
 * @schema Application
 */
export class Application extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Application"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'emrserverless.aws.upbound.io/v1beta1',
    kind: 'Application',
  }

  /**
   * Renders a Kubernetes manifest for "Application".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationProps): any {
    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(props),
    };
  }

  /**
   * Defines a "Application" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationProps) {
    super(scope, id, {
      ...Application.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(resolved),
    };
  }
}

/**
 * Application is the Schema for the Applications API. Manages an EMR Serverless Application
 *
 * @schema Application
 */
export interface ApplicationProps {
  /**
   * @schema Application#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApplicationSpec defines the desired state of Application
   *
   * @schema Application#spec
   */
  readonly spec: ApplicationSpec;

}

/**
 * Converts an object of type 'ApplicationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationProps(obj: ApplicationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSpec defines the desired state of Application
 *
 * @schema ApplicationSpec
 */
export interface ApplicationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApplicationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationSpecDeletionPolicy;

  /**
   * @schema ApplicationSpec#forProvider
   */
  readonly forProvider: ApplicationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ApplicationSpec#initProvider
   */
  readonly initProvider?: ApplicationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApplicationSpec#managementPolicies
   */
  readonly managementPolicies?: ApplicationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpec(obj: ApplicationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationSpecForProvider(obj.forProvider),
    'initProvider': toJson_ApplicationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApplicationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApplicationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApplicationSpecDeletionPolicy
 */
export enum ApplicationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApplicationSpecForProvider
 */
export interface ApplicationSpecForProvider {
  /**
   * –  The CPU architecture of an application. Valid values are ARM64 or X86_64. Default value is X86_64.
   *
   * @schema ApplicationSpecForProvider#architecture
   */
  readonly architecture?: string;

  /**
   * –  The configuration for an application to automatically start on job submission.
   *
   * @schema ApplicationSpecForProvider#autoStartConfiguration
   */
  readonly autoStartConfiguration?: ApplicationSpecForProviderAutoStartConfiguration[];

  /**
   * –  The configuration for an application to automatically stop after a certain amount of time being idle.
   *
   * @schema ApplicationSpecForProvider#autoStopConfiguration
   */
  readonly autoStopConfiguration?: ApplicationSpecForProviderAutoStopConfiguration[];

  /**
   * –  The image configuration applied to all worker types.
   *
   * @schema ApplicationSpecForProvider#imageConfiguration
   */
  readonly imageConfiguration?: ApplicationSpecForProviderImageConfiguration[];

  /**
   * –  The capacity to initialize when the application is created.
   *
   * @schema ApplicationSpecForProvider#initialCapacity
   */
  readonly initialCapacity?: ApplicationSpecForProviderInitialCapacity[];

  /**
   * –  The maximum capacity to allocate when the application is created. This is cumulative across all workers at any given point in time, not just when an application is created. No new resources will be created once any one of the defined limits is hit.
   *
   * @schema ApplicationSpecForProvider#maximumCapacity
   */
  readonly maximumCapacity?: ApplicationSpecForProviderMaximumCapacity[];

  /**
   * –  The name of the application.
   *
   * @schema ApplicationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * –  The network configuration for customer VPC connectivity.
   *
   * @schema ApplicationSpecForProvider#networkConfiguration
   */
  readonly networkConfiguration?: ApplicationSpecForProviderNetworkConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApplicationSpecForProvider#region
   */
  readonly region: string;

  /**
   * –  The EMR release version associated with the application.
   *
   * @schema ApplicationSpecForProvider#releaseLabel
   */
  readonly releaseLabel?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * –  The type of application you want to start, such as spark or hive.
   *
   * @schema ApplicationSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProvider(obj: ApplicationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'architecture': obj.architecture,
    'autoStartConfiguration': obj.autoStartConfiguration?.map(y => toJson_ApplicationSpecForProviderAutoStartConfiguration(y)),
    'autoStopConfiguration': obj.autoStopConfiguration?.map(y => toJson_ApplicationSpecForProviderAutoStopConfiguration(y)),
    'imageConfiguration': obj.imageConfiguration?.map(y => toJson_ApplicationSpecForProviderImageConfiguration(y)),
    'initialCapacity': obj.initialCapacity?.map(y => toJson_ApplicationSpecForProviderInitialCapacity(y)),
    'maximumCapacity': obj.maximumCapacity?.map(y => toJson_ApplicationSpecForProviderMaximumCapacity(y)),
    'name': obj.name,
    'networkConfiguration': obj.networkConfiguration?.map(y => toJson_ApplicationSpecForProviderNetworkConfiguration(y)),
    'region': obj.region,
    'releaseLabel': obj.releaseLabel,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ApplicationSpecInitProvider
 */
export interface ApplicationSpecInitProvider {
  /**
   * –  The CPU architecture of an application. Valid values are ARM64 or X86_64. Default value is X86_64.
   *
   * @schema ApplicationSpecInitProvider#architecture
   */
  readonly architecture?: string;

  /**
   * –  The configuration for an application to automatically start on job submission.
   *
   * @schema ApplicationSpecInitProvider#autoStartConfiguration
   */
  readonly autoStartConfiguration?: ApplicationSpecInitProviderAutoStartConfiguration[];

  /**
   * –  The configuration for an application to automatically stop after a certain amount of time being idle.
   *
   * @schema ApplicationSpecInitProvider#autoStopConfiguration
   */
  readonly autoStopConfiguration?: ApplicationSpecInitProviderAutoStopConfiguration[];

  /**
   * –  The image configuration applied to all worker types.
   *
   * @schema ApplicationSpecInitProvider#imageConfiguration
   */
  readonly imageConfiguration?: ApplicationSpecInitProviderImageConfiguration[];

  /**
   * –  The capacity to initialize when the application is created.
   *
   * @schema ApplicationSpecInitProvider#initialCapacity
   */
  readonly initialCapacity?: ApplicationSpecInitProviderInitialCapacity[];

  /**
   * –  The maximum capacity to allocate when the application is created. This is cumulative across all workers at any given point in time, not just when an application is created. No new resources will be created once any one of the defined limits is hit.
   *
   * @schema ApplicationSpecInitProvider#maximumCapacity
   */
  readonly maximumCapacity?: ApplicationSpecInitProviderMaximumCapacity[];

  /**
   * –  The name of the application.
   *
   * @schema ApplicationSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * –  The network configuration for customer VPC connectivity.
   *
   * @schema ApplicationSpecInitProvider#networkConfiguration
   */
  readonly networkConfiguration?: ApplicationSpecInitProviderNetworkConfiguration[];

  /**
   * –  The EMR release version associated with the application.
   *
   * @schema ApplicationSpecInitProvider#releaseLabel
   */
  readonly releaseLabel?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * –  The type of application you want to start, such as spark or hive.
   *
   * @schema ApplicationSpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProvider(obj: ApplicationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'architecture': obj.architecture,
    'autoStartConfiguration': obj.autoStartConfiguration?.map(y => toJson_ApplicationSpecInitProviderAutoStartConfiguration(y)),
    'autoStopConfiguration': obj.autoStopConfiguration?.map(y => toJson_ApplicationSpecInitProviderAutoStopConfiguration(y)),
    'imageConfiguration': obj.imageConfiguration?.map(y => toJson_ApplicationSpecInitProviderImageConfiguration(y)),
    'initialCapacity': obj.initialCapacity?.map(y => toJson_ApplicationSpecInitProviderInitialCapacity(y)),
    'maximumCapacity': obj.maximumCapacity?.map(y => toJson_ApplicationSpecInitProviderMaximumCapacity(y)),
    'name': obj.name,
    'networkConfiguration': obj.networkConfiguration?.map(y => toJson_ApplicationSpecInitProviderNetworkConfiguration(y)),
    'releaseLabel': obj.releaseLabel,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApplicationSpecManagementPolicies
 */
export enum ApplicationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationSpecProviderConfigRef
 */
export interface ApplicationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRef(obj: ApplicationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationSpecPublishConnectionDetailsTo
 */
export interface ApplicationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsTo(obj: ApplicationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationSpecWriteConnectionSecretToRef
 */
export interface ApplicationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecWriteConnectionSecretToRef(obj: ApplicationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderAutoStartConfiguration
 */
export interface ApplicationSpecForProviderAutoStartConfiguration {
  /**
   * Enables the application to automatically start on job submission. Defaults to true.
   *
   * @default true.
   * @schema ApplicationSpecForProviderAutoStartConfiguration#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderAutoStartConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderAutoStartConfiguration(obj: ApplicationSpecForProviderAutoStartConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderAutoStopConfiguration
 */
export interface ApplicationSpecForProviderAutoStopConfiguration {
  /**
   * Enables the application to automatically start on job submission. Defaults to true.
   *
   * @default true.
   * @schema ApplicationSpecForProviderAutoStopConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.
   *
   * @default 15 minutes.
   * @schema ApplicationSpecForProviderAutoStopConfiguration#idleTimeoutMinutes
   */
  readonly idleTimeoutMinutes?: number;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderAutoStopConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderAutoStopConfiguration(obj: ApplicationSpecForProviderAutoStopConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'idleTimeoutMinutes': obj.idleTimeoutMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderImageConfiguration
 */
export interface ApplicationSpecForProviderImageConfiguration {
  /**
   * The image URI.
   *
   * @schema ApplicationSpecForProviderImageConfiguration#imageUri
   */
  readonly imageUri?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderImageConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderImageConfiguration(obj: ApplicationSpecForProviderImageConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageUri': obj.imageUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInitialCapacity
 */
export interface ApplicationSpecForProviderInitialCapacity {
  /**
   * The initial capacity configuration per worker.
   *
   * @schema ApplicationSpecForProviderInitialCapacity#initialCapacityConfig
   */
  readonly initialCapacityConfig?: ApplicationSpecForProviderInitialCapacityInitialCapacityConfig[];

  /**
   * The worker type for an analytics framework. For Spark applications, the key can either be set to Driver or Executor. For Hive applications, it can be set to HiveDriver or TezTask.
   *
   * @schema ApplicationSpecForProviderInitialCapacity#initialCapacityType
   */
  readonly initialCapacityType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInitialCapacity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInitialCapacity(obj: ApplicationSpecForProviderInitialCapacity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialCapacityConfig': obj.initialCapacityConfig?.map(y => toJson_ApplicationSpecForProviderInitialCapacityInitialCapacityConfig(y)),
    'initialCapacityType': obj.initialCapacityType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderMaximumCapacity
 */
export interface ApplicationSpecForProviderMaximumCapacity {
  /**
   * The maximum allowed CPU for an application.
   *
   * @schema ApplicationSpecForProviderMaximumCapacity#cpu
   */
  readonly cpu?: string;

  /**
   * The maximum allowed disk for an application.
   *
   * @schema ApplicationSpecForProviderMaximumCapacity#disk
   */
  readonly disk?: string;

  /**
   * The maximum allowed resources for an application.
   *
   * @schema ApplicationSpecForProviderMaximumCapacity#memory
   */
  readonly memory?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderMaximumCapacity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderMaximumCapacity(obj: ApplicationSpecForProviderMaximumCapacity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpu': obj.cpu,
    'disk': obj.disk,
    'memory': obj.memory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderNetworkConfiguration
 */
export interface ApplicationSpecForProviderNetworkConfiguration {
  /**
   * The array of security group Ids for customer VPC connectivity.
   *
   * @schema ApplicationSpecForProviderNetworkConfiguration#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * The array of subnet Ids for customer VPC connectivity.
   *
   * @schema ApplicationSpecForProviderNetworkConfiguration#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderNetworkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderNetworkConfiguration(obj: ApplicationSpecForProviderNetworkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderAutoStartConfiguration
 */
export interface ApplicationSpecInitProviderAutoStartConfiguration {
  /**
   * Enables the application to automatically start on job submission. Defaults to true.
   *
   * @default true.
   * @schema ApplicationSpecInitProviderAutoStartConfiguration#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderAutoStartConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderAutoStartConfiguration(obj: ApplicationSpecInitProviderAutoStartConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderAutoStopConfiguration
 */
export interface ApplicationSpecInitProviderAutoStopConfiguration {
  /**
   * Enables the application to automatically start on job submission. Defaults to true.
   *
   * @default true.
   * @schema ApplicationSpecInitProviderAutoStopConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.
   *
   * @default 15 minutes.
   * @schema ApplicationSpecInitProviderAutoStopConfiguration#idleTimeoutMinutes
   */
  readonly idleTimeoutMinutes?: number;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderAutoStopConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderAutoStopConfiguration(obj: ApplicationSpecInitProviderAutoStopConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'idleTimeoutMinutes': obj.idleTimeoutMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderImageConfiguration
 */
export interface ApplicationSpecInitProviderImageConfiguration {
  /**
   * The image URI.
   *
   * @schema ApplicationSpecInitProviderImageConfiguration#imageUri
   */
  readonly imageUri?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderImageConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderImageConfiguration(obj: ApplicationSpecInitProviderImageConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageUri': obj.imageUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInitialCapacity
 */
export interface ApplicationSpecInitProviderInitialCapacity {
  /**
   * The initial capacity configuration per worker.
   *
   * @schema ApplicationSpecInitProviderInitialCapacity#initialCapacityConfig
   */
  readonly initialCapacityConfig?: ApplicationSpecInitProviderInitialCapacityInitialCapacityConfig[];

  /**
   * The worker type for an analytics framework. For Spark applications, the key can either be set to Driver or Executor. For Hive applications, it can be set to HiveDriver or TezTask.
   *
   * @schema ApplicationSpecInitProviderInitialCapacity#initialCapacityType
   */
  readonly initialCapacityType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInitialCapacity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInitialCapacity(obj: ApplicationSpecInitProviderInitialCapacity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialCapacityConfig': obj.initialCapacityConfig?.map(y => toJson_ApplicationSpecInitProviderInitialCapacityInitialCapacityConfig(y)),
    'initialCapacityType': obj.initialCapacityType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderMaximumCapacity
 */
export interface ApplicationSpecInitProviderMaximumCapacity {
  /**
   * The maximum allowed CPU for an application.
   *
   * @schema ApplicationSpecInitProviderMaximumCapacity#cpu
   */
  readonly cpu?: string;

  /**
   * The maximum allowed disk for an application.
   *
   * @schema ApplicationSpecInitProviderMaximumCapacity#disk
   */
  readonly disk?: string;

  /**
   * The maximum allowed resources for an application.
   *
   * @schema ApplicationSpecInitProviderMaximumCapacity#memory
   */
  readonly memory?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderMaximumCapacity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderMaximumCapacity(obj: ApplicationSpecInitProviderMaximumCapacity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpu': obj.cpu,
    'disk': obj.disk,
    'memory': obj.memory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderNetworkConfiguration
 */
export interface ApplicationSpecInitProviderNetworkConfiguration {
  /**
   * The array of security group Ids for customer VPC connectivity.
   *
   * @schema ApplicationSpecInitProviderNetworkConfiguration#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * The array of subnet Ids for customer VPC connectivity.
   *
   * @schema ApplicationSpecInitProviderNetworkConfiguration#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderNetworkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderNetworkConfiguration(obj: ApplicationSpecInitProviderNetworkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderConfigRefPolicy
 */
export interface ApplicationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRefPolicy(obj: ApplicationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj: ApplicationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj: ApplicationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInitialCapacityInitialCapacityConfig
 */
export interface ApplicationSpecForProviderInitialCapacityInitialCapacityConfig {
  /**
   * The resource configuration of the initial capacity configuration.
   *
   * @schema ApplicationSpecForProviderInitialCapacityInitialCapacityConfig#workerConfiguration
   */
  readonly workerConfiguration?: ApplicationSpecForProviderInitialCapacityInitialCapacityConfigWorkerConfiguration[];

  /**
   * The number of workers in the initial capacity configuration.
   *
   * @schema ApplicationSpecForProviderInitialCapacityInitialCapacityConfig#workerCount
   */
  readonly workerCount?: number;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInitialCapacityInitialCapacityConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInitialCapacityInitialCapacityConfig(obj: ApplicationSpecForProviderInitialCapacityInitialCapacityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'workerConfiguration': obj.workerConfiguration?.map(y => toJson_ApplicationSpecForProviderInitialCapacityInitialCapacityConfigWorkerConfiguration(y)),
    'workerCount': obj.workerCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInitialCapacityInitialCapacityConfig
 */
export interface ApplicationSpecInitProviderInitialCapacityInitialCapacityConfig {
  /**
   * The resource configuration of the initial capacity configuration.
   *
   * @schema ApplicationSpecInitProviderInitialCapacityInitialCapacityConfig#workerConfiguration
   */
  readonly workerConfiguration?: ApplicationSpecInitProviderInitialCapacityInitialCapacityConfigWorkerConfiguration[];

  /**
   * The number of workers in the initial capacity configuration.
   *
   * @schema ApplicationSpecInitProviderInitialCapacityInitialCapacityConfig#workerCount
   */
  readonly workerCount?: number;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInitialCapacityInitialCapacityConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInitialCapacityInitialCapacityConfig(obj: ApplicationSpecInitProviderInitialCapacityInitialCapacityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'workerConfiguration': obj.workerConfiguration?.map(y => toJson_ApplicationSpecInitProviderInitialCapacityInitialCapacityConfigWorkerConfiguration(y)),
    'workerCount': obj.workerCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInitialCapacityInitialCapacityConfigWorkerConfiguration
 */
export interface ApplicationSpecForProviderInitialCapacityInitialCapacityConfigWorkerConfiguration {
  /**
   * The maximum allowed CPU for an application.
   *
   * @schema ApplicationSpecForProviderInitialCapacityInitialCapacityConfigWorkerConfiguration#cpu
   */
  readonly cpu?: string;

  /**
   * The maximum allowed disk for an application.
   *
   * @schema ApplicationSpecForProviderInitialCapacityInitialCapacityConfigWorkerConfiguration#disk
   */
  readonly disk?: string;

  /**
   * The maximum allowed resources for an application.
   *
   * @schema ApplicationSpecForProviderInitialCapacityInitialCapacityConfigWorkerConfiguration#memory
   */
  readonly memory?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInitialCapacityInitialCapacityConfigWorkerConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInitialCapacityInitialCapacityConfigWorkerConfiguration(obj: ApplicationSpecForProviderInitialCapacityInitialCapacityConfigWorkerConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpu': obj.cpu,
    'disk': obj.disk,
    'memory': obj.memory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInitialCapacityInitialCapacityConfigWorkerConfiguration
 */
export interface ApplicationSpecInitProviderInitialCapacityInitialCapacityConfigWorkerConfiguration {
  /**
   * The maximum allowed CPU for an application.
   *
   * @schema ApplicationSpecInitProviderInitialCapacityInitialCapacityConfigWorkerConfiguration#cpu
   */
  readonly cpu?: string;

  /**
   * The maximum allowed disk for an application.
   *
   * @schema ApplicationSpecInitProviderInitialCapacityInitialCapacityConfigWorkerConfiguration#disk
   */
  readonly disk?: string;

  /**
   * The maximum allowed resources for an application.
   *
   * @schema ApplicationSpecInitProviderInitialCapacityInitialCapacityConfigWorkerConfiguration#memory
   */
  readonly memory?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInitialCapacityInitialCapacityConfigWorkerConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInitialCapacityInitialCapacityConfigWorkerConfiguration(obj: ApplicationSpecInitProviderInitialCapacityInitialCapacityConfigWorkerConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpu': obj.cpu,
    'disk': obj.disk,
    'memory': obj.memory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

