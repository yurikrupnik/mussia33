// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ExperimentTemplate is the Schema for the ExperimentTemplates API. Provides an FIS Experiment Template.
 *
 * @schema ExperimentTemplate
 */
export class ExperimentTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExperimentTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'fis.aws.upbound.io/v1beta1',
    kind: 'ExperimentTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "ExperimentTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExperimentTemplateProps): any {
    return {
      ...ExperimentTemplate.GVK,
      ...toJson_ExperimentTemplateProps(props),
    };
  }

  /**
   * Defines a "ExperimentTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExperimentTemplateProps) {
    super(scope, id, {
      ...ExperimentTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExperimentTemplate.GVK,
      ...toJson_ExperimentTemplateProps(resolved),
    };
  }
}

/**
 * ExperimentTemplate is the Schema for the ExperimentTemplates API. Provides an FIS Experiment Template.
 *
 * @schema ExperimentTemplate
 */
export interface ExperimentTemplateProps {
  /**
   * @schema ExperimentTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExperimentTemplateSpec defines the desired state of ExperimentTemplate
   *
   * @schema ExperimentTemplate#spec
   */
  readonly spec: ExperimentTemplateSpec;

}

/**
 * Converts an object of type 'ExperimentTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateProps(obj: ExperimentTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExperimentTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExperimentTemplateSpec defines the desired state of ExperimentTemplate
 *
 * @schema ExperimentTemplateSpec
 */
export interface ExperimentTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ExperimentTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: ExperimentTemplateSpecDeletionPolicy;

  /**
   * @schema ExperimentTemplateSpec#forProvider
   */
  readonly forProvider: ExperimentTemplateSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ExperimentTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: ExperimentTemplateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ExperimentTemplateSpec#providerRef
   */
  readonly providerRef?: ExperimentTemplateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ExperimentTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ExperimentTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ExperimentTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ExperimentTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ExperimentTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpec(obj: ExperimentTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ExperimentTemplateSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ExperimentTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ExperimentTemplateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ExperimentTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ExperimentTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ExperimentTemplateSpecDeletionPolicy
 */
export enum ExperimentTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ExperimentTemplateSpecForProvider
 */
export interface ExperimentTemplateSpecForProvider {
  /**
   * Action to be performed during an experiment. See below.
   *
   * @schema ExperimentTemplateSpecForProvider#action
   */
  readonly action: ExperimentTemplateSpecForProviderAction[];

  /**
   * Description for the experiment template.
   *
   * @schema ExperimentTemplateSpecForProvider#description
   */
  readonly description: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ExperimentTemplateSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of an IAM role that grants the AWS FIS service permission to perform service actions on your behalf.
   *
   * @schema ExperimentTemplateSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ExperimentTemplateSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ExperimentTemplateSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ExperimentTemplateSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ExperimentTemplateSpecForProviderRoleArnSelector;

  /**
   * When an ongoing experiment should be stopped. See below.
   *
   * @schema ExperimentTemplateSpecForProvider#stopCondition
   */
  readonly stopCondition: ExperimentTemplateSpecForProviderStopCondition[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ExperimentTemplateSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Target of an action. See below.
   *
   * @schema ExperimentTemplateSpecForProvider#target
   */
  readonly target?: ExperimentTemplateSpecForProviderTarget[];

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProvider(obj: ExperimentTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_ExperimentTemplateSpecForProviderAction(y)),
    'description': obj.description,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ExperimentTemplateSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ExperimentTemplateSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'stopCondition': obj.stopCondition?.map(y => toJson_ExperimentTemplateSpecForProviderStopCondition(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'target': obj.target?.map(y => toJson_ExperimentTemplateSpecForProviderTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ExperimentTemplateSpecProviderConfigRef
 */
export interface ExperimentTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExperimentTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExperimentTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: ExperimentTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecProviderConfigRef(obj: ExperimentTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExperimentTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ExperimentTemplateSpecProviderRef
 */
export interface ExperimentTemplateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExperimentTemplateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExperimentTemplateSpecProviderRef#policy
   */
  readonly policy?: ExperimentTemplateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecProviderRef(obj: ExperimentTemplateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExperimentTemplateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ExperimentTemplateSpecPublishConnectionDetailsTo
 */
export interface ExperimentTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ExperimentTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ExperimentTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ExperimentTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ExperimentTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ExperimentTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecPublishConnectionDetailsTo(obj: ExperimentTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ExperimentTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ExperimentTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ExperimentTemplateSpecWriteConnectionSecretToRef
 */
export interface ExperimentTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ExperimentTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ExperimentTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecWriteConnectionSecretToRef(obj: ExperimentTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExperimentTemplateSpecForProviderAction
 */
export interface ExperimentTemplateSpecForProviderAction {
  /**
   * ID of the action. To find out what actions are supported see AWS FIS actions reference.
   *
   * @schema ExperimentTemplateSpecForProviderAction#actionId
   */
  readonly actionId: string;

  /**
   * Description of the action.
   *
   * @schema ExperimentTemplateSpecForProviderAction#description
   */
  readonly description?: string;

  /**
   * Friendly name of the action.
   *
   * @schema ExperimentTemplateSpecForProviderAction#name
   */
  readonly name: string;

  /**
   * Parameter(s) for the action, if applicable. See below.
   *
   * @schema ExperimentTemplateSpecForProviderAction#parameter
   */
  readonly parameter?: ExperimentTemplateSpecForProviderActionParameter[];

  /**
   * Set of action names that must complete before this action can be executed.
   *
   * @schema ExperimentTemplateSpecForProviderAction#startAfter
   */
  readonly startAfter?: string[];

  /**
   * Action's target, if applicable. See below.
   *
   * @schema ExperimentTemplateSpecForProviderAction#target
   */
  readonly target?: ExperimentTemplateSpecForProviderActionTarget[];

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderAction(obj: ExperimentTemplateSpecForProviderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionId': obj.actionId,
    'description': obj.description,
    'name': obj.name,
    'parameter': obj.parameter?.map(y => toJson_ExperimentTemplateSpecForProviderActionParameter(y)),
    'startAfter': obj.startAfter?.map(y => y),
    'target': obj.target?.map(y => toJson_ExperimentTemplateSpecForProviderActionTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ExperimentTemplateSpecForProviderRoleArnRef
 */
export interface ExperimentTemplateSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExperimentTemplateSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExperimentTemplateSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ExperimentTemplateSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderRoleArnRef(obj: ExperimentTemplateSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExperimentTemplateSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ExperimentTemplateSpecForProviderRoleArnSelector
 */
export interface ExperimentTemplateSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ExperimentTemplateSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ExperimentTemplateSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ExperimentTemplateSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ExperimentTemplateSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderRoleArnSelector(obj: ExperimentTemplateSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ExperimentTemplateSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExperimentTemplateSpecForProviderStopCondition
 */
export interface ExperimentTemplateSpecForProviderStopCondition {
  /**
   * Source of the condition. One of none, aws:cloudwatch:alarm.
   *
   * @schema ExperimentTemplateSpecForProviderStopCondition#source
   */
  readonly source: string;

  /**
   * ARN of the CloudWatch alarm. Required if the source is a CloudWatch alarm.
   *
   * @schema ExperimentTemplateSpecForProviderStopCondition#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderStopCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderStopCondition(obj: ExperimentTemplateSpecForProviderStopCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExperimentTemplateSpecForProviderTarget
 */
export interface ExperimentTemplateSpecForProviderTarget {
  /**
   * Filter(s) for the target. Filters can be used to select resources based on specific attributes returned by the respective describe action of the resource type. For more information, see Targets for AWS FIS. See below.
   *
   * @schema ExperimentTemplateSpecForProviderTarget#filter
   */
  readonly filter?: ExperimentTemplateSpecForProviderTargetFilter[];

  /**
   * Friendly name given to the target.
   *
   * @schema ExperimentTemplateSpecForProviderTarget#name
   */
  readonly name: string;

  /**
   * Set of ARNs of the resources to target with an action. Conflicts with resource_tag.
   *
   * @schema ExperimentTemplateSpecForProviderTarget#resourceArns
   */
  readonly resourceArns?: string[];

  /**
   * Tag(s) the resources need to have to be considered a valid target for an action. Conflicts with resource_arns. See below.
   *
   * @schema ExperimentTemplateSpecForProviderTarget#resourceTag
   */
  readonly resourceTag?: ExperimentTemplateSpecForProviderTargetResourceTag[];

  /**
   * AWS resource type. The resource type must be supported for the specified action. To find out what resource types are supported, see Targets for AWS FIS.
   *
   * @schema ExperimentTemplateSpecForProviderTarget#resourceType
   */
  readonly resourceType: string;

  /**
   * Scopes the identified resources. Valid values are ALL (all identified resources), COUNT(n) (randomly select n of the identified resources), PERCENT(n) (randomly select n percent of the identified resources).
   *
   * @schema ExperimentTemplateSpecForProviderTarget#selectionMode
   */
  readonly selectionMode: string;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderTarget(obj: ExperimentTemplateSpecForProviderTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter?.map(y => toJson_ExperimentTemplateSpecForProviderTargetFilter(y)),
    'name': obj.name,
    'resourceArns': obj.resourceArns?.map(y => y),
    'resourceTag': obj.resourceTag?.map(y => toJson_ExperimentTemplateSpecForProviderTargetResourceTag(y)),
    'resourceType': obj.resourceType,
    'selectionMode': obj.selectionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExperimentTemplateSpecProviderConfigRefPolicy
 */
export interface ExperimentTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperimentTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ExperimentTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperimentTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ExperimentTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecProviderConfigRefPolicy(obj: ExperimentTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExperimentTemplateSpecProviderRefPolicy
 */
export interface ExperimentTemplateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperimentTemplateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ExperimentTemplateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperimentTemplateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ExperimentTemplateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecProviderRefPolicy(obj: ExperimentTemplateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ExperimentTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface ExperimentTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExperimentTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExperimentTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecPublishConnectionDetailsToConfigRef(obj: ExperimentTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ExperimentTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface ExperimentTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ExperimentTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ExperimentTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ExperimentTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecPublishConnectionDetailsToMetadata(obj: ExperimentTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExperimentTemplateSpecForProviderActionParameter
 */
export interface ExperimentTemplateSpecForProviderActionParameter {
  /**
   * Parameter name.
   *
   * @schema ExperimentTemplateSpecForProviderActionParameter#key
   */
  readonly key: string;

  /**
   * Parameter value.
   *
   * @schema ExperimentTemplateSpecForProviderActionParameter#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderActionParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderActionParameter(obj: ExperimentTemplateSpecForProviderActionParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExperimentTemplateSpecForProviderActionTarget
 */
export interface ExperimentTemplateSpecForProviderActionTarget {
  /**
   * Tag key.
   *
   * @schema ExperimentTemplateSpecForProviderActionTarget#key
   */
  readonly key: string;

  /**
   * Target name, referencing a corresponding target.
   *
   * @schema ExperimentTemplateSpecForProviderActionTarget#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderActionTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderActionTarget(obj: ExperimentTemplateSpecForProviderActionTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExperimentTemplateSpecForProviderRoleArnRefPolicy
 */
export interface ExperimentTemplateSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperimentTemplateSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ExperimentTemplateSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperimentTemplateSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ExperimentTemplateSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderRoleArnRefPolicy(obj: ExperimentTemplateSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ExperimentTemplateSpecForProviderRoleArnSelectorPolicy
 */
export interface ExperimentTemplateSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperimentTemplateSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ExperimentTemplateSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperimentTemplateSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ExperimentTemplateSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderRoleArnSelectorPolicy(obj: ExperimentTemplateSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExperimentTemplateSpecForProviderTargetFilter
 */
export interface ExperimentTemplateSpecForProviderTargetFilter {
  /**
   * Attribute path for the filter.
   *
   * @schema ExperimentTemplateSpecForProviderTargetFilter#path
   */
  readonly path: string;

  /**
   * Set of attribute values for the filter.
   *
   * @schema ExperimentTemplateSpecForProviderTargetFilter#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderTargetFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderTargetFilter(obj: ExperimentTemplateSpecForProviderTargetFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExperimentTemplateSpecForProviderTargetResourceTag
 */
export interface ExperimentTemplateSpecForProviderTargetResourceTag {
  /**
   * Tag key.
   *
   * @schema ExperimentTemplateSpecForProviderTargetResourceTag#key
   */
  readonly key: string;

  /**
   * Tag value.
   *
   * @schema ExperimentTemplateSpecForProviderTargetResourceTag#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecForProviderTargetResourceTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecForProviderTargetResourceTag(obj: ExperimentTemplateSpecForProviderTargetResourceTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperimentTemplateSpecProviderConfigRefPolicyResolution
 */
export enum ExperimentTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperimentTemplateSpecProviderConfigRefPolicyResolve
 */
export enum ExperimentTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperimentTemplateSpecProviderRefPolicyResolution
 */
export enum ExperimentTemplateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperimentTemplateSpecProviderRefPolicyResolve
 */
export enum ExperimentTemplateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperimentTemplateSpecForProviderRoleArnRefPolicyResolution
 */
export enum ExperimentTemplateSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperimentTemplateSpecForProviderRoleArnRefPolicyResolve
 */
export enum ExperimentTemplateSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperimentTemplateSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ExperimentTemplateSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperimentTemplateSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ExperimentTemplateSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ExperimentTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

