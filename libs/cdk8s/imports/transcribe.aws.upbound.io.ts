// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LanguageModel is the Schema for the LanguageModels API.
 *
 * @schema LanguageModel
 */
export class LanguageModel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LanguageModel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'transcribe.aws.upbound.io/v1beta1',
    kind: 'LanguageModel',
  }

  /**
   * Renders a Kubernetes manifest for "LanguageModel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LanguageModelProps): any {
    return {
      ...LanguageModel.GVK,
      ...toJson_LanguageModelProps(props),
    };
  }

  /**
   * Defines a "LanguageModel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LanguageModelProps) {
    super(scope, id, {
      ...LanguageModel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LanguageModel.GVK,
      ...toJson_LanguageModelProps(resolved),
    };
  }
}

/**
 * LanguageModel is the Schema for the LanguageModels API.
 *
 * @schema LanguageModel
 */
export interface LanguageModelProps {
  /**
   * @schema LanguageModel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LanguageModelSpec defines the desired state of LanguageModel
   *
   * @schema LanguageModel#spec
   */
  readonly spec: LanguageModelSpec;

}

/**
 * Converts an object of type 'LanguageModelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelProps(obj: LanguageModelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LanguageModelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LanguageModelSpec defines the desired state of LanguageModel
 *
 * @schema LanguageModelSpec
 */
export interface LanguageModelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LanguageModelSpec#deletionPolicy
   */
  readonly deletionPolicy?: LanguageModelSpecDeletionPolicy;

  /**
   * @schema LanguageModelSpec#forProvider
   */
  readonly forProvider: LanguageModelSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LanguageModelSpec#managementPolicy
   */
  readonly managementPolicy?: LanguageModelSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LanguageModelSpec#providerConfigRef
   */
  readonly providerConfigRef?: LanguageModelSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LanguageModelSpec#providerRef
   */
  readonly providerRef?: LanguageModelSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LanguageModelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LanguageModelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LanguageModelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LanguageModelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LanguageModelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpec(obj: LanguageModelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LanguageModelSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LanguageModelSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LanguageModelSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LanguageModelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LanguageModelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LanguageModelSpecDeletionPolicy
 */
export enum LanguageModelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LanguageModelSpecForProvider
 */
export interface LanguageModelSpecForProvider {
  /**
   * Name of reference base model.
   *
   * @schema LanguageModelSpecForProvider#baseModelName
   */
  readonly baseModelName?: string;

  /**
   * The input data config for the LanguageModel. See Input Data Config for more details.
   *
   * @schema LanguageModelSpecForProvider#inputDataConfig
   */
  readonly inputDataConfig?: LanguageModelSpecForProviderInputDataConfig[];

  /**
   * The language code you selected for your language model. Refer to the supported languages page for accepted codes.
   *
   * @schema LanguageModelSpecForProvider#languageCode
   */
  readonly languageCode?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LanguageModelSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LanguageModelSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LanguageModelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecForProvider(obj: LanguageModelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseModelName': obj.baseModelName,
    'inputDataConfig': obj.inputDataConfig?.map(y => toJson_LanguageModelSpecForProviderInputDataConfig(y)),
    'languageCode': obj.languageCode,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LanguageModelSpecManagementPolicy
 */
export enum LanguageModelSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LanguageModelSpecProviderConfigRef
 */
export interface LanguageModelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LanguageModelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LanguageModelSpecProviderConfigRef#policy
   */
  readonly policy?: LanguageModelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LanguageModelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecProviderConfigRef(obj: LanguageModelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LanguageModelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LanguageModelSpecProviderRef
 */
export interface LanguageModelSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LanguageModelSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LanguageModelSpecProviderRef#policy
   */
  readonly policy?: LanguageModelSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LanguageModelSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecProviderRef(obj: LanguageModelSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LanguageModelSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LanguageModelSpecPublishConnectionDetailsTo
 */
export interface LanguageModelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LanguageModelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LanguageModelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LanguageModelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LanguageModelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LanguageModelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LanguageModelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecPublishConnectionDetailsTo(obj: LanguageModelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LanguageModelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LanguageModelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LanguageModelSpecWriteConnectionSecretToRef
 */
export interface LanguageModelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LanguageModelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LanguageModelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LanguageModelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecWriteConnectionSecretToRef(obj: LanguageModelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LanguageModelSpecForProviderInputDataConfig
 */
export interface LanguageModelSpecForProviderInputDataConfig {
  /**
   * IAM role with access to S3 bucket.
   *
   * @schema LanguageModelSpecForProviderInputDataConfig#dataAccessRoleArn
   */
  readonly dataAccessRoleArn?: string;

  /**
   * Reference to a Role in iam to populate dataAccessRoleArn.
   *
   * @schema LanguageModelSpecForProviderInputDataConfig#dataAccessRoleArnRef
   */
  readonly dataAccessRoleArnRef?: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRef;

  /**
   * Selector for a Role in iam to populate dataAccessRoleArn.
   *
   * @schema LanguageModelSpecForProviderInputDataConfig#dataAccessRoleArnSelector
   */
  readonly dataAccessRoleArnSelector?: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelector;

  /**
   * S3 URI where training data is located.
   *
   * @schema LanguageModelSpecForProviderInputDataConfig#s3Uri
   */
  readonly s3Uri: string;

  /**
   * S3 URI where tuning data is located.
   *
   * @schema LanguageModelSpecForProviderInputDataConfig#tuningDataS3Uri
   */
  readonly tuningDataS3Uri?: string;

}

/**
 * Converts an object of type 'LanguageModelSpecForProviderInputDataConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecForProviderInputDataConfig(obj: LanguageModelSpecForProviderInputDataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataAccessRoleArn': obj.dataAccessRoleArn,
    'dataAccessRoleArnRef': toJson_LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRef(obj.dataAccessRoleArnRef),
    'dataAccessRoleArnSelector': toJson_LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelector(obj.dataAccessRoleArnSelector),
    's3Uri': obj.s3Uri,
    'tuningDataS3Uri': obj.tuningDataS3Uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LanguageModelSpecProviderConfigRefPolicy
 */
export interface LanguageModelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LanguageModelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LanguageModelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LanguageModelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LanguageModelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LanguageModelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecProviderConfigRefPolicy(obj: LanguageModelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LanguageModelSpecProviderRefPolicy
 */
export interface LanguageModelSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LanguageModelSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LanguageModelSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LanguageModelSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LanguageModelSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LanguageModelSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecProviderRefPolicy(obj: LanguageModelSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LanguageModelSpecPublishConnectionDetailsToConfigRef
 */
export interface LanguageModelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LanguageModelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LanguageModelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LanguageModelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LanguageModelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecPublishConnectionDetailsToConfigRef(obj: LanguageModelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LanguageModelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LanguageModelSpecPublishConnectionDetailsToMetadata
 */
export interface LanguageModelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LanguageModelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LanguageModelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LanguageModelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LanguageModelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecPublishConnectionDetailsToMetadata(obj: LanguageModelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate dataAccessRoleArn.
 *
 * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRef
 */
export interface LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRef#policy
   */
  readonly policy?: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicy;

}

/**
 * Converts an object of type 'LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRef(obj: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate dataAccessRoleArn.
 *
 * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelector
 */
export interface LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelector#policy
   */
  readonly policy?: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelector(obj: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LanguageModelSpecProviderConfigRefPolicyResolution
 */
export enum LanguageModelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LanguageModelSpecProviderConfigRefPolicyResolve
 */
export enum LanguageModelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LanguageModelSpecProviderRefPolicyResolution
 */
export enum LanguageModelSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LanguageModelSpecProviderRefPolicyResolve
 */
export enum LanguageModelSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LanguageModelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LanguageModelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LanguageModelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LanguageModelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LanguageModelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LanguageModelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LanguageModelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecPublishConnectionDetailsToConfigRefPolicy(obj: LanguageModelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicy
 */
export interface LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicy#resolution
   */
  readonly resolution?: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicy#resolve
   */
  readonly resolve?: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicy(obj: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicy
 */
export interface LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicy(obj: LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LanguageModelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LanguageModelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LanguageModelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LanguageModelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicyResolution
 */
export enum LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicyResolve
 */
export enum LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicyResolution
 */
export enum LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicyResolve
 */
export enum LanguageModelSpecForProviderInputDataConfigDataAccessRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Vocabulary is the Schema for the Vocabularys API.
 *
 * @schema Vocabulary
 */
export class Vocabulary extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Vocabulary"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'transcribe.aws.upbound.io/v1beta1',
    kind: 'Vocabulary',
  }

  /**
   * Renders a Kubernetes manifest for "Vocabulary".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VocabularyProps): any {
    return {
      ...Vocabulary.GVK,
      ...toJson_VocabularyProps(props),
    };
  }

  /**
   * Defines a "Vocabulary" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VocabularyProps) {
    super(scope, id, {
      ...Vocabulary.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Vocabulary.GVK,
      ...toJson_VocabularyProps(resolved),
    };
  }
}

/**
 * Vocabulary is the Schema for the Vocabularys API.
 *
 * @schema Vocabulary
 */
export interface VocabularyProps {
  /**
   * @schema Vocabulary#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VocabularySpec defines the desired state of Vocabulary
   *
   * @schema Vocabulary#spec
   */
  readonly spec: VocabularySpec;

}

/**
 * Converts an object of type 'VocabularyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyProps(obj: VocabularyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VocabularySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VocabularySpec defines the desired state of Vocabulary
 *
 * @schema VocabularySpec
 */
export interface VocabularySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VocabularySpec#deletionPolicy
   */
  readonly deletionPolicy?: VocabularySpecDeletionPolicy;

  /**
   * @schema VocabularySpec#forProvider
   */
  readonly forProvider: VocabularySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VocabularySpec#managementPolicy
   */
  readonly managementPolicy?: VocabularySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VocabularySpec#providerConfigRef
   */
  readonly providerConfigRef?: VocabularySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema VocabularySpec#providerRef
   */
  readonly providerRef?: VocabularySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VocabularySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VocabularySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VocabularySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VocabularySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VocabularySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpec(obj: VocabularySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VocabularySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_VocabularySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_VocabularySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_VocabularySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VocabularySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VocabularySpecDeletionPolicy
 */
export enum VocabularySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VocabularySpecForProvider
 */
export interface VocabularySpecForProvider {
  /**
   * The language code you selected for your vocabulary.
   *
   * @schema VocabularySpecForProvider#languageCode
   */
  readonly languageCode?: string;

  /**
   * - A list of terms to include in the vocabulary. Conflicts with vocabulary_file_uri
   *
   * @schema VocabularySpecForProvider#phrases
   */
  readonly phrases?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VocabularySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema VocabularySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The Amazon S3 location (URI) of the text file that contains your custom vocabulary.
   *
   * @schema VocabularySpecForProvider#vocabularyFileUri
   */
  readonly vocabularyFileUri?: string;

}

/**
 * Converts an object of type 'VocabularySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecForProvider(obj: VocabularySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'languageCode': obj.languageCode,
    'phrases': obj.phrases?.map(y => y),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vocabularyFileUri': obj.vocabularyFileUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VocabularySpecManagementPolicy
 */
export enum VocabularySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VocabularySpecProviderConfigRef
 */
export interface VocabularySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VocabularySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VocabularySpecProviderConfigRef#policy
   */
  readonly policy?: VocabularySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VocabularySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecProviderConfigRef(obj: VocabularySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VocabularySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema VocabularySpecProviderRef
 */
export interface VocabularySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema VocabularySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VocabularySpecProviderRef#policy
   */
  readonly policy?: VocabularySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'VocabularySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecProviderRef(obj: VocabularySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VocabularySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VocabularySpecPublishConnectionDetailsTo
 */
export interface VocabularySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VocabularySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VocabularySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VocabularySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VocabularySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VocabularySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VocabularySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecPublishConnectionDetailsTo(obj: VocabularySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VocabularySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VocabularySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VocabularySpecWriteConnectionSecretToRef
 */
export interface VocabularySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VocabularySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VocabularySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VocabularySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecWriteConnectionSecretToRef(obj: VocabularySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VocabularySpecProviderConfigRefPolicy
 */
export interface VocabularySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VocabularySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VocabularySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VocabularySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecProviderConfigRefPolicy(obj: VocabularySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VocabularySpecProviderRefPolicy
 */
export interface VocabularySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularySpecProviderRefPolicy#resolution
   */
  readonly resolution?: VocabularySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularySpecProviderRefPolicy#resolve
   */
  readonly resolve?: VocabularySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'VocabularySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecProviderRefPolicy(obj: VocabularySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VocabularySpecPublishConnectionDetailsToConfigRef
 */
export interface VocabularySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VocabularySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VocabularySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VocabularySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VocabularySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecPublishConnectionDetailsToConfigRef(obj: VocabularySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VocabularySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VocabularySpecPublishConnectionDetailsToMetadata
 */
export interface VocabularySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VocabularySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VocabularySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VocabularySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VocabularySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecPublishConnectionDetailsToMetadata(obj: VocabularySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularySpecProviderConfigRefPolicyResolution
 */
export enum VocabularySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularySpecProviderConfigRefPolicyResolve
 */
export enum VocabularySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularySpecProviderRefPolicyResolution
 */
export enum VocabularySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularySpecProviderRefPolicyResolve
 */
export enum VocabularySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VocabularySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VocabularySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VocabularySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecPublishConnectionDetailsToConfigRefPolicy(obj: VocabularySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VocabularyFilter is the Schema for the VocabularyFilters API.
 *
 * @schema VocabularyFilter
 */
export class VocabularyFilter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VocabularyFilter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'transcribe.aws.upbound.io/v1beta1',
    kind: 'VocabularyFilter',
  }

  /**
   * Renders a Kubernetes manifest for "VocabularyFilter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VocabularyFilterProps): any {
    return {
      ...VocabularyFilter.GVK,
      ...toJson_VocabularyFilterProps(props),
    };
  }

  /**
   * Defines a "VocabularyFilter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VocabularyFilterProps) {
    super(scope, id, {
      ...VocabularyFilter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VocabularyFilter.GVK,
      ...toJson_VocabularyFilterProps(resolved),
    };
  }
}

/**
 * VocabularyFilter is the Schema for the VocabularyFilters API.
 *
 * @schema VocabularyFilter
 */
export interface VocabularyFilterProps {
  /**
   * @schema VocabularyFilter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VocabularyFilterSpec defines the desired state of VocabularyFilter
   *
   * @schema VocabularyFilter#spec
   */
  readonly spec: VocabularyFilterSpec;

}

/**
 * Converts an object of type 'VocabularyFilterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterProps(obj: VocabularyFilterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VocabularyFilterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VocabularyFilterSpec defines the desired state of VocabularyFilter
 *
 * @schema VocabularyFilterSpec
 */
export interface VocabularyFilterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VocabularyFilterSpec#deletionPolicy
   */
  readonly deletionPolicy?: VocabularyFilterSpecDeletionPolicy;

  /**
   * @schema VocabularyFilterSpec#forProvider
   */
  readonly forProvider: VocabularyFilterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VocabularyFilterSpec#managementPolicy
   */
  readonly managementPolicy?: VocabularyFilterSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VocabularyFilterSpec#providerConfigRef
   */
  readonly providerConfigRef?: VocabularyFilterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema VocabularyFilterSpec#providerRef
   */
  readonly providerRef?: VocabularyFilterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VocabularyFilterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VocabularyFilterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VocabularyFilterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VocabularyFilterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VocabularyFilterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpec(obj: VocabularyFilterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VocabularyFilterSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_VocabularyFilterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_VocabularyFilterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_VocabularyFilterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VocabularyFilterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VocabularyFilterSpecDeletionPolicy
 */
export enum VocabularyFilterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VocabularyFilterSpecForProvider
 */
export interface VocabularyFilterSpecForProvider {
  /**
   * The language code you selected for your vocabulary filter. Refer to the supported languages page for accepted codes.
   *
   * @schema VocabularyFilterSpecForProvider#languageCode
   */
  readonly languageCode?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VocabularyFilterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema VocabularyFilterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The Amazon S3 location (URI) of the text file that contains your custom VocabularyFilter. Conflicts with words argument.
   *
   * @schema VocabularyFilterSpecForProvider#vocabularyFilterFileUri
   */
  readonly vocabularyFilterFileUri?: string;

  /**
   * - A list of terms to include in the vocabulary. Conflicts with vocabulary_filter_file_uri argument.
   *
   * @schema VocabularyFilterSpecForProvider#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'VocabularyFilterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpecForProvider(obj: VocabularyFilterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'languageCode': obj.languageCode,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vocabularyFilterFileUri': obj.vocabularyFilterFileUri,
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VocabularyFilterSpecManagementPolicy
 */
export enum VocabularyFilterSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VocabularyFilterSpecProviderConfigRef
 */
export interface VocabularyFilterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VocabularyFilterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VocabularyFilterSpecProviderConfigRef#policy
   */
  readonly policy?: VocabularyFilterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VocabularyFilterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpecProviderConfigRef(obj: VocabularyFilterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VocabularyFilterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema VocabularyFilterSpecProviderRef
 */
export interface VocabularyFilterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema VocabularyFilterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VocabularyFilterSpecProviderRef#policy
   */
  readonly policy?: VocabularyFilterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'VocabularyFilterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpecProviderRef(obj: VocabularyFilterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VocabularyFilterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VocabularyFilterSpecPublishConnectionDetailsTo
 */
export interface VocabularyFilterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VocabularyFilterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VocabularyFilterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VocabularyFilterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VocabularyFilterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VocabularyFilterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VocabularyFilterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpecPublishConnectionDetailsTo(obj: VocabularyFilterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VocabularyFilterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VocabularyFilterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VocabularyFilterSpecWriteConnectionSecretToRef
 */
export interface VocabularyFilterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VocabularyFilterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VocabularyFilterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VocabularyFilterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpecWriteConnectionSecretToRef(obj: VocabularyFilterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VocabularyFilterSpecProviderConfigRefPolicy
 */
export interface VocabularyFilterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularyFilterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VocabularyFilterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularyFilterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VocabularyFilterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VocabularyFilterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpecProviderConfigRefPolicy(obj: VocabularyFilterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VocabularyFilterSpecProviderRefPolicy
 */
export interface VocabularyFilterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularyFilterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: VocabularyFilterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularyFilterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: VocabularyFilterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'VocabularyFilterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpecProviderRefPolicy(obj: VocabularyFilterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VocabularyFilterSpecPublishConnectionDetailsToConfigRef
 */
export interface VocabularyFilterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VocabularyFilterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VocabularyFilterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VocabularyFilterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpecPublishConnectionDetailsToConfigRef(obj: VocabularyFilterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VocabularyFilterSpecPublishConnectionDetailsToMetadata
 */
export interface VocabularyFilterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VocabularyFilterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VocabularyFilterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VocabularyFilterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VocabularyFilterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpecPublishConnectionDetailsToMetadata(obj: VocabularyFilterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularyFilterSpecProviderConfigRefPolicyResolution
 */
export enum VocabularyFilterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularyFilterSpecProviderConfigRefPolicyResolve
 */
export enum VocabularyFilterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularyFilterSpecProviderRefPolicyResolution
 */
export enum VocabularyFilterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularyFilterSpecProviderRefPolicyResolve
 */
export enum VocabularyFilterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicy(obj: VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VocabularyFilterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

