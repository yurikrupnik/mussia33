// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Asset is the Schema for the Assets API. The Dataplex Asset resource
 *
 * @schema Asset
 */
export class Asset extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Asset"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dataplex.gcp.upbound.io/v1beta1',
    kind: 'Asset',
  }

  /**
   * Renders a Kubernetes manifest for "Asset".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AssetProps): any {
    return {
      ...Asset.GVK,
      ...toJson_AssetProps(props),
    };
  }

  /**
   * Defines a "Asset" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AssetProps) {
    super(scope, id, {
      ...Asset.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Asset.GVK,
      ...toJson_AssetProps(resolved),
    };
  }
}

/**
 * Asset is the Schema for the Assets API. The Dataplex Asset resource
 *
 * @schema Asset
 */
export interface AssetProps {
  /**
   * @schema Asset#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AssetSpec defines the desired state of Asset
   *
   * @schema Asset#spec
   */
  readonly spec: AssetSpec;

}

/**
 * Converts an object of type 'AssetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetProps(obj: AssetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AssetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AssetSpec defines the desired state of Asset
 *
 * @schema AssetSpec
 */
export interface AssetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AssetSpec#deletionPolicy
   */
  readonly deletionPolicy?: AssetSpecDeletionPolicy;

  /**
   * @schema AssetSpec#forProvider
   */
  readonly forProvider: AssetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AssetSpec#managementPolicy
   */
  readonly managementPolicy?: AssetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AssetSpec#providerConfigRef
   */
  readonly providerConfigRef?: AssetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AssetSpec#providerRef
   */
  readonly providerRef?: AssetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AssetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AssetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AssetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AssetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AssetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpec(obj: AssetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AssetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AssetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AssetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AssetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AssetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AssetSpecDeletionPolicy
 */
export enum AssetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AssetSpecForProvider
 */
export interface AssetSpecForProvider {
  /**
   * The zone for the resource
   *
   * @schema AssetSpecForProvider#dataplexZone
   */
  readonly dataplexZone?: string;

  /**
   * Reference to a Zone in dataplex to populate dataplexZone.
   *
   * @schema AssetSpecForProvider#dataplexZoneRef
   */
  readonly dataplexZoneRef?: AssetSpecForProviderDataplexZoneRef;

  /**
   * Selector for a Zone in dataplex to populate dataplexZone.
   *
   * @schema AssetSpecForProvider#dataplexZoneSelector
   */
  readonly dataplexZoneSelector?: AssetSpecForProviderDataplexZoneSelector;

  /**
   * Optional. Description of the asset.
   *
   * @schema AssetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Required. Specification of the discovery feature applied to data referenced by this asset. When this spec is left unset, the asset will use the spec set on the parent zone.
   *
   * @schema AssetSpecForProvider#discoverySpec
   */
  readonly discoverySpec?: AssetSpecForProviderDiscoverySpec[];

  /**
   * Optional. User friendly display name.
   *
   * @schema AssetSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Optional. User defined labels for the asset.
   *
   * @schema AssetSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The lake for the resource
   *
   * @schema AssetSpecForProvider#lake
   */
  readonly lake?: string;

  /**
   * Reference to a Lake in dataplex to populate lake.
   *
   * @schema AssetSpecForProvider#lakeRef
   */
  readonly lakeRef?: AssetSpecForProviderLakeRef;

  /**
   * Selector for a Lake in dataplex to populate lake.
   *
   * @schema AssetSpecForProvider#lakeSelector
   */
  readonly lakeSelector?: AssetSpecForProviderLakeSelector;

  /**
   * The location for the resource
   *
   * @schema AssetSpecForProvider#location
   */
  readonly location: string;

  /**
   * The project for the resource
   *
   * @schema AssetSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Required. Immutable. Specification of the resource that is referenced by this asset.
   *
   * @schema AssetSpecForProvider#resourceSpec
   */
  readonly resourceSpec?: AssetSpecForProviderResourceSpec[];

}

/**
 * Converts an object of type 'AssetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProvider(obj: AssetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataplexZone': obj.dataplexZone,
    'dataplexZoneRef': toJson_AssetSpecForProviderDataplexZoneRef(obj.dataplexZoneRef),
    'dataplexZoneSelector': toJson_AssetSpecForProviderDataplexZoneSelector(obj.dataplexZoneSelector),
    'description': obj.description,
    'discoverySpec': obj.discoverySpec?.map(y => toJson_AssetSpecForProviderDiscoverySpec(y)),
    'displayName': obj.displayName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lake': obj.lake,
    'lakeRef': toJson_AssetSpecForProviderLakeRef(obj.lakeRef),
    'lakeSelector': toJson_AssetSpecForProviderLakeSelector(obj.lakeSelector),
    'location': obj.location,
    'project': obj.project,
    'resourceSpec': obj.resourceSpec?.map(y => toJson_AssetSpecForProviderResourceSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AssetSpecManagementPolicy
 */
export enum AssetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AssetSpecProviderConfigRef
 */
export interface AssetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssetSpecProviderConfigRef#policy
   */
  readonly policy?: AssetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AssetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecProviderConfigRef(obj: AssetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AssetSpecProviderRef
 */
export interface AssetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssetSpecProviderRef#policy
   */
  readonly policy?: AssetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AssetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecProviderRef(obj: AssetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AssetSpecPublishConnectionDetailsTo
 */
export interface AssetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AssetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AssetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AssetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AssetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AssetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AssetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecPublishConnectionDetailsTo(obj: AssetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AssetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AssetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AssetSpecWriteConnectionSecretToRef
 */
export interface AssetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AssetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AssetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AssetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecWriteConnectionSecretToRef(obj: AssetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in dataplex to populate dataplexZone.
 *
 * @schema AssetSpecForProviderDataplexZoneRef
 */
export interface AssetSpecForProviderDataplexZoneRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssetSpecForProviderDataplexZoneRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssetSpecForProviderDataplexZoneRef#policy
   */
  readonly policy?: AssetSpecForProviderDataplexZoneRefPolicy;

}

/**
 * Converts an object of type 'AssetSpecForProviderDataplexZoneRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderDataplexZoneRef(obj: AssetSpecForProviderDataplexZoneRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssetSpecForProviderDataplexZoneRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in dataplex to populate dataplexZone.
 *
 * @schema AssetSpecForProviderDataplexZoneSelector
 */
export interface AssetSpecForProviderDataplexZoneSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AssetSpecForProviderDataplexZoneSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AssetSpecForProviderDataplexZoneSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AssetSpecForProviderDataplexZoneSelector#policy
   */
  readonly policy?: AssetSpecForProviderDataplexZoneSelectorPolicy;

}

/**
 * Converts an object of type 'AssetSpecForProviderDataplexZoneSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderDataplexZoneSelector(obj: AssetSpecForProviderDataplexZoneSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AssetSpecForProviderDataplexZoneSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AssetSpecForProviderDiscoverySpec
 */
export interface AssetSpecForProviderDiscoverySpec {
  /**
   * Optional. Configuration for CSV data.
   *
   * @schema AssetSpecForProviderDiscoverySpec#csvOptions
   */
  readonly csvOptions?: AssetSpecForProviderDiscoverySpecCsvOptions[];

  /**
   * Required. Whether discovery is enabled.
   *
   * @schema AssetSpecForProviderDiscoverySpec#enabled
   */
  readonly enabled: boolean;

  /**
   * Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
   *
   * @schema AssetSpecForProviderDiscoverySpec#excludePatterns
   */
  readonly excludePatterns?: string[];

  /**
   * Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
   *
   * @schema AssetSpecForProviderDiscoverySpec#includePatterns
   */
  readonly includePatterns?: string[];

  /**
   * Optional. Configuration for Json data.
   *
   * @schema AssetSpecForProviderDiscoverySpec#jsonOptions
   */
  readonly jsonOptions?: AssetSpecForProviderDiscoverySpecJsonOptions[];

  /**
   * Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
   *
   * @schema AssetSpecForProviderDiscoverySpec#schedule
   */
  readonly schedule?: string;

}

/**
 * Converts an object of type 'AssetSpecForProviderDiscoverySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderDiscoverySpec(obj: AssetSpecForProviderDiscoverySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvOptions': obj.csvOptions?.map(y => toJson_AssetSpecForProviderDiscoverySpecCsvOptions(y)),
    'enabled': obj.enabled,
    'excludePatterns': obj.excludePatterns?.map(y => y),
    'includePatterns': obj.includePatterns?.map(y => y),
    'jsonOptions': obj.jsonOptions?.map(y => toJson_AssetSpecForProviderDiscoverySpecJsonOptions(y)),
    'schedule': obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Lake in dataplex to populate lake.
 *
 * @schema AssetSpecForProviderLakeRef
 */
export interface AssetSpecForProviderLakeRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssetSpecForProviderLakeRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssetSpecForProviderLakeRef#policy
   */
  readonly policy?: AssetSpecForProviderLakeRefPolicy;

}

/**
 * Converts an object of type 'AssetSpecForProviderLakeRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderLakeRef(obj: AssetSpecForProviderLakeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssetSpecForProviderLakeRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Lake in dataplex to populate lake.
 *
 * @schema AssetSpecForProviderLakeSelector
 */
export interface AssetSpecForProviderLakeSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AssetSpecForProviderLakeSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AssetSpecForProviderLakeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AssetSpecForProviderLakeSelector#policy
   */
  readonly policy?: AssetSpecForProviderLakeSelectorPolicy;

}

/**
 * Converts an object of type 'AssetSpecForProviderLakeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderLakeSelector(obj: AssetSpecForProviderLakeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AssetSpecForProviderLakeSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AssetSpecForProviderResourceSpec
 */
export interface AssetSpecForProviderResourceSpec {
  /**
   * Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: projects/{project_number}/buckets/{bucket_id} projects/{project_number}/datasets/{dataset_id}
   *
   * @schema AssetSpecForProviderResourceSpec#name
   */
  readonly name?: string;

  /**
   * Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET
   *
   * @schema AssetSpecForProviderResourceSpec#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'AssetSpecForProviderResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderResourceSpec(obj: AssetSpecForProviderResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssetSpecProviderConfigRefPolicy
 */
export interface AssetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AssetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AssetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AssetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecProviderConfigRefPolicy(obj: AssetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssetSpecProviderRefPolicy
 */
export interface AssetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AssetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AssetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AssetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecProviderRefPolicy(obj: AssetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AssetSpecPublishConnectionDetailsToConfigRef
 */
export interface AssetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AssetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AssetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecPublishConnectionDetailsToConfigRef(obj: AssetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AssetSpecPublishConnectionDetailsToMetadata
 */
export interface AssetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AssetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AssetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AssetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AssetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecPublishConnectionDetailsToMetadata(obj: AssetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssetSpecForProviderDataplexZoneRefPolicy
 */
export interface AssetSpecForProviderDataplexZoneRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssetSpecForProviderDataplexZoneRefPolicy#resolution
   */
  readonly resolution?: AssetSpecForProviderDataplexZoneRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssetSpecForProviderDataplexZoneRefPolicy#resolve
   */
  readonly resolve?: AssetSpecForProviderDataplexZoneRefPolicyResolve;

}

/**
 * Converts an object of type 'AssetSpecForProviderDataplexZoneRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderDataplexZoneRefPolicy(obj: AssetSpecForProviderDataplexZoneRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AssetSpecForProviderDataplexZoneSelectorPolicy
 */
export interface AssetSpecForProviderDataplexZoneSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssetSpecForProviderDataplexZoneSelectorPolicy#resolution
   */
  readonly resolution?: AssetSpecForProviderDataplexZoneSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssetSpecForProviderDataplexZoneSelectorPolicy#resolve
   */
  readonly resolve?: AssetSpecForProviderDataplexZoneSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AssetSpecForProviderDataplexZoneSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderDataplexZoneSelectorPolicy(obj: AssetSpecForProviderDataplexZoneSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AssetSpecForProviderDiscoverySpecCsvOptions
 */
export interface AssetSpecForProviderDiscoverySpecCsvOptions {
  /**
   * Optional. The delimiter being used to separate values. This defaults to ','.
   *
   * @schema AssetSpecForProviderDiscoverySpecCsvOptions#delimiter
   */
  readonly delimiter?: string;

  /**
   * Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
   *
   * @schema AssetSpecForProviderDiscoverySpecCsvOptions#disableTypeInference
   */
  readonly disableTypeInference?: boolean;

  /**
   * Optional. The character encoding of the data. The default is UTF-8.
   *
   * @schema AssetSpecForProviderDiscoverySpecCsvOptions#encoding
   */
  readonly encoding?: string;

  /**
   * Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
   *
   * @schema AssetSpecForProviderDiscoverySpecCsvOptions#headerRows
   */
  readonly headerRows?: number;

}

/**
 * Converts an object of type 'AssetSpecForProviderDiscoverySpecCsvOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderDiscoverySpecCsvOptions(obj: AssetSpecForProviderDiscoverySpecCsvOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'delimiter': obj.delimiter,
    'disableTypeInference': obj.disableTypeInference,
    'encoding': obj.encoding,
    'headerRows': obj.headerRows,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AssetSpecForProviderDiscoverySpecJsonOptions
 */
export interface AssetSpecForProviderDiscoverySpecJsonOptions {
  /**
   * Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
   *
   * @schema AssetSpecForProviderDiscoverySpecJsonOptions#disableTypeInference
   */
  readonly disableTypeInference?: boolean;

  /**
   * Optional. The character encoding of the data. The default is UTF-8.
   *
   * @schema AssetSpecForProviderDiscoverySpecJsonOptions#encoding
   */
  readonly encoding?: string;

}

/**
 * Converts an object of type 'AssetSpecForProviderDiscoverySpecJsonOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderDiscoverySpecJsonOptions(obj: AssetSpecForProviderDiscoverySpecJsonOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableTypeInference': obj.disableTypeInference,
    'encoding': obj.encoding,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssetSpecForProviderLakeRefPolicy
 */
export interface AssetSpecForProviderLakeRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssetSpecForProviderLakeRefPolicy#resolution
   */
  readonly resolution?: AssetSpecForProviderLakeRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssetSpecForProviderLakeRefPolicy#resolve
   */
  readonly resolve?: AssetSpecForProviderLakeRefPolicyResolve;

}

/**
 * Converts an object of type 'AssetSpecForProviderLakeRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderLakeRefPolicy(obj: AssetSpecForProviderLakeRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AssetSpecForProviderLakeSelectorPolicy
 */
export interface AssetSpecForProviderLakeSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssetSpecForProviderLakeSelectorPolicy#resolution
   */
  readonly resolution?: AssetSpecForProviderLakeSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssetSpecForProviderLakeSelectorPolicy#resolve
   */
  readonly resolve?: AssetSpecForProviderLakeSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AssetSpecForProviderLakeSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecForProviderLakeSelectorPolicy(obj: AssetSpecForProviderLakeSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssetSpecProviderConfigRefPolicyResolution
 */
export enum AssetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssetSpecProviderConfigRefPolicyResolve
 */
export enum AssetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssetSpecProviderRefPolicyResolution
 */
export enum AssetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssetSpecProviderRefPolicyResolve
 */
export enum AssetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AssetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AssetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AssetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AssetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AssetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssetSpecPublishConnectionDetailsToConfigRefPolicy(obj: AssetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssetSpecForProviderDataplexZoneRefPolicyResolution
 */
export enum AssetSpecForProviderDataplexZoneRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssetSpecForProviderDataplexZoneRefPolicyResolve
 */
export enum AssetSpecForProviderDataplexZoneRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssetSpecForProviderDataplexZoneSelectorPolicyResolution
 */
export enum AssetSpecForProviderDataplexZoneSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssetSpecForProviderDataplexZoneSelectorPolicyResolve
 */
export enum AssetSpecForProviderDataplexZoneSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssetSpecForProviderLakeRefPolicyResolution
 */
export enum AssetSpecForProviderLakeRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssetSpecForProviderLakeRefPolicyResolve
 */
export enum AssetSpecForProviderLakeRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssetSpecForProviderLakeSelectorPolicyResolution
 */
export enum AssetSpecForProviderLakeSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssetSpecForProviderLakeSelectorPolicyResolve
 */
export enum AssetSpecForProviderLakeSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AssetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AssetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Lake is the Schema for the Lakes API. The Dataplex Lake resource
 *
 * @schema Lake
 */
export class Lake extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Lake"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dataplex.gcp.upbound.io/v1beta1',
    kind: 'Lake',
  }

  /**
   * Renders a Kubernetes manifest for "Lake".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LakeProps): any {
    return {
      ...Lake.GVK,
      ...toJson_LakeProps(props),
    };
  }

  /**
   * Defines a "Lake" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LakeProps) {
    super(scope, id, {
      ...Lake.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Lake.GVK,
      ...toJson_LakeProps(resolved),
    };
  }
}

/**
 * Lake is the Schema for the Lakes API. The Dataplex Lake resource
 *
 * @schema Lake
 */
export interface LakeProps {
  /**
   * @schema Lake#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LakeSpec defines the desired state of Lake
   *
   * @schema Lake#spec
   */
  readonly spec: LakeSpec;

}

/**
 * Converts an object of type 'LakeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeProps(obj: LakeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LakeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LakeSpec defines the desired state of Lake
 *
 * @schema LakeSpec
 */
export interface LakeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LakeSpec#deletionPolicy
   */
  readonly deletionPolicy?: LakeSpecDeletionPolicy;

  /**
   * @schema LakeSpec#forProvider
   */
  readonly forProvider: LakeSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LakeSpec#managementPolicy
   */
  readonly managementPolicy?: LakeSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LakeSpec#providerConfigRef
   */
  readonly providerConfigRef?: LakeSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LakeSpec#providerRef
   */
  readonly providerRef?: LakeSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LakeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LakeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LakeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LakeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LakeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpec(obj: LakeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LakeSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LakeSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LakeSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LakeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LakeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LakeSpecDeletionPolicy
 */
export enum LakeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LakeSpecForProvider
 */
export interface LakeSpecForProvider {
  /**
   * Optional. Description of the lake.
   *
   * @schema LakeSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Optional. User friendly display name.
   *
   * @schema LakeSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Optional. User-defined labels for the lake.
   *
   * @schema LakeSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The location for the resource
   *
   * @schema LakeSpecForProvider#location
   */
  readonly location: string;

  /**
   * Optional. Settings to manage lake and Dataproc Metastore service instance association.
   *
   * @schema LakeSpecForProvider#metastore
   */
  readonly metastore?: LakeSpecForProviderMetastore[];

  /**
   * The project for the resource
   *
   * @schema LakeSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'LakeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecForProvider(obj: LakeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'metastore': obj.metastore?.map(y => toJson_LakeSpecForProviderMetastore(y)),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LakeSpecManagementPolicy
 */
export enum LakeSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LakeSpecProviderConfigRef
 */
export interface LakeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LakeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LakeSpecProviderConfigRef#policy
   */
  readonly policy?: LakeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LakeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecProviderConfigRef(obj: LakeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LakeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LakeSpecProviderRef
 */
export interface LakeSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LakeSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LakeSpecProviderRef#policy
   */
  readonly policy?: LakeSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LakeSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecProviderRef(obj: LakeSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LakeSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LakeSpecPublishConnectionDetailsTo
 */
export interface LakeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LakeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LakeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LakeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LakeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LakeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LakeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecPublishConnectionDetailsTo(obj: LakeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LakeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LakeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LakeSpecWriteConnectionSecretToRef
 */
export interface LakeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LakeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LakeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LakeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecWriteConnectionSecretToRef(obj: LakeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LakeSpecForProviderMetastore
 */
export interface LakeSpecForProviderMetastore {
  /**
   * Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: projects/{project_id}/locations/{location_id}/services/{service_id}
   *
   * @schema LakeSpecForProviderMetastore#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'LakeSpecForProviderMetastore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecForProviderMetastore(obj: LakeSpecForProviderMetastore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LakeSpecProviderConfigRefPolicy
 */
export interface LakeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LakeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LakeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LakeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LakeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LakeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecProviderConfigRefPolicy(obj: LakeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LakeSpecProviderRefPolicy
 */
export interface LakeSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LakeSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LakeSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LakeSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LakeSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LakeSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecProviderRefPolicy(obj: LakeSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LakeSpecPublishConnectionDetailsToConfigRef
 */
export interface LakeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LakeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LakeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LakeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LakeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecPublishConnectionDetailsToConfigRef(obj: LakeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LakeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LakeSpecPublishConnectionDetailsToMetadata
 */
export interface LakeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LakeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LakeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LakeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LakeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecPublishConnectionDetailsToMetadata(obj: LakeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LakeSpecProviderConfigRefPolicyResolution
 */
export enum LakeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LakeSpecProviderConfigRefPolicyResolve
 */
export enum LakeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LakeSpecProviderRefPolicyResolution
 */
export enum LakeSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LakeSpecProviderRefPolicyResolve
 */
export enum LakeSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LakeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LakeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LakeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LakeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LakeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LakeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LakeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LakeSpecPublishConnectionDetailsToConfigRefPolicy(obj: LakeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LakeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LakeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LakeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LakeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Zone is the Schema for the Zones API. The Dataplex Zone resource
 *
 * @schema Zone
 */
export class Zone extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Zone"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dataplex.gcp.upbound.io/v1beta1',
    kind: 'Zone',
  }

  /**
   * Renders a Kubernetes manifest for "Zone".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ZoneProps): any {
    return {
      ...Zone.GVK,
      ...toJson_ZoneProps(props),
    };
  }

  /**
   * Defines a "Zone" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ZoneProps) {
    super(scope, id, {
      ...Zone.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Zone.GVK,
      ...toJson_ZoneProps(resolved),
    };
  }
}

/**
 * Zone is the Schema for the Zones API. The Dataplex Zone resource
 *
 * @schema Zone
 */
export interface ZoneProps {
  /**
   * @schema Zone#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ZoneSpec defines the desired state of Zone
   *
   * @schema Zone#spec
   */
  readonly spec: ZoneSpec;

}

/**
 * Converts an object of type 'ZoneProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneProps(obj: ZoneProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ZoneSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ZoneSpec defines the desired state of Zone
 *
 * @schema ZoneSpec
 */
export interface ZoneSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ZoneSpec#deletionPolicy
   */
  readonly deletionPolicy?: ZoneSpecDeletionPolicy;

  /**
   * @schema ZoneSpec#forProvider
   */
  readonly forProvider: ZoneSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ZoneSpec#managementPolicy
   */
  readonly managementPolicy?: ZoneSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ZoneSpec#providerConfigRef
   */
  readonly providerConfigRef?: ZoneSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ZoneSpec#providerRef
   */
  readonly providerRef?: ZoneSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ZoneSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ZoneSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ZoneSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ZoneSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ZoneSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpec(obj: ZoneSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ZoneSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ZoneSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ZoneSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ZoneSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ZoneSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ZoneSpecDeletionPolicy
 */
export enum ZoneSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ZoneSpecForProvider
 */
export interface ZoneSpecForProvider {
  /**
   * Optional. Description of the zone.
   *
   * @schema ZoneSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Required. Specification of the discovery feature applied to data in this zone.
   *
   * @schema ZoneSpecForProvider#discoverySpec
   */
  readonly discoverySpec?: ZoneSpecForProviderDiscoverySpec[];

  /**
   * Optional. User friendly display name.
   *
   * @schema ZoneSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Optional. User defined labels for the zone.
   *
   * @schema ZoneSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The lake for the resource
   *
   * @schema ZoneSpecForProvider#lake
   */
  readonly lake?: string;

  /**
   * Reference to a Lake in dataplex to populate lake.
   *
   * @schema ZoneSpecForProvider#lakeRef
   */
  readonly lakeRef?: ZoneSpecForProviderLakeRef;

  /**
   * Selector for a Lake in dataplex to populate lake.
   *
   * @schema ZoneSpecForProvider#lakeSelector
   */
  readonly lakeSelector?: ZoneSpecForProviderLakeSelector;

  /**
   * The location for the resource
   *
   * @schema ZoneSpecForProvider#location
   */
  readonly location: string;

  /**
   * The project for the resource
   *
   * @schema ZoneSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Required. Immutable. Specification of the resources that are referenced by the assets within this zone.
   *
   * @schema ZoneSpecForProvider#resourceSpec
   */
  readonly resourceSpec?: ZoneSpecForProviderResourceSpec[];

  /**
   * Required. Immutable. The type of the zone. Possible values: TYPE_UNSPECIFIED, RAW, CURATED
   *
   * @schema ZoneSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ZoneSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProvider(obj: ZoneSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'discoverySpec': obj.discoverySpec?.map(y => toJson_ZoneSpecForProviderDiscoverySpec(y)),
    'displayName': obj.displayName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lake': obj.lake,
    'lakeRef': toJson_ZoneSpecForProviderLakeRef(obj.lakeRef),
    'lakeSelector': toJson_ZoneSpecForProviderLakeSelector(obj.lakeSelector),
    'location': obj.location,
    'project': obj.project,
    'resourceSpec': obj.resourceSpec?.map(y => toJson_ZoneSpecForProviderResourceSpec(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ZoneSpecManagementPolicy
 */
export enum ZoneSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ZoneSpecProviderConfigRef
 */
export interface ZoneSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecProviderConfigRef#policy
   */
  readonly policy?: ZoneSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecProviderConfigRef(obj: ZoneSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ZoneSpecProviderRef
 */
export interface ZoneSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecProviderRef#policy
   */
  readonly policy?: ZoneSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecProviderRef(obj: ZoneSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ZoneSpecPublishConnectionDetailsTo
 */
export interface ZoneSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ZoneSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ZoneSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ZoneSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ZoneSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ZoneSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsTo(obj: ZoneSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ZoneSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ZoneSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ZoneSpecWriteConnectionSecretToRef
 */
export interface ZoneSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ZoneSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ZoneSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ZoneSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecWriteConnectionSecretToRef(obj: ZoneSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ZoneSpecForProviderDiscoverySpec
 */
export interface ZoneSpecForProviderDiscoverySpec {
  /**
   * Optional. Configuration for CSV data.
   *
   * @schema ZoneSpecForProviderDiscoverySpec#csvOptions
   */
  readonly csvOptions?: ZoneSpecForProviderDiscoverySpecCsvOptions[];

  /**
   * Required. Whether discovery is enabled.
   *
   * @schema ZoneSpecForProviderDiscoverySpec#enabled
   */
  readonly enabled: boolean;

  /**
   * Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
   *
   * @schema ZoneSpecForProviderDiscoverySpec#excludePatterns
   */
  readonly excludePatterns?: string[];

  /**
   * Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
   *
   * @schema ZoneSpecForProviderDiscoverySpec#includePatterns
   */
  readonly includePatterns?: string[];

  /**
   * Optional. Configuration for Json data.
   *
   * @schema ZoneSpecForProviderDiscoverySpec#jsonOptions
   */
  readonly jsonOptions?: ZoneSpecForProviderDiscoverySpecJsonOptions[];

  /**
   * Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
   *
   * @schema ZoneSpecForProviderDiscoverySpec#schedule
   */
  readonly schedule?: string;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDiscoverySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDiscoverySpec(obj: ZoneSpecForProviderDiscoverySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvOptions': obj.csvOptions?.map(y => toJson_ZoneSpecForProviderDiscoverySpecCsvOptions(y)),
    'enabled': obj.enabled,
    'excludePatterns': obj.excludePatterns?.map(y => y),
    'includePatterns': obj.includePatterns?.map(y => y),
    'jsonOptions': obj.jsonOptions?.map(y => toJson_ZoneSpecForProviderDiscoverySpecJsonOptions(y)),
    'schedule': obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Lake in dataplex to populate lake.
 *
 * @schema ZoneSpecForProviderLakeRef
 */
export interface ZoneSpecForProviderLakeRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecForProviderLakeRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecForProviderLakeRef#policy
   */
  readonly policy?: ZoneSpecForProviderLakeRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecForProviderLakeRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderLakeRef(obj: ZoneSpecForProviderLakeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecForProviderLakeRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Lake in dataplex to populate lake.
 *
 * @schema ZoneSpecForProviderLakeSelector
 */
export interface ZoneSpecForProviderLakeSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ZoneSpecForProviderLakeSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneSpecForProviderLakeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneSpecForProviderLakeSelector#policy
   */
  readonly policy?: ZoneSpecForProviderLakeSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneSpecForProviderLakeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderLakeSelector(obj: ZoneSpecForProviderLakeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneSpecForProviderLakeSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ZoneSpecForProviderResourceSpec
 */
export interface ZoneSpecForProviderResourceSpec {
  /**
   * Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION
   *
   * @schema ZoneSpecForProviderResourceSpec#locationType
   */
  readonly locationType: string;

}

/**
 * Converts an object of type 'ZoneSpecForProviderResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderResourceSpec(obj: ZoneSpecForProviderResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'locationType': obj.locationType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecProviderConfigRefPolicy
 */
export interface ZoneSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecProviderConfigRefPolicy(obj: ZoneSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecProviderRefPolicy
 */
export interface ZoneSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecProviderRefPolicy(obj: ZoneSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRef
 */
export interface ZoneSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ZoneSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsToConfigRef(obj: ZoneSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ZoneSpecPublishConnectionDetailsToMetadata
 */
export interface ZoneSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ZoneSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ZoneSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ZoneSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsToMetadata(obj: ZoneSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ZoneSpecForProviderDiscoverySpecCsvOptions
 */
export interface ZoneSpecForProviderDiscoverySpecCsvOptions {
  /**
   * Optional. The delimiter being used to separate values. This defaults to ','.
   *
   * @schema ZoneSpecForProviderDiscoverySpecCsvOptions#delimiter
   */
  readonly delimiter?: string;

  /**
   * Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
   *
   * @schema ZoneSpecForProviderDiscoverySpecCsvOptions#disableTypeInference
   */
  readonly disableTypeInference?: boolean;

  /**
   * Optional. The character encoding of the data. The default is UTF-8.
   *
   * @schema ZoneSpecForProviderDiscoverySpecCsvOptions#encoding
   */
  readonly encoding?: string;

  /**
   * Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
   *
   * @schema ZoneSpecForProviderDiscoverySpecCsvOptions#headerRows
   */
  readonly headerRows?: number;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDiscoverySpecCsvOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDiscoverySpecCsvOptions(obj: ZoneSpecForProviderDiscoverySpecCsvOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'delimiter': obj.delimiter,
    'disableTypeInference': obj.disableTypeInference,
    'encoding': obj.encoding,
    'headerRows': obj.headerRows,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ZoneSpecForProviderDiscoverySpecJsonOptions
 */
export interface ZoneSpecForProviderDiscoverySpecJsonOptions {
  /**
   * Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
   *
   * @schema ZoneSpecForProviderDiscoverySpecJsonOptions#disableTypeInference
   */
  readonly disableTypeInference?: boolean;

  /**
   * Optional. The character encoding of the data. The default is UTF-8.
   *
   * @schema ZoneSpecForProviderDiscoverySpecJsonOptions#encoding
   */
  readonly encoding?: string;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDiscoverySpecJsonOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDiscoverySpecJsonOptions(obj: ZoneSpecForProviderDiscoverySpecJsonOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableTypeInference': obj.disableTypeInference,
    'encoding': obj.encoding,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecForProviderLakeRefPolicy
 */
export interface ZoneSpecForProviderLakeRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecForProviderLakeRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecForProviderLakeRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecForProviderLakeRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecForProviderLakeRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecForProviderLakeRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderLakeRefPolicy(obj: ZoneSpecForProviderLakeRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneSpecForProviderLakeSelectorPolicy
 */
export interface ZoneSpecForProviderLakeSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecForProviderLakeSelectorPolicy#resolution
   */
  readonly resolution?: ZoneSpecForProviderLakeSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecForProviderLakeSelectorPolicy#resolve
   */
  readonly resolve?: ZoneSpecForProviderLakeSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecForProviderLakeSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderLakeSelectorPolicy(obj: ZoneSpecForProviderLakeSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecProviderConfigRefPolicyResolution
 */
export enum ZoneSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecProviderConfigRefPolicyResolve
 */
export enum ZoneSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecProviderRefPolicyResolution
 */
export enum ZoneSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecProviderRefPolicyResolve
 */
export enum ZoneSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ZoneSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsToConfigRefPolicy(obj: ZoneSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecForProviderLakeRefPolicyResolution
 */
export enum ZoneSpecForProviderLakeRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecForProviderLakeRefPolicyResolve
 */
export enum ZoneSpecForProviderLakeRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecForProviderLakeSelectorPolicyResolution
 */
export enum ZoneSpecForProviderLakeSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecForProviderLakeSelectorPolicyResolve
 */
export enum ZoneSpecForProviderLakeSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

