// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Schedule is the Schema for the Schedules API. Provides an EventBridge Scheduler Schedule resource.
 *
 * @schema Schedule
 */
export class Schedule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Schedule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'scheduler.aws.upbound.io/v1beta1',
    kind: 'Schedule',
  }

  /**
   * Renders a Kubernetes manifest for "Schedule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScheduleProps): any {
    return {
      ...Schedule.GVK,
      ...toJson_ScheduleProps(props),
    };
  }

  /**
   * Defines a "Schedule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScheduleProps) {
    super(scope, id, {
      ...Schedule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Schedule.GVK,
      ...toJson_ScheduleProps(resolved),
    };
  }
}

/**
 * Schedule is the Schema for the Schedules API. Provides an EventBridge Scheduler Schedule resource.
 *
 * @schema Schedule
 */
export interface ScheduleProps {
  /**
   * @schema Schedule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScheduleSpec defines the desired state of Schedule
   *
   * @schema Schedule#spec
   */
  readonly spec: ScheduleSpec;

}

/**
 * Converts an object of type 'ScheduleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleProps(obj: ScheduleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScheduleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScheduleSpec defines the desired state of Schedule
 *
 * @schema ScheduleSpec
 */
export interface ScheduleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScheduleSpec#deletionPolicy
   */
  readonly deletionPolicy?: ScheduleSpecDeletionPolicy;

  /**
   * @schema ScheduleSpec#forProvider
   */
  readonly forProvider: ScheduleSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ScheduleSpec#initProvider
   */
  readonly initProvider?: ScheduleSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ScheduleSpec#managementPolicies
   */
  readonly managementPolicies?: ScheduleSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ScheduleSpec#providerConfigRef
   */
  readonly providerConfigRef?: ScheduleSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ScheduleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ScheduleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ScheduleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ScheduleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ScheduleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpec(obj: ScheduleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ScheduleSpecForProvider(obj.forProvider),
    'initProvider': toJson_ScheduleSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ScheduleSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ScheduleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ScheduleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScheduleSpecDeletionPolicy
 */
export enum ScheduleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ScheduleSpecForProvider
 */
export interface ScheduleSpecForProvider {
  /**
   * Brief description of the schedule.
   *
   * @schema ScheduleSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the end date you specify. EventBridge Scheduler ignores the end date for one-time schedules. Example: 2030-01-01T01:00:00Z.
   *
   * @schema ScheduleSpecForProvider#endDate
   */
  readonly endDate?: string;

  /**
   * Configures a time window during which EventBridge Scheduler invokes the schedule. Detailed below.
   *
   * @schema ScheduleSpecForProvider#flexibleTimeWindow
   */
  readonly flexibleTimeWindow?: ScheduleSpecForProviderFlexibleTimeWindow[];

  /**
   * Name of the schedule group to associate with this schedule. When omitted, the default schedule group is used.
   *
   * @schema ScheduleSpecForProvider#groupName
   */
  readonly groupName?: string;

  /**
   * ARN for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
   *
   * @schema ScheduleSpecForProvider#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema ScheduleSpecForProvider#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: ScheduleSpecForProviderKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema ScheduleSpecForProvider#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: ScheduleSpecForProviderKmsKeyArnSelector;

  /**
   * Name of the schedule. Conflicts with name_prefix.
   *
   * @schema ScheduleSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ScheduleSpecForProvider#region
   */
  readonly region: string;

  /**
   * Defines when the schedule runs. Read more in Schedule types on EventBridge Scheduler.
   *
   * @schema ScheduleSpecForProvider#scheduleExpression
   */
  readonly scheduleExpression?: string;

  /**
   * Timezone in which the scheduling expression is evaluated. Defaults to UTC. Example: Australia/Sydney.
   *
   * @default UTC. Example: Australia/Sydney.
   * @schema ScheduleSpecForProvider#scheduleExpressionTimezone
   */
  readonly scheduleExpressionTimezone?: string;

  /**
   * The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the start date you specify. EventBridge Scheduler ignores the start date for one-time schedules. Example: 2030-01-01T01:00:00Z.
   *
   * @schema ScheduleSpecForProvider#startDate
   */
  readonly startDate?: string;

  /**
   * Specifies whether the schedule is enabled or disabled. One of: ENABLED (default), DISABLED.
   *
   * @schema ScheduleSpecForProvider#state
   */
  readonly state?: string;

  /**
   * Configures the target of the schedule. Detailed below.
   *
   * @schema ScheduleSpecForProvider#target
   */
  readonly target?: ScheduleSpecForProviderTarget[];

}

/**
 * Converts an object of type 'ScheduleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProvider(obj: ScheduleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'endDate': obj.endDate,
    'flexibleTimeWindow': obj.flexibleTimeWindow?.map(y => toJson_ScheduleSpecForProviderFlexibleTimeWindow(y)),
    'groupName': obj.groupName,
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_ScheduleSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_ScheduleSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'name': obj.name,
    'region': obj.region,
    'scheduleExpression': obj.scheduleExpression,
    'scheduleExpressionTimezone': obj.scheduleExpressionTimezone,
    'startDate': obj.startDate,
    'state': obj.state,
    'target': obj.target?.map(y => toJson_ScheduleSpecForProviderTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ScheduleSpecInitProvider
 */
export interface ScheduleSpecInitProvider {
  /**
   * Brief description of the schedule.
   *
   * @schema ScheduleSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the end date you specify. EventBridge Scheduler ignores the end date for one-time schedules. Example: 2030-01-01T01:00:00Z.
   *
   * @schema ScheduleSpecInitProvider#endDate
   */
  readonly endDate?: string;

  /**
   * Configures a time window during which EventBridge Scheduler invokes the schedule. Detailed below.
   *
   * @schema ScheduleSpecInitProvider#flexibleTimeWindow
   */
  readonly flexibleTimeWindow?: ScheduleSpecInitProviderFlexibleTimeWindow[];

  /**
   * Name of the schedule group to associate with this schedule. When omitted, the default schedule group is used.
   *
   * @schema ScheduleSpecInitProvider#groupName
   */
  readonly groupName?: string;

  /**
   * Name of the schedule. Conflicts with name_prefix.
   *
   * @schema ScheduleSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Defines when the schedule runs. Read more in Schedule types on EventBridge Scheduler.
   *
   * @schema ScheduleSpecInitProvider#scheduleExpression
   */
  readonly scheduleExpression?: string;

  /**
   * Timezone in which the scheduling expression is evaluated. Defaults to UTC. Example: Australia/Sydney.
   *
   * @default UTC. Example: Australia/Sydney.
   * @schema ScheduleSpecInitProvider#scheduleExpressionTimezone
   */
  readonly scheduleExpressionTimezone?: string;

  /**
   * The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the start date you specify. EventBridge Scheduler ignores the start date for one-time schedules. Example: 2030-01-01T01:00:00Z.
   *
   * @schema ScheduleSpecInitProvider#startDate
   */
  readonly startDate?: string;

  /**
   * Specifies whether the schedule is enabled or disabled. One of: ENABLED (default), DISABLED.
   *
   * @schema ScheduleSpecInitProvider#state
   */
  readonly state?: string;

  /**
   * Configures the target of the schedule. Detailed below.
   *
   * @schema ScheduleSpecInitProvider#target
   */
  readonly target?: ScheduleSpecInitProviderTarget[];

}

/**
 * Converts an object of type 'ScheduleSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProvider(obj: ScheduleSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'endDate': obj.endDate,
    'flexibleTimeWindow': obj.flexibleTimeWindow?.map(y => toJson_ScheduleSpecInitProviderFlexibleTimeWindow(y)),
    'groupName': obj.groupName,
    'name': obj.name,
    'scheduleExpression': obj.scheduleExpression,
    'scheduleExpressionTimezone': obj.scheduleExpressionTimezone,
    'startDate': obj.startDate,
    'state': obj.state,
    'target': obj.target?.map(y => toJson_ScheduleSpecInitProviderTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ScheduleSpecManagementPolicies
 */
export enum ScheduleSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ScheduleSpecProviderConfigRef
 */
export interface ScheduleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduleSpecProviderConfigRef#policy
   */
  readonly policy?: ScheduleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecProviderConfigRef(obj: ScheduleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ScheduleSpecPublishConnectionDetailsTo
 */
export interface ScheduleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ScheduleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ScheduleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ScheduleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ScheduleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ScheduleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ScheduleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPublishConnectionDetailsTo(obj: ScheduleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ScheduleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ScheduleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ScheduleSpecWriteConnectionSecretToRef
 */
export interface ScheduleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ScheduleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ScheduleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ScheduleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecWriteConnectionSecretToRef(obj: ScheduleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderFlexibleTimeWindow
 */
export interface ScheduleSpecForProviderFlexibleTimeWindow {
  /**
   * Maximum time window during which a schedule can be invoked. Ranges from 1 to 1440 minutes.
   *
   * @schema ScheduleSpecForProviderFlexibleTimeWindow#maximumWindowInMinutes
   */
  readonly maximumWindowInMinutes?: number;

  /**
   * Determines whether the schedule is invoked within a flexible time window. One of: OFF, FLEXIBLE.
   *
   * @schema ScheduleSpecForProviderFlexibleTimeWindow#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderFlexibleTimeWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderFlexibleTimeWindow(obj: ScheduleSpecForProviderFlexibleTimeWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumWindowInMinutes': obj.maximumWindowInMinutes,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema ScheduleSpecForProviderKmsKeyArnRef
 */
export interface ScheduleSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduleSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduleSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: ScheduleSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderKmsKeyArnRef(obj: ScheduleSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduleSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema ScheduleSpecForProviderKmsKeyArnSelector
 */
export interface ScheduleSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduleSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduleSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduleSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: ScheduleSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderKmsKeyArnSelector(obj: ScheduleSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduleSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTarget
 */
export interface ScheduleSpecForProviderTarget {
  /**
   * ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a Service ARN specific to the target service.
   *
   * @schema ScheduleSpecForProviderTarget#arn
   */
  readonly arn?: string;

  /**
   * Reference to a Queue in sqs to populate arn.
   *
   * @schema ScheduleSpecForProviderTarget#arnRef
   */
  readonly arnRef?: ScheduleSpecForProviderTargetArnRef;

  /**
   * Selector for a Queue in sqs to populate arn.
   *
   * @schema ScheduleSpecForProviderTarget#arnSelector
   */
  readonly arnSelector?: ScheduleSpecForProviderTargetArnSelector;

  /**
   * Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
   *
   * @schema ScheduleSpecForProviderTarget#deadLetterConfig
   */
  readonly deadLetterConfig?: ScheduleSpecForProviderTargetDeadLetterConfig[];

  /**
   * Templated target type for the Amazon ECS RunTask API operation. Detailed below.
   *
   * @schema ScheduleSpecForProviderTarget#ecsParameters
   */
  readonly ecsParameters?: ScheduleSpecForProviderTargetEcsParameters[];

  /**
   * Templated target type for the EventBridge PutEvents API operation. Detailed below.
   *
   * @schema ScheduleSpecForProviderTarget#eventbridgeParameters
   */
  readonly eventbridgeParameters?: ScheduleSpecForProviderTargetEventbridgeParameters[];

  /**
   * Text, or well-formed JSON, passed to the target. Read more in Universal target.
   *
   * @schema ScheduleSpecForProviderTarget#input
   */
  readonly input?: string;

  /**
   * Templated target type for the Amazon Kinesis PutRecord API operation. Detailed below.
   *
   * @schema ScheduleSpecForProviderTarget#kinesisParameters
   */
  readonly kinesisParameters?: ScheduleSpecForProviderTargetKinesisParameters[];

  /**
   * Information about the retry policy settings. Detailed below.
   *
   * @schema ScheduleSpecForProviderTarget#retryPolicy
   */
  readonly retryPolicy?: ScheduleSpecForProviderTargetRetryPolicy[];

  /**
   * ARN of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked. Read more in Set up the execution role.
   *
   * @schema ScheduleSpecForProviderTarget#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ScheduleSpecForProviderTarget#roleArnRef
   */
  readonly roleArnRef?: ScheduleSpecForProviderTargetRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ScheduleSpecForProviderTarget#roleArnSelector
   */
  readonly roleArnSelector?: ScheduleSpecForProviderTargetRoleArnSelector;

  /**
   * Templated target type for the Amazon SageMaker StartPipelineExecution API operation. Detailed below.
   *
   * @schema ScheduleSpecForProviderTarget#sagemakerPipelineParameters
   */
  readonly sagemakerPipelineParameters?: ScheduleSpecForProviderTargetSagemakerPipelineParameters[];

  /**
   * The templated target type for the Amazon SQS SendMessage API operation. Detailed below.
   *
   * @schema ScheduleSpecForProviderTarget#sqsParameters
   */
  readonly sqsParameters?: ScheduleSpecForProviderTargetSqsParameters[];

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTarget(obj: ScheduleSpecForProviderTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'arnRef': toJson_ScheduleSpecForProviderTargetArnRef(obj.arnRef),
    'arnSelector': toJson_ScheduleSpecForProviderTargetArnSelector(obj.arnSelector),
    'deadLetterConfig': obj.deadLetterConfig?.map(y => toJson_ScheduleSpecForProviderTargetDeadLetterConfig(y)),
    'ecsParameters': obj.ecsParameters?.map(y => toJson_ScheduleSpecForProviderTargetEcsParameters(y)),
    'eventbridgeParameters': obj.eventbridgeParameters?.map(y => toJson_ScheduleSpecForProviderTargetEventbridgeParameters(y)),
    'input': obj.input,
    'kinesisParameters': obj.kinesisParameters?.map(y => toJson_ScheduleSpecForProviderTargetKinesisParameters(y)),
    'retryPolicy': obj.retryPolicy?.map(y => toJson_ScheduleSpecForProviderTargetRetryPolicy(y)),
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ScheduleSpecForProviderTargetRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ScheduleSpecForProviderTargetRoleArnSelector(obj.roleArnSelector),
    'sagemakerPipelineParameters': obj.sagemakerPipelineParameters?.map(y => toJson_ScheduleSpecForProviderTargetSagemakerPipelineParameters(y)),
    'sqsParameters': obj.sqsParameters?.map(y => toJson_ScheduleSpecForProviderTargetSqsParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderFlexibleTimeWindow
 */
export interface ScheduleSpecInitProviderFlexibleTimeWindow {
  /**
   * Maximum time window during which a schedule can be invoked. Ranges from 1 to 1440 minutes.
   *
   * @schema ScheduleSpecInitProviderFlexibleTimeWindow#maximumWindowInMinutes
   */
  readonly maximumWindowInMinutes?: number;

  /**
   * Determines whether the schedule is invoked within a flexible time window. One of: OFF, FLEXIBLE.
   *
   * @schema ScheduleSpecInitProviderFlexibleTimeWindow#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderFlexibleTimeWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderFlexibleTimeWindow(obj: ScheduleSpecInitProviderFlexibleTimeWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumWindowInMinutes': obj.maximumWindowInMinutes,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTarget
 */
export interface ScheduleSpecInitProviderTarget {
  /**
   * Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTarget#deadLetterConfig
   */
  readonly deadLetterConfig?: ScheduleSpecInitProviderTargetDeadLetterConfig[];

  /**
   * Templated target type for the Amazon ECS RunTask API operation. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTarget#ecsParameters
   */
  readonly ecsParameters?: ScheduleSpecInitProviderTargetEcsParameters[];

  /**
   * Templated target type for the EventBridge PutEvents API operation. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTarget#eventbridgeParameters
   */
  readonly eventbridgeParameters?: ScheduleSpecInitProviderTargetEventbridgeParameters[];

  /**
   * Text, or well-formed JSON, passed to the target. Read more in Universal target.
   *
   * @schema ScheduleSpecInitProviderTarget#input
   */
  readonly input?: string;

  /**
   * Templated target type for the Amazon Kinesis PutRecord API operation. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTarget#kinesisParameters
   */
  readonly kinesisParameters?: ScheduleSpecInitProviderTargetKinesisParameters[];

  /**
   * Information about the retry policy settings. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTarget#retryPolicy
   */
  readonly retryPolicy?: ScheduleSpecInitProviderTargetRetryPolicy[];

  /**
   * Templated target type for the Amazon SageMaker StartPipelineExecution API operation. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTarget#sagemakerPipelineParameters
   */
  readonly sagemakerPipelineParameters?: ScheduleSpecInitProviderTargetSagemakerPipelineParameters[];

  /**
   * The templated target type for the Amazon SQS SendMessage API operation. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTarget#sqsParameters
   */
  readonly sqsParameters?: ScheduleSpecInitProviderTargetSqsParameters[];

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTarget(obj: ScheduleSpecInitProviderTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deadLetterConfig': obj.deadLetterConfig?.map(y => toJson_ScheduleSpecInitProviderTargetDeadLetterConfig(y)),
    'ecsParameters': obj.ecsParameters?.map(y => toJson_ScheduleSpecInitProviderTargetEcsParameters(y)),
    'eventbridgeParameters': obj.eventbridgeParameters?.map(y => toJson_ScheduleSpecInitProviderTargetEventbridgeParameters(y)),
    'input': obj.input,
    'kinesisParameters': obj.kinesisParameters?.map(y => toJson_ScheduleSpecInitProviderTargetKinesisParameters(y)),
    'retryPolicy': obj.retryPolicy?.map(y => toJson_ScheduleSpecInitProviderTargetRetryPolicy(y)),
    'sagemakerPipelineParameters': obj.sagemakerPipelineParameters?.map(y => toJson_ScheduleSpecInitProviderTargetSagemakerPipelineParameters(y)),
    'sqsParameters': obj.sqsParameters?.map(y => toJson_ScheduleSpecInitProviderTargetSqsParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduleSpecProviderConfigRefPolicy
 */
export interface ScheduleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecProviderConfigRefPolicy(obj: ScheduleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ScheduleSpecPublishConnectionDetailsToConfigRef
 */
export interface ScheduleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ScheduleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPublishConnectionDetailsToConfigRef(obj: ScheduleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ScheduleSpecPublishConnectionDetailsToMetadata
 */
export interface ScheduleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScheduleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPublishConnectionDetailsToMetadata(obj: ScheduleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduleSpecForProviderKmsKeyArnRefPolicy
 */
export interface ScheduleSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: ScheduleSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: ScheduleSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderKmsKeyArnRefPolicy(obj: ScheduleSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduleSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface ScheduleSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: ScheduleSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: ScheduleSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderKmsKeyArnSelectorPolicy(obj: ScheduleSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Queue in sqs to populate arn.
 *
 * @schema ScheduleSpecForProviderTargetArnRef
 */
export interface ScheduleSpecForProviderTargetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduleSpecForProviderTargetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduleSpecForProviderTargetArnRef#policy
   */
  readonly policy?: ScheduleSpecForProviderTargetArnRefPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetArnRef(obj: ScheduleSpecForProviderTargetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduleSpecForProviderTargetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Queue in sqs to populate arn.
 *
 * @schema ScheduleSpecForProviderTargetArnSelector
 */
export interface ScheduleSpecForProviderTargetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduleSpecForProviderTargetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduleSpecForProviderTargetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduleSpecForProviderTargetArnSelector#policy
   */
  readonly policy?: ScheduleSpecForProviderTargetArnSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetArnSelector(obj: ScheduleSpecForProviderTargetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduleSpecForProviderTargetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetDeadLetterConfig
 */
export interface ScheduleSpecForProviderTargetDeadLetterConfig {
  /**
   * ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a Service ARN specific to the target service.
   *
   * @schema ScheduleSpecForProviderTargetDeadLetterConfig#arn
   */
  readonly arn?: string;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetDeadLetterConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetDeadLetterConfig(obj: ScheduleSpecForProviderTargetDeadLetterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetEcsParameters
 */
export interface ScheduleSpecForProviderTargetEcsParameters {
  /**
   * Up to 6 capacity provider strategies to use for the task. Detailed below.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#capacityProviderStrategy
   */
  readonly capacityProviderStrategy?: ScheduleSpecForProviderTargetEcsParametersCapacityProviderStrategy[];

  /**
   * Specifies whether to enable Amazon ECS managed tags for the task. For more information, see Tagging Your Amazon ECS Resources in the Amazon ECS Developer Guide.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#enableEcsManagedTags
   */
  readonly enableEcsManagedTags?: boolean;

  /**
   * Specifies whether to enable the execute command functionality for the containers in this task.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#enableExecuteCommand
   */
  readonly enableExecuteCommand?: boolean;

  /**
   * Specifies an ECS task group for the task. At most 255 characters.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#group
   */
  readonly group?: string;

  /**
   * Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. One of: EC2, FARGATE, EXTERNAL.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#launchType
   */
  readonly launchType?: string;

  /**
   * Configures the networking associated with the task. Detailed below.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#networkConfiguration
   */
  readonly networkConfiguration?: ScheduleSpecForProviderTargetEcsParametersNetworkConfiguration[];

  /**
   * A set of up to 10 placement constraints to use for the task. Detailed below.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#placementConstraints
   */
  readonly placementConstraints?: ScheduleSpecForProviderTargetEcsParametersPlacementConstraints[];

  /**
   * A set of up to 5 placement strategies. Detailed below.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#placementStrategy
   */
  readonly placementStrategy?: ScheduleSpecForProviderTargetEcsParametersPlacementStrategy[];

  /**
   * Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#platformVersion
   */
  readonly platformVersion?: string;

  /**
   * Specifies whether to propagate the tags from the task definition to the task. One of: TASK_DEFINITION.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#propagateTags
   */
  readonly propagateTags?: string;

  /**
   * Reference ID to use for the task.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#referenceId
   */
  readonly referenceId?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The number of tasks to create. Ranges from 1 (default) to 10.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#taskCount
   */
  readonly taskCount?: number;

  /**
   * ARN of the task definition to use.
   *
   * @schema ScheduleSpecForProviderTargetEcsParameters#taskDefinitionArn
   */
  readonly taskDefinitionArn?: string;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetEcsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetEcsParameters(obj: ScheduleSpecForProviderTargetEcsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityProviderStrategy': obj.capacityProviderStrategy?.map(y => toJson_ScheduleSpecForProviderTargetEcsParametersCapacityProviderStrategy(y)),
    'enableEcsManagedTags': obj.enableEcsManagedTags,
    'enableExecuteCommand': obj.enableExecuteCommand,
    'group': obj.group,
    'launchType': obj.launchType,
    'networkConfiguration': obj.networkConfiguration?.map(y => toJson_ScheduleSpecForProviderTargetEcsParametersNetworkConfiguration(y)),
    'placementConstraints': obj.placementConstraints?.map(y => toJson_ScheduleSpecForProviderTargetEcsParametersPlacementConstraints(y)),
    'placementStrategy': obj.placementStrategy?.map(y => toJson_ScheduleSpecForProviderTargetEcsParametersPlacementStrategy(y)),
    'platformVersion': obj.platformVersion,
    'propagateTags': obj.propagateTags,
    'referenceId': obj.referenceId,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taskCount': obj.taskCount,
    'taskDefinitionArn': obj.taskDefinitionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetEventbridgeParameters
 */
export interface ScheduleSpecForProviderTargetEventbridgeParameters {
  /**
   * Free-form string used to decide what fields to expect in the event detail. Up to 128 characters.
   *
   * @schema ScheduleSpecForProviderTargetEventbridgeParameters#detailType
   */
  readonly detailType?: string;

  /**
   * Source of the event.
   *
   * @schema ScheduleSpecForProviderTargetEventbridgeParameters#source
   */
  readonly source?: string;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetEventbridgeParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetEventbridgeParameters(obj: ScheduleSpecForProviderTargetEventbridgeParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'detailType': obj.detailType,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetKinesisParameters
 */
export interface ScheduleSpecForProviderTargetKinesisParameters {
  /**
   * Specifies the shard to which EventBridge Scheduler sends the event. Up to 256 characters.
   *
   * @schema ScheduleSpecForProviderTargetKinesisParameters#partitionKey
   */
  readonly partitionKey?: string;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetKinesisParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetKinesisParameters(obj: ScheduleSpecForProviderTargetKinesisParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitionKey': obj.partitionKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetRetryPolicy
 */
export interface ScheduleSpecForProviderTargetRetryPolicy {
  /**
   * Maximum amount of time, in seconds, to continue to make retry attempts. Ranges from 60 to 86400 (default).
   *
   * @schema ScheduleSpecForProviderTargetRetryPolicy#maximumEventAgeInSeconds
   */
  readonly maximumEventAgeInSeconds?: number;

  /**
   * Maximum number of retry attempts to make before the request fails. Ranges from 0 to 185 (default).
   *
   * @schema ScheduleSpecForProviderTargetRetryPolicy#maximumRetryAttempts
   */
  readonly maximumRetryAttempts?: number;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetRetryPolicy(obj: ScheduleSpecForProviderTargetRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumEventAgeInSeconds': obj.maximumEventAgeInSeconds,
    'maximumRetryAttempts': obj.maximumRetryAttempts,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ScheduleSpecForProviderTargetRoleArnRef
 */
export interface ScheduleSpecForProviderTargetRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduleSpecForProviderTargetRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduleSpecForProviderTargetRoleArnRef#policy
   */
  readonly policy?: ScheduleSpecForProviderTargetRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetRoleArnRef(obj: ScheduleSpecForProviderTargetRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduleSpecForProviderTargetRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ScheduleSpecForProviderTargetRoleArnSelector
 */
export interface ScheduleSpecForProviderTargetRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduleSpecForProviderTargetRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduleSpecForProviderTargetRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduleSpecForProviderTargetRoleArnSelector#policy
   */
  readonly policy?: ScheduleSpecForProviderTargetRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetRoleArnSelector(obj: ScheduleSpecForProviderTargetRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduleSpecForProviderTargetRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetSagemakerPipelineParameters
 */
export interface ScheduleSpecForProviderTargetSagemakerPipelineParameters {
  /**
   * Set of up to 200 parameter names and values to use when executing the SageMaker Model Building Pipeline. Detailed below.
   *
   * @schema ScheduleSpecForProviderTargetSagemakerPipelineParameters#pipelineParameter
   */
  readonly pipelineParameter?: ScheduleSpecForProviderTargetSagemakerPipelineParametersPipelineParameter[];

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetSagemakerPipelineParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetSagemakerPipelineParameters(obj: ScheduleSpecForProviderTargetSagemakerPipelineParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pipelineParameter': obj.pipelineParameter?.map(y => toJson_ScheduleSpecForProviderTargetSagemakerPipelineParametersPipelineParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetSqsParameters
 */
export interface ScheduleSpecForProviderTargetSqsParameters {
  /**
   * FIFO message group ID to use as the target.
   *
   * @schema ScheduleSpecForProviderTargetSqsParameters#messageGroupId
   */
  readonly messageGroupId?: string;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetSqsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetSqsParameters(obj: ScheduleSpecForProviderTargetSqsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messageGroupId': obj.messageGroupId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetDeadLetterConfig
 */
export interface ScheduleSpecInitProviderTargetDeadLetterConfig {
  /**
   * ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a Service ARN specific to the target service.
   *
   * @schema ScheduleSpecInitProviderTargetDeadLetterConfig#arn
   */
  readonly arn?: string;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetDeadLetterConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetDeadLetterConfig(obj: ScheduleSpecInitProviderTargetDeadLetterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetEcsParameters
 */
export interface ScheduleSpecInitProviderTargetEcsParameters {
  /**
   * Up to 6 capacity provider strategies to use for the task. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#capacityProviderStrategy
   */
  readonly capacityProviderStrategy?: ScheduleSpecInitProviderTargetEcsParametersCapacityProviderStrategy[];

  /**
   * Specifies whether to enable Amazon ECS managed tags for the task. For more information, see Tagging Your Amazon ECS Resources in the Amazon ECS Developer Guide.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#enableEcsManagedTags
   */
  readonly enableEcsManagedTags?: boolean;

  /**
   * Specifies whether to enable the execute command functionality for the containers in this task.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#enableExecuteCommand
   */
  readonly enableExecuteCommand?: boolean;

  /**
   * Specifies an ECS task group for the task. At most 255 characters.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#group
   */
  readonly group?: string;

  /**
   * Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. One of: EC2, FARGATE, EXTERNAL.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#launchType
   */
  readonly launchType?: string;

  /**
   * Configures the networking associated with the task. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#networkConfiguration
   */
  readonly networkConfiguration?: ScheduleSpecInitProviderTargetEcsParametersNetworkConfiguration[];

  /**
   * A set of up to 10 placement constraints to use for the task. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#placementConstraints
   */
  readonly placementConstraints?: ScheduleSpecInitProviderTargetEcsParametersPlacementConstraints[];

  /**
   * A set of up to 5 placement strategies. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#placementStrategy
   */
  readonly placementStrategy?: ScheduleSpecInitProviderTargetEcsParametersPlacementStrategy[];

  /**
   * Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#platformVersion
   */
  readonly platformVersion?: string;

  /**
   * Specifies whether to propagate the tags from the task definition to the task. One of: TASK_DEFINITION.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#propagateTags
   */
  readonly propagateTags?: string;

  /**
   * Reference ID to use for the task.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#referenceId
   */
  readonly referenceId?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The number of tasks to create. Ranges from 1 (default) to 10.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#taskCount
   */
  readonly taskCount?: number;

  /**
   * ARN of the task definition to use.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParameters#taskDefinitionArn
   */
  readonly taskDefinitionArn?: string;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetEcsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetEcsParameters(obj: ScheduleSpecInitProviderTargetEcsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityProviderStrategy': obj.capacityProviderStrategy?.map(y => toJson_ScheduleSpecInitProviderTargetEcsParametersCapacityProviderStrategy(y)),
    'enableEcsManagedTags': obj.enableEcsManagedTags,
    'enableExecuteCommand': obj.enableExecuteCommand,
    'group': obj.group,
    'launchType': obj.launchType,
    'networkConfiguration': obj.networkConfiguration?.map(y => toJson_ScheduleSpecInitProviderTargetEcsParametersNetworkConfiguration(y)),
    'placementConstraints': obj.placementConstraints?.map(y => toJson_ScheduleSpecInitProviderTargetEcsParametersPlacementConstraints(y)),
    'placementStrategy': obj.placementStrategy?.map(y => toJson_ScheduleSpecInitProviderTargetEcsParametersPlacementStrategy(y)),
    'platformVersion': obj.platformVersion,
    'propagateTags': obj.propagateTags,
    'referenceId': obj.referenceId,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taskCount': obj.taskCount,
    'taskDefinitionArn': obj.taskDefinitionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetEventbridgeParameters
 */
export interface ScheduleSpecInitProviderTargetEventbridgeParameters {
  /**
   * Free-form string used to decide what fields to expect in the event detail. Up to 128 characters.
   *
   * @schema ScheduleSpecInitProviderTargetEventbridgeParameters#detailType
   */
  readonly detailType?: string;

  /**
   * Source of the event.
   *
   * @schema ScheduleSpecInitProviderTargetEventbridgeParameters#source
   */
  readonly source?: string;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetEventbridgeParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetEventbridgeParameters(obj: ScheduleSpecInitProviderTargetEventbridgeParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'detailType': obj.detailType,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetKinesisParameters
 */
export interface ScheduleSpecInitProviderTargetKinesisParameters {
  /**
   * Specifies the shard to which EventBridge Scheduler sends the event. Up to 256 characters.
   *
   * @schema ScheduleSpecInitProviderTargetKinesisParameters#partitionKey
   */
  readonly partitionKey?: string;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetKinesisParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetKinesisParameters(obj: ScheduleSpecInitProviderTargetKinesisParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitionKey': obj.partitionKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetRetryPolicy
 */
export interface ScheduleSpecInitProviderTargetRetryPolicy {
  /**
   * Maximum amount of time, in seconds, to continue to make retry attempts. Ranges from 60 to 86400 (default).
   *
   * @schema ScheduleSpecInitProviderTargetRetryPolicy#maximumEventAgeInSeconds
   */
  readonly maximumEventAgeInSeconds?: number;

  /**
   * Maximum number of retry attempts to make before the request fails. Ranges from 0 to 185 (default).
   *
   * @schema ScheduleSpecInitProviderTargetRetryPolicy#maximumRetryAttempts
   */
  readonly maximumRetryAttempts?: number;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetRetryPolicy(obj: ScheduleSpecInitProviderTargetRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumEventAgeInSeconds': obj.maximumEventAgeInSeconds,
    'maximumRetryAttempts': obj.maximumRetryAttempts,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetSagemakerPipelineParameters
 */
export interface ScheduleSpecInitProviderTargetSagemakerPipelineParameters {
  /**
   * Set of up to 200 parameter names and values to use when executing the SageMaker Model Building Pipeline. Detailed below.
   *
   * @schema ScheduleSpecInitProviderTargetSagemakerPipelineParameters#pipelineParameter
   */
  readonly pipelineParameter?: ScheduleSpecInitProviderTargetSagemakerPipelineParametersPipelineParameter[];

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetSagemakerPipelineParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetSagemakerPipelineParameters(obj: ScheduleSpecInitProviderTargetSagemakerPipelineParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pipelineParameter': obj.pipelineParameter?.map(y => toJson_ScheduleSpecInitProviderTargetSagemakerPipelineParametersPipelineParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetSqsParameters
 */
export interface ScheduleSpecInitProviderTargetSqsParameters {
  /**
   * FIFO message group ID to use as the target.
   *
   * @schema ScheduleSpecInitProviderTargetSqsParameters#messageGroupId
   */
  readonly messageGroupId?: string;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetSqsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetSqsParameters(obj: ScheduleSpecInitProviderTargetSqsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messageGroupId': obj.messageGroupId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecProviderConfigRefPolicyResolution
 */
export enum ScheduleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecProviderConfigRefPolicyResolve
 */
export enum ScheduleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ScheduleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ScheduleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPublishConnectionDetailsToConfigRefPolicy(obj: ScheduleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum ScheduleSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum ScheduleSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum ScheduleSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum ScheduleSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ScheduleSpecForProviderTargetArnRefPolicy
 */
export interface ScheduleSpecForProviderTargetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecForProviderTargetArnRefPolicy#resolution
   */
  readonly resolution?: ScheduleSpecForProviderTargetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecForProviderTargetArnRefPolicy#resolve
   */
  readonly resolve?: ScheduleSpecForProviderTargetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetArnRefPolicy(obj: ScheduleSpecForProviderTargetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduleSpecForProviderTargetArnSelectorPolicy
 */
export interface ScheduleSpecForProviderTargetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecForProviderTargetArnSelectorPolicy#resolution
   */
  readonly resolution?: ScheduleSpecForProviderTargetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecForProviderTargetArnSelectorPolicy#resolve
   */
  readonly resolve?: ScheduleSpecForProviderTargetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetArnSelectorPolicy(obj: ScheduleSpecForProviderTargetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetEcsParametersCapacityProviderStrategy
 */
export interface ScheduleSpecForProviderTargetEcsParametersCapacityProviderStrategy {
  /**
   * How many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Ranges from 0 (default) to 100000.
   *
   * @schema ScheduleSpecForProviderTargetEcsParametersCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * Short name of the capacity provider.
   *
   * @schema ScheduleSpecForProviderTargetEcsParametersCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider?: string;

  /**
   * Designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Ranges from from 0 to 1000.
   *
   * @schema ScheduleSpecForProviderTargetEcsParametersCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetEcsParametersCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetEcsParametersCapacityProviderStrategy(obj: ScheduleSpecForProviderTargetEcsParametersCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetEcsParametersNetworkConfiguration
 */
export interface ScheduleSpecForProviderTargetEcsParametersNetworkConfiguration {
  /**
   * Specifies whether the task's elastic network interface receives a public IP address. This attribute is a boolean type, where true maps to ENABLED and false to DISABLED. You can specify true only when the launch_type is set to FARGATE.
   *
   * @schema ScheduleSpecForProviderTargetEcsParametersNetworkConfiguration#assignPublicIp
   */
  readonly assignPublicIp?: boolean;

  /**
   * Set of 1 to 5 Security Group ID-s to be associated with the task. These security groups must all be in the same VPC.
   *
   * @schema ScheduleSpecForProviderTargetEcsParametersNetworkConfiguration#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * Set of 1 to 16 subnets to be associated with the task. These subnets must all be in the same VPC.
   *
   * @schema ScheduleSpecForProviderTargetEcsParametersNetworkConfiguration#subnets
   */
  readonly subnets?: string[];

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetEcsParametersNetworkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetEcsParametersNetworkConfiguration(obj: ScheduleSpecForProviderTargetEcsParametersNetworkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assignPublicIp': obj.assignPublicIp,
    'securityGroups': obj.securityGroups?.map(y => y),
    'subnets': obj.subnets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetEcsParametersPlacementConstraints
 */
export interface ScheduleSpecForProviderTargetEcsParametersPlacementConstraints {
  /**
   * A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. For more information, see Cluster query language in the Amazon ECS Developer Guide.
   *
   * @schema ScheduleSpecForProviderTargetEcsParametersPlacementConstraints#expression
   */
  readonly expression?: string;

  /**
   * The type of placement strategy. One of: random, spread, binpack.
   *
   * @schema ScheduleSpecForProviderTargetEcsParametersPlacementConstraints#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetEcsParametersPlacementConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetEcsParametersPlacementConstraints(obj: ScheduleSpecForProviderTargetEcsParametersPlacementConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetEcsParametersPlacementStrategy
 */
export interface ScheduleSpecForProviderTargetEcsParametersPlacementStrategy {
  /**
   * The field to apply the placement strategy against.
   *
   * @schema ScheduleSpecForProviderTargetEcsParametersPlacementStrategy#field
   */
  readonly field?: string;

  /**
   * The type of placement strategy. One of: random, spread, binpack.
   *
   * @schema ScheduleSpecForProviderTargetEcsParametersPlacementStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetEcsParametersPlacementStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetEcsParametersPlacementStrategy(obj: ScheduleSpecForProviderTargetEcsParametersPlacementStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduleSpecForProviderTargetRoleArnRefPolicy
 */
export interface ScheduleSpecForProviderTargetRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecForProviderTargetRoleArnRefPolicy#resolution
   */
  readonly resolution?: ScheduleSpecForProviderTargetRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecForProviderTargetRoleArnRefPolicy#resolve
   */
  readonly resolve?: ScheduleSpecForProviderTargetRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetRoleArnRefPolicy(obj: ScheduleSpecForProviderTargetRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduleSpecForProviderTargetRoleArnSelectorPolicy
 */
export interface ScheduleSpecForProviderTargetRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecForProviderTargetRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ScheduleSpecForProviderTargetRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecForProviderTargetRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ScheduleSpecForProviderTargetRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetRoleArnSelectorPolicy(obj: ScheduleSpecForProviderTargetRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecForProviderTargetSagemakerPipelineParametersPipelineParameter
 */
export interface ScheduleSpecForProviderTargetSagemakerPipelineParametersPipelineParameter {
  /**
   * Name of parameter to start execution of a SageMaker Model Building Pipeline.
   *
   * @schema ScheduleSpecForProviderTargetSagemakerPipelineParametersPipelineParameter#name
   */
  readonly name?: string;

  /**
   * Value of parameter to start execution of a SageMaker Model Building Pipeline.
   *
   * @schema ScheduleSpecForProviderTargetSagemakerPipelineParametersPipelineParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderTargetSagemakerPipelineParametersPipelineParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderTargetSagemakerPipelineParametersPipelineParameter(obj: ScheduleSpecForProviderTargetSagemakerPipelineParametersPipelineParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetEcsParametersCapacityProviderStrategy
 */
export interface ScheduleSpecInitProviderTargetEcsParametersCapacityProviderStrategy {
  /**
   * How many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Ranges from 0 (default) to 100000.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParametersCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * Short name of the capacity provider.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParametersCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider?: string;

  /**
   * Designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Ranges from from 0 to 1000.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParametersCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetEcsParametersCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetEcsParametersCapacityProviderStrategy(obj: ScheduleSpecInitProviderTargetEcsParametersCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetEcsParametersNetworkConfiguration
 */
export interface ScheduleSpecInitProviderTargetEcsParametersNetworkConfiguration {
  /**
   * Specifies whether the task's elastic network interface receives a public IP address. This attribute is a boolean type, where true maps to ENABLED and false to DISABLED. You can specify true only when the launch_type is set to FARGATE.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParametersNetworkConfiguration#assignPublicIp
   */
  readonly assignPublicIp?: boolean;

  /**
   * Set of 1 to 5 Security Group ID-s to be associated with the task. These security groups must all be in the same VPC.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParametersNetworkConfiguration#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * Set of 1 to 16 subnets to be associated with the task. These subnets must all be in the same VPC.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParametersNetworkConfiguration#subnets
   */
  readonly subnets?: string[];

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetEcsParametersNetworkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetEcsParametersNetworkConfiguration(obj: ScheduleSpecInitProviderTargetEcsParametersNetworkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assignPublicIp': obj.assignPublicIp,
    'securityGroups': obj.securityGroups?.map(y => y),
    'subnets': obj.subnets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetEcsParametersPlacementConstraints
 */
export interface ScheduleSpecInitProviderTargetEcsParametersPlacementConstraints {
  /**
   * A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. For more information, see Cluster query language in the Amazon ECS Developer Guide.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParametersPlacementConstraints#expression
   */
  readonly expression?: string;

  /**
   * The type of placement strategy. One of: random, spread, binpack.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParametersPlacementConstraints#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetEcsParametersPlacementConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetEcsParametersPlacementConstraints(obj: ScheduleSpecInitProviderTargetEcsParametersPlacementConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetEcsParametersPlacementStrategy
 */
export interface ScheduleSpecInitProviderTargetEcsParametersPlacementStrategy {
  /**
   * The field to apply the placement strategy against.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParametersPlacementStrategy#field
   */
  readonly field?: string;

  /**
   * The type of placement strategy. One of: random, spread, binpack.
   *
   * @schema ScheduleSpecInitProviderTargetEcsParametersPlacementStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetEcsParametersPlacementStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetEcsParametersPlacementStrategy(obj: ScheduleSpecInitProviderTargetEcsParametersPlacementStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecInitProviderTargetSagemakerPipelineParametersPipelineParameter
 */
export interface ScheduleSpecInitProviderTargetSagemakerPipelineParametersPipelineParameter {
  /**
   * Name of parameter to start execution of a SageMaker Model Building Pipeline.
   *
   * @schema ScheduleSpecInitProviderTargetSagemakerPipelineParametersPipelineParameter#name
   */
  readonly name?: string;

  /**
   * Value of parameter to start execution of a SageMaker Model Building Pipeline.
   *
   * @schema ScheduleSpecInitProviderTargetSagemakerPipelineParametersPipelineParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ScheduleSpecInitProviderTargetSagemakerPipelineParametersPipelineParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProviderTargetSagemakerPipelineParametersPipelineParameter(obj: ScheduleSpecInitProviderTargetSagemakerPipelineParametersPipelineParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecForProviderTargetArnRefPolicyResolution
 */
export enum ScheduleSpecForProviderTargetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecForProviderTargetArnRefPolicyResolve
 */
export enum ScheduleSpecForProviderTargetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecForProviderTargetArnSelectorPolicyResolution
 */
export enum ScheduleSpecForProviderTargetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecForProviderTargetArnSelectorPolicyResolve
 */
export enum ScheduleSpecForProviderTargetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecForProviderTargetRoleArnRefPolicyResolution
 */
export enum ScheduleSpecForProviderTargetRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecForProviderTargetRoleArnRefPolicyResolve
 */
export enum ScheduleSpecForProviderTargetRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecForProviderTargetRoleArnSelectorPolicyResolution
 */
export enum ScheduleSpecForProviderTargetRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecForProviderTargetRoleArnSelectorPolicyResolve
 */
export enum ScheduleSpecForProviderTargetRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ScheduleGroup is the Schema for the ScheduleGroups API. Provides an EventBridge Scheduler Schedule Group resource.
 *
 * @schema ScheduleGroup
 */
export class ScheduleGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ScheduleGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'scheduler.aws.upbound.io/v1beta1',
    kind: 'ScheduleGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ScheduleGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScheduleGroupProps): any {
    return {
      ...ScheduleGroup.GVK,
      ...toJson_ScheduleGroupProps(props),
    };
  }

  /**
   * Defines a "ScheduleGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScheduleGroupProps) {
    super(scope, id, {
      ...ScheduleGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ScheduleGroup.GVK,
      ...toJson_ScheduleGroupProps(resolved),
    };
  }
}

/**
 * ScheduleGroup is the Schema for the ScheduleGroups API. Provides an EventBridge Scheduler Schedule Group resource.
 *
 * @schema ScheduleGroup
 */
export interface ScheduleGroupProps {
  /**
   * @schema ScheduleGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScheduleGroupSpec defines the desired state of ScheduleGroup
   *
   * @schema ScheduleGroup#spec
   */
  readonly spec: ScheduleGroupSpec;

}

/**
 * Converts an object of type 'ScheduleGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupProps(obj: ScheduleGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScheduleGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScheduleGroupSpec defines the desired state of ScheduleGroup
 *
 * @schema ScheduleGroupSpec
 */
export interface ScheduleGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScheduleGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ScheduleGroupSpecDeletionPolicy;

  /**
   * @schema ScheduleGroupSpec#forProvider
   */
  readonly forProvider: ScheduleGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ScheduleGroupSpec#initProvider
   */
  readonly initProvider?: ScheduleGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ScheduleGroupSpec#managementPolicies
   */
  readonly managementPolicies?: ScheduleGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ScheduleGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ScheduleGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ScheduleGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ScheduleGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ScheduleGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ScheduleGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ScheduleGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupSpec(obj: ScheduleGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ScheduleGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_ScheduleGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ScheduleGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ScheduleGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ScheduleGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScheduleGroupSpecDeletionPolicy
 */
export enum ScheduleGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ScheduleGroupSpecForProvider
 */
export interface ScheduleGroupSpecForProvider {
  /**
   * Name of the schedule group. Conflicts with name_prefix.
   *
   * @schema ScheduleGroupSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ScheduleGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ScheduleGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ScheduleGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupSpecForProvider(obj: ScheduleGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ScheduleGroupSpecInitProvider
 */
export interface ScheduleGroupSpecInitProvider {
  /**
   * Name of the schedule group. Conflicts with name_prefix.
   *
   * @schema ScheduleGroupSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ScheduleGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ScheduleGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupSpecInitProvider(obj: ScheduleGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ScheduleGroupSpecManagementPolicies
 */
export enum ScheduleGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ScheduleGroupSpecProviderConfigRef
 */
export interface ScheduleGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduleGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduleGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ScheduleGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduleGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupSpecProviderConfigRef(obj: ScheduleGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduleGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ScheduleGroupSpecPublishConnectionDetailsTo
 */
export interface ScheduleGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ScheduleGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ScheduleGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ScheduleGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ScheduleGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ScheduleGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ScheduleGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupSpecPublishConnectionDetailsTo(obj: ScheduleGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ScheduleGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ScheduleGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ScheduleGroupSpecWriteConnectionSecretToRef
 */
export interface ScheduleGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ScheduleGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ScheduleGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ScheduleGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupSpecWriteConnectionSecretToRef(obj: ScheduleGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduleGroupSpecProviderConfigRefPolicy
 */
export interface ScheduleGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduleGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduleGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupSpecProviderConfigRefPolicy(obj: ScheduleGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ScheduleGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ScheduleGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduleGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduleGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduleGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupSpecPublishConnectionDetailsToConfigRef(obj: ScheduleGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ScheduleGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ScheduleGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduleGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduleGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ScheduleGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScheduleGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupSpecPublishConnectionDetailsToMetadata(obj: ScheduleGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleGroupSpecProviderConfigRefPolicyResolution
 */
export enum ScheduleGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleGroupSpecProviderConfigRefPolicyResolve
 */
export enum ScheduleGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ScheduleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

