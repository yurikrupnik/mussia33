// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CAPool is the Schema for the CAPools API. A CaPool represents a group of CertificateAuthorities that form a trust anchor.
 *
 * @schema CAPool
 */
export class CaPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CAPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'CAPool',
  }

  /**
   * Renders a Kubernetes manifest for "CAPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CaPoolProps): any {
    return {
      ...CaPool.GVK,
      ...toJson_CaPoolProps(props),
    };
  }

  /**
   * Defines a "CAPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CaPoolProps) {
    super(scope, id, {
      ...CaPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CaPool.GVK,
      ...toJson_CaPoolProps(resolved),
    };
  }
}

/**
 * CAPool is the Schema for the CAPools API. A CaPool represents a group of CertificateAuthorities that form a trust anchor.
 *
 * @schema CAPool
 */
export interface CaPoolProps {
  /**
   * @schema CAPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CAPoolSpec defines the desired state of CAPool
   *
   * @schema CAPool#spec
   */
  readonly spec: CaPoolSpec;

}

/**
 * Converts an object of type 'CaPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolProps(obj: CaPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CaPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CAPoolSpec defines the desired state of CAPool
 *
 * @schema CaPoolSpec
 */
export interface CaPoolSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema CaPoolSpec#deletionPolicy
   */
  readonly deletionPolicy?: CaPoolSpecDeletionPolicy;

  /**
   * @schema CaPoolSpec#forProvider
   */
  readonly forProvider: CaPoolSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CaPoolSpec#providerConfigRef
   */
  readonly providerConfigRef?: CaPoolSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CaPoolSpec#providerRef
   */
  readonly providerRef?: CaPoolSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CaPoolSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CaPoolSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CaPoolSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CaPoolSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CaPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpec(obj: CaPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CaPoolSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_CaPoolSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CaPoolSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CaPoolSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CaPoolSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema CaPoolSpecDeletionPolicy
 */
export enum CaPoolSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CaPoolSpecForProvider
 */
export interface CaPoolSpecForProvider {
  /**
   * The IssuancePolicy to control how Certificates will be issued from this CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecForProvider#issuancePolicy
   */
  readonly issuancePolicy?: CaPoolSpecForProviderIssuancePolicy[];

  /**
   * Labels with user-defined metadata. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema CaPoolSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Location of the CaPool. A full list of valid locations can be found by running gcloud privateca locations list.
   *
   * @schema CaPoolSpecForProvider#location
   */
  readonly location: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema CaPoolSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The PublishingOptions to follow when issuing Certificates from any CertificateAuthority in this CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecForProvider#publishingOptions
   */
  readonly publishingOptions?: CaPoolSpecForProviderPublishingOptions[];

  /**
   * The Tier of this CaPool. Possible values are ENTERPRISE and DEVOPS.
   *
   * @schema CaPoolSpecForProvider#tier
   */
  readonly tier: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProvider(obj: CaPoolSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issuancePolicy': obj.issuancePolicy?.map(y => toJson_CaPoolSpecForProviderIssuancePolicy(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'project': obj.project,
    'publishingOptions': obj.publishingOptions?.map(y => toJson_CaPoolSpecForProviderPublishingOptions(y)),
    'tier': obj.tier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CaPoolSpecProviderConfigRef
 */
export interface CaPoolSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolSpecProviderConfigRef#policy
   */
  readonly policy?: CaPoolSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CaPoolSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecProviderConfigRef(obj: CaPoolSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CaPoolSpecProviderRef
 */
export interface CaPoolSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolSpecProviderRef#policy
   */
  readonly policy?: CaPoolSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CaPoolSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecProviderRef(obj: CaPoolSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CaPoolSpecPublishConnectionDetailsTo
 */
export interface CaPoolSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CaPoolSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CaPoolSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CaPoolSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CaPoolSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CaPoolSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CaPoolSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecPublishConnectionDetailsTo(obj: CaPoolSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CaPoolSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CaPoolSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CaPoolSpecWriteConnectionSecretToRef
 */
export interface CaPoolSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CaPoolSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CaPoolSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CaPoolSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecWriteConnectionSecretToRef(obj: CaPoolSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicy
 */
export interface CaPoolSpecForProviderIssuancePolicy {
  /**
   * IssuanceModes specifies the allowed ways in which Certificates may be requested from this CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicy#allowedIssuanceModes
   */
  readonly allowedIssuanceModes?: CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes[];

  /**
   * If any AllowedKeyType is specified, then the certificate request's public key must match one of the key types listed here. Otherwise, any key may be used. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicy#allowedKeyTypes
   */
  readonly allowedKeyTypes?: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes[];

  /**
   * A set of X.509 values that will be applied to all certificates issued through this CaPool. If a certificate request includes conflicting values for the same properties, they will be overwritten by the values defined here. If a certificate request uses a CertificateTemplate that defines conflicting predefinedValues for the same properties, the certificate issuance request will fail. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicy#baselineValues
   */
  readonly baselineValues?: CaPoolSpecForProviderIssuancePolicyBaselineValues[];

  /**
   * Describes constraints on identities that may appear in Certificates issued through this CaPool. If this is omitted, then this CaPool will not add restrictions on a certificate's identity. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicy#identityConstraints
   */
  readonly identityConstraints?: CaPoolSpecForProviderIssuancePolicyIdentityConstraints[];

  /**
   * The maximum lifetime allowed for issued Certificates. Note that if the issuing CertificateAuthority expires before a Certificate's requested maximumLifetime, the effective lifetime will be explicitly truncated to match it.
   *
   * @schema CaPoolSpecForProviderIssuancePolicy#maximumLifetime
   */
  readonly maximumLifetime?: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicy(obj: CaPoolSpecForProviderIssuancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIssuanceModes': obj.allowedIssuanceModes?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes(y)),
    'allowedKeyTypes': obj.allowedKeyTypes?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes(y)),
    'baselineValues': obj.baselineValues?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValues(y)),
    'identityConstraints': obj.identityConstraints?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyIdentityConstraints(y)),
    'maximumLifetime': obj.maximumLifetime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderPublishingOptions
 */
export interface CaPoolSpecForProviderPublishingOptions {
  /**
   * When true, publishes each CertificateAuthority's CA certificate and includes its URL in the "Authority Information Access" X.509 extension in all issued Certificates. If this is false, the CA certificate will not be published and the corresponding X.509 extension will not be written in issued certificates.
   *
   * @schema CaPoolSpecForProviderPublishingOptions#publishCaCert
   */
  readonly publishCaCert: boolean;

  /**
   * When true, publishes each CertificateAuthority's CRL and includes its URL in the "CRL Distribution Points" X.509 extension in all issued Certificates. If this is false, CRLs will not be published and the corresponding X.509 extension will not be written in issued certificates. CRLs will expire 7 days from their creation. However, we will rebuild daily. CRLs are also rebuilt shortly after a certificate is revoked.
   *
   * @schema CaPoolSpecForProviderPublishingOptions#publishCrl
   */
  readonly publishCrl: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderPublishingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderPublishingOptions(obj: CaPoolSpecForProviderPublishingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publishCaCert': obj.publishCaCert,
    'publishCrl': obj.publishCrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CaPoolSpecProviderConfigRefPolicy
 */
export interface CaPoolSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CaPoolSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CaPoolSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecProviderConfigRefPolicy(obj: CaPoolSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CaPoolSpecProviderRefPolicy
 */
export interface CaPoolSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CaPoolSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CaPoolSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecProviderRefPolicy(obj: CaPoolSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CaPoolSpecPublishConnectionDetailsToConfigRef
 */
export interface CaPoolSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CaPoolSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CaPoolSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecPublishConnectionDetailsToConfigRef(obj: CaPoolSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CaPoolSpecPublishConnectionDetailsToMetadata
 */
export interface CaPoolSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CaPoolSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecPublishConnectionDetailsToMetadata(obj: CaPoolSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes
 */
export interface CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes {
  /**
   * When true, allows callers to create Certificates by specifying a CertificateConfig.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes#allowConfigBasedIssuance
   */
  readonly allowConfigBasedIssuance: boolean;

  /**
   * When true, allows callers to create Certificates by specifying a CSR.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes#allowCsrBasedIssuance
   */
  readonly allowCsrBasedIssuance: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes(obj: CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowConfigBasedIssuance': obj.allowConfigBasedIssuance,
    'allowCsrBasedIssuance': obj.allowCsrBasedIssuance,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes
 */
export interface CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes {
  /**
   * Represents an allowed Elliptic Curve key type. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes#ellipticCurve
   */
  readonly ellipticCurve?: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve[];

  /**
   * Describes an RSA key that may be used in a Certificate issued from a CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes#rsa
   */
  readonly rsa?: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes(obj: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ellipticCurve': obj.ellipticCurve?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve(y)),
    'rsa': obj.rsa?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValues {
  /**
   * Specifies an X.509 extension, which may be used in different parts of X.509 objects like certificates, CSRs, and CRLs. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#additionalExtensions
   */
  readonly additionalExtensions?: CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions[];

  /**
   * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#caOptions
   */
  readonly caOptions: CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions[];

  /**
   * Indicates the intended use for keys that correspond to a certificate. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#keyUsage
   */
  readonly keyUsage: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage[];

  /**
   * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#policyIds
   */
  readonly policyIds?: CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValues(obj: CaPoolSpecForProviderIssuancePolicyBaselineValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraints
 */
export interface CaPoolSpecForProviderIssuancePolicyIdentityConstraints {
  /**
   * If this is set, the SubjectAltNames extension may be copied from a certificate request into the signed certificate. Otherwise, the requested SubjectAltNames will be discarded.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraints#allowSubjectAltNamesPassthrough
   */
  readonly allowSubjectAltNamesPassthrough: boolean;

  /**
   * If this is set, the Subject field may be copied from a certificate request into the signed certificate. Otherwise, the requested Subject will be discarded.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraints#allowSubjectPassthrough
   */
  readonly allowSubjectPassthrough: boolean;

  /**
   * A CEL expression that may be used to validate the resolved X.509 Subject and/or Subject Alternative Name before a certificate is signed. To see the full allowed syntax and some examples, see https://cloud.google.com/certificate-authority-service/docs/cel-guide Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraints#celExpression
   */
  readonly celExpression?: CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyIdentityConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyIdentityConstraints(obj: CaPoolSpecForProviderIssuancePolicyIdentityConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSubjectAltNamesPassthrough': obj.allowSubjectAltNamesPassthrough,
    'allowSubjectPassthrough': obj.allowSubjectPassthrough,
    'celExpression': obj.celExpression?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolSpecProviderConfigRefPolicyResolution
 */
export enum CaPoolSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolSpecProviderConfigRefPolicyResolve
 */
export enum CaPoolSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolSpecProviderRefPolicyResolution
 */
export enum CaPoolSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolSpecProviderRefPolicyResolve
 */
export enum CaPoolSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CaPoolSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CaPoolSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj: CaPoolSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve
 */
export interface CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve {
  /**
   * The algorithm used. Possible values are ECDSA_P256, ECDSA_P384, and EDDSA_25519.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve#signatureAlgorithm
   */
  readonly signatureAlgorithm: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve(obj: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa
 */
export interface CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa {
  /**
   * The maximum allowed RSA modulus size, in bits. If this is not set, or if set to zero, the service will not enforce an explicit upper bound on RSA modulus sizes.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa#maxModulusSize
   */
  readonly maxModulusSize?: string;

  /**
   * The minimum allowed RSA modulus size, in bits. If this is not set, or if set to zero, the service-level min RSA modulus size will continue to apply.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa#minModulusSize
   */
  readonly minModulusSize?: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa(obj: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxModulusSize': obj.maxModulusSize,
    'minModulusSize': obj.minModulusSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions {
  /**
   * Indicates whether or not this extension is critical (i.e., if the client does not know how to handle this extension, the client should consider this to be an error).
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions#critical
   */
  readonly critical: boolean;

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions#objectId
   */
  readonly objectId: CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId[];

  /**
   * The value of this X.509 extension. A base64-encoded string.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions {
  /**
   * When true, the "CA" in Basic Constraints extension will be set to true.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

  /**
   * When true, the "CA" in Basic Constraints extension will be set to false. If both is_ca and non_ca are unset, the extension will be omitted from the CA certificate.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions#nonCa
   */
  readonly nonCa?: boolean;

  /**
   * When true, the "path length constraint" in Basic Constraints extension will be set to 0. if both max_issuer_path_length and zero_max_issuer_path_length are unset, the max path length will be omitted from the CA certificate.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions#zeroMaxIssuerPathLength
   */
  readonly zeroMaxIssuerPathLength?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
    'nonCa': obj.nonCa,
    'zeroMaxIssuerPathLength': obj.zeroMaxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage {
  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage[];

  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage[];

  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression
 */
export interface CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression {
  /**
   * Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression#description
   */
  readonly description?: string;

  /**
   * Textual representation of an expression in Common Expression Language syntax.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression#expression
   */
  readonly expression: string;

  /**
   * Location of the CaPool. A full list of valid locations can be found by running gcloud privateca locations list.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression#location
   */
  readonly location?: string;

  /**
   * Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression(obj: CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'location': obj.location,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage {
  /**
   * The key may be used to sign certificates.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * The key may be used sign certificate revocation lists.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * The key may be used to encipher data.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * The key may be used to decipher only.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * The key may be used for digital signatures.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * The key may be used to encipher only.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * The key may be used in a key agreement protocol.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * The key may be used to encipher other keys.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CAPoolIAMMember is the Schema for the CAPoolIAMMembers API. <no value>
 *
 * @schema CAPoolIAMMember
 */
export class CaPoolIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CAPoolIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'CAPoolIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "CAPoolIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CaPoolIamMemberProps): any {
    return {
      ...CaPoolIamMember.GVK,
      ...toJson_CaPoolIamMemberProps(props),
    };
  }

  /**
   * Defines a "CAPoolIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CaPoolIamMemberProps) {
    super(scope, id, {
      ...CaPoolIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CaPoolIamMember.GVK,
      ...toJson_CaPoolIamMemberProps(resolved),
    };
  }
}

/**
 * CAPoolIAMMember is the Schema for the CAPoolIAMMembers API. <no value>
 *
 * @schema CAPoolIAMMember
 */
export interface CaPoolIamMemberProps {
  /**
   * @schema CAPoolIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CAPoolIAMMemberSpec defines the desired state of CAPoolIAMMember
   *
   * @schema CAPoolIAMMember#spec
   */
  readonly spec: CaPoolIamMemberSpec;

}

/**
 * Converts an object of type 'CaPoolIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberProps(obj: CaPoolIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CaPoolIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CAPoolIAMMemberSpec defines the desired state of CAPoolIAMMember
 *
 * @schema CaPoolIamMemberSpec
 */
export interface CaPoolIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema CaPoolIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: CaPoolIamMemberSpecDeletionPolicy;

  /**
   * @schema CaPoolIamMemberSpec#forProvider
   */
  readonly forProvider: CaPoolIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CaPoolIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: CaPoolIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CaPoolIamMemberSpec#providerRef
   */
  readonly providerRef?: CaPoolIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CaPoolIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CaPoolIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CaPoolIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CaPoolIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpec(obj: CaPoolIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CaPoolIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_CaPoolIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CaPoolIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CaPoolIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CaPoolIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema CaPoolIamMemberSpecDeletionPolicy
 */
export enum CaPoolIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CaPoolIamMemberSpecForProvider
 */
export interface CaPoolIamMemberSpecForProvider {
  /**
   * @schema CaPoolIamMemberSpecForProvider#caPool
   */
  readonly caPool?: string;

  /**
   * Reference to a CAPool to populate caPool.
   *
   * @schema CaPoolIamMemberSpecForProvider#caPoolRef
   */
  readonly caPoolRef?: CaPoolIamMemberSpecForProviderCaPoolRef;

  /**
   * Selector for a CAPool to populate caPool.
   *
   * @schema CaPoolIamMemberSpecForProvider#caPoolSelector
   */
  readonly caPoolSelector?: CaPoolIamMemberSpecForProviderCaPoolSelector;

  /**
   * @schema CaPoolIamMemberSpecForProvider#condition
   */
  readonly condition?: CaPoolIamMemberSpecForProviderCondition[];

  /**
   * @schema CaPoolIamMemberSpecForProvider#location
   */
  readonly location?: string;

  /**
   * @schema CaPoolIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema CaPoolIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema CaPoolIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProvider(obj: CaPoolIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caPool': obj.caPool,
    'caPoolRef': toJson_CaPoolIamMemberSpecForProviderCaPoolRef(obj.caPoolRef),
    'caPoolSelector': toJson_CaPoolIamMemberSpecForProviderCaPoolSelector(obj.caPoolSelector),
    'condition': obj.condition?.map(y => toJson_CaPoolIamMemberSpecForProviderCondition(y)),
    'location': obj.location,
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CaPoolIamMemberSpecProviderConfigRef
 */
export interface CaPoolIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: CaPoolIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecProviderConfigRef(obj: CaPoolIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CaPoolIamMemberSpecProviderRef
 */
export interface CaPoolIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolIamMemberSpecProviderRef#policy
   */
  readonly policy?: CaPoolIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecProviderRef(obj: CaPoolIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsTo
 */
export interface CaPoolIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CaPoolIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecPublishConnectionDetailsTo(obj: CaPoolIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CaPoolIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CaPoolIamMemberSpecWriteConnectionSecretToRef
 */
export interface CaPoolIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CaPoolIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CaPoolIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecWriteConnectionSecretToRef(obj: CaPoolIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CAPool to populate caPool.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolRef
 */
export interface CaPoolIamMemberSpecForProviderCaPoolRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolRef#policy
   */
  readonly policy?: CaPoolIamMemberSpecForProviderCaPoolRefPolicy;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProviderCaPoolRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProviderCaPoolRef(obj: CaPoolIamMemberSpecForProviderCaPoolRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolIamMemberSpecForProviderCaPoolRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CAPool to populate caPool.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolSelector
 */
export interface CaPoolIamMemberSpecForProviderCaPoolSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolSelector#policy
   */
  readonly policy?: CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProviderCaPoolSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProviderCaPoolSelector(obj: CaPoolIamMemberSpecForProviderCaPoolSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolIamMemberSpecForProviderCondition
 */
export interface CaPoolIamMemberSpecForProviderCondition {
  /**
   * @schema CaPoolIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema CaPoolIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema CaPoolIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProviderCondition(obj: CaPoolIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CaPoolIamMemberSpecProviderConfigRefPolicy
 */
export interface CaPoolIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CaPoolIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CaPoolIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecProviderConfigRefPolicy(obj: CaPoolIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CaPoolIamMemberSpecProviderRefPolicy
 */
export interface CaPoolIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CaPoolIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CaPoolIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecProviderRefPolicy(obj: CaPoolIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef(obj: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface CaPoolIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecPublishConnectionDetailsToMetadata(obj: CaPoolIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolRefPolicy
 */
export interface CaPoolIamMemberSpecForProviderCaPoolRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolRefPolicy#resolution
   */
  readonly resolution?: CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolRefPolicy#resolve
   */
  readonly resolve?: CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProviderCaPoolRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProviderCaPoolRefPolicy(obj: CaPoolIamMemberSpecForProviderCaPoolRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy
 */
export interface CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy#resolution
   */
  readonly resolution?: CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy#resolve
   */
  readonly resolve?: CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy(obj: CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum CaPoolIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum CaPoolIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolIamMemberSpecProviderRefPolicyResolution
 */
export enum CaPoolIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolIamMemberSpecProviderRefPolicyResolve
 */
export enum CaPoolIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolution
 */
export enum CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolve
 */
export enum CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolution
 */
export enum CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolve
 */
export enum CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Certificate is the Schema for the Certificates API. A Certificate corresponds to a signed X.
 *
 * @schema Certificate
 */
export class Certificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Certificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'Certificate',
  }

  /**
   * Renders a Kubernetes manifest for "Certificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateProps): any {
    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(props),
    };
  }

  /**
   * Defines a "Certificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateProps) {
    super(scope, id, {
      ...Certificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(resolved),
    };
  }
}

/**
 * Certificate is the Schema for the Certificates API. A Certificate corresponds to a signed X.
 *
 * @schema Certificate
 */
export interface CertificateProps {
  /**
   * @schema Certificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateSpec defines the desired state of Certificate
   *
   * @schema Certificate#spec
   */
  readonly spec: CertificateSpec;

}

/**
 * Converts an object of type 'CertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateProps(obj: CertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateSpec defines the desired state of Certificate
 *
 * @schema CertificateSpec
 */
export interface CertificateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema CertificateSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateSpecDeletionPolicy;

  /**
   * @schema CertificateSpec#forProvider
   */
  readonly forProvider: CertificateSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CertificateSpec#providerRef
   */
  readonly providerRef?: CertificateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpec(obj: CertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_CertificateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CertificateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CertificateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema CertificateSpecDeletionPolicy
 */
export enum CertificateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateSpecForProvider
 */
export interface CertificateSpecForProvider {
  /**
   * The Certificate Authority ID that should issue the certificate. For example, to issue a Certificate from a Certificate Authority with resource name projects/my-project/locations/us-central1/caPools/my-pool/certificateAuthorities/my-ca, argument pool should be set to projects/my-project/locations/us-central1/caPools/my-pool, argument certificate_authority should be set to my-ca.
   *
   * @schema CertificateSpecForProvider#certificateAuthority
   */
  readonly certificateAuthority?: string;

  /**
   * Reference to a CertificateAuthority in privateca to populate certificateAuthority.
   *
   * @schema CertificateSpecForProvider#certificateAuthorityRef
   */
  readonly certificateAuthorityRef?: CertificateSpecForProviderCertificateAuthorityRef;

  /**
   * Selector for a CertificateAuthority in privateca to populate certificateAuthority.
   *
   * @schema CertificateSpecForProvider#certificateAuthoritySelector
   */
  readonly certificateAuthoritySelector?: CertificateSpecForProviderCertificateAuthoritySelector;

  /**
   * The resource name for a CertificateTemplate used to issue this certificate, in the format projects/_/locations/_/certificateTemplates/*. If this is specified, the caller must have the necessary permission to use this template. If this is omitted, no template will be used. This template must be in the same location as the Certificate.
   *
   * @schema CertificateSpecForProvider#certificateTemplate
   */
  readonly certificateTemplate?: string;

  /**
   * Reference to a CertificateTemplate in privateca to populate certificateTemplate.
   *
   * @schema CertificateSpecForProvider#certificateTemplateRef
   */
  readonly certificateTemplateRef?: CertificateSpecForProviderCertificateTemplateRef;

  /**
   * Selector for a CertificateTemplate in privateca to populate certificateTemplate.
   *
   * @schema CertificateSpecForProvider#certificateTemplateSelector
   */
  readonly certificateTemplateSelector?: CertificateSpecForProviderCertificateTemplateSelector;

  /**
   * The config used to create a self-signed X.509 certificate or CSR. Structure is documented below.
   *
   * @schema CertificateSpecForProvider#config
   */
  readonly config?: CertificateSpecForProviderConfig[];

  /**
   * Labels with user-defined metadata to apply to this resource.
   *
   * @schema CertificateSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The desired lifetime of the CA certificate. Used to create the "notBeforeTime" and "notAfterTime" fields inside an X.509 certificate. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema CertificateSpecForProvider#lifetime
   */
  readonly lifetime?: string;

  /**
   * Location of the Certificate. A full list of valid locations can be found by running gcloud privateca locations list.
   *
   * @schema CertificateSpecForProvider#location
   */
  readonly location: string;

  /**
   * Immutable. A pem-encoded X.509 certificate signing request (CSR).
   *
   * @schema CertificateSpecForProvider#pemCsr
   */
  readonly pemCsr?: string;

  /**
   * The name of the CaPool this Certificate belongs to.
   *
   * @schema CertificateSpecForProvider#pool
   */
  readonly pool?: string;

  /**
   * Reference to a CAPool to populate pool.
   *
   * @schema CertificateSpecForProvider#poolRef
   */
  readonly poolRef?: CertificateSpecForProviderPoolRef;

  /**
   * Selector for a CAPool to populate pool.
   *
   * @schema CertificateSpecForProvider#poolSelector
   */
  readonly poolSelector?: CertificateSpecForProviderPoolSelector;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema CertificateSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'CertificateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProvider(obj: CertificateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthority': obj.certificateAuthority,
    'certificateAuthorityRef': toJson_CertificateSpecForProviderCertificateAuthorityRef(obj.certificateAuthorityRef),
    'certificateAuthoritySelector': toJson_CertificateSpecForProviderCertificateAuthoritySelector(obj.certificateAuthoritySelector),
    'certificateTemplate': obj.certificateTemplate,
    'certificateTemplateRef': toJson_CertificateSpecForProviderCertificateTemplateRef(obj.certificateTemplateRef),
    'certificateTemplateSelector': toJson_CertificateSpecForProviderCertificateTemplateSelector(obj.certificateTemplateSelector),
    'config': obj.config?.map(y => toJson_CertificateSpecForProviderConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifetime': obj.lifetime,
    'location': obj.location,
    'pemCsr': obj.pemCsr,
    'pool': obj.pool,
    'poolRef': toJson_CertificateSpecForProviderPoolRef(obj.poolRef),
    'poolSelector': toJson_CertificateSpecForProviderPoolSelector(obj.poolSelector),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateSpecProviderConfigRef
 */
export interface CertificateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRef(obj: CertificateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CertificateSpecProviderRef
 */
export interface CertificateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecProviderRef#policy
   */
  readonly policy?: CertificateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderRef(obj: CertificateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateSpecPublishConnectionDetailsTo
 */
export interface CertificateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsTo(obj: CertificateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateSpecWriteConnectionSecretToRef
 */
export interface CertificateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecWriteConnectionSecretToRef(obj: CertificateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateAuthority in privateca to populate certificateAuthority.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityRef
 */
export interface CertificateSpecForProviderCertificateAuthorityRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityRef#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateAuthorityRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityRef(obj: CertificateSpecForProviderCertificateAuthorityRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecForProviderCertificateAuthorityRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateAuthority in privateca to populate certificateAuthority.
 *
 * @schema CertificateSpecForProviderCertificateAuthoritySelector
 */
export interface CertificateSpecForProviderCertificateAuthoritySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateSpecForProviderCertificateAuthoritySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateSpecForProviderCertificateAuthoritySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateSpecForProviderCertificateAuthoritySelector#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateAuthoritySelectorPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthoritySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthoritySelector(obj: CertificateSpecForProviderCertificateAuthoritySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateSpecForProviderCertificateAuthoritySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateTemplate in privateca to populate certificateTemplate.
 *
 * @schema CertificateSpecForProviderCertificateTemplateRef
 */
export interface CertificateSpecForProviderCertificateTemplateRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecForProviderCertificateTemplateRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecForProviderCertificateTemplateRef#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateTemplateRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateTemplateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateTemplateRef(obj: CertificateSpecForProviderCertificateTemplateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecForProviderCertificateTemplateRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateTemplate in privateca to populate certificateTemplate.
 *
 * @schema CertificateSpecForProviderCertificateTemplateSelector
 */
export interface CertificateSpecForProviderCertificateTemplateSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateSpecForProviderCertificateTemplateSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateSpecForProviderCertificateTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateSpecForProviderCertificateTemplateSelector#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateTemplateSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateTemplateSelector(obj: CertificateSpecForProviderCertificateTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateSpecForProviderCertificateTemplateSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfig
 */
export interface CertificateSpecForProviderConfig {
  /**
   * A PublicKey describes a public key. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfig#publicKey
   */
  readonly publicKey: CertificateSpecForProviderConfigPublicKey[];

  /**
   * Specifies some of the values in a certificate that are related to the subject. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfig#subjectConfig
   */
  readonly subjectConfig: CertificateSpecForProviderConfigSubjectConfig[];

  /**
   * Describes how some of the technical X.509 fields in a certificate should be populated. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfig#x509Config
   */
  readonly x509Config: CertificateSpecForProviderConfigX509Config[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfig(obj: CertificateSpecForProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicKey': obj.publicKey?.map(y => toJson_CertificateSpecForProviderConfigPublicKey(y)),
    'subjectConfig': obj.subjectConfig?.map(y => toJson_CertificateSpecForProviderConfigSubjectConfig(y)),
    'x509Config': obj.x509Config?.map(y => toJson_CertificateSpecForProviderConfigX509Config(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CAPool to populate pool.
 *
 * @schema CertificateSpecForProviderPoolRef
 */
export interface CertificateSpecForProviderPoolRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecForProviderPoolRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecForProviderPoolRef#policy
   */
  readonly policy?: CertificateSpecForProviderPoolRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderPoolRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderPoolRef(obj: CertificateSpecForProviderPoolRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecForProviderPoolRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CAPool to populate pool.
 *
 * @schema CertificateSpecForProviderPoolSelector
 */
export interface CertificateSpecForProviderPoolSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateSpecForProviderPoolSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateSpecForProviderPoolSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateSpecForProviderPoolSelector#policy
   */
  readonly policy?: CertificateSpecForProviderPoolSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderPoolSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderPoolSelector(obj: CertificateSpecForProviderPoolSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateSpecForProviderPoolSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecProviderConfigRefPolicy
 */
export interface CertificateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRefPolicy(obj: CertificateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecProviderRefPolicy
 */
export interface CertificateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderRefPolicy(obj: CertificateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj: CertificateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj: CertificateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityRefPolicy
 */
export interface CertificateSpecForProviderCertificateAuthorityRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateAuthorityRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateAuthorityRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityRefPolicy(obj: CertificateSpecForProviderCertificateAuthorityRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateSpecForProviderCertificateAuthoritySelectorPolicy
 */
export interface CertificateSpecForProviderCertificateAuthoritySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateAuthoritySelectorPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateAuthoritySelectorPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthoritySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthoritySelectorPolicy(obj: CertificateSpecForProviderCertificateAuthoritySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecForProviderCertificateTemplateRefPolicy
 */
export interface CertificateSpecForProviderCertificateTemplateRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateTemplateRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateTemplateRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateTemplateRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateTemplateRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateTemplateRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateTemplateRefPolicy(obj: CertificateSpecForProviderCertificateTemplateRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateSpecForProviderCertificateTemplateSelectorPolicy
 */
export interface CertificateSpecForProviderCertificateTemplateSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateTemplateSelectorPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateTemplateSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateTemplateSelectorPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateTemplateSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateTemplateSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateTemplateSelectorPolicy(obj: CertificateSpecForProviderCertificateTemplateSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigPublicKey
 */
export interface CertificateSpecForProviderConfigPublicKey {
  /**
   * The format of the public key. Currently, only PEM format is supported. Possible values are KEY_TYPE_UNSPECIFIED and PEM.
   *
   * @schema CertificateSpecForProviderConfigPublicKey#format
   */
  readonly format: string;

  /**
   * Required. A public key. When this is specified in a request, the padding and encoding can be any of the options described by the respective 'KeyType' value. When this is generated by the service, it will always be an RFC 5280 SubjectPublicKeyInfo structure containing an algorithm identifier and a key. A base64-encoded string.
   *
   * @schema CertificateSpecForProviderConfigPublicKey#keySecretRef
   */
  readonly keySecretRef?: CertificateSpecForProviderConfigPublicKeyKeySecretRef;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigPublicKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigPublicKey(obj: CertificateSpecForProviderConfigPublicKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'keySecretRef': toJson_CertificateSpecForProviderConfigPublicKeyKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigSubjectConfig
 */
export interface CertificateSpecForProviderConfigSubjectConfig {
  /**
   * Contains distinguished name fields such as the location and organization. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfig#subject
   */
  readonly subject: CertificateSpecForProviderConfigSubjectConfigSubject[];

  /**
   * The subject alternative name fields. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfig#subjectAltName
   */
  readonly subjectAltName?: CertificateSpecForProviderConfigSubjectConfigSubjectAltName[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigSubjectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigSubjectConfig(obj: CertificateSpecForProviderConfigSubjectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subject': obj.subject?.map(y => toJson_CertificateSpecForProviderConfigSubjectConfigSubject(y)),
    'subjectAltName': obj.subjectAltName?.map(y => toJson_CertificateSpecForProviderConfigSubjectConfigSubjectAltName(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509Config
 */
export interface CertificateSpecForProviderConfigX509Config {
  /**
   * Describes custom X.509 extensions. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509Config#additionalExtensions
   */
  readonly additionalExtensions?: CertificateSpecForProviderConfigX509ConfigAdditionalExtensions[];

  /**
   * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CertificateSpecForProviderConfigX509Config#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509Config#caOptions
   */
  readonly caOptions?: CertificateSpecForProviderConfigX509ConfigCaOptions[];

  /**
   * Indicates the intended use for keys that correspond to a certificate. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509Config#keyUsage
   */
  readonly keyUsage: CertificateSpecForProviderConfigX509ConfigKeyUsage[];

  /**
   * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509Config#policyIds
   */
  readonly policyIds?: CertificateSpecForProviderConfigX509ConfigPolicyIds[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509Config' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509Config(obj: CertificateSpecForProviderConfigX509Config | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigKeyUsage(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecForProviderPoolRefPolicy
 */
export interface CertificateSpecForProviderPoolRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderPoolRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderPoolRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderPoolRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderPoolRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderPoolRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderPoolRefPolicy(obj: CertificateSpecForProviderPoolRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateSpecForProviderPoolSelectorPolicy
 */
export interface CertificateSpecForProviderPoolSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderPoolSelectorPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderPoolSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderPoolSelectorPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderPoolSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderPoolSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderPoolSelectorPolicy(obj: CertificateSpecForProviderPoolSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolution
 */
export enum CertificateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolve
 */
export enum CertificateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecProviderRefPolicyResolution
 */
export enum CertificateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecProviderRefPolicyResolve
 */
export enum CertificateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityRefPolicyResolution
 */
export enum CertificateSpecForProviderCertificateAuthorityRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityRefPolicyResolve
 */
export enum CertificateSpecForProviderCertificateAuthorityRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolution
 */
export enum CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolve
 */
export enum CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateTemplateRefPolicyResolution
 */
export enum CertificateSpecForProviderCertificateTemplateRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateTemplateRefPolicyResolve
 */
export enum CertificateSpecForProviderCertificateTemplateRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateTemplateSelectorPolicyResolution
 */
export enum CertificateSpecForProviderCertificateTemplateSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateTemplateSelectorPolicyResolve
 */
export enum CertificateSpecForProviderCertificateTemplateSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Required. A public key. When this is specified in a request, the padding and encoding can be any of the options described by the respective 'KeyType' value. When this is generated by the service, it will always be an RFC 5280 SubjectPublicKeyInfo structure containing an algorithm identifier and a key. A base64-encoded string.
 *
 * @schema CertificateSpecForProviderConfigPublicKeyKeySecretRef
 */
export interface CertificateSpecForProviderConfigPublicKeyKeySecretRef {
  /**
   * The key to select.
   *
   * @schema CertificateSpecForProviderConfigPublicKeyKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema CertificateSpecForProviderConfigPublicKeyKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecForProviderConfigPublicKeyKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigPublicKeyKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigPublicKeyKeySecretRef(obj: CertificateSpecForProviderConfigPublicKeyKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigSubjectConfigSubject
 */
export interface CertificateSpecForProviderConfigSubjectConfigSubject {
  /**
   * The common name of the distinguished name.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#commonName
   */
  readonly commonName: string;

  /**
   * The country code of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#countryCode
   */
  readonly countryCode?: string;

  /**
   * The locality or city of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#locality
   */
  readonly locality?: string;

  /**
   * The organization of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#organization
   */
  readonly organization: string;

  /**
   * The organizational unit of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#organizationalUnit
   */
  readonly organizationalUnit?: string;

  /**
   * The postal code of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#postalCode
   */
  readonly postalCode?: string;

  /**
   * The province, territory, or regional state of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#province
   */
  readonly province?: string;

  /**
   * The street address of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#streetAddress
   */
  readonly streetAddress?: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigSubjectConfigSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigSubjectConfigSubject(obj: CertificateSpecForProviderConfigSubjectConfigSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'countryCode': obj.countryCode,
    'locality': obj.locality,
    'organization': obj.organization,
    'organizationalUnit': obj.organizationalUnit,
    'postalCode': obj.postalCode,
    'province': obj.province,
    'streetAddress': obj.streetAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigSubjectConfigSubjectAltName
 */
export interface CertificateSpecForProviderConfigSubjectConfigSubjectAltName {
  /**
   * Contains only valid, fully-qualified host names.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubjectAltName#dnsNames
   */
  readonly dnsNames?: string[];

  /**
   * Contains only valid RFC 2822 E-mail addresses.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubjectAltName#emailAddresses
   */
  readonly emailAddresses?: string[];

  /**
   * Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubjectAltName#ipAddresses
   */
  readonly ipAddresses?: string[];

  /**
   * Contains only valid RFC 3986 URIs.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubjectAltName#uris
   */
  readonly uris?: string[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigSubjectConfigSubjectAltName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigSubjectConfigSubjectAltName(obj: CertificateSpecForProviderConfigSubjectConfigSubjectAltName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsNames': obj.dnsNames?.map(y => y),
    'emailAddresses': obj.emailAddresses?.map(y => y),
    'ipAddresses': obj.ipAddresses?.map(y => y),
    'uris': obj.uris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensions
 */
export interface CertificateSpecForProviderConfigX509ConfigAdditionalExtensions {
  /**
   * Required. Indicates whether or not this extension is critical (i.e., if the client does not know how to handle this extension, the client should consider this to be an error).
   *
   * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensions#critical
   */
  readonly critical: boolean;

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensions#objectId
   */
  readonly objectId: CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId[];

  /**
   * The value of this X.509 extension.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensions#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigAdditionalExtensions(obj: CertificateSpecForProviderConfigX509ConfigAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigCaOptions
 */
export interface CertificateSpecForProviderConfigX509ConfigCaOptions {
  /**
   * When true, the "CA" in Basic Constraints extension will be set to true.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

  /**
   * When true, the "CA" in Basic Constraints extension will be set to false. If both is_ca and non_ca are unset, the extension will be omitted from the CA certificate.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigCaOptions#nonCa
   */
  readonly nonCa?: boolean;

  /**
   * When true, the "path length constraint" in Basic Constraints extension will be set to 0. if both max_issuer_path_length and zero_max_issuer_path_length are unset, the max path length will be omitted from the CA certificate.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigCaOptions#zeroMaxIssuerPathLength
   */
  readonly zeroMaxIssuerPathLength?: boolean;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigCaOptions(obj: CertificateSpecForProviderConfigX509ConfigCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
    'nonCa': obj.nonCa,
    'zeroMaxIssuerPathLength': obj.zeroMaxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigKeyUsage
 */
export interface CertificateSpecForProviderConfigX509ConfigKeyUsage {
  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage: CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage[];

  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage: CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage[];

  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigKeyUsage(obj: CertificateSpecForProviderConfigX509ConfigKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigPolicyIds
 */
export interface CertificateSpecForProviderConfigX509ConfigPolicyIds {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigPolicyIds#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigPolicyIds(obj: CertificateSpecForProviderConfigX509ConfigPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderPoolRefPolicyResolution
 */
export enum CertificateSpecForProviderPoolRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderPoolRefPolicyResolve
 */
export enum CertificateSpecForProviderPoolRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderPoolSelectorPolicyResolution
 */
export enum CertificateSpecForProviderPoolSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderPoolSelectorPolicyResolve
 */
export enum CertificateSpecForProviderPoolSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId
 */
export interface CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId(obj: CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage
 */
export interface CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage {
  /**
   * The key may be used to sign certificates.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * The key may be used sign certificate revocation lists.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * The key may be used to encipher data.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * The key may be used to decipher only.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * The key may be used for digital signatures.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * The key may be used to encipher only.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * The key may be used in a key agreement protocol.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * The key may be used to encipher other keys.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage(obj: CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage
 */
export interface CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage(obj: CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages
 */
export interface CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(obj: CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CertificateAuthority is the Schema for the CertificateAuthoritys API. A CertificateAuthority represents an individual Certificate Authority.
 *
 * @schema CertificateAuthority
 */
export class CertificateAuthority extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateAuthority"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'CertificateAuthority',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateAuthority".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateAuthorityProps): any {
    return {
      ...CertificateAuthority.GVK,
      ...toJson_CertificateAuthorityProps(props),
    };
  }

  /**
   * Defines a "CertificateAuthority" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateAuthorityProps) {
    super(scope, id, {
      ...CertificateAuthority.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateAuthority.GVK,
      ...toJson_CertificateAuthorityProps(resolved),
    };
  }
}

/**
 * CertificateAuthority is the Schema for the CertificateAuthoritys API. A CertificateAuthority represents an individual Certificate Authority.
 *
 * @schema CertificateAuthority
 */
export interface CertificateAuthorityProps {
  /**
   * @schema CertificateAuthority#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateAuthoritySpec defines the desired state of CertificateAuthority
   *
   * @schema CertificateAuthority#spec
   */
  readonly spec: CertificateAuthoritySpec;

}

/**
 * Converts an object of type 'CertificateAuthorityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityProps(obj: CertificateAuthorityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateAuthoritySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthoritySpec defines the desired state of CertificateAuthority
 *
 * @schema CertificateAuthoritySpec
 */
export interface CertificateAuthoritySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema CertificateAuthoritySpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateAuthoritySpecDeletionPolicy;

  /**
   * @schema CertificateAuthoritySpec#forProvider
   */
  readonly forProvider: CertificateAuthoritySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateAuthoritySpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateAuthoritySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CertificateAuthoritySpec#providerRef
   */
  readonly providerRef?: CertificateAuthoritySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateAuthoritySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateAuthoritySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateAuthoritySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateAuthoritySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateAuthoritySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpec(obj: CertificateAuthoritySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateAuthoritySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_CertificateAuthoritySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CertificateAuthoritySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CertificateAuthoritySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateAuthoritySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema CertificateAuthoritySpecDeletionPolicy
 */
export enum CertificateAuthoritySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateAuthoritySpecForProvider
 */
export interface CertificateAuthoritySpecForProvider {
  /**
   * The config used to create a self-signed X.509 certificate or CSR. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProvider#config
   */
  readonly config: CertificateAuthoritySpecForProviderConfig[];

  /**
   * @schema CertificateAuthoritySpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Desired state of the CertificateAuthority. Set this field to STAGED to create a STAGED root CA.
   *
   * @schema CertificateAuthoritySpecForProvider#desiredState
   */
  readonly desiredState?: string;

  /**
   * The name of a Cloud Storage bucket where this CertificateAuthority will publish content, such as the CA certificate and CRLs. This must be a bucket name, without any prefixes (such as gs://) or suffixes (such as .googleapis.com). For example, to use a bucket named my-bucket, you would simply specify my-bucket. If not specified, a managed bucket will be created.
   *
   * @schema CertificateAuthoritySpecForProvider#gcsBucket
   */
  readonly gcsBucket?: string;

  /**
   * This field allows the CA to be deleted even if the CA has active certs. Active certs include both unrevoked and unexpired certs. Use with care. Defaults to false.
   *
   * @default false.
   * @schema CertificateAuthoritySpecForProvider#ignoreActiveCertificatesOnDeletion
   */
  readonly ignoreActiveCertificatesOnDeletion?: boolean;

  /**
   * Used when issuing certificates for this CertificateAuthority. If this CertificateAuthority is a self-signed CertificateAuthority, this key is also used to sign the self-signed CA certificate. Otherwise, it is used to sign a CSR. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProvider#keySpec
   */
  readonly keySpec: CertificateAuthoritySpecForProviderKeySpec[];

  /**
   * Labels with user-defined metadata. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema CertificateAuthoritySpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The desired lifetime of the CA certificate. Used to create the "notBeforeTime" and "notAfterTime" fields inside an X.509 certificate. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema CertificateAuthoritySpecForProvider#lifetime
   */
  readonly lifetime?: string;

  /**
   * Location of the CertificateAuthority. A full list of valid locations can be found by running gcloud privateca locations list.
   *
   * @schema CertificateAuthoritySpecForProvider#location
   */
  readonly location: string;

  /**
   * The signed CA certificate issued from the subordinated CA's CSR. This is needed when activating the subordiante CA with a third party issuer.
   *
   * @schema CertificateAuthoritySpecForProvider#pemCaCertificate
   */
  readonly pemCaCertificate?: string;

  /**
   * The name of the CaPool this Certificate Authority belongs to.
   *
   * @schema CertificateAuthoritySpecForProvider#pool
   */
  readonly pool?: string;

  /**
   * Reference to a CAPool to populate pool.
   *
   * @schema CertificateAuthoritySpecForProvider#poolRef
   */
  readonly poolRef?: CertificateAuthoritySpecForProviderPoolRef;

  /**
   * Selector for a CAPool to populate pool.
   *
   * @schema CertificateAuthoritySpecForProvider#poolSelector
   */
  readonly poolSelector?: CertificateAuthoritySpecForProviderPoolSelector;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema CertificateAuthoritySpecForProvider#project
   */
  readonly project?: string;

  /**
   * If this flag is set, the Certificate Authority will be deleted as soon as possible without a 30-day grace period where undeletion would have been allowed. If you proceed, there will be no way to recover this CA. Use with care. Defaults to false.
   *
   * @default false.
   * @schema CertificateAuthoritySpecForProvider#skipGracePeriod
   */
  readonly skipGracePeriod?: boolean;

  /**
   * If this is a subordinate CertificateAuthority, this field will be set with the subordinate configuration, which describes its issuers. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProvider#subordinateConfig
   */
  readonly subordinateConfig?: CertificateAuthoritySpecForProviderSubordinateConfig[];

  /**
   * The Type of this CertificateAuthority. ~> Note: For SUBORDINATE Certificate Authorities, they need to be activated before they can issue certificates. Default value is SELF_SIGNED. Possible values are SELF_SIGNED and SUBORDINATE.
   *
   * @schema CertificateAuthoritySpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProvider(obj: CertificateAuthoritySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config?.map(y => toJson_CertificateAuthoritySpecForProviderConfig(y)),
    'deletionProtection': obj.deletionProtection,
    'desiredState': obj.desiredState,
    'gcsBucket': obj.gcsBucket,
    'ignoreActiveCertificatesOnDeletion': obj.ignoreActiveCertificatesOnDeletion,
    'keySpec': obj.keySpec?.map(y => toJson_CertificateAuthoritySpecForProviderKeySpec(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifetime': obj.lifetime,
    'location': obj.location,
    'pemCaCertificate': obj.pemCaCertificate,
    'pool': obj.pool,
    'poolRef': toJson_CertificateAuthoritySpecForProviderPoolRef(obj.poolRef),
    'poolSelector': toJson_CertificateAuthoritySpecForProviderPoolSelector(obj.poolSelector),
    'project': obj.project,
    'skipGracePeriod': obj.skipGracePeriod,
    'subordinateConfig': obj.subordinateConfig?.map(y => toJson_CertificateAuthoritySpecForProviderSubordinateConfig(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateAuthoritySpecProviderConfigRef
 */
export interface CertificateAuthoritySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecProviderConfigRef#policy
   */
  readonly policy?: CertificateAuthoritySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderConfigRef(obj: CertificateAuthoritySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CertificateAuthoritySpecProviderRef
 */
export interface CertificateAuthoritySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecProviderRef#policy
   */
  readonly policy?: CertificateAuthoritySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderRef(obj: CertificateAuthoritySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsTo
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateAuthoritySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsTo(obj: CertificateAuthoritySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateAuthoritySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateAuthoritySpecWriteConnectionSecretToRef
 */
export interface CertificateAuthoritySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateAuthoritySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateAuthoritySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecWriteConnectionSecretToRef(obj: CertificateAuthoritySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfig
 */
export interface CertificateAuthoritySpecForProviderConfig {
  /**
   * Specifies some of the values in a certificate that are related to the subject. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfig#subjectConfig
   */
  readonly subjectConfig: CertificateAuthoritySpecForProviderConfigSubjectConfig[];

  /**
   * Describes how some of the technical X.509 fields in a certificate should be populated. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfig#x509Config
   */
  readonly x509Config: CertificateAuthoritySpecForProviderConfigX509Config[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfig(obj: CertificateAuthoritySpecForProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectConfig': obj.subjectConfig?.map(y => toJson_CertificateAuthoritySpecForProviderConfigSubjectConfig(y)),
    'x509Config': obj.x509Config?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509Config(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderKeySpec
 */
export interface CertificateAuthoritySpecForProviderKeySpec {
  /**
   * The algorithm to use for creating a managed Cloud KMS key for a for a simplified experience. All managed keys will be have their ProtectionLevel as HSM. Possible values are SIGN_HASH_ALGORITHM_UNSPECIFIED, RSA_PSS_2048_SHA256, RSA_PSS_3072_SHA256, RSA_PSS_4096_SHA256, RSA_PKCS1_2048_SHA256, RSA_PKCS1_3072_SHA256, RSA_PKCS1_4096_SHA256, EC_P256_SHA256, and EC_P384_SHA384.
   *
   * @schema CertificateAuthoritySpecForProviderKeySpec#algorithm
   */
  readonly algorithm?: string;

  /**
   * The resource name for an existing Cloud KMS CryptoKeyVersion in the format projects/_/locations/_/keyRings/_/cryptoKeys/_/cryptoKeyVersions/*.
   *
   * @schema CertificateAuthoritySpecForProviderKeySpec#cloudKmsKeyVersion
   */
  readonly cloudKmsKeyVersion?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderKeySpec(obj: CertificateAuthoritySpecForProviderKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'cloudKmsKeyVersion': obj.cloudKmsKeyVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CAPool to populate pool.
 *
 * @schema CertificateAuthoritySpecForProviderPoolRef
 */
export interface CertificateAuthoritySpecForProviderPoolRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecForProviderPoolRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecForProviderPoolRef#policy
   */
  readonly policy?: CertificateAuthoritySpecForProviderPoolRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderPoolRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderPoolRef(obj: CertificateAuthoritySpecForProviderPoolRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecForProviderPoolRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CAPool to populate pool.
 *
 * @schema CertificateAuthoritySpecForProviderPoolSelector
 */
export interface CertificateAuthoritySpecForProviderPoolSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateAuthoritySpecForProviderPoolSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateAuthoritySpecForProviderPoolSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateAuthoritySpecForProviderPoolSelector#policy
   */
  readonly policy?: CertificateAuthoritySpecForProviderPoolSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderPoolSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderPoolSelector(obj: CertificateAuthoritySpecForProviderPoolSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateAuthoritySpecForProviderPoolSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderSubordinateConfig
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfig {
  /**
   * This can refer to a CertificateAuthority that was used to create a subordinate CertificateAuthority. This field is used for information and usability purposes only. The resource name is in the format projects/_/locations/_/caPools/_/certificateAuthorities/*.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfig#certificateAuthority
   */
  readonly certificateAuthority?: string;

  /**
   * Reference to a CertificateAuthority in privateca to populate certificateAuthority.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfig#certificateAuthorityRef
   */
  readonly certificateAuthorityRef?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef;

  /**
   * Selector for a CertificateAuthority in privateca to populate certificateAuthority.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfig#certificateAuthoritySelector
   */
  readonly certificateAuthoritySelector?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector;

  /**
   * Contains the PEM certificate chain for the issuers of this CertificateAuthority, but not pem certificate for this CA itself. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfig#pemIssuerChain
   */
  readonly pemIssuerChain?: CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfig(obj: CertificateAuthoritySpecForProviderSubordinateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthority': obj.certificateAuthority,
    'certificateAuthorityRef': toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef(obj.certificateAuthorityRef),
    'certificateAuthoritySelector': toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector(obj.certificateAuthoritySelector),
    'pemIssuerChain': obj.pemIssuerChain?.map(y => toJson_CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicy
 */
export interface CertificateAuthoritySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderConfigRefPolicy(obj: CertificateAuthoritySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecProviderRefPolicy
 */
export interface CertificateAuthoritySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecProviderRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecProviderRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderRefPolicy(obj: CertificateAuthoritySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRef(obj: CertificateAuthoritySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToMetadata(obj: CertificateAuthoritySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigSubjectConfig
 */
export interface CertificateAuthoritySpecForProviderConfigSubjectConfig {
  /**
   * Contains distinguished name fields such as the location and organization. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfig#subject
   */
  readonly subject: CertificateAuthoritySpecForProviderConfigSubjectConfigSubject[];

  /**
   * The subject alternative name fields. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfig#subjectAltName
   */
  readonly subjectAltName?: CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigSubjectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigSubjectConfig(obj: CertificateAuthoritySpecForProviderConfigSubjectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subject': obj.subject?.map(y => toJson_CertificateAuthoritySpecForProviderConfigSubjectConfigSubject(y)),
    'subjectAltName': obj.subjectAltName?.map(y => toJson_CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509Config
 */
export interface CertificateAuthoritySpecForProviderConfigX509Config {
  /**
   * Specifies an X.509 extension, which may be used in different parts of X.509 objects like certificates, CSRs, and CRLs. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#additionalExtensions
   */
  readonly additionalExtensions?: CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions[];

  /**
   * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#caOptions
   */
  readonly caOptions: CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions[];

  /**
   * Indicates the intended use for keys that correspond to a certificate. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#keyUsage
   */
  readonly keyUsage: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage[];

  /**
   * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#policyIds
   */
  readonly policyIds?: CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509Config' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509Config(obj: CertificateAuthoritySpecForProviderConfigX509Config | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecForProviderPoolRefPolicy
 */
export interface CertificateAuthoritySpecForProviderPoolRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecForProviderPoolRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecForProviderPoolRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecForProviderPoolRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecForProviderPoolRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderPoolRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderPoolRefPolicy(obj: CertificateAuthoritySpecForProviderPoolRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateAuthoritySpecForProviderPoolSelectorPolicy
 */
export interface CertificateAuthoritySpecForProviderPoolSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecForProviderPoolSelectorPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecForProviderPoolSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecForProviderPoolSelectorPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecForProviderPoolSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderPoolSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderPoolSelectorPolicy(obj: CertificateAuthoritySpecForProviderPoolSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateAuthority in privateca to populate certificateAuthority.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef#policy
   */
  readonly policy?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef(obj: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateAuthority in privateca to populate certificateAuthority.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector#policy
   */
  readonly policy?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector(obj: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain {
  /**
   * Expected to be in leaf-to-root order according to RFC 5246.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain#pemCertificates
   */
  readonly pemCertificates?: string[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain(obj: CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pemCertificates': obj.pemCertificates?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicyResolution
 */
export enum CertificateAuthoritySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicyResolve
 */
export enum CertificateAuthoritySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecProviderRefPolicyResolution
 */
export enum CertificateAuthoritySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecProviderRefPolicyResolve
 */
export enum CertificateAuthoritySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject
 */
export interface CertificateAuthoritySpecForProviderConfigSubjectConfigSubject {
  /**
   * The common name of the distinguished name.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#commonName
   */
  readonly commonName: string;

  /**
   * The country code of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#countryCode
   */
  readonly countryCode?: string;

  /**
   * The locality or city of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#locality
   */
  readonly locality?: string;

  /**
   * The organization of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#organization
   */
  readonly organization: string;

  /**
   * The organizational unit of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#organizationalUnit
   */
  readonly organizationalUnit?: string;

  /**
   * The postal code of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#postalCode
   */
  readonly postalCode?: string;

  /**
   * The province, territory, or regional state of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#province
   */
  readonly province?: string;

  /**
   * The street address of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#streetAddress
   */
  readonly streetAddress?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigSubjectConfigSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigSubjectConfigSubject(obj: CertificateAuthoritySpecForProviderConfigSubjectConfigSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'countryCode': obj.countryCode,
    'locality': obj.locality,
    'organization': obj.organization,
    'organizationalUnit': obj.organizationalUnit,
    'postalCode': obj.postalCode,
    'province': obj.province,
    'streetAddress': obj.streetAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName
 */
export interface CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName {
  /**
   * Contains only valid, fully-qualified host names.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName#dnsNames
   */
  readonly dnsNames?: string[];

  /**
   * Contains only valid RFC 2822 E-mail addresses.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName#emailAddresses
   */
  readonly emailAddresses?: string[];

  /**
   * Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName#ipAddresses
   */
  readonly ipAddresses?: string[];

  /**
   * Contains only valid RFC 3986 URIs.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName#uris
   */
  readonly uris?: string[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName(obj: CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsNames': obj.dnsNames?.map(y => y),
    'emailAddresses': obj.emailAddresses?.map(y => y),
    'ipAddresses': obj.ipAddresses?.map(y => y),
    'uris': obj.uris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions {
  /**
   * Indicates whether or not this extension is critical (i.e., if the client does not know how to handle this extension, the client should consider this to be an error).
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions#critical
   */
  readonly critical: boolean;

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions#objectId
   */
  readonly objectId: CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId[];

  /**
   * The value of this X.509 extension. A base64-encoded string.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions(obj: CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions {
  /**
   * When true, the "CA" in Basic Constraints extension will be set to true.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions#isCa
   */
  readonly isCa: boolean;

  /**
   * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail. Setting the value to 0 requires setting zero_max_issuer_path_length = true.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

  /**
   * When true, the "CA" in Basic Constraints extension will be set to false. If both is_ca and non_ca are unset, the extension will be omitted from the CA certificate.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions#nonCa
   */
  readonly nonCa?: boolean;

  /**
   * When true, the "path length constraint" in Basic Constraints extension will be set to 0. If both max_issuer_path_length and zero_max_issuer_path_length are unset, the max path length will be omitted from the CA certificate.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions#zeroMaxIssuerPathLength
   */
  readonly zeroMaxIssuerPathLength?: boolean;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions(obj: CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
    'nonCa': obj.nonCa,
    'zeroMaxIssuerPathLength': obj.zeroMaxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage {
  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage[];

  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage[];

  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage(obj: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds(obj: CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecForProviderPoolRefPolicyResolution
 */
export enum CertificateAuthoritySpecForProviderPoolRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecForProviderPoolRefPolicyResolve
 */
export enum CertificateAuthoritySpecForProviderPoolRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecForProviderPoolSelectorPolicyResolution
 */
export enum CertificateAuthoritySpecForProviderPoolSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecForProviderPoolSelectorPolicyResolve
 */
export enum CertificateAuthoritySpecForProviderPoolSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy(obj: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy(obj: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId(obj: CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage {
  /**
   * The key may be used to sign certificates.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * The key may be used sign certificate revocation lists.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * The key may be used to encipher data.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * The key may be used to decipher only.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * The key may be used for digital signatures.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * The key may be used to encipher only.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * The key may be used in a key agreement protocol.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * The key may be used to encipher other keys.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage(obj: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage(obj: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(obj: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolution
 */
export enum CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolve
 */
export enum CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolution
 */
export enum CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolve
 */
export enum CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CertificateTemplate is the Schema for the CertificateTemplates API. Certificate Authority Service provides reusable and parameterized templates that you can use for common certificate issuance scenarios. A certificate template represents a relatively static and well-defined certificate issuance schema within an organization.  A certificate template can essentially become a full-fledged vertical certificate issuance framework.
 *
 * @schema CertificateTemplate
 */
export class CertificateTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'CertificateTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateTemplateProps): any {
    return {
      ...CertificateTemplate.GVK,
      ...toJson_CertificateTemplateProps(props),
    };
  }

  /**
   * Defines a "CertificateTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateTemplateProps) {
    super(scope, id, {
      ...CertificateTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateTemplate.GVK,
      ...toJson_CertificateTemplateProps(resolved),
    };
  }
}

/**
 * CertificateTemplate is the Schema for the CertificateTemplates API. Certificate Authority Service provides reusable and parameterized templates that you can use for common certificate issuance scenarios. A certificate template represents a relatively static and well-defined certificate issuance schema within an organization.  A certificate template can essentially become a full-fledged vertical certificate issuance framework.
 *
 * @schema CertificateTemplate
 */
export interface CertificateTemplateProps {
  /**
   * @schema CertificateTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateTemplateSpec defines the desired state of CertificateTemplate
   *
   * @schema CertificateTemplate#spec
   */
  readonly spec: CertificateTemplateSpec;

}

/**
 * Converts an object of type 'CertificateTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateProps(obj: CertificateTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateTemplateSpec defines the desired state of CertificateTemplate
 *
 * @schema CertificateTemplateSpec
 */
export interface CertificateTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema CertificateTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateTemplateSpecDeletionPolicy;

  /**
   * @schema CertificateTemplateSpec#forProvider
   */
  readonly forProvider: CertificateTemplateSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateTemplateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CertificateTemplateSpec#providerRef
   */
  readonly providerRef?: CertificateTemplateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpec(obj: CertificateTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateTemplateSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_CertificateTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CertificateTemplateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CertificateTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema CertificateTemplateSpecDeletionPolicy
 */
export enum CertificateTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateTemplateSpecForProvider
 */
export interface CertificateTemplateSpecForProvider {
  /**
   * Optional. A human-readable description of scenarios this template is intended for.
   *
   * @schema CertificateTemplateSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Optional. Describes constraints on identities that may be appear in Certificates issued using this template. If this is omitted, then this template will not add restrictions on a certificate's identity.
   *
   * @schema CertificateTemplateSpecForProvider#identityConstraints
   */
  readonly identityConstraints?: CertificateTemplateSpecForProviderIdentityConstraints[];

  /**
   * Optional. Labels with user-defined metadata.
   *
   * @schema CertificateTemplateSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The location for the resource
   *
   * @schema CertificateTemplateSpecForProvider#location
   */
  readonly location: string;

  /**
   * Optional. Describes the set of X.509 extensions that may appear in a Certificate issued using this CertificateTemplate. If a certificate request sets extensions that don't appear in the passthrough_extensions, those extensions will be dropped. If the issuing CaPool's IssuancePolicy defines baseline_values that don't appear here, the certificate issuance request will fail. If this is omitted, then this template will not add restrictions on a certificate's X.509 extensions. These constraints do not apply to X.509 extensions set in this CertificateTemplate's predefined_values.
   *
   * @schema CertificateTemplateSpecForProvider#passthroughExtensions
   */
  readonly passthroughExtensions?: CertificateTemplateSpecForProviderPassthroughExtensions[];

  /**
   * Optional. A set of X.509 values that will be applied to all issued certificates that use this template. If the certificate request includes conflicting values for the same properties, they will be overwritten by the values defined here. If the issuing CaPool's IssuancePolicy defines conflicting baseline_values for the same properties, the certificate issuance request will fail.
   *
   * @schema CertificateTemplateSpecForProvider#predefinedValues
   */
  readonly predefinedValues?: CertificateTemplateSpecForProviderPredefinedValues[];

  /**
   * The project for the resource
   *
   * @schema CertificateTemplateSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProvider(obj: CertificateTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'identityConstraints': obj.identityConstraints?.map(y => toJson_CertificateTemplateSpecForProviderIdentityConstraints(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'passthroughExtensions': obj.passthroughExtensions?.map(y => toJson_CertificateTemplateSpecForProviderPassthroughExtensions(y)),
    'predefinedValues': obj.predefinedValues?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValues(y)),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateTemplateSpecProviderConfigRef
 */
export interface CertificateTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecProviderConfigRef(obj: CertificateTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CertificateTemplateSpecProviderRef
 */
export interface CertificateTemplateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateSpecProviderRef#policy
   */
  readonly policy?: CertificateTemplateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecProviderRef(obj: CertificateTemplateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsTo
 */
export interface CertificateTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecPublishConnectionDetailsTo(obj: CertificateTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateTemplateSpecWriteConnectionSecretToRef
 */
export interface CertificateTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecWriteConnectionSecretToRef(obj: CertificateTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderIdentityConstraints
 */
export interface CertificateTemplateSpecForProviderIdentityConstraints {
  /**
   * Required. If this is true, the SubjectAltNames extension may be copied from a certificate request into the signed certificate. Otherwise, the requested SubjectAltNames will be discarded.
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraints#allowSubjectAltNamesPassthrough
   */
  readonly allowSubjectAltNamesPassthrough: boolean;

  /**
   * Required. If this is true, the Subject field may be copied from a certificate request into the signed certificate. Otherwise, the requested Subject will be discarded.
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraints#allowSubjectPassthrough
   */
  readonly allowSubjectPassthrough: boolean;

  /**
   * Optional. A CEL expression that may be used to validate the resolved X.509 Subject and/or Subject Alternative Name before a certificate is signed. To see the full allowed syntax and some examples, see https://cloud.google.com/certificate-authority-service/docs/using-cel
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraints#celExpression
   */
  readonly celExpression?: CertificateTemplateSpecForProviderIdentityConstraintsCelExpression[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderIdentityConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderIdentityConstraints(obj: CertificateTemplateSpecForProviderIdentityConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSubjectAltNamesPassthrough': obj.allowSubjectAltNamesPassthrough,
    'allowSubjectPassthrough': obj.allowSubjectPassthrough,
    'celExpression': obj.celExpression?.map(y => toJson_CertificateTemplateSpecForProviderIdentityConstraintsCelExpression(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPassthroughExtensions
 */
export interface CertificateTemplateSpecForProviderPassthroughExtensions {
  /**
   * Optional. A set of ObjectIds identifying custom X.509 extensions. Will be combined with known_extensions to determine the full set of X.509 extensions.
   *
   * @schema CertificateTemplateSpecForProviderPassthroughExtensions#additionalExtensions
   */
  readonly additionalExtensions?: CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions[];

  /**
   * Optional. A set of named X.509 extensions. Will be combined with additional_extensions to determine the full set of X.509 extensions.
   *
   * @schema CertificateTemplateSpecForProviderPassthroughExtensions#knownExtensions
   */
  readonly knownExtensions?: string[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPassthroughExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPassthroughExtensions(obj: CertificateTemplateSpecForProviderPassthroughExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions(y)),
    'knownExtensions': obj.knownExtensions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValues
 */
export interface CertificateTemplateSpecForProviderPredefinedValues {
  /**
   * Optional. Describes custom X.509 extensions.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValues#additionalExtensions
   */
  readonly additionalExtensions?: CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions[];

  /**
   * Optional. Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValues#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * Optional. Describes options in this X509Parameters that are relevant in a CA certificate.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValues#caOptions
   */
  readonly caOptions?: CertificateTemplateSpecForProviderPredefinedValuesCaOptions[];

  /**
   * Optional. Indicates the intended use for keys that correspond to a certificate.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValues#keyUsage
   */
  readonly keyUsage?: CertificateTemplateSpecForProviderPredefinedValuesKeyUsage[];

  /**
   * Optional. Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValues#policyIds
   */
  readonly policyIds?: CertificateTemplateSpecForProviderPredefinedValuesPolicyIds[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValues(obj: CertificateTemplateSpecForProviderPredefinedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsage(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateSpecProviderConfigRefPolicy
 */
export interface CertificateTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecProviderConfigRefPolicy(obj: CertificateTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateSpecProviderRefPolicy
 */
export interface CertificateTemplateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecProviderRefPolicy(obj: CertificateTemplateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecPublishConnectionDetailsToConfigRef(obj: CertificateTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecPublishConnectionDetailsToMetadata(obj: CertificateTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderIdentityConstraintsCelExpression
 */
export interface CertificateTemplateSpecForProviderIdentityConstraintsCelExpression {
  /**
   * Optional. A human-readable description of scenarios this template is intended for.
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraintsCelExpression#description
   */
  readonly description?: string;

  /**
   * Textual representation of an expression in Common Expression Language syntax.
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraintsCelExpression#expression
   */
  readonly expression?: string;

  /**
   * The location for the resource
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraintsCelExpression#location
   */
  readonly location?: string;

  /**
   * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraintsCelExpression#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderIdentityConstraintsCelExpression' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderIdentityConstraintsCelExpression(obj: CertificateTemplateSpecForProviderIdentityConstraintsCelExpression | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'location': obj.location,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions
 */
export interface CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions(obj: CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions {
  /**
   * Optional. Indicates whether or not this extension is critical (i.e., if the client does not know how to handle this extension, the client should consider this to be an error).
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions#critical
   */
  readonly critical?: boolean;

  /**
   * Required. The OID for this X.509 extension.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions#objectId
   */
  readonly objectId: CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId[];

  /**
   * Required. The value of this X.509 extension.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions(obj: CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesCaOptions
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesCaOptions {
  /**
   * Optional. Refers to the "CA" X.509 extension, which is a boolean value. When this value is missing, the extension will be omitted from the CA certificate.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Optional. Refers to the path length restriction X.509 extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail. If this value is missing, the max path length will be omitted from the CA certificate.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesCaOptions(obj: CertificateTemplateSpecForProviderPredefinedValuesCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsage
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesKeyUsage {
  /**
   * Describes high-level ways in which a key may be used.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage?: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage[];

  /**
   * Detailed scenarios in which a key may be used.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage?: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage[];

  /**
   * Used to describe extended key usages that are not listed in the KeyUsage.ExtendedKeyUsageOptions message.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsage(obj: CertificateTemplateSpecForProviderPredefinedValuesKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesPolicyIds
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesPolicyIds {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesPolicyIds#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesPolicyIds(obj: CertificateTemplateSpecForProviderPredefinedValuesPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateSpecProviderConfigRefPolicyResolution
 */
export enum CertificateTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateSpecProviderConfigRefPolicyResolve
 */
export enum CertificateTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateSpecProviderRefPolicyResolution
 */
export enum CertificateTemplateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateSpecProviderRefPolicyResolve
 */
export enum CertificateTemplateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId(obj: CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage {
  /**
   * The key may be used to sign certificates.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * The key may be used sign certificate revocation lists.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * The key may be used to encipher data.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * The key may be used to decipher only.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * The key may be used for digital signatures.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * The key may be used to encipher only.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * The key may be used in a key agreement protocol.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * The key may be used to encipher other keys.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage(obj: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage(obj: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages(obj: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CertificateTemplateIAMMember is the Schema for the CertificateTemplateIAMMembers API. <no value>
 *
 * @schema CertificateTemplateIAMMember
 */
export class CertificateTemplateIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateTemplateIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'CertificateTemplateIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateTemplateIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateTemplateIamMemberProps): any {
    return {
      ...CertificateTemplateIamMember.GVK,
      ...toJson_CertificateTemplateIamMemberProps(props),
    };
  }

  /**
   * Defines a "CertificateTemplateIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateTemplateIamMemberProps) {
    super(scope, id, {
      ...CertificateTemplateIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateTemplateIamMember.GVK,
      ...toJson_CertificateTemplateIamMemberProps(resolved),
    };
  }
}

/**
 * CertificateTemplateIAMMember is the Schema for the CertificateTemplateIAMMembers API. <no value>
 *
 * @schema CertificateTemplateIAMMember
 */
export interface CertificateTemplateIamMemberProps {
  /**
   * @schema CertificateTemplateIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateTemplateIAMMemberSpec defines the desired state of CertificateTemplateIAMMember
   *
   * @schema CertificateTemplateIAMMember#spec
   */
  readonly spec: CertificateTemplateIamMemberSpec;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberProps(obj: CertificateTemplateIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateTemplateIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateTemplateIAMMemberSpec defines the desired state of CertificateTemplateIAMMember
 *
 * @schema CertificateTemplateIamMemberSpec
 */
export interface CertificateTemplateIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema CertificateTemplateIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateTemplateIamMemberSpecDeletionPolicy;

  /**
   * @schema CertificateTemplateIamMemberSpec#forProvider
   */
  readonly forProvider: CertificateTemplateIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateTemplateIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateTemplateIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CertificateTemplateIamMemberSpec#providerRef
   */
  readonly providerRef?: CertificateTemplateIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateTemplateIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateTemplateIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateTemplateIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateTemplateIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpec(obj: CertificateTemplateIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateTemplateIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_CertificateTemplateIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CertificateTemplateIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateTemplateIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema CertificateTemplateIamMemberSpecDeletionPolicy
 */
export enum CertificateTemplateIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateTemplateIamMemberSpecForProvider
 */
export interface CertificateTemplateIamMemberSpecForProvider {
  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#certificateTemplate
   */
  readonly certificateTemplate?: string;

  /**
   * Reference to a CertificateTemplate to populate certificateTemplate.
   *
   * @schema CertificateTemplateIamMemberSpecForProvider#certificateTemplateRef
   */
  readonly certificateTemplateRef?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef;

  /**
   * Selector for a CertificateTemplate to populate certificateTemplate.
   *
   * @schema CertificateTemplateIamMemberSpecForProvider#certificateTemplateSelector
   */
  readonly certificateTemplateSelector?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector;

  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#condition
   */
  readonly condition?: CertificateTemplateIamMemberSpecForProviderCondition[];

  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#location
   */
  readonly location?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProvider(obj: CertificateTemplateIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateTemplate': obj.certificateTemplate,
    'certificateTemplateRef': toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef(obj.certificateTemplateRef),
    'certificateTemplateSelector': toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector(obj.certificateTemplateSelector),
    'condition': obj.condition?.map(y => toJson_CertificateTemplateIamMemberSpecForProviderCondition(y)),
    'location': obj.location,
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateTemplateIamMemberSpecProviderConfigRef
 */
export interface CertificateTemplateIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateTemplateIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecProviderConfigRef(obj: CertificateTemplateIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CertificateTemplateIamMemberSpecProviderRef
 */
export interface CertificateTemplateIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateIamMemberSpecProviderRef#policy
   */
  readonly policy?: CertificateTemplateIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecProviderRef(obj: CertificateTemplateIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsTo
 */
export interface CertificateTemplateIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsTo(obj: CertificateTemplateIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateTemplateIamMemberSpecWriteConnectionSecretToRef
 */
export interface CertificateTemplateIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateTemplateIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateTemplateIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecWriteConnectionSecretToRef(obj: CertificateTemplateIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateTemplate to populate certificateTemplate.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef
 */
export interface CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef#policy
   */
  readonly policy?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef(obj: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateTemplate to populate certificateTemplate.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector
 */
export interface CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector#policy
   */
  readonly policy?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector(obj: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateIamMemberSpecForProviderCondition
 */
export interface CertificateTemplateIamMemberSpecForProviderCondition {
  /**
   * @schema CertificateTemplateIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema CertificateTemplateIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProviderCondition(obj: CertificateTemplateIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateIamMemberSpecProviderConfigRefPolicy
 */
export interface CertificateTemplateIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecProviderConfigRefPolicy(obj: CertificateTemplateIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateIamMemberSpecProviderRefPolicy
 */
export interface CertificateTemplateIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecProviderRefPolicy(obj: CertificateTemplateIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef(obj: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata(obj: CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy
 */
export interface CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy(obj: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy
 */
export interface CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy#resolution
   */
  readonly resolution?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy#resolve
   */
  readonly resolve?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy(obj: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateIamMemberSpecProviderRefPolicyResolution
 */
export enum CertificateTemplateIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateIamMemberSpecProviderRefPolicyResolve
 */
export enum CertificateTemplateIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolution
 */
export enum CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolve
 */
export enum CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolution
 */
export enum CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolve
 */
export enum CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

