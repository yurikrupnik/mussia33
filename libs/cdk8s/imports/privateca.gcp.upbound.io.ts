// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CAPool is the Schema for the CAPools API. A CaPool represents a group of CertificateAuthorities that form a trust anchor.
 *
 * @schema CAPool
 */
export class CaPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CAPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'CAPool',
  }

  /**
   * Renders a Kubernetes manifest for "CAPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CaPoolProps): any {
    return {
      ...CaPool.GVK,
      ...toJson_CaPoolProps(props),
    };
  }

  /**
   * Defines a "CAPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CaPoolProps) {
    super(scope, id, {
      ...CaPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CaPool.GVK,
      ...toJson_CaPoolProps(resolved),
    };
  }
}

/**
 * CAPool is the Schema for the CAPools API. A CaPool represents a group of CertificateAuthorities that form a trust anchor.
 *
 * @schema CAPool
 */
export interface CaPoolProps {
  /**
   * @schema CAPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CAPoolSpec defines the desired state of CAPool
   *
   * @schema CAPool#spec
   */
  readonly spec: CaPoolSpec;

}

/**
 * Converts an object of type 'CaPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolProps(obj: CaPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CaPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CAPoolSpec defines the desired state of CAPool
 *
 * @schema CaPoolSpec
 */
export interface CaPoolSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CaPoolSpec#deletionPolicy
   */
  readonly deletionPolicy?: CaPoolSpecDeletionPolicy;

  /**
   * @schema CaPoolSpec#forProvider
   */
  readonly forProvider: CaPoolSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CaPoolSpec#initProvider
   */
  readonly initProvider?: CaPoolSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CaPoolSpec#managementPolicies
   */
  readonly managementPolicies?: CaPoolSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CaPoolSpec#providerConfigRef
   */
  readonly providerConfigRef?: CaPoolSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CaPoolSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CaPoolSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CaPoolSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CaPoolSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CaPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpec(obj: CaPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CaPoolSpecForProvider(obj.forProvider),
    'initProvider': toJson_CaPoolSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CaPoolSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CaPoolSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CaPoolSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CaPoolSpecDeletionPolicy
 */
export enum CaPoolSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CaPoolSpecForProvider
 */
export interface CaPoolSpecForProvider {
  /**
   * The IssuancePolicy to control how Certificates will be issued from this CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecForProvider#issuancePolicy
   */
  readonly issuancePolicy?: CaPoolSpecForProviderIssuancePolicy[];

  /**
   * Labels with user-defined metadata. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema CaPoolSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Location of the CaPool. A full list of valid locations can be found by running gcloud privateca locations list.
   *
   * @schema CaPoolSpecForProvider#location
   */
  readonly location: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema CaPoolSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The PublishingOptions to follow when issuing Certificates from any CertificateAuthority in this CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecForProvider#publishingOptions
   */
  readonly publishingOptions?: CaPoolSpecForProviderPublishingOptions[];

  /**
   * The Tier of this CaPool. Possible values are: ENTERPRISE, DEVOPS.
   *
   * @schema CaPoolSpecForProvider#tier
   */
  readonly tier?: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProvider(obj: CaPoolSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issuancePolicy': obj.issuancePolicy?.map(y => toJson_CaPoolSpecForProviderIssuancePolicy(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'project': obj.project,
    'publishingOptions': obj.publishingOptions?.map(y => toJson_CaPoolSpecForProviderPublishingOptions(y)),
    'tier': obj.tier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CaPoolSpecInitProvider
 */
export interface CaPoolSpecInitProvider {
  /**
   * The IssuancePolicy to control how Certificates will be issued from this CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecInitProvider#issuancePolicy
   */
  readonly issuancePolicy?: CaPoolSpecInitProviderIssuancePolicy[];

  /**
   * Labels with user-defined metadata. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema CaPoolSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema CaPoolSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The PublishingOptions to follow when issuing Certificates from any CertificateAuthority in this CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecInitProvider#publishingOptions
   */
  readonly publishingOptions?: CaPoolSpecInitProviderPublishingOptions[];

  /**
   * The Tier of this CaPool. Possible values are: ENTERPRISE, DEVOPS.
   *
   * @schema CaPoolSpecInitProvider#tier
   */
  readonly tier?: string;

}

/**
 * Converts an object of type 'CaPoolSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProvider(obj: CaPoolSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issuancePolicy': obj.issuancePolicy?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicy(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'publishingOptions': obj.publishingOptions?.map(y => toJson_CaPoolSpecInitProviderPublishingOptions(y)),
    'tier': obj.tier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CaPoolSpecManagementPolicies
 */
export enum CaPoolSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CaPoolSpecProviderConfigRef
 */
export interface CaPoolSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolSpecProviderConfigRef#policy
   */
  readonly policy?: CaPoolSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CaPoolSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecProviderConfigRef(obj: CaPoolSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CaPoolSpecPublishConnectionDetailsTo
 */
export interface CaPoolSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CaPoolSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CaPoolSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CaPoolSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CaPoolSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CaPoolSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CaPoolSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecPublishConnectionDetailsTo(obj: CaPoolSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CaPoolSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CaPoolSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CaPoolSpecWriteConnectionSecretToRef
 */
export interface CaPoolSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CaPoolSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CaPoolSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CaPoolSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecWriteConnectionSecretToRef(obj: CaPoolSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicy
 */
export interface CaPoolSpecForProviderIssuancePolicy {
  /**
   * IssuanceModes specifies the allowed ways in which Certificates may be requested from this CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicy#allowedIssuanceModes
   */
  readonly allowedIssuanceModes?: CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes[];

  /**
   * If any AllowedKeyType is specified, then the certificate request's public key must match one of the key types listed here. Otherwise, any key may be used. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicy#allowedKeyTypes
   */
  readonly allowedKeyTypes?: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes[];

  /**
   * A set of X.509 values that will be applied to all certificates issued through this CaPool. If a certificate request includes conflicting values for the same properties, they will be overwritten by the values defined here. If a certificate request uses a CertificateTemplate that defines conflicting predefinedValues for the same properties, the certificate issuance request will fail. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicy#baselineValues
   */
  readonly baselineValues?: CaPoolSpecForProviderIssuancePolicyBaselineValues[];

  /**
   * Describes constraints on identities that may appear in Certificates issued through this CaPool. If this is omitted, then this CaPool will not add restrictions on a certificate's identity. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicy#identityConstraints
   */
  readonly identityConstraints?: CaPoolSpecForProviderIssuancePolicyIdentityConstraints[];

  /**
   * The maximum lifetime allowed for issued Certificates. Note that if the issuing CertificateAuthority expires before a Certificate's requested maximumLifetime, the effective lifetime will be explicitly truncated to match it.
   *
   * @schema CaPoolSpecForProviderIssuancePolicy#maximumLifetime
   */
  readonly maximumLifetime?: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicy(obj: CaPoolSpecForProviderIssuancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIssuanceModes': obj.allowedIssuanceModes?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes(y)),
    'allowedKeyTypes': obj.allowedKeyTypes?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes(y)),
    'baselineValues': obj.baselineValues?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValues(y)),
    'identityConstraints': obj.identityConstraints?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyIdentityConstraints(y)),
    'maximumLifetime': obj.maximumLifetime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderPublishingOptions
 */
export interface CaPoolSpecForProviderPublishingOptions {
  /**
   * Specifies the encoding format of each CertificateAuthority's CA certificate and CRLs. If this is omitted, CA certificates and CRLs will be published in PEM. Possible values are: PEM, DER.
   *
   * @schema CaPoolSpecForProviderPublishingOptions#encodingFormat
   */
  readonly encodingFormat?: string;

  /**
   * When true, publishes each CertificateAuthority's CA certificate and includes its URL in the "Authority Information Access" X.509 extension in all issued Certificates. If this is false, the CA certificate will not be published and the corresponding X.509 extension will not be written in issued certificates.
   *
   * @schema CaPoolSpecForProviderPublishingOptions#publishCaCert
   */
  readonly publishCaCert?: boolean;

  /**
   * When true, publishes each CertificateAuthority's CRL and includes its URL in the "CRL Distribution Points" X.509 extension in all issued Certificates. If this is false, CRLs will not be published and the corresponding X.509 extension will not be written in issued certificates. CRLs will expire 7 days from their creation. However, we will rebuild daily. CRLs are also rebuilt shortly after a certificate is revoked.
   *
   * @schema CaPoolSpecForProviderPublishingOptions#publishCrl
   */
  readonly publishCrl?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderPublishingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderPublishingOptions(obj: CaPoolSpecForProviderPublishingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encodingFormat': obj.encodingFormat,
    'publishCaCert': obj.publishCaCert,
    'publishCrl': obj.publishCrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicy
 */
export interface CaPoolSpecInitProviderIssuancePolicy {
  /**
   * IssuanceModes specifies the allowed ways in which Certificates may be requested from this CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicy#allowedIssuanceModes
   */
  readonly allowedIssuanceModes?: CaPoolSpecInitProviderIssuancePolicyAllowedIssuanceModes[];

  /**
   * If any AllowedKeyType is specified, then the certificate request's public key must match one of the key types listed here. Otherwise, any key may be used. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicy#allowedKeyTypes
   */
  readonly allowedKeyTypes?: CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypes[];

  /**
   * A set of X.509 values that will be applied to all certificates issued through this CaPool. If a certificate request includes conflicting values for the same properties, they will be overwritten by the values defined here. If a certificate request uses a CertificateTemplate that defines conflicting predefinedValues for the same properties, the certificate issuance request will fail. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicy#baselineValues
   */
  readonly baselineValues?: CaPoolSpecInitProviderIssuancePolicyBaselineValues[];

  /**
   * Describes constraints on identities that may appear in Certificates issued through this CaPool. If this is omitted, then this CaPool will not add restrictions on a certificate's identity. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicy#identityConstraints
   */
  readonly identityConstraints?: CaPoolSpecInitProviderIssuancePolicyIdentityConstraints[];

  /**
   * The maximum lifetime allowed for issued Certificates. Note that if the issuing CertificateAuthority expires before a Certificate's requested maximumLifetime, the effective lifetime will be explicitly truncated to match it.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicy#maximumLifetime
   */
  readonly maximumLifetime?: string;

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicy(obj: CaPoolSpecInitProviderIssuancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIssuanceModes': obj.allowedIssuanceModes?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyAllowedIssuanceModes(y)),
    'allowedKeyTypes': obj.allowedKeyTypes?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypes(y)),
    'baselineValues': obj.baselineValues?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValues(y)),
    'identityConstraints': obj.identityConstraints?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyIdentityConstraints(y)),
    'maximumLifetime': obj.maximumLifetime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderPublishingOptions
 */
export interface CaPoolSpecInitProviderPublishingOptions {
  /**
   * Specifies the encoding format of each CertificateAuthority's CA certificate and CRLs. If this is omitted, CA certificates and CRLs will be published in PEM. Possible values are: PEM, DER.
   *
   * @schema CaPoolSpecInitProviderPublishingOptions#encodingFormat
   */
  readonly encodingFormat?: string;

  /**
   * When true, publishes each CertificateAuthority's CA certificate and includes its URL in the "Authority Information Access" X.509 extension in all issued Certificates. If this is false, the CA certificate will not be published and the corresponding X.509 extension will not be written in issued certificates.
   *
   * @schema CaPoolSpecInitProviderPublishingOptions#publishCaCert
   */
  readonly publishCaCert?: boolean;

  /**
   * When true, publishes each CertificateAuthority's CRL and includes its URL in the "CRL Distribution Points" X.509 extension in all issued Certificates. If this is false, CRLs will not be published and the corresponding X.509 extension will not be written in issued certificates. CRLs will expire 7 days from their creation. However, we will rebuild daily. CRLs are also rebuilt shortly after a certificate is revoked.
   *
   * @schema CaPoolSpecInitProviderPublishingOptions#publishCrl
   */
  readonly publishCrl?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderPublishingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderPublishingOptions(obj: CaPoolSpecInitProviderPublishingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encodingFormat': obj.encodingFormat,
    'publishCaCert': obj.publishCaCert,
    'publishCrl': obj.publishCrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CaPoolSpecProviderConfigRefPolicy
 */
export interface CaPoolSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CaPoolSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CaPoolSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecProviderConfigRefPolicy(obj: CaPoolSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CaPoolSpecPublishConnectionDetailsToConfigRef
 */
export interface CaPoolSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CaPoolSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CaPoolSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecPublishConnectionDetailsToConfigRef(obj: CaPoolSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CaPoolSpecPublishConnectionDetailsToMetadata
 */
export interface CaPoolSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CaPoolSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecPublishConnectionDetailsToMetadata(obj: CaPoolSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes
 */
export interface CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes {
  /**
   * When true, allows callers to create Certificates by specifying a CertificateConfig.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes#allowConfigBasedIssuance
   */
  readonly allowConfigBasedIssuance?: boolean;

  /**
   * When true, allows callers to create Certificates by specifying a CSR.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes#allowCsrBasedIssuance
   */
  readonly allowCsrBasedIssuance?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes(obj: CaPoolSpecForProviderIssuancePolicyAllowedIssuanceModes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowConfigBasedIssuance': obj.allowConfigBasedIssuance,
    'allowCsrBasedIssuance': obj.allowCsrBasedIssuance,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes
 */
export interface CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes {
  /**
   * Represents an allowed Elliptic Curve key type. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes#ellipticCurve
   */
  readonly ellipticCurve?: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve[];

  /**
   * Describes an RSA key that may be used in a Certificate issued from a CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes#rsa
   */
  readonly rsa?: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes(obj: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ellipticCurve': obj.ellipticCurve?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve(y)),
    'rsa': obj.rsa?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValues {
  /**
   * Specifies an X.509 extension, which may be used in different parts of X.509 objects like certificates, CSRs, and CRLs. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#additionalExtensions
   */
  readonly additionalExtensions?: CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions[];

  /**
   * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#caOptions
   */
  readonly caOptions?: CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions[];

  /**
   * Indicates the intended use for keys that correspond to a certificate. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#keyUsage
   */
  readonly keyUsage?: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage[];

  /**
   * Describes the X.509 name constraints extension. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#nameConstraints
   */
  readonly nameConstraints?: CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints[];

  /**
   * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValues#policyIds
   */
  readonly policyIds?: CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValues(obj: CaPoolSpecForProviderIssuancePolicyBaselineValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage(y)),
    'nameConstraints': obj.nameConstraints?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraints
 */
export interface CaPoolSpecForProviderIssuancePolicyIdentityConstraints {
  /**
   * If this is set, the SubjectAltNames extension may be copied from a certificate request into the signed certificate. Otherwise, the requested SubjectAltNames will be discarded.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraints#allowSubjectAltNamesPassthrough
   */
  readonly allowSubjectAltNamesPassthrough?: boolean;

  /**
   * If this is set, the Subject field may be copied from a certificate request into the signed certificate. Otherwise, the requested Subject will be discarded.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraints#allowSubjectPassthrough
   */
  readonly allowSubjectPassthrough?: boolean;

  /**
   * A CEL expression that may be used to validate the resolved X.509 Subject and/or Subject Alternative Name before a certificate is signed. To see the full allowed syntax and some examples, see https://cloud.google.com/certificate-authority-service/docs/cel-guide Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraints#celExpression
   */
  readonly celExpression?: CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyIdentityConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyIdentityConstraints(obj: CaPoolSpecForProviderIssuancePolicyIdentityConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSubjectAltNamesPassthrough': obj.allowSubjectAltNamesPassthrough,
    'allowSubjectPassthrough': obj.allowSubjectPassthrough,
    'celExpression': obj.celExpression?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyAllowedIssuanceModes
 */
export interface CaPoolSpecInitProviderIssuancePolicyAllowedIssuanceModes {
  /**
   * When true, allows callers to create Certificates by specifying a CertificateConfig.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyAllowedIssuanceModes#allowConfigBasedIssuance
   */
  readonly allowConfigBasedIssuance?: boolean;

  /**
   * When true, allows callers to create Certificates by specifying a CSR.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyAllowedIssuanceModes#allowCsrBasedIssuance
   */
  readonly allowCsrBasedIssuance?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyAllowedIssuanceModes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyAllowedIssuanceModes(obj: CaPoolSpecInitProviderIssuancePolicyAllowedIssuanceModes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowConfigBasedIssuance': obj.allowConfigBasedIssuance,
    'allowCsrBasedIssuance': obj.allowCsrBasedIssuance,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypes
 */
export interface CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypes {
  /**
   * Represents an allowed Elliptic Curve key type. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypes#ellipticCurve
   */
  readonly ellipticCurve?: CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesEllipticCurve[];

  /**
   * Describes an RSA key that may be used in a Certificate issued from a CaPool. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypes#rsa
   */
  readonly rsa?: CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesRsa[];

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypes(obj: CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ellipticCurve': obj.ellipticCurve?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesEllipticCurve(y)),
    'rsa': obj.rsa?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesRsa(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValues
 */
export interface CaPoolSpecInitProviderIssuancePolicyBaselineValues {
  /**
   * Specifies an X.509 extension, which may be used in different parts of X.509 objects like certificates, CSRs, and CRLs. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValues#additionalExtensions
   */
  readonly additionalExtensions?: CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensions[];

  /**
   * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValues#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValues#caOptions
   */
  readonly caOptions?: CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions[];

  /**
   * Indicates the intended use for keys that correspond to a certificate. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValues#keyUsage
   */
  readonly keyUsage?: CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsage[];

  /**
   * Describes the X.509 name constraints extension. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValues#nameConstraints
   */
  readonly nameConstraints?: CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints[];

  /**
   * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValues#policyIds
   */
  readonly policyIds?: CaPoolSpecInitProviderIssuancePolicyBaselineValuesPolicyIds[];

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyBaselineValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValues(obj: CaPoolSpecInitProviderIssuancePolicyBaselineValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsage(y)),
    'nameConstraints': obj.nameConstraints?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyIdentityConstraints
 */
export interface CaPoolSpecInitProviderIssuancePolicyIdentityConstraints {
  /**
   * If this is set, the SubjectAltNames extension may be copied from a certificate request into the signed certificate. Otherwise, the requested SubjectAltNames will be discarded.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyIdentityConstraints#allowSubjectAltNamesPassthrough
   */
  readonly allowSubjectAltNamesPassthrough?: boolean;

  /**
   * If this is set, the Subject field may be copied from a certificate request into the signed certificate. Otherwise, the requested Subject will be discarded.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyIdentityConstraints#allowSubjectPassthrough
   */
  readonly allowSubjectPassthrough?: boolean;

  /**
   * A CEL expression that may be used to validate the resolved X.509 Subject and/or Subject Alternative Name before a certificate is signed. To see the full allowed syntax and some examples, see https://cloud.google.com/certificate-authority-service/docs/cel-guide Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyIdentityConstraints#celExpression
   */
  readonly celExpression?: CaPoolSpecInitProviderIssuancePolicyIdentityConstraintsCelExpression[];

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyIdentityConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyIdentityConstraints(obj: CaPoolSpecInitProviderIssuancePolicyIdentityConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSubjectAltNamesPassthrough': obj.allowSubjectAltNamesPassthrough,
    'allowSubjectPassthrough': obj.allowSubjectPassthrough,
    'celExpression': obj.celExpression?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyIdentityConstraintsCelExpression(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolSpecProviderConfigRefPolicyResolution
 */
export enum CaPoolSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolSpecProviderConfigRefPolicyResolve
 */
export enum CaPoolSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CaPoolSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CaPoolSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj: CaPoolSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve
 */
export interface CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve {
  /**
   * The algorithm used. Possible values are: ECDSA_P256, ECDSA_P384, EDDSA_25519.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve(obj: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesEllipticCurve | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa
 */
export interface CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa {
  /**
   * The maximum allowed RSA modulus size, in bits. If this is not set, or if set to zero, the service will not enforce an explicit upper bound on RSA modulus sizes.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa#maxModulusSize
   */
  readonly maxModulusSize?: string;

  /**
   * The minimum allowed RSA modulus size, in bits. If this is not set, or if set to zero, the service-level min RSA modulus size will continue to apply.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa#minModulusSize
   */
  readonly minModulusSize?: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa(obj: CaPoolSpecForProviderIssuancePolicyAllowedKeyTypesRsa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxModulusSize': obj.maxModulusSize,
    'minModulusSize': obj.minModulusSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions#critical
   */
  readonly critical?: boolean;

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions#objectId
   */
  readonly objectId?: CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId[];

  /**
   * The value of this X.509 extension. A base64-encoded string.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions {
  /**
   * When true, the "CA" in Basic Constraints extension will be set to true.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

  /**
   * When true, the "CA" in Basic Constraints extension will be set to false. If both is_ca and non_ca are unset, the extension will be omitted from the CA certificate.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions#nonCa
   */
  readonly nonCa?: boolean;

  /**
   * When true, the "path length constraint" in Basic Constraints extension will be set to 0. if both max_issuer_path_length and zero_max_issuer_path_length are unset, the max path length will be omitted from the CA certificate.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions#zeroMaxIssuerPathLength
   */
  readonly zeroMaxIssuerPathLength?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
    'nonCa': obj.nonCa,
    'zeroMaxIssuerPathLength': obj.zeroMaxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage {
  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage?: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage[];

  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage?: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage[];

  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages. Structure is documented below.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints#critical
   */
  readonly critical?: boolean;

  /**
   * Contains excluded DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints#excludedDnsNames
   */
  readonly excludedDnsNames?: string[];

  /**
   * Contains the excluded email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints#excludedEmailAddresses
   */
  readonly excludedEmailAddresses?: string[];

  /**
   * Contains the excluded IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints#excludedIpRanges
   */
  readonly excludedIpRanges?: string[];

  /**
   * Contains the excluded URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints#excludedUris
   */
  readonly excludedUris?: string[];

  /**
   * Contains permitted DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints#permittedDnsNames
   */
  readonly permittedDnsNames?: string[];

  /**
   * Contains the permitted email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints#permittedEmailAddresses
   */
  readonly permittedEmailAddresses?: string[];

  /**
   * Contains the permitted IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints#permittedIpRanges
   */
  readonly permittedIpRanges?: string[];

  /**
   * Contains the permitted URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints#permittedUris
   */
  readonly permittedUris?: string[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesNameConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'excludedDnsNames': obj.excludedDnsNames?.map(y => y),
    'excludedEmailAddresses': obj.excludedEmailAddresses?.map(y => y),
    'excludedIpRanges': obj.excludedIpRanges?.map(y => y),
    'excludedUris': obj.excludedUris?.map(y => y),
    'permittedDnsNames': obj.permittedDnsNames?.map(y => y),
    'permittedEmailAddresses': obj.permittedEmailAddresses?.map(y => y),
    'permittedIpRanges': obj.permittedIpRanges?.map(y => y),
    'permittedUris': obj.permittedUris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression
 */
export interface CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression {
  /**
   * Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression#description
   */
  readonly description?: string;

  /**
   * Textual representation of an expression in Common Expression Language syntax.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression#expression
   */
  readonly expression?: string;

  /**
   * Location of the CaPool. A full list of valid locations can be found by running gcloud privateca locations list.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression#location
   */
  readonly location?: string;

  /**
   * Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression(obj: CaPoolSpecForProviderIssuancePolicyIdentityConstraintsCelExpression | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'location': obj.location,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesEllipticCurve
 */
export interface CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesEllipticCurve {
  /**
   * The algorithm used. Possible values are: ECDSA_P256, ECDSA_P384, EDDSA_25519.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesEllipticCurve#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesEllipticCurve' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesEllipticCurve(obj: CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesEllipticCurve | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesRsa
 */
export interface CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesRsa {
  /**
   * The maximum allowed RSA modulus size, in bits. If this is not set, or if set to zero, the service will not enforce an explicit upper bound on RSA modulus sizes.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesRsa#maxModulusSize
   */
  readonly maxModulusSize?: string;

  /**
   * The minimum allowed RSA modulus size, in bits. If this is not set, or if set to zero, the service-level min RSA modulus size will continue to apply.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesRsa#minModulusSize
   */
  readonly minModulusSize?: string;

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesRsa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesRsa(obj: CaPoolSpecInitProviderIssuancePolicyAllowedKeyTypesRsa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxModulusSize': obj.maxModulusSize,
    'minModulusSize': obj.minModulusSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensions
 */
export interface CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensions {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensions#critical
   */
  readonly critical?: boolean;

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensions#objectId
   */
  readonly objectId?: CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId[];

  /**
   * The value of this X.509 extension. A base64-encoded string.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensions(obj: CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions
 */
export interface CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions {
  /**
   * When true, the "CA" in Basic Constraints extension will be set to true.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

  /**
   * When true, the "CA" in Basic Constraints extension will be set to false. If both is_ca and non_ca are unset, the extension will be omitted from the CA certificate.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions#nonCa
   */
  readonly nonCa?: boolean;

  /**
   * When true, the "path length constraint" in Basic Constraints extension will be set to 0. if both max_issuer_path_length and zero_max_issuer_path_length are unset, the max path length will be omitted from the CA certificate.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions#zeroMaxIssuerPathLength
   */
  readonly zeroMaxIssuerPathLength?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions(obj: CaPoolSpecInitProviderIssuancePolicyBaselineValuesCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
    'nonCa': obj.nonCa,
    'zeroMaxIssuerPathLength': obj.zeroMaxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsage
 */
export interface CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsage {
  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage?: CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage[];

  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage?: CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage[];

  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages. Structure is documented below.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsage(obj: CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints
 */
export interface CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints#critical
   */
  readonly critical?: boolean;

  /**
   * Contains excluded DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints#excludedDnsNames
   */
  readonly excludedDnsNames?: string[];

  /**
   * Contains the excluded email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints#excludedEmailAddresses
   */
  readonly excludedEmailAddresses?: string[];

  /**
   * Contains the excluded IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints#excludedIpRanges
   */
  readonly excludedIpRanges?: string[];

  /**
   * Contains the excluded URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints#excludedUris
   */
  readonly excludedUris?: string[];

  /**
   * Contains permitted DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints#permittedDnsNames
   */
  readonly permittedDnsNames?: string[];

  /**
   * Contains the permitted email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints#permittedEmailAddresses
   */
  readonly permittedEmailAddresses?: string[];

  /**
   * Contains the permitted IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints#permittedIpRanges
   */
  readonly permittedIpRanges?: string[];

  /**
   * Contains the permitted URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints#permittedUris
   */
  readonly permittedUris?: string[];

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints(obj: CaPoolSpecInitProviderIssuancePolicyBaselineValuesNameConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'excludedDnsNames': obj.excludedDnsNames?.map(y => y),
    'excludedEmailAddresses': obj.excludedEmailAddresses?.map(y => y),
    'excludedIpRanges': obj.excludedIpRanges?.map(y => y),
    'excludedUris': obj.excludedUris?.map(y => y),
    'permittedDnsNames': obj.permittedDnsNames?.map(y => y),
    'permittedEmailAddresses': obj.permittedEmailAddresses?.map(y => y),
    'permittedIpRanges': obj.permittedIpRanges?.map(y => y),
    'permittedUris': obj.permittedUris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesPolicyIds
 */
export interface CaPoolSpecInitProviderIssuancePolicyBaselineValuesPolicyIds {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesPolicyIds#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyBaselineValuesPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesPolicyIds(obj: CaPoolSpecInitProviderIssuancePolicyBaselineValuesPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyIdentityConstraintsCelExpression
 */
export interface CaPoolSpecInitProviderIssuancePolicyIdentityConstraintsCelExpression {
  /**
   * Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyIdentityConstraintsCelExpression#description
   */
  readonly description?: string;

  /**
   * Textual representation of an expression in Common Expression Language syntax.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyIdentityConstraintsCelExpression#expression
   */
  readonly expression?: string;

  /**
   * Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyIdentityConstraintsCelExpression#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyIdentityConstraintsCelExpression' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyIdentityConstraintsCelExpression(obj: CaPoolSpecInitProviderIssuancePolicyIdentityConstraintsCelExpression | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CaPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage {
  /**
   * The key may be used to sign certificates.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * The key may be used sign certificate revocation lists.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * The key may be used to encipher data.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * The key may be used to decipher only.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * The key may be used for digital signatures.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * The key may be used to encipher only.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * The key may be used in a key agreement protocol.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * The key may be used to encipher other keys.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages
 */
export interface CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages(obj: CaPoolSpecForProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId
 */
export interface CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId(obj: CaPoolSpecInitProviderIssuancePolicyBaselineValuesAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage
 */
export interface CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage {
  /**
   * The key may be used to sign certificates.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * The key may be used sign certificate revocation lists.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * The key may be used to encipher data.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * The key may be used to decipher only.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * The key may be used for digital signatures.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * The key may be used to encipher only.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * The key may be used in a key agreement protocol.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * The key may be used to encipher other keys.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage(obj: CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage
 */
export interface CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage(obj: CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages
 */
export interface CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages(obj: CaPoolSpecInitProviderIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CAPoolIAMMember is the Schema for the CAPoolIAMMembers API. <no value>
 *
 * @schema CAPoolIAMMember
 */
export class CaPoolIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CAPoolIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'CAPoolIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "CAPoolIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CaPoolIamMemberProps): any {
    return {
      ...CaPoolIamMember.GVK,
      ...toJson_CaPoolIamMemberProps(props),
    };
  }

  /**
   * Defines a "CAPoolIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CaPoolIamMemberProps) {
    super(scope, id, {
      ...CaPoolIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CaPoolIamMember.GVK,
      ...toJson_CaPoolIamMemberProps(resolved),
    };
  }
}

/**
 * CAPoolIAMMember is the Schema for the CAPoolIAMMembers API. <no value>
 *
 * @schema CAPoolIAMMember
 */
export interface CaPoolIamMemberProps {
  /**
   * @schema CAPoolIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CAPoolIAMMemberSpec defines the desired state of CAPoolIAMMember
   *
   * @schema CAPoolIAMMember#spec
   */
  readonly spec: CaPoolIamMemberSpec;

}

/**
 * Converts an object of type 'CaPoolIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberProps(obj: CaPoolIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CaPoolIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CAPoolIAMMemberSpec defines the desired state of CAPoolIAMMember
 *
 * @schema CaPoolIamMemberSpec
 */
export interface CaPoolIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CaPoolIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: CaPoolIamMemberSpecDeletionPolicy;

  /**
   * @schema CaPoolIamMemberSpec#forProvider
   */
  readonly forProvider: CaPoolIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CaPoolIamMemberSpec#initProvider
   */
  readonly initProvider?: CaPoolIamMemberSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CaPoolIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: CaPoolIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CaPoolIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: CaPoolIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CaPoolIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CaPoolIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CaPoolIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CaPoolIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpec(obj: CaPoolIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CaPoolIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_CaPoolIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CaPoolIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CaPoolIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CaPoolIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CaPoolIamMemberSpecDeletionPolicy
 */
export enum CaPoolIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CaPoolIamMemberSpecForProvider
 */
export interface CaPoolIamMemberSpecForProvider {
  /**
   * @schema CaPoolIamMemberSpecForProvider#caPool
   */
  readonly caPool?: string;

  /**
   * Reference to a CAPool to populate caPool.
   *
   * @schema CaPoolIamMemberSpecForProvider#caPoolRef
   */
  readonly caPoolRef?: CaPoolIamMemberSpecForProviderCaPoolRef;

  /**
   * Selector for a CAPool to populate caPool.
   *
   * @schema CaPoolIamMemberSpecForProvider#caPoolSelector
   */
  readonly caPoolSelector?: CaPoolIamMemberSpecForProviderCaPoolSelector;

  /**
   * @schema CaPoolIamMemberSpecForProvider#condition
   */
  readonly condition?: CaPoolIamMemberSpecForProviderCondition[];

  /**
   * @schema CaPoolIamMemberSpecForProvider#location
   */
  readonly location?: string;

  /**
   * @schema CaPoolIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema CaPoolIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema CaPoolIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProvider(obj: CaPoolIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caPool': obj.caPool,
    'caPoolRef': toJson_CaPoolIamMemberSpecForProviderCaPoolRef(obj.caPoolRef),
    'caPoolSelector': toJson_CaPoolIamMemberSpecForProviderCaPoolSelector(obj.caPoolSelector),
    'condition': obj.condition?.map(y => toJson_CaPoolIamMemberSpecForProviderCondition(y)),
    'location': obj.location,
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CaPoolIamMemberSpecInitProvider
 */
export interface CaPoolIamMemberSpecInitProvider {
  /**
   * @schema CaPoolIamMemberSpecInitProvider#condition
   */
  readonly condition?: CaPoolIamMemberSpecInitProviderCondition[];

  /**
   * @schema CaPoolIamMemberSpecInitProvider#location
   */
  readonly location?: string;

  /**
   * @schema CaPoolIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema CaPoolIamMemberSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * @schema CaPoolIamMemberSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecInitProvider(obj: CaPoolIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_CaPoolIamMemberSpecInitProviderCondition(y)),
    'location': obj.location,
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CaPoolIamMemberSpecManagementPolicies
 */
export enum CaPoolIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CaPoolIamMemberSpecProviderConfigRef
 */
export interface CaPoolIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: CaPoolIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecProviderConfigRef(obj: CaPoolIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsTo
 */
export interface CaPoolIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CaPoolIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecPublishConnectionDetailsTo(obj: CaPoolIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CaPoolIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CaPoolIamMemberSpecWriteConnectionSecretToRef
 */
export interface CaPoolIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CaPoolIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CaPoolIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecWriteConnectionSecretToRef(obj: CaPoolIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CAPool to populate caPool.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolRef
 */
export interface CaPoolIamMemberSpecForProviderCaPoolRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolRef#policy
   */
  readonly policy?: CaPoolIamMemberSpecForProviderCaPoolRefPolicy;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProviderCaPoolRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProviderCaPoolRef(obj: CaPoolIamMemberSpecForProviderCaPoolRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolIamMemberSpecForProviderCaPoolRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CAPool to populate caPool.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolSelector
 */
export interface CaPoolIamMemberSpecForProviderCaPoolSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolSelector#policy
   */
  readonly policy?: CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProviderCaPoolSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProviderCaPoolSelector(obj: CaPoolIamMemberSpecForProviderCaPoolSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolIamMemberSpecForProviderCondition
 */
export interface CaPoolIamMemberSpecForProviderCondition {
  /**
   * @schema CaPoolIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema CaPoolIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema CaPoolIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProviderCondition(obj: CaPoolIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CaPoolIamMemberSpecInitProviderCondition
 */
export interface CaPoolIamMemberSpecInitProviderCondition {
  /**
   * @schema CaPoolIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema CaPoolIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema CaPoolIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecInitProviderCondition(obj: CaPoolIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CaPoolIamMemberSpecProviderConfigRefPolicy
 */
export interface CaPoolIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CaPoolIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CaPoolIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecProviderConfigRefPolicy(obj: CaPoolIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef(obj: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface CaPoolIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecPublishConnectionDetailsToMetadata(obj: CaPoolIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolRefPolicy
 */
export interface CaPoolIamMemberSpecForProviderCaPoolRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolRefPolicy#resolution
   */
  readonly resolution?: CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolRefPolicy#resolve
   */
  readonly resolve?: CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProviderCaPoolRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProviderCaPoolRefPolicy(obj: CaPoolIamMemberSpecForProviderCaPoolRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy
 */
export interface CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy#resolution
   */
  readonly resolution?: CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy#resolve
   */
  readonly resolve?: CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy(obj: CaPoolIamMemberSpecForProviderCaPoolSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum CaPoolIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum CaPoolIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolution
 */
export enum CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolve
 */
export enum CaPoolIamMemberSpecForProviderCaPoolRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolution
 */
export enum CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolve
 */
export enum CaPoolIamMemberSpecForProviderCaPoolSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CaPoolIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Certificate is the Schema for the Certificates API. A Certificate corresponds to a signed X.
 *
 * @schema Certificate
 */
export class Certificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Certificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'Certificate',
  }

  /**
   * Renders a Kubernetes manifest for "Certificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateProps): any {
    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(props),
    };
  }

  /**
   * Defines a "Certificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateProps) {
    super(scope, id, {
      ...Certificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(resolved),
    };
  }
}

/**
 * Certificate is the Schema for the Certificates API. A Certificate corresponds to a signed X.
 *
 * @schema Certificate
 */
export interface CertificateProps {
  /**
   * @schema Certificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateSpec defines the desired state of Certificate
   *
   * @schema Certificate#spec
   */
  readonly spec: CertificateSpec;

}

/**
 * Converts an object of type 'CertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateProps(obj: CertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateSpec defines the desired state of Certificate
 *
 * @schema CertificateSpec
 */
export interface CertificateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateSpecDeletionPolicy;

  /**
   * @schema CertificateSpec#forProvider
   */
  readonly forProvider: CertificateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CertificateSpec#initProvider
   */
  readonly initProvider?: CertificateSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateSpec#managementPolicies
   */
  readonly managementPolicies?: CertificateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpec(obj: CertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateSpecForProvider(obj.forProvider),
    'initProvider': toJson_CertificateSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateSpecDeletionPolicy
 */
export enum CertificateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateSpecForProvider
 */
export interface CertificateSpecForProvider {
  /**
   * The Certificate Authority ID that should issue the certificate. For example, to issue a Certificate from a Certificate Authority with resource name projects/my-project/locations/us-central1/caPools/my-pool/certificateAuthorities/my-ca, argument pool should be set to projects/my-project/locations/us-central1/caPools/my-pool, argument certificate_authority should be set to my-ca.
   *
   * @schema CertificateSpecForProvider#certificateAuthority
   */
  readonly certificateAuthority?: string;

  /**
   * Reference to a CertificateAuthority in privateca to populate certificateAuthority.
   *
   * @schema CertificateSpecForProvider#certificateAuthorityRef
   */
  readonly certificateAuthorityRef?: CertificateSpecForProviderCertificateAuthorityRef;

  /**
   * Selector for a CertificateAuthority in privateca to populate certificateAuthority.
   *
   * @schema CertificateSpecForProvider#certificateAuthoritySelector
   */
  readonly certificateAuthoritySelector?: CertificateSpecForProviderCertificateAuthoritySelector;

  /**
   * The resource name for a CertificateTemplate used to issue this certificate, in the format projects/_/locations/_/certificateTemplates/*. If this is specified, the caller must have the necessary permission to use this template. If this is omitted, no template will be used. This template must be in the same location as the Certificate.
   *
   * @schema CertificateSpecForProvider#certificateTemplate
   */
  readonly certificateTemplate?: string;

  /**
   * Reference to a CertificateTemplate in privateca to populate certificateTemplate.
   *
   * @schema CertificateSpecForProvider#certificateTemplateRef
   */
  readonly certificateTemplateRef?: CertificateSpecForProviderCertificateTemplateRef;

  /**
   * Selector for a CertificateTemplate in privateca to populate certificateTemplate.
   *
   * @schema CertificateSpecForProvider#certificateTemplateSelector
   */
  readonly certificateTemplateSelector?: CertificateSpecForProviderCertificateTemplateSelector;

  /**
   * The config used to create a self-signed X.509 certificate or CSR. Structure is documented below.
   *
   * @schema CertificateSpecForProvider#config
   */
  readonly config?: CertificateSpecForProviderConfig[];

  /**
   * Labels with user-defined metadata to apply to this resource.
   *
   * @schema CertificateSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The desired lifetime of the CA certificate. Used to create the "notBeforeTime" and "notAfterTime" fields inside an X.509 certificate. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema CertificateSpecForProvider#lifetime
   */
  readonly lifetime?: string;

  /**
   * Location of the Certificate. A full list of valid locations can be found by running gcloud privateca locations list.
   *
   * @schema CertificateSpecForProvider#location
   */
  readonly location: string;

  /**
   * Immutable. A pem-encoded X.509 certificate signing request (CSR).
   *
   * @schema CertificateSpecForProvider#pemCsr
   */
  readonly pemCsr?: string;

  /**
   * The name of the CaPool this Certificate belongs to.
   *
   * @schema CertificateSpecForProvider#pool
   */
  readonly pool?: string;

  /**
   * Reference to a CAPool to populate pool.
   *
   * @schema CertificateSpecForProvider#poolRef
   */
  readonly poolRef?: CertificateSpecForProviderPoolRef;

  /**
   * Selector for a CAPool to populate pool.
   *
   * @schema CertificateSpecForProvider#poolSelector
   */
  readonly poolSelector?: CertificateSpecForProviderPoolSelector;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema CertificateSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'CertificateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProvider(obj: CertificateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthority': obj.certificateAuthority,
    'certificateAuthorityRef': toJson_CertificateSpecForProviderCertificateAuthorityRef(obj.certificateAuthorityRef),
    'certificateAuthoritySelector': toJson_CertificateSpecForProviderCertificateAuthoritySelector(obj.certificateAuthoritySelector),
    'certificateTemplate': obj.certificateTemplate,
    'certificateTemplateRef': toJson_CertificateSpecForProviderCertificateTemplateRef(obj.certificateTemplateRef),
    'certificateTemplateSelector': toJson_CertificateSpecForProviderCertificateTemplateSelector(obj.certificateTemplateSelector),
    'config': obj.config?.map(y => toJson_CertificateSpecForProviderConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifetime': obj.lifetime,
    'location': obj.location,
    'pemCsr': obj.pemCsr,
    'pool': obj.pool,
    'poolRef': toJson_CertificateSpecForProviderPoolRef(obj.poolRef),
    'poolSelector': toJson_CertificateSpecForProviderPoolSelector(obj.poolSelector),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CertificateSpecInitProvider
 */
export interface CertificateSpecInitProvider {
  /**
   * The config used to create a self-signed X.509 certificate or CSR. Structure is documented below.
   *
   * @schema CertificateSpecInitProvider#config
   */
  readonly config?: CertificateSpecInitProviderConfig[];

  /**
   * Labels with user-defined metadata to apply to this resource.
   *
   * @schema CertificateSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The desired lifetime of the CA certificate. Used to create the "notBeforeTime" and "notAfterTime" fields inside an X.509 certificate. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema CertificateSpecInitProvider#lifetime
   */
  readonly lifetime?: string;

  /**
   * Immutable. A pem-encoded X.509 certificate signing request (CSR).
   *
   * @schema CertificateSpecInitProvider#pemCsr
   */
  readonly pemCsr?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema CertificateSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'CertificateSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProvider(obj: CertificateSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config?.map(y => toJson_CertificateSpecInitProviderConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifetime': obj.lifetime,
    'pemCsr': obj.pemCsr,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateSpecManagementPolicies
 */
export enum CertificateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateSpecProviderConfigRef
 */
export interface CertificateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRef(obj: CertificateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateSpecPublishConnectionDetailsTo
 */
export interface CertificateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsTo(obj: CertificateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateSpecWriteConnectionSecretToRef
 */
export interface CertificateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecWriteConnectionSecretToRef(obj: CertificateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateAuthority in privateca to populate certificateAuthority.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityRef
 */
export interface CertificateSpecForProviderCertificateAuthorityRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityRef#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateAuthorityRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityRef(obj: CertificateSpecForProviderCertificateAuthorityRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecForProviderCertificateAuthorityRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateAuthority in privateca to populate certificateAuthority.
 *
 * @schema CertificateSpecForProviderCertificateAuthoritySelector
 */
export interface CertificateSpecForProviderCertificateAuthoritySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateSpecForProviderCertificateAuthoritySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateSpecForProviderCertificateAuthoritySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateSpecForProviderCertificateAuthoritySelector#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateAuthoritySelectorPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthoritySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthoritySelector(obj: CertificateSpecForProviderCertificateAuthoritySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateSpecForProviderCertificateAuthoritySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateTemplate in privateca to populate certificateTemplate.
 *
 * @schema CertificateSpecForProviderCertificateTemplateRef
 */
export interface CertificateSpecForProviderCertificateTemplateRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecForProviderCertificateTemplateRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecForProviderCertificateTemplateRef#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateTemplateRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateTemplateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateTemplateRef(obj: CertificateSpecForProviderCertificateTemplateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecForProviderCertificateTemplateRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateTemplate in privateca to populate certificateTemplate.
 *
 * @schema CertificateSpecForProviderCertificateTemplateSelector
 */
export interface CertificateSpecForProviderCertificateTemplateSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateSpecForProviderCertificateTemplateSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateSpecForProviderCertificateTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateSpecForProviderCertificateTemplateSelector#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateTemplateSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateTemplateSelector(obj: CertificateSpecForProviderCertificateTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateSpecForProviderCertificateTemplateSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfig
 */
export interface CertificateSpecForProviderConfig {
  /**
   * A PublicKey describes a public key. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfig#publicKey
   */
  readonly publicKey?: CertificateSpecForProviderConfigPublicKey[];

  /**
   * Specifies some of the values in a certificate that are related to the subject. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfig#subjectConfig
   */
  readonly subjectConfig?: CertificateSpecForProviderConfigSubjectConfig[];

  /**
   * Describes how some of the technical X.509 fields in a certificate should be populated. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfig#x509Config
   */
  readonly x509Config?: CertificateSpecForProviderConfigX509Config[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfig(obj: CertificateSpecForProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicKey': obj.publicKey?.map(y => toJson_CertificateSpecForProviderConfigPublicKey(y)),
    'subjectConfig': obj.subjectConfig?.map(y => toJson_CertificateSpecForProviderConfigSubjectConfig(y)),
    'x509Config': obj.x509Config?.map(y => toJson_CertificateSpecForProviderConfigX509Config(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CAPool to populate pool.
 *
 * @schema CertificateSpecForProviderPoolRef
 */
export interface CertificateSpecForProviderPoolRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecForProviderPoolRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecForProviderPoolRef#policy
   */
  readonly policy?: CertificateSpecForProviderPoolRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderPoolRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderPoolRef(obj: CertificateSpecForProviderPoolRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecForProviderPoolRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CAPool to populate pool.
 *
 * @schema CertificateSpecForProviderPoolSelector
 */
export interface CertificateSpecForProviderPoolSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateSpecForProviderPoolSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateSpecForProviderPoolSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateSpecForProviderPoolSelector#policy
   */
  readonly policy?: CertificateSpecForProviderPoolSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderPoolSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderPoolSelector(obj: CertificateSpecForProviderPoolSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateSpecForProviderPoolSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfig
 */
export interface CertificateSpecInitProviderConfig {
  /**
   * A PublicKey describes a public key. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfig#publicKey
   */
  readonly publicKey?: CertificateSpecInitProviderConfigPublicKey[];

  /**
   * Specifies some of the values in a certificate that are related to the subject. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfig#subjectConfig
   */
  readonly subjectConfig?: CertificateSpecInitProviderConfigSubjectConfig[];

  /**
   * Describes how some of the technical X.509 fields in a certificate should be populated. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfig#x509Config
   */
  readonly x509Config?: CertificateSpecInitProviderConfigX509Config[];

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfig(obj: CertificateSpecInitProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicKey': obj.publicKey?.map(y => toJson_CertificateSpecInitProviderConfigPublicKey(y)),
    'subjectConfig': obj.subjectConfig?.map(y => toJson_CertificateSpecInitProviderConfigSubjectConfig(y)),
    'x509Config': obj.x509Config?.map(y => toJson_CertificateSpecInitProviderConfigX509Config(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecProviderConfigRefPolicy
 */
export interface CertificateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRefPolicy(obj: CertificateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj: CertificateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj: CertificateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityRefPolicy
 */
export interface CertificateSpecForProviderCertificateAuthorityRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateAuthorityRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateAuthorityRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityRefPolicy(obj: CertificateSpecForProviderCertificateAuthorityRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateSpecForProviderCertificateAuthoritySelectorPolicy
 */
export interface CertificateSpecForProviderCertificateAuthoritySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateAuthoritySelectorPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateAuthoritySelectorPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthoritySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthoritySelectorPolicy(obj: CertificateSpecForProviderCertificateAuthoritySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecForProviderCertificateTemplateRefPolicy
 */
export interface CertificateSpecForProviderCertificateTemplateRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateTemplateRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateTemplateRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateTemplateRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateTemplateRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateTemplateRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateTemplateRefPolicy(obj: CertificateSpecForProviderCertificateTemplateRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateSpecForProviderCertificateTemplateSelectorPolicy
 */
export interface CertificateSpecForProviderCertificateTemplateSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateTemplateSelectorPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateTemplateSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateTemplateSelectorPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateTemplateSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateTemplateSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateTemplateSelectorPolicy(obj: CertificateSpecForProviderCertificateTemplateSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigPublicKey
 */
export interface CertificateSpecForProviderConfigPublicKey {
  /**
   * The format of the public key. Currently, only PEM format is supported. Possible values are: KEY_TYPE_UNSPECIFIED, PEM.
   *
   * @schema CertificateSpecForProviderConfigPublicKey#format
   */
  readonly format?: string;

  /**
   * Required. A public key. When this is specified in a request, the padding and encoding can be any of the options described by the respective 'KeyType' value. When this is generated by the service, it will always be an RFC 5280 SubjectPublicKeyInfo structure containing an algorithm identifier and a key. A base64-encoded string.
   *
   * @schema CertificateSpecForProviderConfigPublicKey#keySecretRef
   */
  readonly keySecretRef?: CertificateSpecForProviderConfigPublicKeyKeySecretRef;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigPublicKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigPublicKey(obj: CertificateSpecForProviderConfigPublicKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'keySecretRef': toJson_CertificateSpecForProviderConfigPublicKeyKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigSubjectConfig
 */
export interface CertificateSpecForProviderConfigSubjectConfig {
  /**
   * (Output) Contains distinguished name fields such as the location and organization. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfig#subject
   */
  readonly subject?: CertificateSpecForProviderConfigSubjectConfigSubject[];

  /**
   * (Output) The subject alternative name fields. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfig#subjectAltName
   */
  readonly subjectAltName?: CertificateSpecForProviderConfigSubjectConfigSubjectAltName[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigSubjectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigSubjectConfig(obj: CertificateSpecForProviderConfigSubjectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subject': obj.subject?.map(y => toJson_CertificateSpecForProviderConfigSubjectConfigSubject(y)),
    'subjectAltName': obj.subjectAltName?.map(y => toJson_CertificateSpecForProviderConfigSubjectConfigSubjectAltName(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509Config
 */
export interface CertificateSpecForProviderConfigX509Config {
  /**
   * (Output) Describes custom X.509 extensions. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509Config#additionalExtensions
   */
  readonly additionalExtensions?: CertificateSpecForProviderConfigX509ConfigAdditionalExtensions[];

  /**
   * (Output) Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CertificateSpecForProviderConfigX509Config#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * (Output) Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509Config#caOptions
   */
  readonly caOptions?: CertificateSpecForProviderConfigX509ConfigCaOptions[];

  /**
   * (Output) Indicates the intended use for keys that correspond to a certificate. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509Config#keyUsage
   */
  readonly keyUsage?: CertificateSpecForProviderConfigX509ConfigKeyUsage[];

  /**
   * (Output) Describes the X.509 name constraints extension. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509Config#nameConstraints
   */
  readonly nameConstraints?: CertificateSpecForProviderConfigX509ConfigNameConstraints[];

  /**
   * (Output) Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509Config#policyIds
   */
  readonly policyIds?: CertificateSpecForProviderConfigX509ConfigPolicyIds[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509Config' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509Config(obj: CertificateSpecForProviderConfigX509Config | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigKeyUsage(y)),
    'nameConstraints': obj.nameConstraints?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigNameConstraints(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecForProviderPoolRefPolicy
 */
export interface CertificateSpecForProviderPoolRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderPoolRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderPoolRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderPoolRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderPoolRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderPoolRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderPoolRefPolicy(obj: CertificateSpecForProviderPoolRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateSpecForProviderPoolSelectorPolicy
 */
export interface CertificateSpecForProviderPoolSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderPoolSelectorPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderPoolSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderPoolSelectorPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderPoolSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderPoolSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderPoolSelectorPolicy(obj: CertificateSpecForProviderPoolSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigPublicKey
 */
export interface CertificateSpecInitProviderConfigPublicKey {
  /**
   * The format of the public key. Currently, only PEM format is supported. Possible values are: KEY_TYPE_UNSPECIFIED, PEM.
   *
   * @schema CertificateSpecInitProviderConfigPublicKey#format
   */
  readonly format?: string;

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigPublicKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigPublicKey(obj: CertificateSpecInitProviderConfigPublicKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigSubjectConfig
 */
export interface CertificateSpecInitProviderConfigSubjectConfig {
  /**
   * (Output) Contains distinguished name fields such as the location and organization. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfig#subject
   */
  readonly subject?: CertificateSpecInitProviderConfigSubjectConfigSubject[];

  /**
   * (Output) The subject alternative name fields. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfig#subjectAltName
   */
  readonly subjectAltName?: CertificateSpecInitProviderConfigSubjectConfigSubjectAltName[];

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigSubjectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigSubjectConfig(obj: CertificateSpecInitProviderConfigSubjectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subject': obj.subject?.map(y => toJson_CertificateSpecInitProviderConfigSubjectConfigSubject(y)),
    'subjectAltName': obj.subjectAltName?.map(y => toJson_CertificateSpecInitProviderConfigSubjectConfigSubjectAltName(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigX509Config
 */
export interface CertificateSpecInitProviderConfigX509Config {
  /**
   * (Output) Describes custom X.509 extensions. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigX509Config#additionalExtensions
   */
  readonly additionalExtensions?: CertificateSpecInitProviderConfigX509ConfigAdditionalExtensions[];

  /**
   * (Output) Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CertificateSpecInitProviderConfigX509Config#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * (Output) Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigX509Config#caOptions
   */
  readonly caOptions?: CertificateSpecInitProviderConfigX509ConfigCaOptions[];

  /**
   * (Output) Indicates the intended use for keys that correspond to a certificate. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigX509Config#keyUsage
   */
  readonly keyUsage?: CertificateSpecInitProviderConfigX509ConfigKeyUsage[];

  /**
   * (Output) Describes the X.509 name constraints extension. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigX509Config#nameConstraints
   */
  readonly nameConstraints?: CertificateSpecInitProviderConfigX509ConfigNameConstraints[];

  /**
   * (Output) Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigX509Config#policyIds
   */
  readonly policyIds?: CertificateSpecInitProviderConfigX509ConfigPolicyIds[];

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigX509Config' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigX509Config(obj: CertificateSpecInitProviderConfigX509Config | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateSpecInitProviderConfigX509ConfigAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CertificateSpecInitProviderConfigX509ConfigCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CertificateSpecInitProviderConfigX509ConfigKeyUsage(y)),
    'nameConstraints': obj.nameConstraints?.map(y => toJson_CertificateSpecInitProviderConfigX509ConfigNameConstraints(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CertificateSpecInitProviderConfigX509ConfigPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolution
 */
export enum CertificateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolve
 */
export enum CertificateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityRefPolicyResolution
 */
export enum CertificateSpecForProviderCertificateAuthorityRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityRefPolicyResolve
 */
export enum CertificateSpecForProviderCertificateAuthorityRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolution
 */
export enum CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolve
 */
export enum CertificateSpecForProviderCertificateAuthoritySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateTemplateRefPolicyResolution
 */
export enum CertificateSpecForProviderCertificateTemplateRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateTemplateRefPolicyResolve
 */
export enum CertificateSpecForProviderCertificateTemplateRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateTemplateSelectorPolicyResolution
 */
export enum CertificateSpecForProviderCertificateTemplateSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateTemplateSelectorPolicyResolve
 */
export enum CertificateSpecForProviderCertificateTemplateSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Required. A public key. When this is specified in a request, the padding and encoding can be any of the options described by the respective 'KeyType' value. When this is generated by the service, it will always be an RFC 5280 SubjectPublicKeyInfo structure containing an algorithm identifier and a key. A base64-encoded string.
 *
 * @schema CertificateSpecForProviderConfigPublicKeyKeySecretRef
 */
export interface CertificateSpecForProviderConfigPublicKeyKeySecretRef {
  /**
   * The key to select.
   *
   * @schema CertificateSpecForProviderConfigPublicKeyKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema CertificateSpecForProviderConfigPublicKeyKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecForProviderConfigPublicKeyKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigPublicKeyKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigPublicKeyKeySecretRef(obj: CertificateSpecForProviderConfigPublicKeyKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigSubjectConfigSubject
 */
export interface CertificateSpecForProviderConfigSubjectConfigSubject {
  /**
   * The common name of the distinguished name.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#commonName
   */
  readonly commonName?: string;

  /**
   * The country code of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#countryCode
   */
  readonly countryCode?: string;

  /**
   * The locality or city of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#locality
   */
  readonly locality?: string;

  /**
   * The organization of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#organization
   */
  readonly organization?: string;

  /**
   * The organizational unit of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#organizationalUnit
   */
  readonly organizationalUnit?: string;

  /**
   * The postal code of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#postalCode
   */
  readonly postalCode?: string;

  /**
   * The province, territory, or regional state of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#province
   */
  readonly province?: string;

  /**
   * The street address of the subject.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubject#streetAddress
   */
  readonly streetAddress?: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigSubjectConfigSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigSubjectConfigSubject(obj: CertificateSpecForProviderConfigSubjectConfigSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'countryCode': obj.countryCode,
    'locality': obj.locality,
    'organization': obj.organization,
    'organizationalUnit': obj.organizationalUnit,
    'postalCode': obj.postalCode,
    'province': obj.province,
    'streetAddress': obj.streetAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigSubjectConfigSubjectAltName
 */
export interface CertificateSpecForProviderConfigSubjectConfigSubjectAltName {
  /**
   * Contains only valid, fully-qualified host names.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubjectAltName#dnsNames
   */
  readonly dnsNames?: string[];

  /**
   * Contains only valid RFC 2822 E-mail addresses.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubjectAltName#emailAddresses
   */
  readonly emailAddresses?: string[];

  /**
   * Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubjectAltName#ipAddresses
   */
  readonly ipAddresses?: string[];

  /**
   * Contains only valid RFC 3986 URIs.
   *
   * @schema CertificateSpecForProviderConfigSubjectConfigSubjectAltName#uris
   */
  readonly uris?: string[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigSubjectConfigSubjectAltName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigSubjectConfigSubjectAltName(obj: CertificateSpecForProviderConfigSubjectConfigSubjectAltName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsNames': obj.dnsNames?.map(y => y),
    'emailAddresses': obj.emailAddresses?.map(y => y),
    'ipAddresses': obj.ipAddresses?.map(y => y),
    'uris': obj.uris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensions
 */
export interface CertificateSpecForProviderConfigX509ConfigAdditionalExtensions {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensions#critical
   */
  readonly critical?: boolean;

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensions#objectId
   */
  readonly objectId?: CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId[];

  /**
   * (Output) The value of this X.509 extension.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigAdditionalExtensions(obj: CertificateSpecForProviderConfigX509ConfigAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigCaOptions
 */
export interface CertificateSpecForProviderConfigX509ConfigCaOptions {
  /**
   * When true, the "CA" in Basic Constraints extension will be set to true.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

  /**
   * When true, the "CA" in Basic Constraints extension will be set to false. If both is_ca and non_ca are unset, the extension will be omitted from the CA certificate.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigCaOptions#nonCa
   */
  readonly nonCa?: boolean;

  /**
   * When true, the "path length constraint" in Basic Constraints extension will be set to 0. if both max_issuer_path_length and zero_max_issuer_path_length are unset, the max path length will be omitted from the CA certificate.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigCaOptions#zeroMaxIssuerPathLength
   */
  readonly zeroMaxIssuerPathLength?: boolean;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigCaOptions(obj: CertificateSpecForProviderConfigX509ConfigCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
    'nonCa': obj.nonCa,
    'zeroMaxIssuerPathLength': obj.zeroMaxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigKeyUsage
 */
export interface CertificateSpecForProviderConfigX509ConfigKeyUsage {
  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage?: CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage[];

  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage?: CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage[];

  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages. Structure is documented below.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigKeyUsage(obj: CertificateSpecForProviderConfigX509ConfigKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigNameConstraints
 */
export interface CertificateSpecForProviderConfigX509ConfigNameConstraints {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigNameConstraints#critical
   */
  readonly critical?: boolean;

  /**
   * Contains excluded DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigNameConstraints#excludedDnsNames
   */
  readonly excludedDnsNames?: string[];

  /**
   * Contains the excluded email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigNameConstraints#excludedEmailAddresses
   */
  readonly excludedEmailAddresses?: string[];

  /**
   * Contains the excluded IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigNameConstraints#excludedIpRanges
   */
  readonly excludedIpRanges?: string[];

  /**
   * Contains the excluded URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CertificateSpecForProviderConfigX509ConfigNameConstraints#excludedUris
   */
  readonly excludedUris?: string[];

  /**
   * Contains permitted DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigNameConstraints#permittedDnsNames
   */
  readonly permittedDnsNames?: string[];

  /**
   * Contains the permitted email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigNameConstraints#permittedEmailAddresses
   */
  readonly permittedEmailAddresses?: string[];

  /**
   * Contains the permitted IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigNameConstraints#permittedIpRanges
   */
  readonly permittedIpRanges?: string[];

  /**
   * Contains the permitted URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CertificateSpecForProviderConfigX509ConfigNameConstraints#permittedUris
   */
  readonly permittedUris?: string[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigNameConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigNameConstraints(obj: CertificateSpecForProviderConfigX509ConfigNameConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'excludedDnsNames': obj.excludedDnsNames?.map(y => y),
    'excludedEmailAddresses': obj.excludedEmailAddresses?.map(y => y),
    'excludedIpRanges': obj.excludedIpRanges?.map(y => y),
    'excludedUris': obj.excludedUris?.map(y => y),
    'permittedDnsNames': obj.permittedDnsNames?.map(y => y),
    'permittedEmailAddresses': obj.permittedEmailAddresses?.map(y => y),
    'permittedIpRanges': obj.permittedIpRanges?.map(y => y),
    'permittedUris': obj.permittedUris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigPolicyIds
 */
export interface CertificateSpecForProviderConfigX509ConfigPolicyIds {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigPolicyIds#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigPolicyIds(obj: CertificateSpecForProviderConfigX509ConfigPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderPoolRefPolicyResolution
 */
export enum CertificateSpecForProviderPoolRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderPoolRefPolicyResolve
 */
export enum CertificateSpecForProviderPoolRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderPoolSelectorPolicyResolution
 */
export enum CertificateSpecForProviderPoolSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderPoolSelectorPolicyResolve
 */
export enum CertificateSpecForProviderPoolSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema CertificateSpecInitProviderConfigSubjectConfigSubject
 */
export interface CertificateSpecInitProviderConfigSubjectConfigSubject {
  /**
   * The common name of the distinguished name.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubject#commonName
   */
  readonly commonName?: string;

  /**
   * The country code of the subject.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubject#countryCode
   */
  readonly countryCode?: string;

  /**
   * The locality or city of the subject.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubject#locality
   */
  readonly locality?: string;

  /**
   * The organization of the subject.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubject#organization
   */
  readonly organization?: string;

  /**
   * The organizational unit of the subject.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubject#organizationalUnit
   */
  readonly organizationalUnit?: string;

  /**
   * The postal code of the subject.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubject#postalCode
   */
  readonly postalCode?: string;

  /**
   * The province, territory, or regional state of the subject.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubject#province
   */
  readonly province?: string;

  /**
   * The street address of the subject.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubject#streetAddress
   */
  readonly streetAddress?: string;

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigSubjectConfigSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigSubjectConfigSubject(obj: CertificateSpecInitProviderConfigSubjectConfigSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'countryCode': obj.countryCode,
    'locality': obj.locality,
    'organization': obj.organization,
    'organizationalUnit': obj.organizationalUnit,
    'postalCode': obj.postalCode,
    'province': obj.province,
    'streetAddress': obj.streetAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigSubjectConfigSubjectAltName
 */
export interface CertificateSpecInitProviderConfigSubjectConfigSubjectAltName {
  /**
   * Contains only valid, fully-qualified host names.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubjectAltName#dnsNames
   */
  readonly dnsNames?: string[];

  /**
   * Contains only valid RFC 2822 E-mail addresses.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubjectAltName#emailAddresses
   */
  readonly emailAddresses?: string[];

  /**
   * Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubjectAltName#ipAddresses
   */
  readonly ipAddresses?: string[];

  /**
   * Contains only valid RFC 3986 URIs.
   *
   * @schema CertificateSpecInitProviderConfigSubjectConfigSubjectAltName#uris
   */
  readonly uris?: string[];

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigSubjectConfigSubjectAltName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigSubjectConfigSubjectAltName(obj: CertificateSpecInitProviderConfigSubjectConfigSubjectAltName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsNames': obj.dnsNames?.map(y => y),
    'emailAddresses': obj.emailAddresses?.map(y => y),
    'ipAddresses': obj.ipAddresses?.map(y => y),
    'uris': obj.uris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigX509ConfigAdditionalExtensions
 */
export interface CertificateSpecInitProviderConfigX509ConfigAdditionalExtensions {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigAdditionalExtensions#critical
   */
  readonly critical?: boolean;

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigAdditionalExtensions#objectId
   */
  readonly objectId?: CertificateSpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId[];

  /**
   * (Output) The value of this X.509 extension.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigAdditionalExtensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigX509ConfigAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigX509ConfigAdditionalExtensions(obj: CertificateSpecInitProviderConfigX509ConfigAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CertificateSpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigX509ConfigCaOptions
 */
export interface CertificateSpecInitProviderConfigX509ConfigCaOptions {
  /**
   * When true, the "CA" in Basic Constraints extension will be set to true.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

  /**
   * When true, the "CA" in Basic Constraints extension will be set to false. If both is_ca and non_ca are unset, the extension will be omitted from the CA certificate.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigCaOptions#nonCa
   */
  readonly nonCa?: boolean;

  /**
   * When true, the "path length constraint" in Basic Constraints extension will be set to 0. if both max_issuer_path_length and zero_max_issuer_path_length are unset, the max path length will be omitted from the CA certificate.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigCaOptions#zeroMaxIssuerPathLength
   */
  readonly zeroMaxIssuerPathLength?: boolean;

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigX509ConfigCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigX509ConfigCaOptions(obj: CertificateSpecInitProviderConfigX509ConfigCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
    'nonCa': obj.nonCa,
    'zeroMaxIssuerPathLength': obj.zeroMaxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsage
 */
export interface CertificateSpecInitProviderConfigX509ConfigKeyUsage {
  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage?: CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage[];

  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage?: CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage[];

  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages. Structure is documented below.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CertificateSpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigX509ConfigKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigX509ConfigKeyUsage(obj: CertificateSpecInitProviderConfigX509ConfigKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CertificateSpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigX509ConfigNameConstraints
 */
export interface CertificateSpecInitProviderConfigX509ConfigNameConstraints {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigNameConstraints#critical
   */
  readonly critical?: boolean;

  /**
   * Contains excluded DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigNameConstraints#excludedDnsNames
   */
  readonly excludedDnsNames?: string[];

  /**
   * Contains the excluded email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigNameConstraints#excludedEmailAddresses
   */
  readonly excludedEmailAddresses?: string[];

  /**
   * Contains the excluded IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigNameConstraints#excludedIpRanges
   */
  readonly excludedIpRanges?: string[];

  /**
   * Contains the excluded URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigNameConstraints#excludedUris
   */
  readonly excludedUris?: string[];

  /**
   * Contains permitted DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigNameConstraints#permittedDnsNames
   */
  readonly permittedDnsNames?: string[];

  /**
   * Contains the permitted email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigNameConstraints#permittedEmailAddresses
   */
  readonly permittedEmailAddresses?: string[];

  /**
   * Contains the permitted IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigNameConstraints#permittedIpRanges
   */
  readonly permittedIpRanges?: string[];

  /**
   * Contains the permitted URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigNameConstraints#permittedUris
   */
  readonly permittedUris?: string[];

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigX509ConfigNameConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigX509ConfigNameConstraints(obj: CertificateSpecInitProviderConfigX509ConfigNameConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'excludedDnsNames': obj.excludedDnsNames?.map(y => y),
    'excludedEmailAddresses': obj.excludedEmailAddresses?.map(y => y),
    'excludedIpRanges': obj.excludedIpRanges?.map(y => y),
    'excludedUris': obj.excludedUris?.map(y => y),
    'permittedDnsNames': obj.permittedDnsNames?.map(y => y),
    'permittedEmailAddresses': obj.permittedEmailAddresses?.map(y => y),
    'permittedIpRanges': obj.permittedIpRanges?.map(y => y),
    'permittedUris': obj.permittedUris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigX509ConfigPolicyIds
 */
export interface CertificateSpecInitProviderConfigX509ConfigPolicyIds {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigPolicyIds#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigX509ConfigPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigX509ConfigPolicyIds(obj: CertificateSpecInitProviderConfigX509ConfigPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId
 */
export interface CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId(obj: CertificateSpecForProviderConfigX509ConfigAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage
 */
export interface CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage {
  /**
   * (Output) The key may be used to sign certificates.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * (Output) The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * (Output) The key may be used sign certificate revocation lists.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * (Output) The key may be used to encipher data.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * (Output) The key may be used to decipher only.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * (Output) The key may be used for digital signatures.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * (Output) The key may be used to encipher only.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * (Output) The key may be used in a key agreement protocol.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * (Output) The key may be used to encipher other keys.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage(obj: CertificateSpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage
 */
export interface CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage(obj: CertificateSpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages
 */
export interface CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(obj: CertificateSpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId
 */
export interface CertificateSpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId(obj: CertificateSpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage
 */
export interface CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage {
  /**
   * (Output) The key may be used to sign certificates.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * (Output) The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * (Output) The key may be used sign certificate revocation lists.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * (Output) The key may be used to encipher data.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * (Output) The key may be used to decipher only.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * (Output) The key may be used for digital signatures.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * (Output) The key may be used to encipher only.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * (Output) The key may be used in a key agreement protocol.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * (Output) The key may be used to encipher other keys.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage(obj: CertificateSpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage
 */
export interface CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage(obj: CertificateSpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages
 */
export interface CertificateSpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateSpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateSpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(obj: CertificateSpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CertificateAuthority is the Schema for the CertificateAuthoritys API. A CertificateAuthority represents an individual Certificate Authority.
 *
 * @schema CertificateAuthority
 */
export class CertificateAuthority extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateAuthority"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'CertificateAuthority',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateAuthority".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateAuthorityProps): any {
    return {
      ...CertificateAuthority.GVK,
      ...toJson_CertificateAuthorityProps(props),
    };
  }

  /**
   * Defines a "CertificateAuthority" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateAuthorityProps) {
    super(scope, id, {
      ...CertificateAuthority.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateAuthority.GVK,
      ...toJson_CertificateAuthorityProps(resolved),
    };
  }
}

/**
 * CertificateAuthority is the Schema for the CertificateAuthoritys API. A CertificateAuthority represents an individual Certificate Authority.
 *
 * @schema CertificateAuthority
 */
export interface CertificateAuthorityProps {
  /**
   * @schema CertificateAuthority#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateAuthoritySpec defines the desired state of CertificateAuthority
   *
   * @schema CertificateAuthority#spec
   */
  readonly spec: CertificateAuthoritySpec;

}

/**
 * Converts an object of type 'CertificateAuthorityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityProps(obj: CertificateAuthorityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateAuthoritySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthoritySpec defines the desired state of CertificateAuthority
 *
 * @schema CertificateAuthoritySpec
 */
export interface CertificateAuthoritySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateAuthoritySpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateAuthoritySpecDeletionPolicy;

  /**
   * @schema CertificateAuthoritySpec#forProvider
   */
  readonly forProvider: CertificateAuthoritySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CertificateAuthoritySpec#initProvider
   */
  readonly initProvider?: CertificateAuthoritySpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateAuthoritySpec#managementPolicies
   */
  readonly managementPolicies?: CertificateAuthoritySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateAuthoritySpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateAuthoritySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateAuthoritySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateAuthoritySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateAuthoritySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateAuthoritySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateAuthoritySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpec(obj: CertificateAuthoritySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateAuthoritySpecForProvider(obj.forProvider),
    'initProvider': toJson_CertificateAuthoritySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateAuthoritySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateAuthoritySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateAuthoritySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateAuthoritySpecDeletionPolicy
 */
export enum CertificateAuthoritySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateAuthoritySpecForProvider
 */
export interface CertificateAuthoritySpecForProvider {
  /**
   * The config used to create a self-signed X.509 certificate or CSR. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProvider#config
   */
  readonly config?: CertificateAuthoritySpecForProviderConfig[];

  /**
   * @schema CertificateAuthoritySpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Desired state of the CertificateAuthority. Set this field to STAGED to create a STAGED root CA.
   *
   * @schema CertificateAuthoritySpecForProvider#desiredState
   */
  readonly desiredState?: string;

  /**
   * The name of a Cloud Storage bucket where this CertificateAuthority will publish content, such as the CA certificate and CRLs. This must be a bucket name, without any prefixes (such as gs://) or suffixes (such as .googleapis.com). For example, to use a bucket named my-bucket, you would simply specify my-bucket. If not specified, a managed bucket will be created.
   *
   * @schema CertificateAuthoritySpecForProvider#gcsBucket
   */
  readonly gcsBucket?: string;

  /**
   * This field allows the CA to be deleted even if the CA has active certs. Active certs include both unrevoked and unexpired certs. Use with care. Defaults to false.
   *
   * @default false.
   * @schema CertificateAuthoritySpecForProvider#ignoreActiveCertificatesOnDeletion
   */
  readonly ignoreActiveCertificatesOnDeletion?: boolean;

  /**
   * Used when issuing certificates for this CertificateAuthority. If this CertificateAuthority is a self-signed CertificateAuthority, this key is also used to sign the self-signed CA certificate. Otherwise, it is used to sign a CSR. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProvider#keySpec
   */
  readonly keySpec?: CertificateAuthoritySpecForProviderKeySpec[];

  /**
   * Labels with user-defined metadata. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema CertificateAuthoritySpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The desired lifetime of the CA certificate. Used to create the "notBeforeTime" and "notAfterTime" fields inside an X.509 certificate. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema CertificateAuthoritySpecForProvider#lifetime
   */
  readonly lifetime?: string;

  /**
   * Location of the CertificateAuthority. A full list of valid locations can be found by running gcloud privateca locations list.
   *
   * @schema CertificateAuthoritySpecForProvider#location
   */
  readonly location: string;

  /**
   * The signed CA certificate issued from the subordinated CA's CSR. This is needed when activating the subordiante CA with a third party issuer.
   *
   * @schema CertificateAuthoritySpecForProvider#pemCaCertificate
   */
  readonly pemCaCertificate?: string;

  /**
   * The name of the CaPool this Certificate Authority belongs to.
   *
   * @schema CertificateAuthoritySpecForProvider#pool
   */
  readonly pool?: string;

  /**
   * Reference to a CAPool to populate pool.
   *
   * @schema CertificateAuthoritySpecForProvider#poolRef
   */
  readonly poolRef?: CertificateAuthoritySpecForProviderPoolRef;

  /**
   * Selector for a CAPool to populate pool.
   *
   * @schema CertificateAuthoritySpecForProvider#poolSelector
   */
  readonly poolSelector?: CertificateAuthoritySpecForProviderPoolSelector;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema CertificateAuthoritySpecForProvider#project
   */
  readonly project?: string;

  /**
   * If this flag is set, the Certificate Authority will be deleted as soon as possible without a 30-day grace period where undeletion would have been allowed. If you proceed, there will be no way to recover this CA. Use with care. Defaults to false.
   *
   * @default false.
   * @schema CertificateAuthoritySpecForProvider#skipGracePeriod
   */
  readonly skipGracePeriod?: boolean;

  /**
   * If this is a subordinate CertificateAuthority, this field will be set with the subordinate configuration, which describes its issuers. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProvider#subordinateConfig
   */
  readonly subordinateConfig?: CertificateAuthoritySpecForProviderSubordinateConfig[];

  /**
   * The Type of this CertificateAuthority. ~> Note: For SUBORDINATE Certificate Authorities, they need to be activated before they can issue certificates. Default value is SELF_SIGNED. Possible values are: SELF_SIGNED, SUBORDINATE.
   *
   * @schema CertificateAuthoritySpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProvider(obj: CertificateAuthoritySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config?.map(y => toJson_CertificateAuthoritySpecForProviderConfig(y)),
    'deletionProtection': obj.deletionProtection,
    'desiredState': obj.desiredState,
    'gcsBucket': obj.gcsBucket,
    'ignoreActiveCertificatesOnDeletion': obj.ignoreActiveCertificatesOnDeletion,
    'keySpec': obj.keySpec?.map(y => toJson_CertificateAuthoritySpecForProviderKeySpec(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifetime': obj.lifetime,
    'location': obj.location,
    'pemCaCertificate': obj.pemCaCertificate,
    'pool': obj.pool,
    'poolRef': toJson_CertificateAuthoritySpecForProviderPoolRef(obj.poolRef),
    'poolSelector': toJson_CertificateAuthoritySpecForProviderPoolSelector(obj.poolSelector),
    'project': obj.project,
    'skipGracePeriod': obj.skipGracePeriod,
    'subordinateConfig': obj.subordinateConfig?.map(y => toJson_CertificateAuthoritySpecForProviderSubordinateConfig(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CertificateAuthoritySpecInitProvider
 */
export interface CertificateAuthoritySpecInitProvider {
  /**
   * The config used to create a self-signed X.509 certificate or CSR. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProvider#config
   */
  readonly config?: CertificateAuthoritySpecInitProviderConfig[];

  /**
   * @schema CertificateAuthoritySpecInitProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Desired state of the CertificateAuthority. Set this field to STAGED to create a STAGED root CA.
   *
   * @schema CertificateAuthoritySpecInitProvider#desiredState
   */
  readonly desiredState?: string;

  /**
   * The name of a Cloud Storage bucket where this CertificateAuthority will publish content, such as the CA certificate and CRLs. This must be a bucket name, without any prefixes (such as gs://) or suffixes (such as .googleapis.com). For example, to use a bucket named my-bucket, you would simply specify my-bucket. If not specified, a managed bucket will be created.
   *
   * @schema CertificateAuthoritySpecInitProvider#gcsBucket
   */
  readonly gcsBucket?: string;

  /**
   * This field allows the CA to be deleted even if the CA has active certs. Active certs include both unrevoked and unexpired certs. Use with care. Defaults to false.
   *
   * @default false.
   * @schema CertificateAuthoritySpecInitProvider#ignoreActiveCertificatesOnDeletion
   */
  readonly ignoreActiveCertificatesOnDeletion?: boolean;

  /**
   * Used when issuing certificates for this CertificateAuthority. If this CertificateAuthority is a self-signed CertificateAuthority, this key is also used to sign the self-signed CA certificate. Otherwise, it is used to sign a CSR. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProvider#keySpec
   */
  readonly keySpec?: CertificateAuthoritySpecInitProviderKeySpec[];

  /**
   * Labels with user-defined metadata. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema CertificateAuthoritySpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The desired lifetime of the CA certificate. Used to create the "notBeforeTime" and "notAfterTime" fields inside an X.509 certificate. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema CertificateAuthoritySpecInitProvider#lifetime
   */
  readonly lifetime?: string;

  /**
   * The signed CA certificate issued from the subordinated CA's CSR. This is needed when activating the subordiante CA with a third party issuer.
   *
   * @schema CertificateAuthoritySpecInitProvider#pemCaCertificate
   */
  readonly pemCaCertificate?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema CertificateAuthoritySpecInitProvider#project
   */
  readonly project?: string;

  /**
   * If this flag is set, the Certificate Authority will be deleted as soon as possible without a 30-day grace period where undeletion would have been allowed. If you proceed, there will be no way to recover this CA. Use with care. Defaults to false.
   *
   * @default false.
   * @schema CertificateAuthoritySpecInitProvider#skipGracePeriod
   */
  readonly skipGracePeriod?: boolean;

  /**
   * If this is a subordinate CertificateAuthority, this field will be set with the subordinate configuration, which describes its issuers. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProvider#subordinateConfig
   */
  readonly subordinateConfig?: CertificateAuthoritySpecInitProviderSubordinateConfig[];

  /**
   * The Type of this CertificateAuthority. ~> Note: For SUBORDINATE Certificate Authorities, they need to be activated before they can issue certificates. Default value is SELF_SIGNED. Possible values are: SELF_SIGNED, SUBORDINATE.
   *
   * @schema CertificateAuthoritySpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProvider(obj: CertificateAuthoritySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config?.map(y => toJson_CertificateAuthoritySpecInitProviderConfig(y)),
    'deletionProtection': obj.deletionProtection,
    'desiredState': obj.desiredState,
    'gcsBucket': obj.gcsBucket,
    'ignoreActiveCertificatesOnDeletion': obj.ignoreActiveCertificatesOnDeletion,
    'keySpec': obj.keySpec?.map(y => toJson_CertificateAuthoritySpecInitProviderKeySpec(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifetime': obj.lifetime,
    'pemCaCertificate': obj.pemCaCertificate,
    'project': obj.project,
    'skipGracePeriod': obj.skipGracePeriod,
    'subordinateConfig': obj.subordinateConfig?.map(y => toJson_CertificateAuthoritySpecInitProviderSubordinateConfig(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateAuthoritySpecManagementPolicies
 */
export enum CertificateAuthoritySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateAuthoritySpecProviderConfigRef
 */
export interface CertificateAuthoritySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecProviderConfigRef#policy
   */
  readonly policy?: CertificateAuthoritySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderConfigRef(obj: CertificateAuthoritySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsTo
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateAuthoritySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsTo(obj: CertificateAuthoritySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateAuthoritySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateAuthoritySpecWriteConnectionSecretToRef
 */
export interface CertificateAuthoritySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateAuthoritySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateAuthoritySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecWriteConnectionSecretToRef(obj: CertificateAuthoritySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfig
 */
export interface CertificateAuthoritySpecForProviderConfig {
  /**
   * Specifies some of the values in a certificate that are related to the subject. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfig#subjectConfig
   */
  readonly subjectConfig?: CertificateAuthoritySpecForProviderConfigSubjectConfig[];

  /**
   * Describes how some of the technical X.509 fields in a certificate should be populated. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfig#x509Config
   */
  readonly x509Config?: CertificateAuthoritySpecForProviderConfigX509Config[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfig(obj: CertificateAuthoritySpecForProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectConfig': obj.subjectConfig?.map(y => toJson_CertificateAuthoritySpecForProviderConfigSubjectConfig(y)),
    'x509Config': obj.x509Config?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509Config(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderKeySpec
 */
export interface CertificateAuthoritySpecForProviderKeySpec {
  /**
   * The algorithm to use for creating a managed Cloud KMS key for a for a simplified experience. All managed keys will be have their ProtectionLevel as HSM. Possible values are: SIGN_HASH_ALGORITHM_UNSPECIFIED, RSA_PSS_2048_SHA256, RSA_PSS_3072_SHA256, RSA_PSS_4096_SHA256, RSA_PKCS1_2048_SHA256, RSA_PKCS1_3072_SHA256, RSA_PKCS1_4096_SHA256, EC_P256_SHA256, EC_P384_SHA384.
   *
   * @schema CertificateAuthoritySpecForProviderKeySpec#algorithm
   */
  readonly algorithm?: string;

  /**
   * The resource name for an existing Cloud KMS CryptoKeyVersion in the format projects/_/locations/_/keyRings/_/cryptoKeys/_/cryptoKeyVersions/*.
   *
   * @schema CertificateAuthoritySpecForProviderKeySpec#cloudKmsKeyVersion
   */
  readonly cloudKmsKeyVersion?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderKeySpec(obj: CertificateAuthoritySpecForProviderKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'cloudKmsKeyVersion': obj.cloudKmsKeyVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CAPool to populate pool.
 *
 * @schema CertificateAuthoritySpecForProviderPoolRef
 */
export interface CertificateAuthoritySpecForProviderPoolRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecForProviderPoolRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecForProviderPoolRef#policy
   */
  readonly policy?: CertificateAuthoritySpecForProviderPoolRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderPoolRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderPoolRef(obj: CertificateAuthoritySpecForProviderPoolRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecForProviderPoolRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CAPool to populate pool.
 *
 * @schema CertificateAuthoritySpecForProviderPoolSelector
 */
export interface CertificateAuthoritySpecForProviderPoolSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateAuthoritySpecForProviderPoolSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateAuthoritySpecForProviderPoolSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateAuthoritySpecForProviderPoolSelector#policy
   */
  readonly policy?: CertificateAuthoritySpecForProviderPoolSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderPoolSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderPoolSelector(obj: CertificateAuthoritySpecForProviderPoolSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateAuthoritySpecForProviderPoolSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderSubordinateConfig
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfig {
  /**
   * This can refer to a CertificateAuthority that was used to create a subordinate CertificateAuthority. This field is used for information and usability purposes only. The resource name is in the format projects/_/locations/_/caPools/_/certificateAuthorities/*.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfig#certificateAuthority
   */
  readonly certificateAuthority?: string;

  /**
   * Reference to a CertificateAuthority in privateca to populate certificateAuthority.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfig#certificateAuthorityRef
   */
  readonly certificateAuthorityRef?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef;

  /**
   * Selector for a CertificateAuthority in privateca to populate certificateAuthority.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfig#certificateAuthoritySelector
   */
  readonly certificateAuthoritySelector?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector;

  /**
   * Contains the PEM certificate chain for the issuers of this CertificateAuthority, but not pem certificate for this CA itself. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfig#pemIssuerChain
   */
  readonly pemIssuerChain?: CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfig(obj: CertificateAuthoritySpecForProviderSubordinateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthority': obj.certificateAuthority,
    'certificateAuthorityRef': toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef(obj.certificateAuthorityRef),
    'certificateAuthoritySelector': toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector(obj.certificateAuthoritySelector),
    'pemIssuerChain': obj.pemIssuerChain?.map(y => toJson_CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfig
 */
export interface CertificateAuthoritySpecInitProviderConfig {
  /**
   * Specifies some of the values in a certificate that are related to the subject. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfig#subjectConfig
   */
  readonly subjectConfig?: CertificateAuthoritySpecInitProviderConfigSubjectConfig[];

  /**
   * Describes how some of the technical X.509 fields in a certificate should be populated. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfig#x509Config
   */
  readonly x509Config?: CertificateAuthoritySpecInitProviderConfigX509Config[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfig(obj: CertificateAuthoritySpecInitProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectConfig': obj.subjectConfig?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigSubjectConfig(y)),
    'x509Config': obj.x509Config?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigX509Config(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderKeySpec
 */
export interface CertificateAuthoritySpecInitProviderKeySpec {
  /**
   * The algorithm to use for creating a managed Cloud KMS key for a for a simplified experience. All managed keys will be have their ProtectionLevel as HSM. Possible values are: SIGN_HASH_ALGORITHM_UNSPECIFIED, RSA_PSS_2048_SHA256, RSA_PSS_3072_SHA256, RSA_PSS_4096_SHA256, RSA_PKCS1_2048_SHA256, RSA_PKCS1_3072_SHA256, RSA_PKCS1_4096_SHA256, EC_P256_SHA256, EC_P384_SHA384.
   *
   * @schema CertificateAuthoritySpecInitProviderKeySpec#algorithm
   */
  readonly algorithm?: string;

  /**
   * The resource name for an existing Cloud KMS CryptoKeyVersion in the format projects/_/locations/_/keyRings/_/cryptoKeys/_/cryptoKeyVersions/*.
   *
   * @schema CertificateAuthoritySpecInitProviderKeySpec#cloudKmsKeyVersion
   */
  readonly cloudKmsKeyVersion?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderKeySpec(obj: CertificateAuthoritySpecInitProviderKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'cloudKmsKeyVersion': obj.cloudKmsKeyVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderSubordinateConfig
 */
export interface CertificateAuthoritySpecInitProviderSubordinateConfig {
  /**
   * Contains the PEM certificate chain for the issuers of this CertificateAuthority, but not pem certificate for this CA itself. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderSubordinateConfig#pemIssuerChain
   */
  readonly pemIssuerChain?: CertificateAuthoritySpecInitProviderSubordinateConfigPemIssuerChain[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderSubordinateConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderSubordinateConfig(obj: CertificateAuthoritySpecInitProviderSubordinateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pemIssuerChain': obj.pemIssuerChain?.map(y => toJson_CertificateAuthoritySpecInitProviderSubordinateConfigPemIssuerChain(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicy
 */
export interface CertificateAuthoritySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderConfigRefPolicy(obj: CertificateAuthoritySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRef(obj: CertificateAuthoritySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToMetadata(obj: CertificateAuthoritySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigSubjectConfig
 */
export interface CertificateAuthoritySpecForProviderConfigSubjectConfig {
  /**
   * Contains distinguished name fields such as the location and organization. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfig#subject
   */
  readonly subject?: CertificateAuthoritySpecForProviderConfigSubjectConfigSubject[];

  /**
   * The subject alternative name fields. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfig#subjectAltName
   */
  readonly subjectAltName?: CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigSubjectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigSubjectConfig(obj: CertificateAuthoritySpecForProviderConfigSubjectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subject': obj.subject?.map(y => toJson_CertificateAuthoritySpecForProviderConfigSubjectConfigSubject(y)),
    'subjectAltName': obj.subjectAltName?.map(y => toJson_CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509Config
 */
export interface CertificateAuthoritySpecForProviderConfigX509Config {
  /**
   * Specifies an X.509 extension, which may be used in different parts of X.509 objects like certificates, CSRs, and CRLs. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#additionalExtensions
   */
  readonly additionalExtensions?: CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions[];

  /**
   * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#caOptions
   */
  readonly caOptions?: CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions[];

  /**
   * Indicates the intended use for keys that correspond to a certificate. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#keyUsage
   */
  readonly keyUsage?: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage[];

  /**
   * Describes the X.509 name constraints extension. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#nameConstraints
   */
  readonly nameConstraints?: CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints[];

  /**
   * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509Config#policyIds
   */
  readonly policyIds?: CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509Config' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509Config(obj: CertificateAuthoritySpecForProviderConfigX509Config | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage(y)),
    'nameConstraints': obj.nameConstraints?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecForProviderPoolRefPolicy
 */
export interface CertificateAuthoritySpecForProviderPoolRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecForProviderPoolRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecForProviderPoolRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecForProviderPoolRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecForProviderPoolRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderPoolRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderPoolRefPolicy(obj: CertificateAuthoritySpecForProviderPoolRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateAuthoritySpecForProviderPoolSelectorPolicy
 */
export interface CertificateAuthoritySpecForProviderPoolSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecForProviderPoolSelectorPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecForProviderPoolSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecForProviderPoolSelectorPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecForProviderPoolSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderPoolSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderPoolSelectorPolicy(obj: CertificateAuthoritySpecForProviderPoolSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateAuthority in privateca to populate certificateAuthority.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef#policy
   */
  readonly policy?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef(obj: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateAuthority in privateca to populate certificateAuthority.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector#policy
   */
  readonly policy?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector(obj: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain {
  /**
   * Expected to be in leaf-to-root order according to RFC 5246.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain#pemCertificates
   */
  readonly pemCertificates?: string[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain(obj: CertificateAuthoritySpecForProviderSubordinateConfigPemIssuerChain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pemCertificates': obj.pemCertificates?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfig
 */
export interface CertificateAuthoritySpecInitProviderConfigSubjectConfig {
  /**
   * Contains distinguished name fields such as the location and organization. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfig#subject
   */
  readonly subject?: CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject[];

  /**
   * The subject alternative name fields. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfig#subjectAltName
   */
  readonly subjectAltName?: CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigSubjectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigSubjectConfig(obj: CertificateAuthoritySpecInitProviderConfigSubjectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subject': obj.subject?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject(y)),
    'subjectAltName': obj.subjectAltName?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigX509Config
 */
export interface CertificateAuthoritySpecInitProviderConfigX509Config {
  /**
   * Specifies an X.509 extension, which may be used in different parts of X.509 objects like certificates, CSRs, and CRLs. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509Config#additionalExtensions
   */
  readonly additionalExtensions?: CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensions[];

  /**
   * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509Config#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509Config#caOptions
   */
  readonly caOptions?: CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions[];

  /**
   * Indicates the intended use for keys that correspond to a certificate. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509Config#keyUsage
   */
  readonly keyUsage?: CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsage[];

  /**
   * Describes the X.509 name constraints extension. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509Config#nameConstraints
   */
  readonly nameConstraints?: CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints[];

  /**
   * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509Config#policyIds
   */
  readonly policyIds?: CertificateAuthoritySpecInitProviderConfigX509ConfigPolicyIds[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigX509Config' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigX509Config(obj: CertificateAuthoritySpecInitProviderConfigX509Config | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsage(y)),
    'nameConstraints': obj.nameConstraints?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderSubordinateConfigPemIssuerChain
 */
export interface CertificateAuthoritySpecInitProviderSubordinateConfigPemIssuerChain {
  /**
   * Expected to be in leaf-to-root order according to RFC 5246.
   *
   * @schema CertificateAuthoritySpecInitProviderSubordinateConfigPemIssuerChain#pemCertificates
   */
  readonly pemCertificates?: string[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderSubordinateConfigPemIssuerChain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderSubordinateConfigPemIssuerChain(obj: CertificateAuthoritySpecInitProviderSubordinateConfigPemIssuerChain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pemCertificates': obj.pemCertificates?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicyResolution
 */
export enum CertificateAuthoritySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicyResolve
 */
export enum CertificateAuthoritySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject
 */
export interface CertificateAuthoritySpecForProviderConfigSubjectConfigSubject {
  /**
   * The common name of the distinguished name.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#commonName
   */
  readonly commonName?: string;

  /**
   * The country code of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#countryCode
   */
  readonly countryCode?: string;

  /**
   * The locality or city of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#locality
   */
  readonly locality?: string;

  /**
   * The organization of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#organization
   */
  readonly organization?: string;

  /**
   * The organizational unit of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#organizationalUnit
   */
  readonly organizationalUnit?: string;

  /**
   * The postal code of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#postalCode
   */
  readonly postalCode?: string;

  /**
   * The province, territory, or regional state of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#province
   */
  readonly province?: string;

  /**
   * The street address of the subject.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubject#streetAddress
   */
  readonly streetAddress?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigSubjectConfigSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigSubjectConfigSubject(obj: CertificateAuthoritySpecForProviderConfigSubjectConfigSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'countryCode': obj.countryCode,
    'locality': obj.locality,
    'organization': obj.organization,
    'organizationalUnit': obj.organizationalUnit,
    'postalCode': obj.postalCode,
    'province': obj.province,
    'streetAddress': obj.streetAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName
 */
export interface CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName {
  /**
   * Contains only valid, fully-qualified host names.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName#dnsNames
   */
  readonly dnsNames?: string[];

  /**
   * Contains only valid RFC 2822 E-mail addresses.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName#emailAddresses
   */
  readonly emailAddresses?: string[];

  /**
   * Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName#ipAddresses
   */
  readonly ipAddresses?: string[];

  /**
   * Contains only valid RFC 3986 URIs.
   *
   * @schema CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName#uris
   */
  readonly uris?: string[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName(obj: CertificateAuthoritySpecForProviderConfigSubjectConfigSubjectAltName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsNames': obj.dnsNames?.map(y => y),
    'emailAddresses': obj.emailAddresses?.map(y => y),
    'ipAddresses': obj.ipAddresses?.map(y => y),
    'uris': obj.uris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions#critical
   */
  readonly critical?: boolean;

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions#objectId
   */
  readonly objectId?: CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId[];

  /**
   * The value of this X.509 extension. A base64-encoded string.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions(obj: CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions {
  /**
   * When true, the "CA" in Basic Constraints extension will be set to true.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail. Setting the value to 0 requires setting zero_max_issuer_path_length = true.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

  /**
   * When true, the "CA" in Basic Constraints extension will be set to false. If both is_ca and non_ca are unset, the extension will be omitted from the CA certificate.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions#nonCa
   */
  readonly nonCa?: boolean;

  /**
   * When true, the "path length constraint" in Basic Constraints extension will be set to 0. If both max_issuer_path_length and zero_max_issuer_path_length are unset, the max path length will be omitted from the CA certificate.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions#zeroMaxIssuerPathLength
   */
  readonly zeroMaxIssuerPathLength?: boolean;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions(obj: CertificateAuthoritySpecForProviderConfigX509ConfigCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
    'nonCa': obj.nonCa,
    'zeroMaxIssuerPathLength': obj.zeroMaxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage {
  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage?: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage[];

  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage?: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage[];

  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage(obj: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints#critical
   */
  readonly critical?: boolean;

  /**
   * Contains excluded DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints#excludedDnsNames
   */
  readonly excludedDnsNames?: string[];

  /**
   * Contains the excluded email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints#excludedEmailAddresses
   */
  readonly excludedEmailAddresses?: string[];

  /**
   * Contains the excluded IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints#excludedIpRanges
   */
  readonly excludedIpRanges?: string[];

  /**
   * Contains the excluded URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints#excludedUris
   */
  readonly excludedUris?: string[];

  /**
   * Contains permitted DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints#permittedDnsNames
   */
  readonly permittedDnsNames?: string[];

  /**
   * Contains the permitted email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints#permittedEmailAddresses
   */
  readonly permittedEmailAddresses?: string[];

  /**
   * Contains the permitted IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints#permittedIpRanges
   */
  readonly permittedIpRanges?: string[];

  /**
   * Contains the permitted URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints#permittedUris
   */
  readonly permittedUris?: string[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints(obj: CertificateAuthoritySpecForProviderConfigX509ConfigNameConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'excludedDnsNames': obj.excludedDnsNames?.map(y => y),
    'excludedEmailAddresses': obj.excludedEmailAddresses?.map(y => y),
    'excludedIpRanges': obj.excludedIpRanges?.map(y => y),
    'excludedUris': obj.excludedUris?.map(y => y),
    'permittedDnsNames': obj.permittedDnsNames?.map(y => y),
    'permittedEmailAddresses': obj.permittedEmailAddresses?.map(y => y),
    'permittedIpRanges': obj.permittedIpRanges?.map(y => y),
    'permittedUris': obj.permittedUris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds(obj: CertificateAuthoritySpecForProviderConfigX509ConfigPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecForProviderPoolRefPolicyResolution
 */
export enum CertificateAuthoritySpecForProviderPoolRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecForProviderPoolRefPolicyResolve
 */
export enum CertificateAuthoritySpecForProviderPoolRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecForProviderPoolSelectorPolicyResolution
 */
export enum CertificateAuthoritySpecForProviderPoolSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecForProviderPoolSelectorPolicyResolve
 */
export enum CertificateAuthoritySpecForProviderPoolSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy(obj: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy
 */
export interface CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy(obj: CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject
 */
export interface CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject {
  /**
   * The common name of the distinguished name.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject#commonName
   */
  readonly commonName?: string;

  /**
   * The country code of the subject.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject#countryCode
   */
  readonly countryCode?: string;

  /**
   * The locality or city of the subject.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject#locality
   */
  readonly locality?: string;

  /**
   * The organization of the subject.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject#organization
   */
  readonly organization?: string;

  /**
   * The organizational unit of the subject.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject#organizationalUnit
   */
  readonly organizationalUnit?: string;

  /**
   * The postal code of the subject.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject#postalCode
   */
  readonly postalCode?: string;

  /**
   * The province, territory, or regional state of the subject.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject#province
   */
  readonly province?: string;

  /**
   * The street address of the subject.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject#streetAddress
   */
  readonly streetAddress?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject(obj: CertificateAuthoritySpecInitProviderConfigSubjectConfigSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'countryCode': obj.countryCode,
    'locality': obj.locality,
    'organization': obj.organization,
    'organizationalUnit': obj.organizationalUnit,
    'postalCode': obj.postalCode,
    'province': obj.province,
    'streetAddress': obj.streetAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName
 */
export interface CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName {
  /**
   * Contains only valid, fully-qualified host names.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName#dnsNames
   */
  readonly dnsNames?: string[];

  /**
   * Contains only valid RFC 2822 E-mail addresses.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName#emailAddresses
   */
  readonly emailAddresses?: string[];

  /**
   * Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName#ipAddresses
   */
  readonly ipAddresses?: string[];

  /**
   * Contains only valid RFC 3986 URIs.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName#uris
   */
  readonly uris?: string[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName(obj: CertificateAuthoritySpecInitProviderConfigSubjectConfigSubjectAltName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsNames': obj.dnsNames?.map(y => y),
    'emailAddresses': obj.emailAddresses?.map(y => y),
    'ipAddresses': obj.ipAddresses?.map(y => y),
    'uris': obj.uris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensions
 */
export interface CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensions {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensions#critical
   */
  readonly critical?: boolean;

  /**
   * Describes values that are relevant in a CA certificate. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensions#objectId
   */
  readonly objectId?: CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId[];

  /**
   * The value of this X.509 extension. A base64-encoded string.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensions(obj: CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions
 */
export interface CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions {
  /**
   * When true, the "CA" in Basic Constraints extension will be set to true.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail. Setting the value to 0 requires setting zero_max_issuer_path_length = true.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

  /**
   * When true, the "CA" in Basic Constraints extension will be set to false. If both is_ca and non_ca are unset, the extension will be omitted from the CA certificate.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions#nonCa
   */
  readonly nonCa?: boolean;

  /**
   * When true, the "path length constraint" in Basic Constraints extension will be set to 0. If both max_issuer_path_length and zero_max_issuer_path_length are unset, the max path length will be omitted from the CA certificate.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions#zeroMaxIssuerPathLength
   */
  readonly zeroMaxIssuerPathLength?: boolean;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions(obj: CertificateAuthoritySpecInitProviderConfigX509ConfigCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
    'nonCa': obj.nonCa,
    'zeroMaxIssuerPathLength': obj.zeroMaxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsage
 */
export interface CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsage {
  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage?: CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage[];

  /**
   * Describes high-level ways in which a key may be used. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage?: CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage[];

  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages. Structure is documented below.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsage(obj: CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints
 */
export interface CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints {
  /**
   * Indicates whether or not the name constraints are marked critical.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints#critical
   */
  readonly critical?: boolean;

  /**
   * Contains excluded DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints#excludedDnsNames
   */
  readonly excludedDnsNames?: string[];

  /**
   * Contains the excluded email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints#excludedEmailAddresses
   */
  readonly excludedEmailAddresses?: string[];

  /**
   * Contains the excluded IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints#excludedIpRanges
   */
  readonly excludedIpRanges?: string[];

  /**
   * Contains the excluded URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints#excludedUris
   */
  readonly excludedUris?: string[];

  /**
   * Contains permitted DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, example.com, www.example.com, www.sub.example.com would satisfy example.com while example1.com does not.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints#permittedDnsNames
   */
  readonly permittedDnsNames?: string[];

  /**
   * Contains the permitted email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. .example.com) to indicate all email addresses in that domain.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints#permittedEmailAddresses
   */
  readonly permittedEmailAddresses?: string[];

  /**
   * Contains the permitted IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints#permittedIpRanges
   */
  readonly permittedIpRanges?: string[];

  /**
   * Contains the permitted URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like .example.com)
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints#permittedUris
   */
  readonly permittedUris?: string[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints(obj: CertificateAuthoritySpecInitProviderConfigX509ConfigNameConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'excludedDnsNames': obj.excludedDnsNames?.map(y => y),
    'excludedEmailAddresses': obj.excludedEmailAddresses?.map(y => y),
    'excludedIpRanges': obj.excludedIpRanges?.map(y => y),
    'excludedUris': obj.excludedUris?.map(y => y),
    'permittedDnsNames': obj.permittedDnsNames?.map(y => y),
    'permittedEmailAddresses': obj.permittedEmailAddresses?.map(y => y),
    'permittedIpRanges': obj.permittedIpRanges?.map(y => y),
    'permittedUris': obj.permittedUris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigPolicyIds
 */
export interface CertificateAuthoritySpecInitProviderConfigX509ConfigPolicyIds {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigPolicyIds#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigX509ConfigPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigPolicyIds(obj: CertificateAuthoritySpecInitProviderConfigX509ConfigPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId(obj: CertificateAuthoritySpecForProviderConfigX509ConfigAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage {
  /**
   * The key may be used to sign certificates.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * The key may be used sign certificate revocation lists.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * The key may be used to encipher data.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * The key may be used to decipher only.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * The key may be used for digital signatures.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * The key may be used to encipher only.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * The key may be used in a key agreement protocol.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * The key may be used to encipher other keys.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage(obj: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage(obj: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages
 */
export interface CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(obj: CertificateAuthoritySpecForProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolution
 */
export enum CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolve
 */
export enum CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthorityRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolution
 */
export enum CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolve
 */
export enum CertificateAuthoritySpecForProviderSubordinateConfigCertificateAuthoritySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId
 */
export interface CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId(obj: CertificateAuthoritySpecInitProviderConfigX509ConfigAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage
 */
export interface CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage {
  /**
   * The key may be used to sign certificates.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * The key may be used sign certificate revocation lists.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * The key may be used to encipher data.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * The key may be used to decipher only.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * The key may be used for digital signatures.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * The key may be used to encipher only.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * The key may be used in a key agreement protocol.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * The key may be used to encipher other keys.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage(obj: CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage
 */
export interface CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage(obj: CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages
 */
export interface CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages {
  /**
   * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
   *
   * @schema CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages(obj: CertificateAuthoritySpecInitProviderConfigX509ConfigKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CertificateTemplate is the Schema for the CertificateTemplates API. Certificate Authority Service provides reusable and parameterized templates that you can use for common certificate issuance scenarios. A certificate template represents a relatively static and well-defined certificate issuance schema within an organization.  A certificate template can essentially become a full-fledged vertical certificate issuance framework.
 *
 * @schema CertificateTemplate
 */
export class CertificateTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'CertificateTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateTemplateProps): any {
    return {
      ...CertificateTemplate.GVK,
      ...toJson_CertificateTemplateProps(props),
    };
  }

  /**
   * Defines a "CertificateTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateTemplateProps) {
    super(scope, id, {
      ...CertificateTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateTemplate.GVK,
      ...toJson_CertificateTemplateProps(resolved),
    };
  }
}

/**
 * CertificateTemplate is the Schema for the CertificateTemplates API. Certificate Authority Service provides reusable and parameterized templates that you can use for common certificate issuance scenarios. A certificate template represents a relatively static and well-defined certificate issuance schema within an organization.  A certificate template can essentially become a full-fledged vertical certificate issuance framework.
 *
 * @schema CertificateTemplate
 */
export interface CertificateTemplateProps {
  /**
   * @schema CertificateTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateTemplateSpec defines the desired state of CertificateTemplate
   *
   * @schema CertificateTemplate#spec
   */
  readonly spec: CertificateTemplateSpec;

}

/**
 * Converts an object of type 'CertificateTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateProps(obj: CertificateTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateTemplateSpec defines the desired state of CertificateTemplate
 *
 * @schema CertificateTemplateSpec
 */
export interface CertificateTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateTemplateSpecDeletionPolicy;

  /**
   * @schema CertificateTemplateSpec#forProvider
   */
  readonly forProvider: CertificateTemplateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CertificateTemplateSpec#initProvider
   */
  readonly initProvider?: CertificateTemplateSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateTemplateSpec#managementPolicies
   */
  readonly managementPolicies?: CertificateTemplateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateTemplateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpec(obj: CertificateTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateTemplateSpecForProvider(obj.forProvider),
    'initProvider': toJson_CertificateTemplateSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateTemplateSpecDeletionPolicy
 */
export enum CertificateTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateTemplateSpecForProvider
 */
export interface CertificateTemplateSpecForProvider {
  /**
   * Optional. A human-readable description of scenarios this template is intended for.
   *
   * @schema CertificateTemplateSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Optional. Describes constraints on identities that may be appear in Certificates issued using this template. If this is omitted, then this template will not add restrictions on a certificate's identity.
   *
   * @schema CertificateTemplateSpecForProvider#identityConstraints
   */
  readonly identityConstraints?: CertificateTemplateSpecForProviderIdentityConstraints[];

  /**
   * Optional. Labels with user-defined metadata.
   *
   * @schema CertificateTemplateSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The location for the resource
   *
   * @schema CertificateTemplateSpecForProvider#location
   */
  readonly location: string;

  /**
   * Optional. Describes the set of X.509 extensions that may appear in a Certificate issued using this CertificateTemplate. If a certificate request sets extensions that don't appear in the passthrough_extensions, those extensions will be dropped. If the issuing CaPool's IssuancePolicy defines baseline_values that don't appear here, the certificate issuance request will fail. If this is omitted, then this template will not add restrictions on a certificate's X.509 extensions. These constraints do not apply to X.509 extensions set in this CertificateTemplate's predefined_values.
   *
   * @schema CertificateTemplateSpecForProvider#passthroughExtensions
   */
  readonly passthroughExtensions?: CertificateTemplateSpecForProviderPassthroughExtensions[];

  /**
   * Optional. A set of X.509 values that will be applied to all issued certificates that use this template. If the certificate request includes conflicting values for the same properties, they will be overwritten by the values defined here. If the issuing CaPool's IssuancePolicy defines conflicting baseline_values for the same properties, the certificate issuance request will fail.
   *
   * @schema CertificateTemplateSpecForProvider#predefinedValues
   */
  readonly predefinedValues?: CertificateTemplateSpecForProviderPredefinedValues[];

  /**
   * The project for the resource
   *
   * @schema CertificateTemplateSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProvider(obj: CertificateTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'identityConstraints': obj.identityConstraints?.map(y => toJson_CertificateTemplateSpecForProviderIdentityConstraints(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'passthroughExtensions': obj.passthroughExtensions?.map(y => toJson_CertificateTemplateSpecForProviderPassthroughExtensions(y)),
    'predefinedValues': obj.predefinedValues?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValues(y)),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CertificateTemplateSpecInitProvider
 */
export interface CertificateTemplateSpecInitProvider {
  /**
   * Optional. A human-readable description of scenarios this template is intended for.
   *
   * @schema CertificateTemplateSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Optional. Describes constraints on identities that may be appear in Certificates issued using this template. If this is omitted, then this template will not add restrictions on a certificate's identity.
   *
   * @schema CertificateTemplateSpecInitProvider#identityConstraints
   */
  readonly identityConstraints?: CertificateTemplateSpecInitProviderIdentityConstraints[];

  /**
   * Optional. Labels with user-defined metadata.
   *
   * @schema CertificateTemplateSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Optional. Describes the set of X.509 extensions that may appear in a Certificate issued using this CertificateTemplate. If a certificate request sets extensions that don't appear in the passthrough_extensions, those extensions will be dropped. If the issuing CaPool's IssuancePolicy defines baseline_values that don't appear here, the certificate issuance request will fail. If this is omitted, then this template will not add restrictions on a certificate's X.509 extensions. These constraints do not apply to X.509 extensions set in this CertificateTemplate's predefined_values.
   *
   * @schema CertificateTemplateSpecInitProvider#passthroughExtensions
   */
  readonly passthroughExtensions?: CertificateTemplateSpecInitProviderPassthroughExtensions[];

  /**
   * Optional. A set of X.509 values that will be applied to all issued certificates that use this template. If the certificate request includes conflicting values for the same properties, they will be overwritten by the values defined here. If the issuing CaPool's IssuancePolicy defines conflicting baseline_values for the same properties, the certificate issuance request will fail.
   *
   * @schema CertificateTemplateSpecInitProvider#predefinedValues
   */
  readonly predefinedValues?: CertificateTemplateSpecInitProviderPredefinedValues[];

  /**
   * The project for the resource
   *
   * @schema CertificateTemplateSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProvider(obj: CertificateTemplateSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'identityConstraints': obj.identityConstraints?.map(y => toJson_CertificateTemplateSpecInitProviderIdentityConstraints(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'passthroughExtensions': obj.passthroughExtensions?.map(y => toJson_CertificateTemplateSpecInitProviderPassthroughExtensions(y)),
    'predefinedValues': obj.predefinedValues?.map(y => toJson_CertificateTemplateSpecInitProviderPredefinedValues(y)),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateTemplateSpecManagementPolicies
 */
export enum CertificateTemplateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateTemplateSpecProviderConfigRef
 */
export interface CertificateTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecProviderConfigRef(obj: CertificateTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsTo
 */
export interface CertificateTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecPublishConnectionDetailsTo(obj: CertificateTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateTemplateSpecWriteConnectionSecretToRef
 */
export interface CertificateTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecWriteConnectionSecretToRef(obj: CertificateTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderIdentityConstraints
 */
export interface CertificateTemplateSpecForProviderIdentityConstraints {
  /**
   * Required. If this is true, the SubjectAltNames extension may be copied from a certificate request into the signed certificate. Otherwise, the requested SubjectAltNames will be discarded.
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraints#allowSubjectAltNamesPassthrough
   */
  readonly allowSubjectAltNamesPassthrough?: boolean;

  /**
   * Required. If this is true, the Subject field may be copied from a certificate request into the signed certificate. Otherwise, the requested Subject will be discarded.
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraints#allowSubjectPassthrough
   */
  readonly allowSubjectPassthrough?: boolean;

  /**
   * Optional. A CEL expression that may be used to validate the resolved X.509 Subject and/or Subject Alternative Name before a certificate is signed. To see the full allowed syntax and some examples, see https://cloud.google.com/certificate-authority-service/docs/using-cel
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraints#celExpression
   */
  readonly celExpression?: CertificateTemplateSpecForProviderIdentityConstraintsCelExpression[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderIdentityConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderIdentityConstraints(obj: CertificateTemplateSpecForProviderIdentityConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSubjectAltNamesPassthrough': obj.allowSubjectAltNamesPassthrough,
    'allowSubjectPassthrough': obj.allowSubjectPassthrough,
    'celExpression': obj.celExpression?.map(y => toJson_CertificateTemplateSpecForProviderIdentityConstraintsCelExpression(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPassthroughExtensions
 */
export interface CertificateTemplateSpecForProviderPassthroughExtensions {
  /**
   * Optional. A set of ObjectIds identifying custom X.509 extensions. Will be combined with known_extensions to determine the full set of X.509 extensions.
   *
   * @schema CertificateTemplateSpecForProviderPassthroughExtensions#additionalExtensions
   */
  readonly additionalExtensions?: CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions[];

  /**
   * Optional. A set of named X.509 extensions. Will be combined with additional_extensions to determine the full set of X.509 extensions.
   *
   * @schema CertificateTemplateSpecForProviderPassthroughExtensions#knownExtensions
   */
  readonly knownExtensions?: string[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPassthroughExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPassthroughExtensions(obj: CertificateTemplateSpecForProviderPassthroughExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions(y)),
    'knownExtensions': obj.knownExtensions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValues
 */
export interface CertificateTemplateSpecForProviderPredefinedValues {
  /**
   * Optional. Describes custom X.509 extensions.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValues#additionalExtensions
   */
  readonly additionalExtensions?: CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions[];

  /**
   * Optional. Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValues#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * Optional. Describes options in this X509Parameters that are relevant in a CA certificate.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValues#caOptions
   */
  readonly caOptions?: CertificateTemplateSpecForProviderPredefinedValuesCaOptions[];

  /**
   * Optional. Indicates the intended use for keys that correspond to a certificate.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValues#keyUsage
   */
  readonly keyUsage?: CertificateTemplateSpecForProviderPredefinedValuesKeyUsage[];

  /**
   * Optional. Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValues#policyIds
   */
  readonly policyIds?: CertificateTemplateSpecForProviderPredefinedValuesPolicyIds[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValues(obj: CertificateTemplateSpecForProviderPredefinedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsage(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderIdentityConstraints
 */
export interface CertificateTemplateSpecInitProviderIdentityConstraints {
  /**
   * Required. If this is true, the SubjectAltNames extension may be copied from a certificate request into the signed certificate. Otherwise, the requested SubjectAltNames will be discarded.
   *
   * @schema CertificateTemplateSpecInitProviderIdentityConstraints#allowSubjectAltNamesPassthrough
   */
  readonly allowSubjectAltNamesPassthrough?: boolean;

  /**
   * Required. If this is true, the Subject field may be copied from a certificate request into the signed certificate. Otherwise, the requested Subject will be discarded.
   *
   * @schema CertificateTemplateSpecInitProviderIdentityConstraints#allowSubjectPassthrough
   */
  readonly allowSubjectPassthrough?: boolean;

  /**
   * Optional. A CEL expression that may be used to validate the resolved X.509 Subject and/or Subject Alternative Name before a certificate is signed. To see the full allowed syntax and some examples, see https://cloud.google.com/certificate-authority-service/docs/using-cel
   *
   * @schema CertificateTemplateSpecInitProviderIdentityConstraints#celExpression
   */
  readonly celExpression?: CertificateTemplateSpecInitProviderIdentityConstraintsCelExpression[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderIdentityConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderIdentityConstraints(obj: CertificateTemplateSpecInitProviderIdentityConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSubjectAltNamesPassthrough': obj.allowSubjectAltNamesPassthrough,
    'allowSubjectPassthrough': obj.allowSubjectPassthrough,
    'celExpression': obj.celExpression?.map(y => toJson_CertificateTemplateSpecInitProviderIdentityConstraintsCelExpression(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPassthroughExtensions
 */
export interface CertificateTemplateSpecInitProviderPassthroughExtensions {
  /**
   * Optional. A set of ObjectIds identifying custom X.509 extensions. Will be combined with known_extensions to determine the full set of X.509 extensions.
   *
   * @schema CertificateTemplateSpecInitProviderPassthroughExtensions#additionalExtensions
   */
  readonly additionalExtensions?: CertificateTemplateSpecInitProviderPassthroughExtensionsAdditionalExtensions[];

  /**
   * Optional. A set of named X.509 extensions. Will be combined with additional_extensions to determine the full set of X.509 extensions.
   *
   * @schema CertificateTemplateSpecInitProviderPassthroughExtensions#knownExtensions
   */
  readonly knownExtensions?: string[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPassthroughExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPassthroughExtensions(obj: CertificateTemplateSpecInitProviderPassthroughExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateTemplateSpecInitProviderPassthroughExtensionsAdditionalExtensions(y)),
    'knownExtensions': obj.knownExtensions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPredefinedValues
 */
export interface CertificateTemplateSpecInitProviderPredefinedValues {
  /**
   * Optional. Describes custom X.509 extensions.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValues#additionalExtensions
   */
  readonly additionalExtensions?: CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensions[];

  /**
   * Optional. Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValues#aiaOcspServers
   */
  readonly aiaOcspServers?: string[];

  /**
   * Optional. Describes options in this X509Parameters that are relevant in a CA certificate.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValues#caOptions
   */
  readonly caOptions?: CertificateTemplateSpecInitProviderPredefinedValuesCaOptions[];

  /**
   * Optional. Indicates the intended use for keys that correspond to a certificate.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValues#keyUsage
   */
  readonly keyUsage?: CertificateTemplateSpecInitProviderPredefinedValuesKeyUsage[];

  /**
   * Optional. Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValues#policyIds
   */
  readonly policyIds?: CertificateTemplateSpecInitProviderPredefinedValuesPolicyIds[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPredefinedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPredefinedValues(obj: CertificateTemplateSpecInitProviderPredefinedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': obj.additionalExtensions?.map(y => toJson_CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensions(y)),
    'aiaOcspServers': obj.aiaOcspServers?.map(y => y),
    'caOptions': obj.caOptions?.map(y => toJson_CertificateTemplateSpecInitProviderPredefinedValuesCaOptions(y)),
    'keyUsage': obj.keyUsage?.map(y => toJson_CertificateTemplateSpecInitProviderPredefinedValuesKeyUsage(y)),
    'policyIds': obj.policyIds?.map(y => toJson_CertificateTemplateSpecInitProviderPredefinedValuesPolicyIds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateSpecProviderConfigRefPolicy
 */
export interface CertificateTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecProviderConfigRefPolicy(obj: CertificateTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecPublishConnectionDetailsToConfigRef(obj: CertificateTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecPublishConnectionDetailsToMetadata(obj: CertificateTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderIdentityConstraintsCelExpression
 */
export interface CertificateTemplateSpecForProviderIdentityConstraintsCelExpression {
  /**
   * Optional. A human-readable description of scenarios this template is intended for.
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraintsCelExpression#description
   */
  readonly description?: string;

  /**
   * Textual representation of an expression in Common Expression Language syntax.
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraintsCelExpression#expression
   */
  readonly expression?: string;

  /**
   * The location for the resource
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraintsCelExpression#location
   */
  readonly location?: string;

  /**
   * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
   *
   * @schema CertificateTemplateSpecForProviderIdentityConstraintsCelExpression#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderIdentityConstraintsCelExpression' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderIdentityConstraintsCelExpression(obj: CertificateTemplateSpecForProviderIdentityConstraintsCelExpression | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'location': obj.location,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions
 */
export interface CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions(obj: CertificateTemplateSpecForProviderPassthroughExtensionsAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions {
  /**
   * Optional. Indicates whether or not this extension is critical (i.e., if the client does not know how to handle this extension, the client should consider this to be an error).
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions#critical
   */
  readonly critical?: boolean;

  /**
   * Required. The OID for this X.509 extension.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions#objectId
   */
  readonly objectId?: CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId[];

  /**
   * Required. The value of this X.509 extension.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions(obj: CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesCaOptions
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesCaOptions {
  /**
   * Optional. Refers to the "CA" X.509 extension, which is a boolean value. When this value is missing, the extension will be omitted from the CA certificate.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Optional. Refers to the path length restriction X.509 extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail. If this value is missing, the max path length will be omitted from the CA certificate.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesCaOptions(obj: CertificateTemplateSpecForProviderPredefinedValuesCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsage
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesKeyUsage {
  /**
   * Describes high-level ways in which a key may be used.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage?: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage[];

  /**
   * Detailed scenarios in which a key may be used.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage?: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage[];

  /**
   * Used to describe extended key usages that are not listed in the KeyUsage.ExtendedKeyUsageOptions message.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsage(obj: CertificateTemplateSpecForProviderPredefinedValuesKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesPolicyIds
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesPolicyIds {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesPolicyIds#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesPolicyIds(obj: CertificateTemplateSpecForProviderPredefinedValuesPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderIdentityConstraintsCelExpression
 */
export interface CertificateTemplateSpecInitProviderIdentityConstraintsCelExpression {
  /**
   * Optional. A human-readable description of scenarios this template is intended for.
   *
   * @schema CertificateTemplateSpecInitProviderIdentityConstraintsCelExpression#description
   */
  readonly description?: string;

  /**
   * Textual representation of an expression in Common Expression Language syntax.
   *
   * @schema CertificateTemplateSpecInitProviderIdentityConstraintsCelExpression#expression
   */
  readonly expression?: string;

  /**
   * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
   *
   * @schema CertificateTemplateSpecInitProviderIdentityConstraintsCelExpression#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderIdentityConstraintsCelExpression' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderIdentityConstraintsCelExpression(obj: CertificateTemplateSpecInitProviderIdentityConstraintsCelExpression | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPassthroughExtensionsAdditionalExtensions
 */
export interface CertificateTemplateSpecInitProviderPassthroughExtensionsAdditionalExtensions {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecInitProviderPassthroughExtensionsAdditionalExtensions#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPassthroughExtensionsAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPassthroughExtensionsAdditionalExtensions(obj: CertificateTemplateSpecInitProviderPassthroughExtensionsAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensions
 */
export interface CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensions {
  /**
   * Optional. Indicates whether or not this extension is critical (i.e., if the client does not know how to handle this extension, the client should consider this to be an error).
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensions#critical
   */
  readonly critical?: boolean;

  /**
   * Required. The OID for this X.509 extension.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensions#objectId
   */
  readonly objectId?: CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensionsObjectId[];

  /**
   * Required. The value of this X.509 extension.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensions(obj: CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'objectId': obj.objectId?.map(y => toJson_CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensionsObjectId(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPredefinedValuesCaOptions
 */
export interface CertificateTemplateSpecInitProviderPredefinedValuesCaOptions {
  /**
   * Optional. Refers to the "CA" X.509 extension, which is a boolean value. When this value is missing, the extension will be omitted from the CA certificate.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesCaOptions#isCa
   */
  readonly isCa?: boolean;

  /**
   * Optional. Refers to the path length restriction X.509 extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail. If this value is missing, the max path length will be omitted from the CA certificate.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesCaOptions#maxIssuerPathLength
   */
  readonly maxIssuerPathLength?: number;

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPredefinedValuesCaOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPredefinedValuesCaOptions(obj: CertificateTemplateSpecInitProviderPredefinedValuesCaOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isCa': obj.isCa,
    'maxIssuerPathLength': obj.maxIssuerPathLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsage
 */
export interface CertificateTemplateSpecInitProviderPredefinedValuesKeyUsage {
  /**
   * Describes high-level ways in which a key may be used.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsage#baseKeyUsage
   */
  readonly baseKeyUsage?: CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage[];

  /**
   * Detailed scenarios in which a key may be used.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsage#extendedKeyUsage
   */
  readonly extendedKeyUsage?: CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage[];

  /**
   * Used to describe extended key usages that are not listed in the KeyUsage.ExtendedKeyUsageOptions message.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsage#unknownExtendedKeyUsages
   */
  readonly unknownExtendedKeyUsages?: CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPredefinedValuesKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPredefinedValuesKeyUsage(obj: CertificateTemplateSpecInitProviderPredefinedValuesKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseKeyUsage': obj.baseKeyUsage?.map(y => toJson_CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage(y)),
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => toJson_CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage(y)),
    'unknownExtendedKeyUsages': obj.unknownExtendedKeyUsages?.map(y => toJson_CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPredefinedValuesPolicyIds
 */
export interface CertificateTemplateSpecInitProviderPredefinedValuesPolicyIds {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesPolicyIds#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPredefinedValuesPolicyIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPredefinedValuesPolicyIds(obj: CertificateTemplateSpecInitProviderPredefinedValuesPolicyIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateSpecProviderConfigRefPolicyResolution
 */
export enum CertificateTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateSpecProviderConfigRefPolicyResolve
 */
export enum CertificateTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId(obj: CertificateTemplateSpecForProviderPredefinedValuesAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage {
  /**
   * The key may be used to sign certificates.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * The key may be used sign certificate revocation lists.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * The key may be used to encipher data.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * The key may be used to decipher only.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * The key may be used for digital signatures.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * The key may be used to encipher only.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * The key may be used in a key agreement protocol.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * The key may be used to encipher other keys.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage(obj: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage(obj: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages
 */
export interface CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages(obj: CertificateTemplateSpecForProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensionsObjectId
 */
export interface CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensionsObjectId {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensionsObjectId#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensionsObjectId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensionsObjectId(obj: CertificateTemplateSpecInitProviderPredefinedValuesAdditionalExtensionsObjectId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage
 */
export interface CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage {
  /**
   * The key may be used to sign certificates.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage#certSign
   */
  readonly certSign?: boolean;

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage#contentCommitment
   */
  readonly contentCommitment?: boolean;

  /**
   * The key may be used sign certificate revocation lists.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage#crlSign
   */
  readonly crlSign?: boolean;

  /**
   * The key may be used to encipher data.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage#dataEncipherment
   */
  readonly dataEncipherment?: boolean;

  /**
   * The key may be used to decipher only.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage#decipherOnly
   */
  readonly decipherOnly?: boolean;

  /**
   * The key may be used for digital signatures.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage#digitalSignature
   */
  readonly digitalSignature?: boolean;

  /**
   * The key may be used to encipher only.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage#encipherOnly
   */
  readonly encipherOnly?: boolean;

  /**
   * The key may be used in a key agreement protocol.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage#keyAgreement
   */
  readonly keyAgreement?: boolean;

  /**
   * The key may be used to encipher other keys.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage#keyEncipherment
   */
  readonly keyEncipherment?: boolean;

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage(obj: CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageBaseKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSign': obj.certSign,
    'contentCommitment': obj.contentCommitment,
    'crlSign': obj.crlSign,
    'dataEncipherment': obj.dataEncipherment,
    'decipherOnly': obj.decipherOnly,
    'digitalSignature': obj.digitalSignature,
    'encipherOnly': obj.encipherOnly,
    'keyAgreement': obj.keyAgreement,
    'keyEncipherment': obj.keyEncipherment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage
 */
export interface CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage#clientAuth
   */
  readonly clientAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage#codeSigning
   */
  readonly codeSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage#emailProtection
   */
  readonly emailProtection?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage#ocspSigning
   */
  readonly ocspSigning?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage#serverAuth
   */
  readonly serverAuth?: boolean;

  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage#timeStamping
   */
  readonly timeStamping?: boolean;

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage(obj: CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageExtendedKeyUsage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuth': obj.clientAuth,
    'codeSigning': obj.codeSigning,
    'emailProtection': obj.emailProtection,
    'ocspSigning': obj.ocspSigning,
    'serverAuth': obj.serverAuth,
    'timeStamping': obj.timeStamping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages
 */
export interface CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come first.
   *
   * @schema CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages#objectIdPath
   */
  readonly objectIdPath?: number[];

}

/**
 * Converts an object of type 'CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages(obj: CertificateTemplateSpecInitProviderPredefinedValuesKeyUsageUnknownExtendedKeyUsages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectIdPath': obj.objectIdPath?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CertificateTemplateIAMMember is the Schema for the CertificateTemplateIAMMembers API. <no value>
 *
 * @schema CertificateTemplateIAMMember
 */
export class CertificateTemplateIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateTemplateIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'privateca.gcp.upbound.io/v1beta1',
    kind: 'CertificateTemplateIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateTemplateIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateTemplateIamMemberProps): any {
    return {
      ...CertificateTemplateIamMember.GVK,
      ...toJson_CertificateTemplateIamMemberProps(props),
    };
  }

  /**
   * Defines a "CertificateTemplateIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateTemplateIamMemberProps) {
    super(scope, id, {
      ...CertificateTemplateIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateTemplateIamMember.GVK,
      ...toJson_CertificateTemplateIamMemberProps(resolved),
    };
  }
}

/**
 * CertificateTemplateIAMMember is the Schema for the CertificateTemplateIAMMembers API. <no value>
 *
 * @schema CertificateTemplateIAMMember
 */
export interface CertificateTemplateIamMemberProps {
  /**
   * @schema CertificateTemplateIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateTemplateIAMMemberSpec defines the desired state of CertificateTemplateIAMMember
   *
   * @schema CertificateTemplateIAMMember#spec
   */
  readonly spec: CertificateTemplateIamMemberSpec;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberProps(obj: CertificateTemplateIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateTemplateIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateTemplateIAMMemberSpec defines the desired state of CertificateTemplateIAMMember
 *
 * @schema CertificateTemplateIamMemberSpec
 */
export interface CertificateTemplateIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateTemplateIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateTemplateIamMemberSpecDeletionPolicy;

  /**
   * @schema CertificateTemplateIamMemberSpec#forProvider
   */
  readonly forProvider: CertificateTemplateIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CertificateTemplateIamMemberSpec#initProvider
   */
  readonly initProvider?: CertificateTemplateIamMemberSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateTemplateIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: CertificateTemplateIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateTemplateIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateTemplateIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateTemplateIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateTemplateIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateTemplateIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateTemplateIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpec(obj: CertificateTemplateIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateTemplateIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_CertificateTemplateIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateTemplateIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateTemplateIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateTemplateIamMemberSpecDeletionPolicy
 */
export enum CertificateTemplateIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateTemplateIamMemberSpecForProvider
 */
export interface CertificateTemplateIamMemberSpecForProvider {
  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#certificateTemplate
   */
  readonly certificateTemplate?: string;

  /**
   * Reference to a CertificateTemplate to populate certificateTemplate.
   *
   * @schema CertificateTemplateIamMemberSpecForProvider#certificateTemplateRef
   */
  readonly certificateTemplateRef?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef;

  /**
   * Selector for a CertificateTemplate to populate certificateTemplate.
   *
   * @schema CertificateTemplateIamMemberSpecForProvider#certificateTemplateSelector
   */
  readonly certificateTemplateSelector?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector;

  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#condition
   */
  readonly condition?: CertificateTemplateIamMemberSpecForProviderCondition[];

  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#location
   */
  readonly location?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProvider(obj: CertificateTemplateIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateTemplate': obj.certificateTemplate,
    'certificateTemplateRef': toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef(obj.certificateTemplateRef),
    'certificateTemplateSelector': toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector(obj.certificateTemplateSelector),
    'condition': obj.condition?.map(y => toJson_CertificateTemplateIamMemberSpecForProviderCondition(y)),
    'location': obj.location,
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CertificateTemplateIamMemberSpecInitProvider
 */
export interface CertificateTemplateIamMemberSpecInitProvider {
  /**
   * @schema CertificateTemplateIamMemberSpecInitProvider#condition
   */
  readonly condition?: CertificateTemplateIamMemberSpecInitProviderCondition[];

  /**
   * @schema CertificateTemplateIamMemberSpecInitProvider#location
   */
  readonly location?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecInitProvider(obj: CertificateTemplateIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_CertificateTemplateIamMemberSpecInitProviderCondition(y)),
    'location': obj.location,
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateTemplateIamMemberSpecManagementPolicies
 */
export enum CertificateTemplateIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateTemplateIamMemberSpecProviderConfigRef
 */
export interface CertificateTemplateIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateTemplateIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecProviderConfigRef(obj: CertificateTemplateIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsTo
 */
export interface CertificateTemplateIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsTo(obj: CertificateTemplateIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateTemplateIamMemberSpecWriteConnectionSecretToRef
 */
export interface CertificateTemplateIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateTemplateIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateTemplateIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecWriteConnectionSecretToRef(obj: CertificateTemplateIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateTemplate to populate certificateTemplate.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef
 */
export interface CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef#policy
   */
  readonly policy?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef(obj: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateTemplate to populate certificateTemplate.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector
 */
export interface CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector#policy
   */
  readonly policy?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector(obj: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateIamMemberSpecForProviderCondition
 */
export interface CertificateTemplateIamMemberSpecForProviderCondition {
  /**
   * @schema CertificateTemplateIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProviderCondition(obj: CertificateTemplateIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateTemplateIamMemberSpecInitProviderCondition
 */
export interface CertificateTemplateIamMemberSpecInitProviderCondition {
  /**
   * @schema CertificateTemplateIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema CertificateTemplateIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecInitProviderCondition(obj: CertificateTemplateIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateIamMemberSpecProviderConfigRefPolicy
 */
export interface CertificateTemplateIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecProviderConfigRefPolicy(obj: CertificateTemplateIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef(obj: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata(obj: CertificateTemplateIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy
 */
export interface CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy(obj: CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy
 */
export interface CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy#resolution
   */
  readonly resolution?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy#resolve
   */
  readonly resolve?: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy(obj: CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum CertificateTemplateIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolution
 */
export enum CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolve
 */
export enum CertificateTemplateIamMemberSpecForProviderCertificateTemplateRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolution
 */
export enum CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolve
 */
export enum CertificateTemplateIamMemberSpecForProviderCertificateTemplateSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateTemplateIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

