// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Application is the Schema for the Applications API. Provides an OpsWorks application resource.
 *
 * @schema Application
 */
export class Application extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Application"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'Application',
  }

  /**
   * Renders a Kubernetes manifest for "Application".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationProps): any {
    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(props),
    };
  }

  /**
   * Defines a "Application" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationProps) {
    super(scope, id, {
      ...Application.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(resolved),
    };
  }
}

/**
 * Application is the Schema for the Applications API. Provides an OpsWorks application resource.
 *
 * @schema Application
 */
export interface ApplicationProps {
  /**
   * @schema Application#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApplicationSpec defines the desired state of Application
   *
   * @schema Application#spec
   */
  readonly spec: ApplicationSpec;

}

/**
 * Converts an object of type 'ApplicationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationProps(obj: ApplicationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSpec defines the desired state of Application
 *
 * @schema ApplicationSpec
 */
export interface ApplicationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApplicationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationSpecDeletionPolicy;

  /**
   * @schema ApplicationSpec#forProvider
   */
  readonly forProvider: ApplicationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApplicationSpec#managementPolicy
   */
  readonly managementPolicy?: ApplicationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApplicationSpec#providerRef
   */
  readonly providerRef?: ApplicationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpec(obj: ApplicationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ApplicationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApplicationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApplicationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApplicationSpecDeletionPolicy
 */
export enum ApplicationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApplicationSpecForProvider
 */
export interface ApplicationSpecForProvider {
  /**
   * SCM configuration of the app as described below.
   *
   * @schema ApplicationSpecForProvider#appSource
   */
  readonly appSource?: ApplicationSpecForProviderAppSource[];

  /**
   * Run bundle install when deploying for application of type rails.
   *
   * @schema ApplicationSpecForProvider#autoBundleOnDeploy
   */
  readonly autoBundleOnDeploy?: string;

  /**
   * Specify activity and workflow workers for your app using the aws-flow gem.
   *
   * @schema ApplicationSpecForProvider#awsFlowRubySettings
   */
  readonly awsFlowRubySettings?: string;

  /**
   * The data source's ARN.
   *
   * @schema ApplicationSpecForProvider#dataSourceArn
   */
  readonly dataSourceArn?: string;

  /**
   * The database name.
   *
   * @schema ApplicationSpecForProvider#dataSourceDatabaseName
   */
  readonly dataSourceDatabaseName?: string;

  /**
   * The data source's type one of AutoSelectOpsworksMysqlInstance, OpsworksMysqlInstance, or RdsDbInstance.
   *
   * @schema ApplicationSpecForProvider#dataSourceType
   */
  readonly dataSourceType?: string;

  /**
   * A description of the app.
   *
   * @schema ApplicationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Subfolder for the document root for application of type rails.
   *
   * @schema ApplicationSpecForProvider#documentRoot
   */
  readonly documentRoot?: string;

  /**
   * A list of virtual host alias.
   *
   * @schema ApplicationSpecForProvider#domains
   */
  readonly domains?: string[];

  /**
   * Whether to enable SSL for the app. This must be set in order to let ssl_configuration.private_key, ssl_configuration.certificate and ssl_configuration.chain take effect.
   *
   * @schema ApplicationSpecForProvider#enableSsl
   */
  readonly enableSsl?: boolean;

  /**
   * Object to define environment variables.  Object is described below.
   *
   * @schema ApplicationSpecForProvider#environment
   */
  readonly environment?: ApplicationSpecForProviderEnvironment[];

  /**
   * A human-readable name for the application.
   *
   * @schema ApplicationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The name of the Rails environment for application of type rails.
   *
   * @schema ApplicationSpecForProvider#railsEnv
   */
  readonly railsEnv?: string;

  /**
   * A short, machine-readable name for the application. This can only be defined on resource creation and ignored on resource update.
   *
   * @schema ApplicationSpecForProvider#shortName
   */
  readonly shortName?: string;

  /**
   * The SSL configuration of the app. Object is described below.
   *
   * @schema ApplicationSpecForProvider#sslConfiguration
   */
  readonly sslConfiguration?: ApplicationSpecForProviderSslConfiguration[];

  /**
   * ID of the stack the application will belong to.
   *
   * @schema ApplicationSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema ApplicationSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: ApplicationSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema ApplicationSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: ApplicationSpecForProviderStackIdSelector;

  /**
   * Opsworks application type. One of aws-flow-ruby, java, rails, php, nodejs, static or other.
   *
   * @schema ApplicationSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProvider(obj: ApplicationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appSource': obj.appSource?.map(y => toJson_ApplicationSpecForProviderAppSource(y)),
    'autoBundleOnDeploy': obj.autoBundleOnDeploy,
    'awsFlowRubySettings': obj.awsFlowRubySettings,
    'dataSourceArn': obj.dataSourceArn,
    'dataSourceDatabaseName': obj.dataSourceDatabaseName,
    'dataSourceType': obj.dataSourceType,
    'description': obj.description,
    'documentRoot': obj.documentRoot,
    'domains': obj.domains?.map(y => y),
    'enableSsl': obj.enableSsl,
    'environment': obj.environment?.map(y => toJson_ApplicationSpecForProviderEnvironment(y)),
    'name': obj.name,
    'railsEnv': obj.railsEnv,
    'shortName': obj.shortName,
    'sslConfiguration': obj.sslConfiguration?.map(y => toJson_ApplicationSpecForProviderSslConfiguration(y)),
    'stackId': obj.stackId,
    'stackIdRef': toJson_ApplicationSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_ApplicationSpecForProviderStackIdSelector(obj.stackIdSelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApplicationSpecManagementPolicy
 */
export enum ApplicationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationSpecProviderConfigRef
 */
export interface ApplicationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRef(obj: ApplicationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApplicationSpecProviderRef
 */
export interface ApplicationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderRef#policy
   */
  readonly policy?: ApplicationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderRef(obj: ApplicationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationSpecPublishConnectionDetailsTo
 */
export interface ApplicationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsTo(obj: ApplicationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationSpecWriteConnectionSecretToRef
 */
export interface ApplicationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecWriteConnectionSecretToRef(obj: ApplicationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderAppSource
 */
export interface ApplicationSpecForProviderAppSource {
  /**
   * Password to use when authenticating to the source.
   *
   * @schema ApplicationSpecForProviderAppSource#passwordSecretRef
   */
  readonly passwordSecretRef?: ApplicationSpecForProviderAppSourcePasswordSecretRef;

  /**
   * For sources that are version-aware, the revision to use.
   *
   * @schema ApplicationSpecForProviderAppSource#revision
   */
  readonly revision?: string;

  /**
   * SSH key to use when authenticating to the source.
   *
   * @schema ApplicationSpecForProviderAppSource#sshKeySecretRef
   */
  readonly sshKeySecretRef?: ApplicationSpecForProviderAppSourceSshKeySecretRef;

  /**
   * The type of source to use. For example, "archive".
   *
   * @schema ApplicationSpecForProviderAppSource#type
   */
  readonly type: string;

  /**
   * The URL where the app resource can be found.
   *
   * @schema ApplicationSpecForProviderAppSource#url
   */
  readonly url?: string;

  /**
   * Username to use when authenticating to the source.
   *
   * @schema ApplicationSpecForProviderAppSource#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderAppSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderAppSource(obj: ApplicationSpecForProviderAppSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretRef': toJson_ApplicationSpecForProviderAppSourcePasswordSecretRef(obj.passwordSecretRef),
    'revision': obj.revision,
    'sshKeySecretRef': toJson_ApplicationSpecForProviderAppSourceSshKeySecretRef(obj.sshKeySecretRef),
    'type': obj.type,
    'url': obj.url,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderEnvironment
 */
export interface ApplicationSpecForProviderEnvironment {
  /**
   * Variable name.
   *
   * @schema ApplicationSpecForProviderEnvironment#key
   */
  readonly key: string;

  /**
   * Set visibility of the variable value to true or false.
   *
   * @schema ApplicationSpecForProviderEnvironment#secure
   */
  readonly secure?: boolean;

  /**
   * Variable value.
   *
   * @schema ApplicationSpecForProviderEnvironment#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderEnvironment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderEnvironment(obj: ApplicationSpecForProviderEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secure': obj.secure,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderSslConfiguration
 */
export interface ApplicationSpecForProviderSslConfiguration {
  /**
   * The contents of the certificate's domain.crt file.
   *
   * @schema ApplicationSpecForProviderSslConfiguration#certificate
   */
  readonly certificate: string;

  /**
   * Can be used to specify an intermediate certificate authority key or client authentication.
   *
   * @schema ApplicationSpecForProviderSslConfiguration#chain
   */
  readonly chain?: string;

  /**
   * The private key; the contents of the certificate's domain.key file.
   *
   * @schema ApplicationSpecForProviderSslConfiguration#privateKeySecretRef
   */
  readonly privateKeySecretRef: ApplicationSpecForProviderSslConfigurationPrivateKeySecretRef;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSslConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSslConfiguration(obj: ApplicationSpecForProviderSslConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'chain': obj.chain,
    'privateKeySecretRef': toJson_ApplicationSpecForProviderSslConfigurationPrivateKeySecretRef(obj.privateKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema ApplicationSpecForProviderStackIdRef
 */
export interface ApplicationSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderStackIdRef#policy
   */
  readonly policy?: ApplicationSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderStackIdRef(obj: ApplicationSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema ApplicationSpecForProviderStackIdSelector
 */
export interface ApplicationSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderStackIdSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderStackIdSelector(obj: ApplicationSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderConfigRefPolicy
 */
export interface ApplicationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRefPolicy(obj: ApplicationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderRefPolicy
 */
export interface ApplicationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderRefPolicy(obj: ApplicationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj: ApplicationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj: ApplicationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password to use when authenticating to the source.
 *
 * @schema ApplicationSpecForProviderAppSourcePasswordSecretRef
 */
export interface ApplicationSpecForProviderAppSourcePasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema ApplicationSpecForProviderAppSourcePasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecForProviderAppSourcePasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecForProviderAppSourcePasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderAppSourcePasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderAppSourcePasswordSecretRef(obj: ApplicationSpecForProviderAppSourcePasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SSH key to use when authenticating to the source.
 *
 * @schema ApplicationSpecForProviderAppSourceSshKeySecretRef
 */
export interface ApplicationSpecForProviderAppSourceSshKeySecretRef {
  /**
   * The key to select.
   *
   * @schema ApplicationSpecForProviderAppSourceSshKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecForProviderAppSourceSshKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecForProviderAppSourceSshKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderAppSourceSshKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderAppSourceSshKeySecretRef(obj: ApplicationSpecForProviderAppSourceSshKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The private key; the contents of the certificate's domain.key file.
 *
 * @schema ApplicationSpecForProviderSslConfigurationPrivateKeySecretRef
 */
export interface ApplicationSpecForProviderSslConfigurationPrivateKeySecretRef {
  /**
   * The key to select.
   *
   * @schema ApplicationSpecForProviderSslConfigurationPrivateKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecForProviderSslConfigurationPrivateKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecForProviderSslConfigurationPrivateKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSslConfigurationPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSslConfigurationPrivateKeySecretRef(obj: ApplicationSpecForProviderSslConfigurationPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderStackIdRefPolicy
 */
export interface ApplicationSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderStackIdRefPolicy(obj: ApplicationSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderStackIdSelectorPolicy
 */
export interface ApplicationSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderStackIdSelectorPolicy(obj: ApplicationSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderRefPolicyResolution
 */
export enum ApplicationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderRefPolicyResolve
 */
export enum ApplicationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderStackIdRefPolicyResolution
 */
export enum ApplicationSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderStackIdRefPolicyResolve
 */
export enum ApplicationSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderStackIdSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderStackIdSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CustomLayer is the Schema for the CustomLayers API. Provides an OpsWorks custom layer resource.
 *
 * @schema CustomLayer
 */
export class CustomLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CustomLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'CustomLayer',
  }

  /**
   * Renders a Kubernetes manifest for "CustomLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CustomLayerProps): any {
    return {
      ...CustomLayer.GVK,
      ...toJson_CustomLayerProps(props),
    };
  }

  /**
   * Defines a "CustomLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CustomLayerProps) {
    super(scope, id, {
      ...CustomLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CustomLayer.GVK,
      ...toJson_CustomLayerProps(resolved),
    };
  }
}

/**
 * CustomLayer is the Schema for the CustomLayers API. Provides an OpsWorks custom layer resource.
 *
 * @schema CustomLayer
 */
export interface CustomLayerProps {
  /**
   * @schema CustomLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CustomLayerSpec defines the desired state of CustomLayer
   *
   * @schema CustomLayer#spec
   */
  readonly spec: CustomLayerSpec;

}

/**
 * Converts an object of type 'CustomLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerProps(obj: CustomLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CustomLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomLayerSpec defines the desired state of CustomLayer
 *
 * @schema CustomLayerSpec
 */
export interface CustomLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CustomLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: CustomLayerSpecDeletionPolicy;

  /**
   * @schema CustomLayerSpec#forProvider
   */
  readonly forProvider: CustomLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CustomLayerSpec#managementPolicy
   */
  readonly managementPolicy?: CustomLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CustomLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: CustomLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CustomLayerSpec#providerRef
   */
  readonly providerRef?: CustomLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CustomLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CustomLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CustomLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CustomLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CustomLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpec(obj: CustomLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CustomLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CustomLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CustomLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CustomLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CustomLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CustomLayerSpecDeletionPolicy
 */
export enum CustomLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CustomLayerSpecForProvider
 */
export interface CustomLayerSpecForProvider {
  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema CustomLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema CustomLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema CustomLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * Will create an EBS volume and connect it to the layer's instances. See Cloudwatch Configuration.
   *
   * @schema CustomLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: CustomLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema CustomLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema CustomLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema CustomLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * Custom JSON attributes to apply to the layer.
   *
   * @schema CustomLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema CustomLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: CustomLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema CustomLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: CustomLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema CustomLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema CustomLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema CustomLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema CustomLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema CustomLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * Will create an EBS volume and connect it to the layer's instances. See EBS Volume.
   *
   * @schema CustomLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: CustomLayerSpecForProviderEbsVolume[];

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema CustomLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema CustomLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema CustomLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * Load-based auto scaling configuration. See Load Based AutoScaling
   *
   * @schema CustomLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: CustomLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * A human-readable name for the layer.
   *
   * @schema CustomLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A short, machine-readable name for the layer, which will be used to identify it in the Chef node JSON.
   *
   * @schema CustomLayerSpecForProvider#shortName
   */
  readonly shortName?: string;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema CustomLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema CustomLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: CustomLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema CustomLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: CustomLayerSpecForProviderStackIdSelector;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema CustomLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CustomLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema CustomLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

}

/**
 * Converts an object of type 'CustomLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProvider(obj: CustomLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_CustomLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_CustomLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_CustomLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_CustomLayerSpecForProviderEbsVolume(y)),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_CustomLayerSpecForProviderLoadBasedAutoScaling(y)),
    'name': obj.name,
    'shortName': obj.shortName,
    'stackId': obj.stackId,
    'stackIdRef': toJson_CustomLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_CustomLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CustomLayerSpecManagementPolicy
 */
export enum CustomLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CustomLayerSpecProviderConfigRef
 */
export interface CustomLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomLayerSpecProviderConfigRef#policy
   */
  readonly policy?: CustomLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecProviderConfigRef(obj: CustomLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CustomLayerSpecProviderRef
 */
export interface CustomLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomLayerSpecProviderRef#policy
   */
  readonly policy?: CustomLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CustomLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecProviderRef(obj: CustomLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CustomLayerSpecPublishConnectionDetailsTo
 */
export interface CustomLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CustomLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CustomLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CustomLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CustomLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CustomLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CustomLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecPublishConnectionDetailsTo(obj: CustomLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CustomLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CustomLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CustomLayerSpecWriteConnectionSecretToRef
 */
export interface CustomLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CustomLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CustomLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CustomLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecWriteConnectionSecretToRef(obj: CustomLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomLayerSpecForProviderCloudwatchConfiguration
 */
export interface CustomLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema CustomLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * A block the specifies how an opsworks logs look like. See Log Streams.
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: CustomLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderCloudwatchConfiguration(obj: CustomLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_CustomLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema CustomLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface CustomLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema CustomLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderCustomSecurityGroupIdRefs(obj: CustomLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema CustomLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface CustomLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CustomLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderCustomSecurityGroupIdSelector(obj: CustomLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomLayerSpecForProviderEbsVolume
 */
export interface CustomLayerSpecForProviderEbsVolume {
  /**
   * Encrypt the volume.
   *
   * @schema CustomLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema CustomLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema CustomLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema CustomLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema CustomLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema CustomLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema CustomLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderEbsVolume(obj: CustomLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomLayerSpecForProviderLoadBasedAutoScaling
 */
export interface CustomLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * The downscaling settings, as defined below, used for load-based autoscaling
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * Whether load-based auto scaling is enabled for the layer.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * The upscaling settings, as defined below, used for load-based autoscaling
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderLoadBasedAutoScaling(obj: CustomLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema CustomLayerSpecForProviderStackIdRef
 */
export interface CustomLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: CustomLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderStackIdRef(obj: CustomLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema CustomLayerSpecForProviderStackIdSelector
 */
export interface CustomLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CustomLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: CustomLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderStackIdSelector(obj: CustomLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomLayerSpecProviderConfigRefPolicy
 */
export interface CustomLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CustomLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CustomLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecProviderConfigRefPolicy(obj: CustomLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomLayerSpecProviderRefPolicy
 */
export interface CustomLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CustomLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CustomLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecProviderRefPolicy(obj: CustomLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CustomLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface CustomLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CustomLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecPublishConnectionDetailsToConfigRef(obj: CustomLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CustomLayerSpecPublishConnectionDetailsToMetadata
 */
export interface CustomLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CustomLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecPublishConnectionDetailsToMetadata(obj: CustomLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface CustomLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * Specifies the max number of log events in a batch, up to 10000. The default value is 1000.
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * Specifies the maximum size of log events in a batch, in bytes, up to 1048576 bytes. The default value is 32768 bytes.
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * Specifies the time duration for the batching of log events. The minimum value is 5000 and default value is 5000.
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * Specifies how the timestamp is extracted from logs. For more information, see the CloudWatch Logs Agent Reference (https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * Specifies the encoding of the log file so that the file can be read correctly. The default is utf_8.
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * Specifies log files that you want to push to CloudWatch Logs. File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log*).
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers, such as 1, 2-5. The default value is 1.
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * Specifies where to start to read data (start_of_file or end_of_file). The default is start_of_file.
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * Specifies the destination log group. A log group is created automatically if it doesn't already exist.
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * Specifies the pattern for identifying the start of a log message.
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * Specifies the time zone of log event time stamps.
   *
   * @schema CustomLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: CustomLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * The number of instances to add or remove when the load exceeds a threshold.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * The load threshold. A value of -1 disables the threshold.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: CustomLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * The number of instances to add or remove when the load exceeds a threshold.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * The load threshold. A value of -1 disables the threshold.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
   *
   * @schema CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: CustomLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomLayerSpecForProviderStackIdRefPolicy
 */
export interface CustomLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: CustomLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: CustomLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderStackIdRefPolicy(obj: CustomLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomLayerSpecForProviderStackIdSelectorPolicy
 */
export interface CustomLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: CustomLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: CustomLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecForProviderStackIdSelectorPolicy(obj: CustomLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomLayerSpecProviderConfigRefPolicyResolution
 */
export enum CustomLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomLayerSpecProviderConfigRefPolicyResolve
 */
export enum CustomLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomLayerSpecProviderRefPolicyResolution
 */
export enum CustomLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomLayerSpecProviderRefPolicyResolve
 */
export enum CustomLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CustomLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CustomLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CustomLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CustomLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: CustomLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum CustomLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum CustomLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum CustomLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum CustomLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum CustomLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum CustomLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CustomLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CustomLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EcsClusterLayer is the Schema for the EcsClusterLayers API. Provides an OpsWorks HAProxy layer resource.
 *
 * @schema EcsClusterLayer
 */
export class EcsClusterLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EcsClusterLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'EcsClusterLayer',
  }

  /**
   * Renders a Kubernetes manifest for "EcsClusterLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EcsClusterLayerProps): any {
    return {
      ...EcsClusterLayer.GVK,
      ...toJson_EcsClusterLayerProps(props),
    };
  }

  /**
   * Defines a "EcsClusterLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EcsClusterLayerProps) {
    super(scope, id, {
      ...EcsClusterLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EcsClusterLayer.GVK,
      ...toJson_EcsClusterLayerProps(resolved),
    };
  }
}

/**
 * EcsClusterLayer is the Schema for the EcsClusterLayers API. Provides an OpsWorks HAProxy layer resource.
 *
 * @schema EcsClusterLayer
 */
export interface EcsClusterLayerProps {
  /**
   * @schema EcsClusterLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EcsClusterLayerSpec defines the desired state of EcsClusterLayer
   *
   * @schema EcsClusterLayer#spec
   */
  readonly spec: EcsClusterLayerSpec;

}

/**
 * Converts an object of type 'EcsClusterLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerProps(obj: EcsClusterLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EcsClusterLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EcsClusterLayerSpec defines the desired state of EcsClusterLayer
 *
 * @schema EcsClusterLayerSpec
 */
export interface EcsClusterLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EcsClusterLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: EcsClusterLayerSpecDeletionPolicy;

  /**
   * @schema EcsClusterLayerSpec#forProvider
   */
  readonly forProvider: EcsClusterLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EcsClusterLayerSpec#managementPolicy
   */
  readonly managementPolicy?: EcsClusterLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EcsClusterLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: EcsClusterLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EcsClusterLayerSpec#providerRef
   */
  readonly providerRef?: EcsClusterLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EcsClusterLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EcsClusterLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EcsClusterLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EcsClusterLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EcsClusterLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpec(obj: EcsClusterLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EcsClusterLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EcsClusterLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EcsClusterLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EcsClusterLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EcsClusterLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EcsClusterLayerSpecDeletionPolicy
 */
export enum EcsClusterLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EcsClusterLayerSpecForProvider
 */
export interface EcsClusterLayerSpecForProvider {
  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema EcsClusterLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema EcsClusterLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema EcsClusterLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * @schema EcsClusterLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: EcsClusterLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema EcsClusterLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema EcsClusterLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema EcsClusterLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * Custom JSON attributes to apply to the layer.
   *
   * @schema EcsClusterLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema EcsClusterLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema EcsClusterLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema EcsClusterLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema EcsClusterLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema EcsClusterLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema EcsClusterLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema EcsClusterLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * ebs_volume blocks, as described below, will each create an EBS volume and connect it to the layer's instances.
   *
   * @schema EcsClusterLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: EcsClusterLayerSpecForProviderEbsVolume[];

  /**
   * The ECS Cluster ARN of the layer.
   *
   * @schema EcsClusterLayerSpecForProvider#ecsClusterArn
   */
  readonly ecsClusterArn?: string;

  /**
   * Reference to a Cluster in ecs to populate ecsClusterArn.
   *
   * @schema EcsClusterLayerSpecForProvider#ecsClusterArnRef
   */
  readonly ecsClusterArnRef?: EcsClusterLayerSpecForProviderEcsClusterArnRef;

  /**
   * Selector for a Cluster in ecs to populate ecsClusterArn.
   *
   * @schema EcsClusterLayerSpecForProvider#ecsClusterArnSelector
   */
  readonly ecsClusterArnSelector?: EcsClusterLayerSpecForProviderEcsClusterArnSelector;

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema EcsClusterLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema EcsClusterLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema EcsClusterLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * @schema EcsClusterLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: EcsClusterLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * A human-readable name for the layer.
   *
   * @schema EcsClusterLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema EcsClusterLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema EcsClusterLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: EcsClusterLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema EcsClusterLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: EcsClusterLayerSpecForProviderStackIdSelector;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema EcsClusterLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema EcsClusterLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema EcsClusterLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProvider(obj: EcsClusterLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_EcsClusterLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_EcsClusterLayerSpecForProviderEbsVolume(y)),
    'ecsClusterArn': obj.ecsClusterArn,
    'ecsClusterArnRef': toJson_EcsClusterLayerSpecForProviderEcsClusterArnRef(obj.ecsClusterArnRef),
    'ecsClusterArnSelector': toJson_EcsClusterLayerSpecForProviderEcsClusterArnSelector(obj.ecsClusterArnSelector),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_EcsClusterLayerSpecForProviderLoadBasedAutoScaling(y)),
    'name': obj.name,
    'stackId': obj.stackId,
    'stackIdRef': toJson_EcsClusterLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_EcsClusterLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EcsClusterLayerSpecManagementPolicy
 */
export enum EcsClusterLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EcsClusterLayerSpecProviderConfigRef
 */
export interface EcsClusterLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EcsClusterLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EcsClusterLayerSpecProviderConfigRef#policy
   */
  readonly policy?: EcsClusterLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecProviderConfigRef(obj: EcsClusterLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EcsClusterLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EcsClusterLayerSpecProviderRef
 */
export interface EcsClusterLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EcsClusterLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EcsClusterLayerSpecProviderRef#policy
   */
  readonly policy?: EcsClusterLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecProviderRef(obj: EcsClusterLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EcsClusterLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EcsClusterLayerSpecPublishConnectionDetailsTo
 */
export interface EcsClusterLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EcsClusterLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EcsClusterLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EcsClusterLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EcsClusterLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EcsClusterLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecPublishConnectionDetailsTo(obj: EcsClusterLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EcsClusterLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EcsClusterLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EcsClusterLayerSpecWriteConnectionSecretToRef
 */
export interface EcsClusterLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EcsClusterLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EcsClusterLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecWriteConnectionSecretToRef(obj: EcsClusterLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EcsClusterLayerSpecForProviderCloudwatchConfiguration
 */
export interface EcsClusterLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderCloudwatchConfiguration(obj: EcsClusterLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefs(obj: EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelector(obj: EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EcsClusterLayerSpecForProviderEbsVolume
 */
export interface EcsClusterLayerSpecForProviderEbsVolume {
  /**
   * @schema EcsClusterLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema EcsClusterLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema EcsClusterLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema EcsClusterLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema EcsClusterLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema EcsClusterLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema EcsClusterLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderEbsVolume(obj: EcsClusterLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in ecs to populate ecsClusterArn.
 *
 * @schema EcsClusterLayerSpecForProviderEcsClusterArnRef
 */
export interface EcsClusterLayerSpecForProviderEcsClusterArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EcsClusterLayerSpecForProviderEcsClusterArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EcsClusterLayerSpecForProviderEcsClusterArnRef#policy
   */
  readonly policy?: EcsClusterLayerSpecForProviderEcsClusterArnRefPolicy;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderEcsClusterArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderEcsClusterArnRef(obj: EcsClusterLayerSpecForProviderEcsClusterArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EcsClusterLayerSpecForProviderEcsClusterArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in ecs to populate ecsClusterArn.
 *
 * @schema EcsClusterLayerSpecForProviderEcsClusterArnSelector
 */
export interface EcsClusterLayerSpecForProviderEcsClusterArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EcsClusterLayerSpecForProviderEcsClusterArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EcsClusterLayerSpecForProviderEcsClusterArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EcsClusterLayerSpecForProviderEcsClusterArnSelector#policy
   */
  readonly policy?: EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicy;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderEcsClusterArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderEcsClusterArnSelector(obj: EcsClusterLayerSpecForProviderEcsClusterArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScaling
 */
export interface EcsClusterLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderLoadBasedAutoScaling(obj: EcsClusterLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema EcsClusterLayerSpecForProviderStackIdRef
 */
export interface EcsClusterLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema EcsClusterLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EcsClusterLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: EcsClusterLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderStackIdRef(obj: EcsClusterLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EcsClusterLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema EcsClusterLayerSpecForProviderStackIdSelector
 */
export interface EcsClusterLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EcsClusterLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EcsClusterLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EcsClusterLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: EcsClusterLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderStackIdSelector(obj: EcsClusterLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EcsClusterLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EcsClusterLayerSpecProviderConfigRefPolicy
 */
export interface EcsClusterLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EcsClusterLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EcsClusterLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EcsClusterLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EcsClusterLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecProviderConfigRefPolicy(obj: EcsClusterLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EcsClusterLayerSpecProviderRefPolicy
 */
export interface EcsClusterLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EcsClusterLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EcsClusterLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EcsClusterLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EcsClusterLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecProviderRefPolicy(obj: EcsClusterLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EcsClusterLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface EcsClusterLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EcsClusterLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EcsClusterLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecPublishConnectionDetailsToConfigRef(obj: EcsClusterLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EcsClusterLayerSpecPublishConnectionDetailsToMetadata
 */
export interface EcsClusterLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EcsClusterLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EcsClusterLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EcsClusterLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecPublishConnectionDetailsToMetadata(obj: EcsClusterLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * A human-readable name for the layer.
   *
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * @schema EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: EcsClusterLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EcsClusterLayerSpecForProviderEcsClusterArnRefPolicy
 */
export interface EcsClusterLayerSpecForProviderEcsClusterArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EcsClusterLayerSpecForProviderEcsClusterArnRefPolicy#resolution
   */
  readonly resolution?: EcsClusterLayerSpecForProviderEcsClusterArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EcsClusterLayerSpecForProviderEcsClusterArnRefPolicy#resolve
   */
  readonly resolve?: EcsClusterLayerSpecForProviderEcsClusterArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderEcsClusterArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderEcsClusterArnRefPolicy(obj: EcsClusterLayerSpecForProviderEcsClusterArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicy
 */
export interface EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicy#resolution
   */
  readonly resolution?: EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicy#resolve
   */
  readonly resolve?: EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicy(obj: EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: EcsClusterLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: EcsClusterLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EcsClusterLayerSpecForProviderStackIdRefPolicy
 */
export interface EcsClusterLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EcsClusterLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: EcsClusterLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EcsClusterLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: EcsClusterLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderStackIdRefPolicy(obj: EcsClusterLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EcsClusterLayerSpecForProviderStackIdSelectorPolicy
 */
export interface EcsClusterLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EcsClusterLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: EcsClusterLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EcsClusterLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: EcsClusterLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecForProviderStackIdSelectorPolicy(obj: EcsClusterLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EcsClusterLayerSpecProviderConfigRefPolicyResolution
 */
export enum EcsClusterLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EcsClusterLayerSpecProviderConfigRefPolicyResolve
 */
export enum EcsClusterLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EcsClusterLayerSpecProviderRefPolicyResolution
 */
export enum EcsClusterLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EcsClusterLayerSpecProviderRefPolicyResolve
 */
export enum EcsClusterLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum EcsClusterLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum EcsClusterLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EcsClusterLayerSpecForProviderEcsClusterArnRefPolicyResolution
 */
export enum EcsClusterLayerSpecForProviderEcsClusterArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EcsClusterLayerSpecForProviderEcsClusterArnRefPolicyResolve
 */
export enum EcsClusterLayerSpecForProviderEcsClusterArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicyResolution
 */
export enum EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicyResolve
 */
export enum EcsClusterLayerSpecForProviderEcsClusterArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EcsClusterLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum EcsClusterLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EcsClusterLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum EcsClusterLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EcsClusterLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum EcsClusterLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EcsClusterLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum EcsClusterLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EcsClusterLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GangliaLayer is the Schema for the GangliaLayers API. Provides an OpsWorks Ganglia layer resource.
 *
 * @schema GangliaLayer
 */
export class GangliaLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GangliaLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'GangliaLayer',
  }

  /**
   * Renders a Kubernetes manifest for "GangliaLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GangliaLayerProps): any {
    return {
      ...GangliaLayer.GVK,
      ...toJson_GangliaLayerProps(props),
    };
  }

  /**
   * Defines a "GangliaLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GangliaLayerProps) {
    super(scope, id, {
      ...GangliaLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GangliaLayer.GVK,
      ...toJson_GangliaLayerProps(resolved),
    };
  }
}

/**
 * GangliaLayer is the Schema for the GangliaLayers API. Provides an OpsWorks Ganglia layer resource.
 *
 * @schema GangliaLayer
 */
export interface GangliaLayerProps {
  /**
   * @schema GangliaLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GangliaLayerSpec defines the desired state of GangliaLayer
   *
   * @schema GangliaLayer#spec
   */
  readonly spec: GangliaLayerSpec;

}

/**
 * Converts an object of type 'GangliaLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerProps(obj: GangliaLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GangliaLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GangliaLayerSpec defines the desired state of GangliaLayer
 *
 * @schema GangliaLayerSpec
 */
export interface GangliaLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GangliaLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: GangliaLayerSpecDeletionPolicy;

  /**
   * @schema GangliaLayerSpec#forProvider
   */
  readonly forProvider: GangliaLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GangliaLayerSpec#managementPolicy
   */
  readonly managementPolicy?: GangliaLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GangliaLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: GangliaLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GangliaLayerSpec#providerRef
   */
  readonly providerRef?: GangliaLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GangliaLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GangliaLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GangliaLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GangliaLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GangliaLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpec(obj: GangliaLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GangliaLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_GangliaLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GangliaLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GangliaLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GangliaLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GangliaLayerSpecDeletionPolicy
 */
export enum GangliaLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GangliaLayerSpecForProvider
 */
export interface GangliaLayerSpecForProvider {
  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema GangliaLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema GangliaLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema GangliaLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * @schema GangliaLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: GangliaLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema GangliaLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema GangliaLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema GangliaLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * Custom JSON attributes to apply to the layer.
   *
   * @schema GangliaLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema GangliaLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: GangliaLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema GangliaLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: GangliaLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema GangliaLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema GangliaLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema GangliaLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema GangliaLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema GangliaLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * ebs_volume blocks, as described below, will each create an EBS volume and connect it to the layer's instances.
   *
   * @schema GangliaLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: GangliaLayerSpecForProviderEbsVolume[];

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema GangliaLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema GangliaLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema GangliaLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * @schema GangliaLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: GangliaLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * A human-readable name for the layer.
   *
   * @schema GangliaLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The password to use for Ganglia.
   *
   * @schema GangliaLayerSpecForProvider#password
   */
  readonly password?: string;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema GangliaLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema GangliaLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: GangliaLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema GangliaLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: GangliaLayerSpecForProviderStackIdSelector;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema GangliaLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema GangliaLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The URL path to use for Ganglia. Defaults to "/ganglia".
   *
   * @default ganglia".
   * @schema GangliaLayerSpecForProvider#url
   */
  readonly url?: string;

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema GangliaLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

  /**
   * (Optiona) The username to use for Ganglia. Defaults to "opsworks".
   *
   * @default opsworks".
   * @schema GangliaLayerSpecForProvider#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProvider(obj: GangliaLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_GangliaLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_GangliaLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_GangliaLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_GangliaLayerSpecForProviderEbsVolume(y)),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_GangliaLayerSpecForProviderLoadBasedAutoScaling(y)),
    'name': obj.name,
    'password': obj.password,
    'stackId': obj.stackId,
    'stackIdRef': toJson_GangliaLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_GangliaLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'url': obj.url,
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GangliaLayerSpecManagementPolicy
 */
export enum GangliaLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GangliaLayerSpecProviderConfigRef
 */
export interface GangliaLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GangliaLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GangliaLayerSpecProviderConfigRef#policy
   */
  readonly policy?: GangliaLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GangliaLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecProviderConfigRef(obj: GangliaLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GangliaLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GangliaLayerSpecProviderRef
 */
export interface GangliaLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GangliaLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GangliaLayerSpecProviderRef#policy
   */
  readonly policy?: GangliaLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GangliaLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecProviderRef(obj: GangliaLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GangliaLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GangliaLayerSpecPublishConnectionDetailsTo
 */
export interface GangliaLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GangliaLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GangliaLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GangliaLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GangliaLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GangliaLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GangliaLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecPublishConnectionDetailsTo(obj: GangliaLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GangliaLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GangliaLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GangliaLayerSpecWriteConnectionSecretToRef
 */
export interface GangliaLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GangliaLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GangliaLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GangliaLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecWriteConnectionSecretToRef(obj: GangliaLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GangliaLayerSpecForProviderCloudwatchConfiguration
 */
export interface GangliaLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderCloudwatchConfiguration(obj: GangliaLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface GangliaLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderCustomSecurityGroupIdRefs(obj: GangliaLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface GangliaLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderCustomSecurityGroupIdSelector(obj: GangliaLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GangliaLayerSpecForProviderEbsVolume
 */
export interface GangliaLayerSpecForProviderEbsVolume {
  /**
   * @schema GangliaLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema GangliaLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema GangliaLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema GangliaLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema GangliaLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema GangliaLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema GangliaLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderEbsVolume(obj: GangliaLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GangliaLayerSpecForProviderLoadBasedAutoScaling
 */
export interface GangliaLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderLoadBasedAutoScaling(obj: GangliaLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema GangliaLayerSpecForProviderStackIdRef
 */
export interface GangliaLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GangliaLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GangliaLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: GangliaLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderStackIdRef(obj: GangliaLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GangliaLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema GangliaLayerSpecForProviderStackIdSelector
 */
export interface GangliaLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GangliaLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GangliaLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GangliaLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: GangliaLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderStackIdSelector(obj: GangliaLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GangliaLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GangliaLayerSpecProviderConfigRefPolicy
 */
export interface GangliaLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GangliaLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GangliaLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GangliaLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GangliaLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GangliaLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecProviderConfigRefPolicy(obj: GangliaLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GangliaLayerSpecProviderRefPolicy
 */
export interface GangliaLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GangliaLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GangliaLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GangliaLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GangliaLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GangliaLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecProviderRefPolicy(obj: GangliaLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GangliaLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface GangliaLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GangliaLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GangliaLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GangliaLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecPublishConnectionDetailsToConfigRef(obj: GangliaLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GangliaLayerSpecPublishConnectionDetailsToMetadata
 */
export interface GangliaLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GangliaLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GangliaLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GangliaLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GangliaLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecPublishConnectionDetailsToMetadata(obj: GangliaLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * A human-readable name for the layer.
   *
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * @schema GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: GangliaLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: GangliaLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: GangliaLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GangliaLayerSpecForProviderStackIdRefPolicy
 */
export interface GangliaLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GangliaLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: GangliaLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GangliaLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: GangliaLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderStackIdRefPolicy(obj: GangliaLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GangliaLayerSpecForProviderStackIdSelectorPolicy
 */
export interface GangliaLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GangliaLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: GangliaLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GangliaLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: GangliaLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GangliaLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecForProviderStackIdSelectorPolicy(obj: GangliaLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GangliaLayerSpecProviderConfigRefPolicyResolution
 */
export enum GangliaLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GangliaLayerSpecProviderConfigRefPolicyResolve
 */
export enum GangliaLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GangliaLayerSpecProviderRefPolicyResolution
 */
export enum GangliaLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GangliaLayerSpecProviderRefPolicyResolve
 */
export enum GangliaLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum GangliaLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum GangliaLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GangliaLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum GangliaLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GangliaLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum GangliaLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GangliaLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum GangliaLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GangliaLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum GangliaLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GangliaLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HAProxyLayer is the Schema for the HAProxyLayers API. Provides an OpsWorks HAProxy layer resource.
 *
 * @schema HAProxyLayer
 */
export class HaProxyLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HAProxyLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'HAProxyLayer',
  }

  /**
   * Renders a Kubernetes manifest for "HAProxyLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HaProxyLayerProps): any {
    return {
      ...HaProxyLayer.GVK,
      ...toJson_HaProxyLayerProps(props),
    };
  }

  /**
   * Defines a "HAProxyLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HaProxyLayerProps) {
    super(scope, id, {
      ...HaProxyLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HaProxyLayer.GVK,
      ...toJson_HaProxyLayerProps(resolved),
    };
  }
}

/**
 * HAProxyLayer is the Schema for the HAProxyLayers API. Provides an OpsWorks HAProxy layer resource.
 *
 * @schema HAProxyLayer
 */
export interface HaProxyLayerProps {
  /**
   * @schema HAProxyLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HAProxyLayerSpec defines the desired state of HAProxyLayer
   *
   * @schema HAProxyLayer#spec
   */
  readonly spec: HaProxyLayerSpec;

}

/**
 * Converts an object of type 'HaProxyLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerProps(obj: HaProxyLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HaProxyLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HAProxyLayerSpec defines the desired state of HAProxyLayer
 *
 * @schema HaProxyLayerSpec
 */
export interface HaProxyLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HaProxyLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: HaProxyLayerSpecDeletionPolicy;

  /**
   * @schema HaProxyLayerSpec#forProvider
   */
  readonly forProvider: HaProxyLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HaProxyLayerSpec#managementPolicy
   */
  readonly managementPolicy?: HaProxyLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HaProxyLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: HaProxyLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema HaProxyLayerSpec#providerRef
   */
  readonly providerRef?: HaProxyLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HaProxyLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HaProxyLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HaProxyLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HaProxyLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HaProxyLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpec(obj: HaProxyLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HaProxyLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_HaProxyLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_HaProxyLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_HaProxyLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HaProxyLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HaProxyLayerSpecDeletionPolicy
 */
export enum HaProxyLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HaProxyLayerSpecForProvider
 */
export interface HaProxyLayerSpecForProvider {
  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema HaProxyLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema HaProxyLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema HaProxyLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * @schema HaProxyLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: HaProxyLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema HaProxyLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema HaProxyLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema HaProxyLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * Custom JSON attributes to apply to the layer.
   *
   * @schema HaProxyLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema HaProxyLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: HaProxyLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema HaProxyLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: HaProxyLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema HaProxyLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema HaProxyLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema HaProxyLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema HaProxyLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema HaProxyLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * ebs_volume blocks, as described below, will each create an EBS volume and connect it to the layer's instances.
   *
   * @schema HaProxyLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: HaProxyLayerSpecForProviderEbsVolume[];

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema HaProxyLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * HTTP method to use for instance healthchecks. Defaults to "OPTIONS".
   *
   * @default OPTIONS".
   * @schema HaProxyLayerSpecForProvider#healthcheckMethod
   */
  readonly healthcheckMethod?: string;

  /**
   * URL path to use for instance healthchecks. Defaults to "/".
   *
   * @default .
   * @schema HaProxyLayerSpecForProvider#healthcheckUrl
   */
  readonly healthcheckUrl?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema HaProxyLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema HaProxyLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * @schema HaProxyLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: HaProxyLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * A human-readable name for the layer.
   *
   * @schema HaProxyLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema HaProxyLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema HaProxyLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: HaProxyLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema HaProxyLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: HaProxyLayerSpecForProviderStackIdSelector;

  /**
   * Whether to enable HAProxy stats.
   *
   * @schema HaProxyLayerSpecForProvider#statsEnabled
   */
  readonly statsEnabled?: boolean;

  /**
   * The password to use for HAProxy stats.
   *
   * @schema HaProxyLayerSpecForProvider#statsPassword
   */
  readonly statsPassword?: string;

  /**
   * The HAProxy stats URL. Defaults to "/haproxy?stats".
   *
   * @default haproxy?stats".
   * @schema HaProxyLayerSpecForProvider#statsUrl
   */
  readonly statsUrl?: string;

  /**
   * The username for HAProxy stats. Defaults to "opsworks".
   *
   * @default opsworks".
   * @schema HaProxyLayerSpecForProvider#statsUser
   */
  readonly statsUser?: string;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema HaProxyLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema HaProxyLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema HaProxyLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProvider(obj: HaProxyLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_HaProxyLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_HaProxyLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_HaProxyLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_HaProxyLayerSpecForProviderEbsVolume(y)),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'healthcheckMethod': obj.healthcheckMethod,
    'healthcheckUrl': obj.healthcheckUrl,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_HaProxyLayerSpecForProviderLoadBasedAutoScaling(y)),
    'name': obj.name,
    'stackId': obj.stackId,
    'stackIdRef': toJson_HaProxyLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_HaProxyLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'statsEnabled': obj.statsEnabled,
    'statsPassword': obj.statsPassword,
    'statsUrl': obj.statsUrl,
    'statsUser': obj.statsUser,
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HaProxyLayerSpecManagementPolicy
 */
export enum HaProxyLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HaProxyLayerSpecProviderConfigRef
 */
export interface HaProxyLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HaProxyLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HaProxyLayerSpecProviderConfigRef#policy
   */
  readonly policy?: HaProxyLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HaProxyLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecProviderConfigRef(obj: HaProxyLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HaProxyLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema HaProxyLayerSpecProviderRef
 */
export interface HaProxyLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema HaProxyLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HaProxyLayerSpecProviderRef#policy
   */
  readonly policy?: HaProxyLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'HaProxyLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecProviderRef(obj: HaProxyLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HaProxyLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HaProxyLayerSpecPublishConnectionDetailsTo
 */
export interface HaProxyLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HaProxyLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HaProxyLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HaProxyLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HaProxyLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HaProxyLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HaProxyLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecPublishConnectionDetailsTo(obj: HaProxyLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HaProxyLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HaProxyLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HaProxyLayerSpecWriteConnectionSecretToRef
 */
export interface HaProxyLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HaProxyLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HaProxyLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HaProxyLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecWriteConnectionSecretToRef(obj: HaProxyLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HaProxyLayerSpecForProviderCloudwatchConfiguration
 */
export interface HaProxyLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderCloudwatchConfiguration(obj: HaProxyLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface HaProxyLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderCustomSecurityGroupIdRefs(obj: HaProxyLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface HaProxyLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderCustomSecurityGroupIdSelector(obj: HaProxyLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HaProxyLayerSpecForProviderEbsVolume
 */
export interface HaProxyLayerSpecForProviderEbsVolume {
  /**
   * @schema HaProxyLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema HaProxyLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema HaProxyLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema HaProxyLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema HaProxyLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema HaProxyLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema HaProxyLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderEbsVolume(obj: HaProxyLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HaProxyLayerSpecForProviderLoadBasedAutoScaling
 */
export interface HaProxyLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderLoadBasedAutoScaling(obj: HaProxyLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema HaProxyLayerSpecForProviderStackIdRef
 */
export interface HaProxyLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HaProxyLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HaProxyLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: HaProxyLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderStackIdRef(obj: HaProxyLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HaProxyLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema HaProxyLayerSpecForProviderStackIdSelector
 */
export interface HaProxyLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HaProxyLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HaProxyLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HaProxyLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: HaProxyLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderStackIdSelector(obj: HaProxyLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HaProxyLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HaProxyLayerSpecProviderConfigRefPolicy
 */
export interface HaProxyLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HaProxyLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HaProxyLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HaProxyLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HaProxyLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HaProxyLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecProviderConfigRefPolicy(obj: HaProxyLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HaProxyLayerSpecProviderRefPolicy
 */
export interface HaProxyLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HaProxyLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: HaProxyLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HaProxyLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: HaProxyLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'HaProxyLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecProviderRefPolicy(obj: HaProxyLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HaProxyLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface HaProxyLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HaProxyLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HaProxyLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HaProxyLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecPublishConnectionDetailsToConfigRef(obj: HaProxyLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HaProxyLayerSpecPublishConnectionDetailsToMetadata
 */
export interface HaProxyLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HaProxyLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HaProxyLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HaProxyLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HaProxyLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecPublishConnectionDetailsToMetadata(obj: HaProxyLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * A human-readable name for the layer.
   *
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * @schema HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: HaProxyLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: HaProxyLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: HaProxyLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HaProxyLayerSpecForProviderStackIdRefPolicy
 */
export interface HaProxyLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HaProxyLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: HaProxyLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HaProxyLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: HaProxyLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderStackIdRefPolicy(obj: HaProxyLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HaProxyLayerSpecForProviderStackIdSelectorPolicy
 */
export interface HaProxyLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HaProxyLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: HaProxyLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HaProxyLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: HaProxyLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HaProxyLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecForProviderStackIdSelectorPolicy(obj: HaProxyLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HaProxyLayerSpecProviderConfigRefPolicyResolution
 */
export enum HaProxyLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HaProxyLayerSpecProviderConfigRefPolicyResolve
 */
export enum HaProxyLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HaProxyLayerSpecProviderRefPolicyResolution
 */
export enum HaProxyLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HaProxyLayerSpecProviderRefPolicyResolve
 */
export enum HaProxyLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum HaProxyLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum HaProxyLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HaProxyLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum HaProxyLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HaProxyLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum HaProxyLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HaProxyLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum HaProxyLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HaProxyLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum HaProxyLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HaProxyLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Instance is the Schema for the Instances API. Provides an OpsWorks instance resource.
 *
 * @schema Instance
 */
export class Instance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Instance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'Instance',
  }

  /**
   * Renders a Kubernetes manifest for "Instance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProps): any {
    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(props),
    };
  }

  /**
   * Defines a "Instance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProps) {
    super(scope, id, {
      ...Instance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(resolved),
    };
  }
}

/**
 * Instance is the Schema for the Instances API. Provides an OpsWorks instance resource.
 *
 * @schema Instance
 */
export interface InstanceProps {
  /**
   * @schema Instance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceSpec defines the desired state of Instance
   *
   * @schema Instance#spec
   */
  readonly spec: InstanceSpec;

}

/**
 * Converts an object of type 'InstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProps(obj: InstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSpec defines the desired state of Instance
 *
 * @schema InstanceSpec
 */
export interface InstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceSpecDeletionPolicy;

  /**
   * @schema InstanceSpec#forProvider
   */
  readonly forProvider: InstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#managementPolicy
   */
  readonly managementPolicy?: InstanceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InstanceSpec#providerRef
   */
  readonly providerRef?: InstanceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpec(obj: InstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_InstanceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InstanceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecDeletionPolicy
 */
export enum InstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceSpecForProvider
 */
export interface InstanceSpecForProvider {
  /**
   * OpsWorks agent to install. Default is INHERIT.
   *
   * @default INHERIT.
   * @schema InstanceSpecForProvider#agentVersion
   */
  readonly agentVersion?: string;

  /**
   * AMI to use for the instance.  If an AMI is specified, os must be Custom.
   *
   * @schema InstanceSpecForProvider#amiId
   */
  readonly amiId?: string;

  /**
   * Machine architecture for created instances.  Valid values are x86_64 or i386. The default is x86_64.
   *
   * @schema InstanceSpecForProvider#architecture
   */
  readonly architecture?: string;

  /**
   * Creates load-based or time-based instances.  Valid values are load, timer.
   *
   * @schema InstanceSpecForProvider#autoScalingType
   */
  readonly autoScalingType?: string;

  /**
   * Name of the availability zone where instances will be created by default.
   *
   * @schema InstanceSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * Time that the instance was created.
   *
   * @schema InstanceSpecForProvider#createdAt
   */
  readonly createdAt?: string;

  /**
   * Whether to delete EBS volume on deletion. Default is true.
   *
   * @default true.
   * @schema InstanceSpecForProvider#deleteEbs
   */
  readonly deleteEbs?: boolean;

  /**
   * Whether to delete the Elastic IP on deletion.
   *
   * @schema InstanceSpecForProvider#deleteEip
   */
  readonly deleteEip?: boolean;

  /**
   * Configuration block for additional EBS block devices to attach to the instance. See Block Devices below.
   *
   * @schema InstanceSpecForProvider#ebsBlockDevice
   */
  readonly ebsBlockDevice?: InstanceSpecForProviderEbsBlockDevice[];

  /**
   * Whether the launched EC2 instance will be EBS-optimized.
   *
   * @schema InstanceSpecForProvider#ebsOptimized
   */
  readonly ebsOptimized?: boolean;

  /**
   * ECS cluster's ARN for container instances.
   *
   * @schema InstanceSpecForProvider#ecsClusterArn
   */
  readonly ecsClusterArn?: string;

  /**
   * Instance Elastic IP address.
   *
   * @schema InstanceSpecForProvider#elasticIp
   */
  readonly elasticIp?: string;

  /**
   * Configuration block for ephemeral (also known as "Instance Store") volumes on the instance. See Block Devices below.
   *
   * @schema InstanceSpecForProvider#ephemeralBlockDevice
   */
  readonly ephemeralBlockDevice?: InstanceSpecForProviderEphemeralBlockDevice[];

  /**
   * Instance's host name.
   *
   * @schema InstanceSpecForProvider#hostname
   */
  readonly hostname?: string;

  /**
   * For registered instances, infrastructure class: ec2 or on-premises.
   *
   * @schema InstanceSpecForProvider#infrastructureClass
   */
  readonly infrastructureClass?: string;

  /**
   * Controls where to install OS and package updates when the instance boots.  Default is true.
   *
   * @default true.
   * @schema InstanceSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * ARN of the instance's IAM profile.
   *
   * @schema InstanceSpecForProvider#instanceProfileArn
   */
  readonly instanceProfileArn?: string;

  /**
   * Type of instance to start.
   *
   * @schema InstanceSpecForProvider#instanceType
   */
  readonly instanceType?: string;

  /**
   * List of the layers the instance will belong to.
   *
   * @schema InstanceSpecForProvider#layerIds
   */
  readonly layerIds?: string[];

  /**
   * References to CustomLayer to populate layerIds.
   *
   * @schema InstanceSpecForProvider#layerIdsRefs
   */
  readonly layerIdsRefs?: InstanceSpecForProviderLayerIdsRefs[];

  /**
   * Selector for a list of CustomLayer to populate layerIds.
   *
   * @schema InstanceSpecForProvider#layerIdsSelector
   */
  readonly layerIdsSelector?: InstanceSpecForProviderLayerIdsSelector;

  /**
   * Name of operating system that will be installed.
   *
   * @schema InstanceSpecForProvider#os
   */
  readonly os?: string;

  /**
   * Configuration block for the root block device of the instance. See Block Devices below.
   *
   * @schema InstanceSpecForProvider#rootBlockDevice
   */
  readonly rootBlockDevice?: InstanceSpecForProviderRootBlockDevice[];

  /**
   * Name of the type of root device instances will have by default. Valid values are ebs or instance-store.
   *
   * @schema InstanceSpecForProvider#rootDeviceType
   */
  readonly rootDeviceType?: string;

  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema InstanceSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: InstanceSpecForProviderSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema InstanceSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: InstanceSpecForProviderSecurityGroupIdSelector;

  /**
   * Associated security groups.
   *
   * @schema InstanceSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * Name of the SSH keypair that instances will have by default.
   *
   * @schema InstanceSpecForProvider#sshKeyName
   */
  readonly sshKeyName?: string;

  /**
   * Identifier of the stack the instance will belong to.
   *
   * @schema InstanceSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema InstanceSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: InstanceSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema InstanceSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: InstanceSpecForProviderStackIdSelector;

  /**
   * Desired state of the instance. Valid values are running or stopped.
   *
   * @schema InstanceSpecForProvider#state
   */
  readonly state?: string;

  /**
   * Instance status. Will be one of booting, connection_lost, online, pending, rebooting, requested, running_setup, setup_failed, shutting_down, start_failed, stop_failed, stopped, stopping, terminated, or terminating.
   *
   * @schema InstanceSpecForProvider#status
   */
  readonly status?: string;

  /**
   * Subnet ID to attach to.
   *
   * @schema InstanceSpecForProvider#subnetId
   */
  readonly subnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate subnetId.
   *
   * @schema InstanceSpecForProvider#subnetIdRef
   */
  readonly subnetIdRef?: InstanceSpecForProviderSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate subnetId.
   *
   * @schema InstanceSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: InstanceSpecForProviderSubnetIdSelector;

  /**
   * Instance tenancy to use. Valid values are default, dedicated or host.
   *
   * @schema InstanceSpecForProvider#tenancy
   */
  readonly tenancy?: string;

  /**
   * Keyword to choose what virtualization mode created instances will use. Valid values are paravirtual or hvm.
   *
   * @schema InstanceSpecForProvider#virtualizationType
   */
  readonly virtualizationType?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProvider(obj: InstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agentVersion': obj.agentVersion,
    'amiId': obj.amiId,
    'architecture': obj.architecture,
    'autoScalingType': obj.autoScalingType,
    'availabilityZone': obj.availabilityZone,
    'createdAt': obj.createdAt,
    'deleteEbs': obj.deleteEbs,
    'deleteEip': obj.deleteEip,
    'ebsBlockDevice': obj.ebsBlockDevice?.map(y => toJson_InstanceSpecForProviderEbsBlockDevice(y)),
    'ebsOptimized': obj.ebsOptimized,
    'ecsClusterArn': obj.ecsClusterArn,
    'elasticIp': obj.elasticIp,
    'ephemeralBlockDevice': obj.ephemeralBlockDevice?.map(y => toJson_InstanceSpecForProviderEphemeralBlockDevice(y)),
    'hostname': obj.hostname,
    'infrastructureClass': obj.infrastructureClass,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceProfileArn': obj.instanceProfileArn,
    'instanceType': obj.instanceType,
    'layerIds': obj.layerIds?.map(y => y),
    'layerIdsRefs': obj.layerIdsRefs?.map(y => toJson_InstanceSpecForProviderLayerIdsRefs(y)),
    'layerIdsSelector': toJson_InstanceSpecForProviderLayerIdsSelector(obj.layerIdsSelector),
    'os': obj.os,
    'rootBlockDevice': obj.rootBlockDevice?.map(y => toJson_InstanceSpecForProviderRootBlockDevice(y)),
    'rootDeviceType': obj.rootDeviceType,
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_InstanceSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_InstanceSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'sshKeyName': obj.sshKeyName,
    'stackId': obj.stackId,
    'stackIdRef': toJson_InstanceSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_InstanceSpecForProviderStackIdSelector(obj.stackIdSelector),
    'state': obj.state,
    'status': obj.status,
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_InstanceSpecForProviderSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_InstanceSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'tenancy': obj.tenancy,
    'virtualizationType': obj.virtualizationType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecManagementPolicy
 */
export enum InstanceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceSpecProviderConfigRef
 */
export interface InstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRef(obj: InstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InstanceSpecProviderRef
 */
export interface InstanceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderRef#policy
   */
  readonly policy?: InstanceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderRef(obj: InstanceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceSpecPublishConnectionDetailsTo
 */
export interface InstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsTo(obj: InstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceSpecWriteConnectionSecretToRef
 */
export interface InstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecWriteConnectionSecretToRef(obj: InstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderEbsBlockDevice
 */
export interface InstanceSpecForProviderEbsBlockDevice {
  /**
   * Whether the volume should be destroyed on instance termination. Default is true.
   *
   * @default true.
   * @schema InstanceSpecForProviderEbsBlockDevice#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * Name of the device to mount.
   *
   * @schema InstanceSpecForProviderEbsBlockDevice#deviceName
   */
  readonly deviceName: string;

  /**
   * Amount of provisioned IOPS. This must be set with a volume_type of io1.
   *
   * @schema InstanceSpecForProviderEbsBlockDevice#iops
   */
  readonly iops?: number;

  /**
   * Snapshot ID to mount.
   *
   * @schema InstanceSpecForProviderEbsBlockDevice#snapshotId
   */
  readonly snapshotId?: string;

  /**
   * Size of the volume in gigabytes.
   *
   * @schema InstanceSpecForProviderEbsBlockDevice#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * Type of volume. Valid values are standard, gp2, or io1. Default is standard.
   *
   * @default standard.
   * @schema InstanceSpecForProviderEbsBlockDevice#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderEbsBlockDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderEbsBlockDevice(obj: InstanceSpecForProviderEbsBlockDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'deviceName': obj.deviceName,
    'iops': obj.iops,
    'snapshotId': obj.snapshotId,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderEphemeralBlockDevice
 */
export interface InstanceSpecForProviderEphemeralBlockDevice {
  /**
   * Name of the block device to mount on the instance.
   *
   * @schema InstanceSpecForProviderEphemeralBlockDevice#deviceName
   */
  readonly deviceName: string;

  /**
   * The Instance Store Device Name (e.g., ephemeral0).
   *
   * @schema InstanceSpecForProviderEphemeralBlockDevice#virtualName
   */
  readonly virtualName: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderEphemeralBlockDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderEphemeralBlockDevice(obj: InstanceSpecForProviderEphemeralBlockDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'virtualName': obj.virtualName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema InstanceSpecForProviderLayerIdsRefs
 */
export interface InstanceSpecForProviderLayerIdsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderLayerIdsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderLayerIdsRefs#policy
   */
  readonly policy?: InstanceSpecForProviderLayerIdsRefsPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderLayerIdsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderLayerIdsRefs(obj: InstanceSpecForProviderLayerIdsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderLayerIdsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of CustomLayer to populate layerIds.
 *
 * @schema InstanceSpecForProviderLayerIdsSelector
 */
export interface InstanceSpecForProviderLayerIdsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderLayerIdsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderLayerIdsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderLayerIdsSelector#policy
   */
  readonly policy?: InstanceSpecForProviderLayerIdsSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderLayerIdsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderLayerIdsSelector(obj: InstanceSpecForProviderLayerIdsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderLayerIdsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderRootBlockDevice
 */
export interface InstanceSpecForProviderRootBlockDevice {
  /**
   * Whether the volume should be destroyed on instance termination. Default is true.
   *
   * @default true.
   * @schema InstanceSpecForProviderRootBlockDevice#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * Amount of provisioned IOPS. This must be set with a volume_type of io1.
   *
   * @schema InstanceSpecForProviderRootBlockDevice#iops
   */
  readonly iops?: number;

  /**
   * Size of the volume in gigabytes.
   *
   * @schema InstanceSpecForProviderRootBlockDevice#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * Type of volume. Valid values are standard, gp2, or io1. Default is standard.
   *
   * @default standard.
   * @schema InstanceSpecForProviderRootBlockDevice#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderRootBlockDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderRootBlockDevice(obj: InstanceSpecForProviderRootBlockDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'iops': obj.iops,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema InstanceSpecForProviderSecurityGroupIdRefs
 */
export interface InstanceSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: InstanceSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSecurityGroupIdRefs(obj: InstanceSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema InstanceSpecForProviderSecurityGroupIdSelector
 */
export interface InstanceSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: InstanceSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSecurityGroupIdSelector(obj: InstanceSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema InstanceSpecForProviderStackIdRef
 */
export interface InstanceSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderStackIdRef#policy
   */
  readonly policy?: InstanceSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderStackIdRef(obj: InstanceSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema InstanceSpecForProviderStackIdSelector
 */
export interface InstanceSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderStackIdSelector#policy
   */
  readonly policy?: InstanceSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderStackIdSelector(obj: InstanceSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate subnetId.
 *
 * @schema InstanceSpecForProviderSubnetIdRef
 */
export interface InstanceSpecForProviderSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderSubnetIdRef#policy
   */
  readonly policy?: InstanceSpecForProviderSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSubnetIdRef(obj: InstanceSpecForProviderSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate subnetId.
 *
 * @schema InstanceSpecForProviderSubnetIdSelector
 */
export interface InstanceSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: InstanceSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSubnetIdSelector(obj: InstanceSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderConfigRefPolicy
 */
export interface InstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRefPolicy(obj: InstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderRefPolicy
 */
export interface InstanceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderRefPolicy(obj: InstanceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj: InstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj: InstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderLayerIdsRefsPolicy
 */
export interface InstanceSpecForProviderLayerIdsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderLayerIdsRefsPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderLayerIdsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderLayerIdsRefsPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderLayerIdsRefsPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderLayerIdsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderLayerIdsRefsPolicy(obj: InstanceSpecForProviderLayerIdsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderLayerIdsSelectorPolicy
 */
export interface InstanceSpecForProviderLayerIdsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderLayerIdsSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderLayerIdsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderLayerIdsSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderLayerIdsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderLayerIdsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderLayerIdsSelectorPolicy(obj: InstanceSpecForProviderLayerIdsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface InstanceSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSecurityGroupIdRefsPolicy(obj: InstanceSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface InstanceSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSecurityGroupIdSelectorPolicy(obj: InstanceSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderStackIdRefPolicy
 */
export interface InstanceSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderStackIdRefPolicy(obj: InstanceSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderStackIdSelectorPolicy
 */
export interface InstanceSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderStackIdSelectorPolicy(obj: InstanceSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderSubnetIdRefPolicy
 */
export interface InstanceSpecForProviderSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderSubnetIdRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderSubnetIdRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSubnetIdRefPolicy(obj: InstanceSpecForProviderSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderSubnetIdSelectorPolicy
 */
export interface InstanceSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderSubnetIdSelectorPolicy(obj: InstanceSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolution
 */
export enum InstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolve
 */
export enum InstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderRefPolicyResolution
 */
export enum InstanceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderRefPolicyResolve
 */
export enum InstanceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderLayerIdsRefsPolicyResolution
 */
export enum InstanceSpecForProviderLayerIdsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderLayerIdsRefsPolicyResolve
 */
export enum InstanceSpecForProviderLayerIdsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderLayerIdsSelectorPolicyResolution
 */
export enum InstanceSpecForProviderLayerIdsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderLayerIdsSelectorPolicyResolve
 */
export enum InstanceSpecForProviderLayerIdsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum InstanceSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum InstanceSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum InstanceSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum InstanceSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderStackIdRefPolicyResolution
 */
export enum InstanceSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderStackIdRefPolicyResolve
 */
export enum InstanceSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderStackIdSelectorPolicyResolution
 */
export enum InstanceSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderStackIdSelectorPolicyResolve
 */
export enum InstanceSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderSubnetIdRefPolicyResolution
 */
export enum InstanceSpecForProviderSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderSubnetIdRefPolicyResolve
 */
export enum InstanceSpecForProviderSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum InstanceSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum InstanceSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * JavaAppLayer is the Schema for the JavaAppLayers API. Provides an OpsWorks Java application layer resource.
 *
 * @schema JavaAppLayer
 */
export class JavaAppLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "JavaAppLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'JavaAppLayer',
  }

  /**
   * Renders a Kubernetes manifest for "JavaAppLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: JavaAppLayerProps): any {
    return {
      ...JavaAppLayer.GVK,
      ...toJson_JavaAppLayerProps(props),
    };
  }

  /**
   * Defines a "JavaAppLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: JavaAppLayerProps) {
    super(scope, id, {
      ...JavaAppLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...JavaAppLayer.GVK,
      ...toJson_JavaAppLayerProps(resolved),
    };
  }
}

/**
 * JavaAppLayer is the Schema for the JavaAppLayers API. Provides an OpsWorks Java application layer resource.
 *
 * @schema JavaAppLayer
 */
export interface JavaAppLayerProps {
  /**
   * @schema JavaAppLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * JavaAppLayerSpec defines the desired state of JavaAppLayer
   *
   * @schema JavaAppLayer#spec
   */
  readonly spec: JavaAppLayerSpec;

}

/**
 * Converts an object of type 'JavaAppLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerProps(obj: JavaAppLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_JavaAppLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JavaAppLayerSpec defines the desired state of JavaAppLayer
 *
 * @schema JavaAppLayerSpec
 */
export interface JavaAppLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema JavaAppLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: JavaAppLayerSpecDeletionPolicy;

  /**
   * @schema JavaAppLayerSpec#forProvider
   */
  readonly forProvider: JavaAppLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema JavaAppLayerSpec#managementPolicy
   */
  readonly managementPolicy?: JavaAppLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema JavaAppLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: JavaAppLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema JavaAppLayerSpec#providerRef
   */
  readonly providerRef?: JavaAppLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema JavaAppLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: JavaAppLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema JavaAppLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: JavaAppLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'JavaAppLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpec(obj: JavaAppLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_JavaAppLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_JavaAppLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_JavaAppLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_JavaAppLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_JavaAppLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema JavaAppLayerSpecDeletionPolicy
 */
export enum JavaAppLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema JavaAppLayerSpecForProvider
 */
export interface JavaAppLayerSpecForProvider {
  /**
   * Keyword for the application container to use. Defaults to "tomcat".
   *
   * @default tomcat".
   * @schema JavaAppLayerSpecForProvider#appServer
   */
  readonly appServer?: string;

  /**
   * Version of the selected application container to use. Defaults to "7".
   *
   * @default 7".
   * @schema JavaAppLayerSpecForProvider#appServerVersion
   */
  readonly appServerVersion?: string;

  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema JavaAppLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema JavaAppLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema JavaAppLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * @schema JavaAppLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: JavaAppLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema JavaAppLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema JavaAppLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema JavaAppLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * Custom JSON attributes to apply to the layer.
   *
   * @schema JavaAppLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema JavaAppLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: JavaAppLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema JavaAppLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: JavaAppLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema JavaAppLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema JavaAppLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema JavaAppLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema JavaAppLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema JavaAppLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * ebs_volume blocks, as described below, will each create an EBS volume and connect it to the layer's instances.
   *
   * @schema JavaAppLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: JavaAppLayerSpecForProviderEbsVolume[];

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema JavaAppLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema JavaAppLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema JavaAppLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * Options to set for the JVM.
   *
   * @schema JavaAppLayerSpecForProvider#jvmOptions
   */
  readonly jvmOptions?: string;

  /**
   * Keyword for the type of JVM to use. Defaults to openjdk.
   *
   * @default openjdk.
   * @schema JavaAppLayerSpecForProvider#jvmType
   */
  readonly jvmType?: string;

  /**
   * Version of JVM to use. Defaults to "7".
   *
   * @default 7".
   * @schema JavaAppLayerSpecForProvider#jvmVersion
   */
  readonly jvmVersion?: string;

  /**
   * @schema JavaAppLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: JavaAppLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * A human-readable name for the layer.
   *
   * @schema JavaAppLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema JavaAppLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema JavaAppLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: JavaAppLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema JavaAppLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: JavaAppLayerSpecForProviderStackIdSelector;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema JavaAppLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema JavaAppLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema JavaAppLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProvider(obj: JavaAppLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appServer': obj.appServer,
    'appServerVersion': obj.appServerVersion,
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_JavaAppLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_JavaAppLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_JavaAppLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_JavaAppLayerSpecForProviderEbsVolume(y)),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'jvmOptions': obj.jvmOptions,
    'jvmType': obj.jvmType,
    'jvmVersion': obj.jvmVersion,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_JavaAppLayerSpecForProviderLoadBasedAutoScaling(y)),
    'name': obj.name,
    'stackId': obj.stackId,
    'stackIdRef': toJson_JavaAppLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_JavaAppLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema JavaAppLayerSpecManagementPolicy
 */
export enum JavaAppLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema JavaAppLayerSpecProviderConfigRef
 */
export interface JavaAppLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JavaAppLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JavaAppLayerSpecProviderConfigRef#policy
   */
  readonly policy?: JavaAppLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'JavaAppLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecProviderConfigRef(obj: JavaAppLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JavaAppLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema JavaAppLayerSpecProviderRef
 */
export interface JavaAppLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema JavaAppLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JavaAppLayerSpecProviderRef#policy
   */
  readonly policy?: JavaAppLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'JavaAppLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecProviderRef(obj: JavaAppLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JavaAppLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema JavaAppLayerSpecPublishConnectionDetailsTo
 */
export interface JavaAppLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema JavaAppLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: JavaAppLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema JavaAppLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: JavaAppLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema JavaAppLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'JavaAppLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecPublishConnectionDetailsTo(obj: JavaAppLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_JavaAppLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_JavaAppLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema JavaAppLayerSpecWriteConnectionSecretToRef
 */
export interface JavaAppLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema JavaAppLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema JavaAppLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'JavaAppLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecWriteConnectionSecretToRef(obj: JavaAppLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JavaAppLayerSpecForProviderCloudwatchConfiguration
 */
export interface JavaAppLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderCloudwatchConfiguration(obj: JavaAppLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface JavaAppLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderCustomSecurityGroupIdRefs(obj: JavaAppLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface JavaAppLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderCustomSecurityGroupIdSelector(obj: JavaAppLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JavaAppLayerSpecForProviderEbsVolume
 */
export interface JavaAppLayerSpecForProviderEbsVolume {
  /**
   * @schema JavaAppLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema JavaAppLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema JavaAppLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema JavaAppLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema JavaAppLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema JavaAppLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema JavaAppLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderEbsVolume(obj: JavaAppLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JavaAppLayerSpecForProviderLoadBasedAutoScaling
 */
export interface JavaAppLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderLoadBasedAutoScaling(obj: JavaAppLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema JavaAppLayerSpecForProviderStackIdRef
 */
export interface JavaAppLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JavaAppLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JavaAppLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: JavaAppLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderStackIdRef(obj: JavaAppLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JavaAppLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema JavaAppLayerSpecForProviderStackIdSelector
 */
export interface JavaAppLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JavaAppLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JavaAppLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JavaAppLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: JavaAppLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderStackIdSelector(obj: JavaAppLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JavaAppLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JavaAppLayerSpecProviderConfigRefPolicy
 */
export interface JavaAppLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JavaAppLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: JavaAppLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JavaAppLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: JavaAppLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JavaAppLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecProviderConfigRefPolicy(obj: JavaAppLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JavaAppLayerSpecProviderRefPolicy
 */
export interface JavaAppLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JavaAppLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: JavaAppLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JavaAppLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: JavaAppLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'JavaAppLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecProviderRefPolicy(obj: JavaAppLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema JavaAppLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface JavaAppLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JavaAppLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JavaAppLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'JavaAppLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecPublishConnectionDetailsToConfigRef(obj: JavaAppLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema JavaAppLayerSpecPublishConnectionDetailsToMetadata
 */
export interface JavaAppLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema JavaAppLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema JavaAppLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema JavaAppLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JavaAppLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecPublishConnectionDetailsToMetadata(obj: JavaAppLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * A human-readable name for the layer.
   *
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * @schema JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: JavaAppLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: JavaAppLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: JavaAppLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JavaAppLayerSpecForProviderStackIdRefPolicy
 */
export interface JavaAppLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JavaAppLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: JavaAppLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JavaAppLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: JavaAppLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderStackIdRefPolicy(obj: JavaAppLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JavaAppLayerSpecForProviderStackIdSelectorPolicy
 */
export interface JavaAppLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JavaAppLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: JavaAppLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JavaAppLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: JavaAppLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JavaAppLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecForProviderStackIdSelectorPolicy(obj: JavaAppLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JavaAppLayerSpecProviderConfigRefPolicyResolution
 */
export enum JavaAppLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JavaAppLayerSpecProviderConfigRefPolicyResolve
 */
export enum JavaAppLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JavaAppLayerSpecProviderRefPolicyResolution
 */
export enum JavaAppLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JavaAppLayerSpecProviderRefPolicyResolve
 */
export enum JavaAppLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum JavaAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum JavaAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JavaAppLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum JavaAppLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JavaAppLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum JavaAppLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JavaAppLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum JavaAppLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JavaAppLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum JavaAppLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum JavaAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MemcachedLayer is the Schema for the MemcachedLayers API. Provides an OpsWorks memcached layer resource.
 *
 * @schema MemcachedLayer
 */
export class MemcachedLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MemcachedLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'MemcachedLayer',
  }

  /**
   * Renders a Kubernetes manifest for "MemcachedLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MemcachedLayerProps): any {
    return {
      ...MemcachedLayer.GVK,
      ...toJson_MemcachedLayerProps(props),
    };
  }

  /**
   * Defines a "MemcachedLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MemcachedLayerProps) {
    super(scope, id, {
      ...MemcachedLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MemcachedLayer.GVK,
      ...toJson_MemcachedLayerProps(resolved),
    };
  }
}

/**
 * MemcachedLayer is the Schema for the MemcachedLayers API. Provides an OpsWorks memcached layer resource.
 *
 * @schema MemcachedLayer
 */
export interface MemcachedLayerProps {
  /**
   * @schema MemcachedLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MemcachedLayerSpec defines the desired state of MemcachedLayer
   *
   * @schema MemcachedLayer#spec
   */
  readonly spec: MemcachedLayerSpec;

}

/**
 * Converts an object of type 'MemcachedLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerProps(obj: MemcachedLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MemcachedLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MemcachedLayerSpec defines the desired state of MemcachedLayer
 *
 * @schema MemcachedLayerSpec
 */
export interface MemcachedLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MemcachedLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: MemcachedLayerSpecDeletionPolicy;

  /**
   * @schema MemcachedLayerSpec#forProvider
   */
  readonly forProvider: MemcachedLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MemcachedLayerSpec#managementPolicy
   */
  readonly managementPolicy?: MemcachedLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MemcachedLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: MemcachedLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MemcachedLayerSpec#providerRef
   */
  readonly providerRef?: MemcachedLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MemcachedLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MemcachedLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MemcachedLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MemcachedLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MemcachedLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpec(obj: MemcachedLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MemcachedLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MemcachedLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MemcachedLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MemcachedLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MemcachedLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MemcachedLayerSpecDeletionPolicy
 */
export enum MemcachedLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MemcachedLayerSpecForProvider
 */
export interface MemcachedLayerSpecForProvider {
  /**
   * Amount of memory to allocate for the cache on each instance, in megabytes. Defaults to 512MB.
   *
   * @default 512MB.
   * @schema MemcachedLayerSpecForProvider#allocatedMemory
   */
  readonly allocatedMemory?: number;

  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema MemcachedLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema MemcachedLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema MemcachedLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * @schema MemcachedLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: MemcachedLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema MemcachedLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema MemcachedLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema MemcachedLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * Custom JSON attributes to apply to the layer.
   *
   * @schema MemcachedLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema MemcachedLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: MemcachedLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema MemcachedLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: MemcachedLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema MemcachedLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema MemcachedLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema MemcachedLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema MemcachedLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema MemcachedLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * ebs_volume blocks, as described below, will each create an EBS volume and connect it to the layer's instances.
   *
   * @schema MemcachedLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: MemcachedLayerSpecForProviderEbsVolume[];

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema MemcachedLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema MemcachedLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema MemcachedLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * @schema MemcachedLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: MemcachedLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * A human-readable name for the layer.
   *
   * @schema MemcachedLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema MemcachedLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema MemcachedLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: MemcachedLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema MemcachedLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: MemcachedLayerSpecForProviderStackIdSelector;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema MemcachedLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema MemcachedLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema MemcachedLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProvider(obj: MemcachedLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedMemory': obj.allocatedMemory,
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_MemcachedLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_MemcachedLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_MemcachedLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_MemcachedLayerSpecForProviderEbsVolume(y)),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_MemcachedLayerSpecForProviderLoadBasedAutoScaling(y)),
    'name': obj.name,
    'stackId': obj.stackId,
    'stackIdRef': toJson_MemcachedLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_MemcachedLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MemcachedLayerSpecManagementPolicy
 */
export enum MemcachedLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MemcachedLayerSpecProviderConfigRef
 */
export interface MemcachedLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemcachedLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemcachedLayerSpecProviderConfigRef#policy
   */
  readonly policy?: MemcachedLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MemcachedLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecProviderConfigRef(obj: MemcachedLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemcachedLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MemcachedLayerSpecProviderRef
 */
export interface MemcachedLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemcachedLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemcachedLayerSpecProviderRef#policy
   */
  readonly policy?: MemcachedLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MemcachedLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecProviderRef(obj: MemcachedLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemcachedLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MemcachedLayerSpecPublishConnectionDetailsTo
 */
export interface MemcachedLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MemcachedLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MemcachedLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MemcachedLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MemcachedLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MemcachedLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MemcachedLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecPublishConnectionDetailsTo(obj: MemcachedLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MemcachedLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MemcachedLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MemcachedLayerSpecWriteConnectionSecretToRef
 */
export interface MemcachedLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MemcachedLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MemcachedLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MemcachedLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecWriteConnectionSecretToRef(obj: MemcachedLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MemcachedLayerSpecForProviderCloudwatchConfiguration
 */
export interface MemcachedLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderCloudwatchConfiguration(obj: MemcachedLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface MemcachedLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderCustomSecurityGroupIdRefs(obj: MemcachedLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface MemcachedLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderCustomSecurityGroupIdSelector(obj: MemcachedLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MemcachedLayerSpecForProviderEbsVolume
 */
export interface MemcachedLayerSpecForProviderEbsVolume {
  /**
   * @schema MemcachedLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema MemcachedLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema MemcachedLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema MemcachedLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema MemcachedLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema MemcachedLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema MemcachedLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderEbsVolume(obj: MemcachedLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MemcachedLayerSpecForProviderLoadBasedAutoScaling
 */
export interface MemcachedLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderLoadBasedAutoScaling(obj: MemcachedLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema MemcachedLayerSpecForProviderStackIdRef
 */
export interface MemcachedLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemcachedLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemcachedLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: MemcachedLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderStackIdRef(obj: MemcachedLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemcachedLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema MemcachedLayerSpecForProviderStackIdSelector
 */
export interface MemcachedLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MemcachedLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MemcachedLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MemcachedLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: MemcachedLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderStackIdSelector(obj: MemcachedLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MemcachedLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemcachedLayerSpecProviderConfigRefPolicy
 */
export interface MemcachedLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemcachedLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MemcachedLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemcachedLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MemcachedLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemcachedLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecProviderConfigRefPolicy(obj: MemcachedLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemcachedLayerSpecProviderRefPolicy
 */
export interface MemcachedLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemcachedLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MemcachedLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemcachedLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MemcachedLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MemcachedLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecProviderRefPolicy(obj: MemcachedLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MemcachedLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface MemcachedLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemcachedLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemcachedLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MemcachedLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecPublishConnectionDetailsToConfigRef(obj: MemcachedLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MemcachedLayerSpecPublishConnectionDetailsToMetadata
 */
export interface MemcachedLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemcachedLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemcachedLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MemcachedLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MemcachedLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecPublishConnectionDetailsToMetadata(obj: MemcachedLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * A human-readable name for the layer.
   *
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * @schema MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: MemcachedLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: MemcachedLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: MemcachedLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemcachedLayerSpecForProviderStackIdRefPolicy
 */
export interface MemcachedLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemcachedLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: MemcachedLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemcachedLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: MemcachedLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderStackIdRefPolicy(obj: MemcachedLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MemcachedLayerSpecForProviderStackIdSelectorPolicy
 */
export interface MemcachedLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemcachedLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: MemcachedLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemcachedLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: MemcachedLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MemcachedLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecForProviderStackIdSelectorPolicy(obj: MemcachedLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemcachedLayerSpecProviderConfigRefPolicyResolution
 */
export enum MemcachedLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemcachedLayerSpecProviderConfigRefPolicyResolve
 */
export enum MemcachedLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemcachedLayerSpecProviderRefPolicyResolution
 */
export enum MemcachedLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemcachedLayerSpecProviderRefPolicyResolve
 */
export enum MemcachedLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum MemcachedLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum MemcachedLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemcachedLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum MemcachedLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemcachedLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum MemcachedLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemcachedLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum MemcachedLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemcachedLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum MemcachedLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MemcachedLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MySQLLayer is the Schema for the MySQLLayers API. Provides an OpsWorks MySQL layer resource.
 *
 * @schema MySQLLayer
 */
export class MySqlLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MySQLLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'MySQLLayer',
  }

  /**
   * Renders a Kubernetes manifest for "MySQLLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MySqlLayerProps): any {
    return {
      ...MySqlLayer.GVK,
      ...toJson_MySqlLayerProps(props),
    };
  }

  /**
   * Defines a "MySQLLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MySqlLayerProps) {
    super(scope, id, {
      ...MySqlLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MySqlLayer.GVK,
      ...toJson_MySqlLayerProps(resolved),
    };
  }
}

/**
 * MySQLLayer is the Schema for the MySQLLayers API. Provides an OpsWorks MySQL layer resource.
 *
 * @schema MySQLLayer
 */
export interface MySqlLayerProps {
  /**
   * @schema MySQLLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MySQLLayerSpec defines the desired state of MySQLLayer
   *
   * @schema MySQLLayer#spec
   */
  readonly spec: MySqlLayerSpec;

}

/**
 * Converts an object of type 'MySqlLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerProps(obj: MySqlLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MySqlLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MySQLLayerSpec defines the desired state of MySQLLayer
 *
 * @schema MySqlLayerSpec
 */
export interface MySqlLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MySqlLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: MySqlLayerSpecDeletionPolicy;

  /**
   * @schema MySqlLayerSpec#forProvider
   */
  readonly forProvider: MySqlLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MySqlLayerSpec#managementPolicy
   */
  readonly managementPolicy?: MySqlLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MySqlLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: MySqlLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MySqlLayerSpec#providerRef
   */
  readonly providerRef?: MySqlLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MySqlLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MySqlLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MySqlLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MySqlLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MySqlLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpec(obj: MySqlLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MySqlLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MySqlLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MySqlLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MySqlLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MySqlLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MySqlLayerSpecDeletionPolicy
 */
export enum MySqlLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MySqlLayerSpecForProvider
 */
export interface MySqlLayerSpecForProvider {
  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema MySqlLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema MySqlLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema MySqlLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * @schema MySqlLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: MySqlLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema MySqlLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema MySqlLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema MySqlLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * Custom JSON attributes to apply to the layer.
   *
   * @schema MySqlLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema MySqlLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: MySqlLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema MySqlLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: MySqlLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema MySqlLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema MySqlLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema MySqlLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema MySqlLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema MySqlLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * ebs_volume blocks, as described below, will each create an EBS volume and connect it to the layer's instances.
   *
   * @schema MySqlLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: MySqlLayerSpecForProviderEbsVolume[];

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema MySqlLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema MySqlLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema MySqlLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * @schema MySqlLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: MySqlLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * A human-readable name for the layer.
   *
   * @schema MySqlLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Root password to use for MySQL.
   *
   * @schema MySqlLayerSpecForProvider#rootPassword
   */
  readonly rootPassword?: string;

  /**
   * Whether to set the root user password to all instances in the stack so they can access the instances in this layer.
   *
   * @schema MySqlLayerSpecForProvider#rootPasswordOnAllInstances
   */
  readonly rootPasswordOnAllInstances?: boolean;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema MySqlLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema MySqlLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: MySqlLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema MySqlLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: MySqlLayerSpecForProviderStackIdSelector;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema MySqlLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema MySqlLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema MySqlLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProvider(obj: MySqlLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_MySqlLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_MySqlLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_MySqlLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_MySqlLayerSpecForProviderEbsVolume(y)),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_MySqlLayerSpecForProviderLoadBasedAutoScaling(y)),
    'name': obj.name,
    'rootPassword': obj.rootPassword,
    'rootPasswordOnAllInstances': obj.rootPasswordOnAllInstances,
    'stackId': obj.stackId,
    'stackIdRef': toJson_MySqlLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_MySqlLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MySqlLayerSpecManagementPolicy
 */
export enum MySqlLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MySqlLayerSpecProviderConfigRef
 */
export interface MySqlLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MySqlLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MySqlLayerSpecProviderConfigRef#policy
   */
  readonly policy?: MySqlLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MySqlLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecProviderConfigRef(obj: MySqlLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MySqlLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MySqlLayerSpecProviderRef
 */
export interface MySqlLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MySqlLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MySqlLayerSpecProviderRef#policy
   */
  readonly policy?: MySqlLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MySqlLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecProviderRef(obj: MySqlLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MySqlLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MySqlLayerSpecPublishConnectionDetailsTo
 */
export interface MySqlLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MySqlLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MySqlLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MySqlLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MySqlLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MySqlLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MySqlLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecPublishConnectionDetailsTo(obj: MySqlLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MySqlLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MySqlLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MySqlLayerSpecWriteConnectionSecretToRef
 */
export interface MySqlLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MySqlLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MySqlLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MySqlLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecWriteConnectionSecretToRef(obj: MySqlLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MySqlLayerSpecForProviderCloudwatchConfiguration
 */
export interface MySqlLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderCloudwatchConfiguration(obj: MySqlLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface MySqlLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderCustomSecurityGroupIdRefs(obj: MySqlLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface MySqlLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderCustomSecurityGroupIdSelector(obj: MySqlLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MySqlLayerSpecForProviderEbsVolume
 */
export interface MySqlLayerSpecForProviderEbsVolume {
  /**
   * @schema MySqlLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema MySqlLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema MySqlLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema MySqlLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema MySqlLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema MySqlLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema MySqlLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderEbsVolume(obj: MySqlLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MySqlLayerSpecForProviderLoadBasedAutoScaling
 */
export interface MySqlLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderLoadBasedAutoScaling(obj: MySqlLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema MySqlLayerSpecForProviderStackIdRef
 */
export interface MySqlLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MySqlLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MySqlLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: MySqlLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderStackIdRef(obj: MySqlLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MySqlLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema MySqlLayerSpecForProviderStackIdSelector
 */
export interface MySqlLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MySqlLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MySqlLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MySqlLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: MySqlLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderStackIdSelector(obj: MySqlLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MySqlLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MySqlLayerSpecProviderConfigRefPolicy
 */
export interface MySqlLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MySqlLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MySqlLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MySqlLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MySqlLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MySqlLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecProviderConfigRefPolicy(obj: MySqlLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MySqlLayerSpecProviderRefPolicy
 */
export interface MySqlLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MySqlLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MySqlLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MySqlLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MySqlLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MySqlLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecProviderRefPolicy(obj: MySqlLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MySqlLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface MySqlLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MySqlLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MySqlLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MySqlLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecPublishConnectionDetailsToConfigRef(obj: MySqlLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MySqlLayerSpecPublishConnectionDetailsToMetadata
 */
export interface MySqlLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MySqlLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MySqlLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MySqlLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MySqlLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecPublishConnectionDetailsToMetadata(obj: MySqlLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * A human-readable name for the layer.
   *
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * @schema MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: MySqlLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: MySqlLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: MySqlLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MySqlLayerSpecForProviderStackIdRefPolicy
 */
export interface MySqlLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MySqlLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: MySqlLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MySqlLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: MySqlLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderStackIdRefPolicy(obj: MySqlLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MySqlLayerSpecForProviderStackIdSelectorPolicy
 */
export interface MySqlLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MySqlLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: MySqlLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MySqlLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: MySqlLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MySqlLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecForProviderStackIdSelectorPolicy(obj: MySqlLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MySqlLayerSpecProviderConfigRefPolicyResolution
 */
export enum MySqlLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MySqlLayerSpecProviderConfigRefPolicyResolve
 */
export enum MySqlLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MySqlLayerSpecProviderRefPolicyResolution
 */
export enum MySqlLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MySqlLayerSpecProviderRefPolicyResolve
 */
export enum MySqlLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum MySqlLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum MySqlLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MySqlLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum MySqlLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MySqlLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum MySqlLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MySqlLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum MySqlLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MySqlLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum MySqlLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MySqlLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * NodeJSAppLayer is the Schema for the NodeJSAppLayers API. Provides an OpsWorks NodeJS application layer resource.
 *
 * @schema NodeJSAppLayer
 */
export class NodeJsAppLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodeJSAppLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'NodeJSAppLayer',
  }

  /**
   * Renders a Kubernetes manifest for "NodeJSAppLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeJsAppLayerProps): any {
    return {
      ...NodeJsAppLayer.GVK,
      ...toJson_NodeJsAppLayerProps(props),
    };
  }

  /**
   * Defines a "NodeJSAppLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodeJsAppLayerProps) {
    super(scope, id, {
      ...NodeJsAppLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodeJsAppLayer.GVK,
      ...toJson_NodeJsAppLayerProps(resolved),
    };
  }
}

/**
 * NodeJSAppLayer is the Schema for the NodeJSAppLayers API. Provides an OpsWorks NodeJS application layer resource.
 *
 * @schema NodeJSAppLayer
 */
export interface NodeJsAppLayerProps {
  /**
   * @schema NodeJSAppLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NodeJSAppLayerSpec defines the desired state of NodeJSAppLayer
   *
   * @schema NodeJSAppLayer#spec
   */
  readonly spec: NodeJsAppLayerSpec;

}

/**
 * Converts an object of type 'NodeJsAppLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerProps(obj: NodeJsAppLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NodeJsAppLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeJSAppLayerSpec defines the desired state of NodeJSAppLayer
 *
 * @schema NodeJsAppLayerSpec
 */
export interface NodeJsAppLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NodeJsAppLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: NodeJsAppLayerSpecDeletionPolicy;

  /**
   * @schema NodeJsAppLayerSpec#forProvider
   */
  readonly forProvider: NodeJsAppLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NodeJsAppLayerSpec#managementPolicy
   */
  readonly managementPolicy?: NodeJsAppLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NodeJsAppLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: NodeJsAppLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema NodeJsAppLayerSpec#providerRef
   */
  readonly providerRef?: NodeJsAppLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NodeJsAppLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NodeJsAppLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NodeJsAppLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NodeJsAppLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpec(obj: NodeJsAppLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NodeJsAppLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_NodeJsAppLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_NodeJsAppLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_NodeJsAppLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NodeJsAppLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NodeJsAppLayerSpecDeletionPolicy
 */
export enum NodeJsAppLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NodeJsAppLayerSpecForProvider
 */
export interface NodeJsAppLayerSpecForProvider {
  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema NodeJsAppLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema NodeJsAppLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema NodeJsAppLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * @schema NodeJsAppLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: NodeJsAppLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema NodeJsAppLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema NodeJsAppLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema NodeJsAppLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * Custom JSON attributes to apply to the layer.
   *
   * @schema NodeJsAppLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema NodeJsAppLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema NodeJsAppLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema NodeJsAppLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema NodeJsAppLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema NodeJsAppLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema NodeJsAppLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema NodeJsAppLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * ebs_volume blocks, as described below, will each create an EBS volume and connect it to the layer's instances.
   *
   * @schema NodeJsAppLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: NodeJsAppLayerSpecForProviderEbsVolume[];

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema NodeJsAppLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema NodeJsAppLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema NodeJsAppLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * @schema NodeJsAppLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: NodeJsAppLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * A human-readable name for the layer.
   *
   * @schema NodeJsAppLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The version of NodeJS to use. Defaults to "0.10.38".
   *
   * @default 0.10.38".
   * @schema NodeJsAppLayerSpecForProvider#nodejsVersion
   */
  readonly nodejsVersion?: string;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema NodeJsAppLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema NodeJsAppLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: NodeJsAppLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema NodeJsAppLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: NodeJsAppLayerSpecForProviderStackIdSelector;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema NodeJsAppLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema NodeJsAppLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema NodeJsAppLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProvider(obj: NodeJsAppLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_NodeJsAppLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_NodeJsAppLayerSpecForProviderEbsVolume(y)),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_NodeJsAppLayerSpecForProviderLoadBasedAutoScaling(y)),
    'name': obj.name,
    'nodejsVersion': obj.nodejsVersion,
    'stackId': obj.stackId,
    'stackIdRef': toJson_NodeJsAppLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_NodeJsAppLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NodeJsAppLayerSpecManagementPolicy
 */
export enum NodeJsAppLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NodeJsAppLayerSpecProviderConfigRef
 */
export interface NodeJsAppLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeJsAppLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeJsAppLayerSpecProviderConfigRef#policy
   */
  readonly policy?: NodeJsAppLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecProviderConfigRef(obj: NodeJsAppLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeJsAppLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema NodeJsAppLayerSpecProviderRef
 */
export interface NodeJsAppLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeJsAppLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeJsAppLayerSpecProviderRef#policy
   */
  readonly policy?: NodeJsAppLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecProviderRef(obj: NodeJsAppLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeJsAppLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NodeJsAppLayerSpecPublishConnectionDetailsTo
 */
export interface NodeJsAppLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NodeJsAppLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NodeJsAppLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NodeJsAppLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NodeJsAppLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NodeJsAppLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecPublishConnectionDetailsTo(obj: NodeJsAppLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NodeJsAppLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NodeJsAppLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NodeJsAppLayerSpecWriteConnectionSecretToRef
 */
export interface NodeJsAppLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NodeJsAppLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NodeJsAppLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecWriteConnectionSecretToRef(obj: NodeJsAppLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeJsAppLayerSpecForProviderCloudwatchConfiguration
 */
export interface NodeJsAppLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderCloudwatchConfiguration(obj: NodeJsAppLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefs(obj: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelector(obj: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeJsAppLayerSpecForProviderEbsVolume
 */
export interface NodeJsAppLayerSpecForProviderEbsVolume {
  /**
   * @schema NodeJsAppLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema NodeJsAppLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema NodeJsAppLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema NodeJsAppLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema NodeJsAppLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema NodeJsAppLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema NodeJsAppLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderEbsVolume(obj: NodeJsAppLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScaling
 */
export interface NodeJsAppLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderLoadBasedAutoScaling(obj: NodeJsAppLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema NodeJsAppLayerSpecForProviderStackIdRef
 */
export interface NodeJsAppLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeJsAppLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeJsAppLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: NodeJsAppLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderStackIdRef(obj: NodeJsAppLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeJsAppLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema NodeJsAppLayerSpecForProviderStackIdSelector
 */
export interface NodeJsAppLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeJsAppLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeJsAppLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeJsAppLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: NodeJsAppLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderStackIdSelector(obj: NodeJsAppLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeJsAppLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeJsAppLayerSpecProviderConfigRefPolicy
 */
export interface NodeJsAppLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeJsAppLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NodeJsAppLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeJsAppLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NodeJsAppLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecProviderConfigRefPolicy(obj: NodeJsAppLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeJsAppLayerSpecProviderRefPolicy
 */
export interface NodeJsAppLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeJsAppLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: NodeJsAppLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeJsAppLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: NodeJsAppLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecProviderRefPolicy(obj: NodeJsAppLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NodeJsAppLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface NodeJsAppLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeJsAppLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeJsAppLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecPublishConnectionDetailsToConfigRef(obj: NodeJsAppLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NodeJsAppLayerSpecPublishConnectionDetailsToMetadata
 */
export interface NodeJsAppLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NodeJsAppLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NodeJsAppLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NodeJsAppLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecPublishConnectionDetailsToMetadata(obj: NodeJsAppLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * A human-readable name for the layer.
   *
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * @schema NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: NodeJsAppLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: NodeJsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: NodeJsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeJsAppLayerSpecForProviderStackIdRefPolicy
 */
export interface NodeJsAppLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeJsAppLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: NodeJsAppLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeJsAppLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: NodeJsAppLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderStackIdRefPolicy(obj: NodeJsAppLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeJsAppLayerSpecForProviderStackIdSelectorPolicy
 */
export interface NodeJsAppLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeJsAppLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: NodeJsAppLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeJsAppLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: NodeJsAppLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecForProviderStackIdSelectorPolicy(obj: NodeJsAppLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeJsAppLayerSpecProviderConfigRefPolicyResolution
 */
export enum NodeJsAppLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeJsAppLayerSpecProviderConfigRefPolicyResolve
 */
export enum NodeJsAppLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeJsAppLayerSpecProviderRefPolicyResolution
 */
export enum NodeJsAppLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeJsAppLayerSpecProviderRefPolicyResolve
 */
export enum NodeJsAppLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum NodeJsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum NodeJsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeJsAppLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum NodeJsAppLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeJsAppLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum NodeJsAppLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeJsAppLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum NodeJsAppLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeJsAppLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum NodeJsAppLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NodeJsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Permission is the Schema for the Permissions API. Provides an OpsWorks permission resource.
 *
 * @schema Permission
 */
export class Permission extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Permission"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'Permission',
  }

  /**
   * Renders a Kubernetes manifest for "Permission".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionProps): any {
    return {
      ...Permission.GVK,
      ...toJson_PermissionProps(props),
    };
  }

  /**
   * Defines a "Permission" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionProps) {
    super(scope, id, {
      ...Permission.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Permission.GVK,
      ...toJson_PermissionProps(resolved),
    };
  }
}

/**
 * Permission is the Schema for the Permissions API. Provides an OpsWorks permission resource.
 *
 * @schema Permission
 */
export interface PermissionProps {
  /**
   * @schema Permission#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionSpec defines the desired state of Permission
   *
   * @schema Permission#spec
   */
  readonly spec: PermissionSpec;

}

/**
 * Converts an object of type 'PermissionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionProps(obj: PermissionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionSpec defines the desired state of Permission
 *
 * @schema PermissionSpec
 */
export interface PermissionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionSpecDeletionPolicy;

  /**
   * @schema PermissionSpec#forProvider
   */
  readonly forProvider: PermissionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSpec#managementPolicy
   */
  readonly managementPolicy?: PermissionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PermissionSpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PermissionSpec#providerRef
   */
  readonly providerRef?: PermissionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PermissionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PermissionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpec(obj: PermissionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PermissionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PermissionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PermissionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSpecDeletionPolicy
 */
export enum PermissionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionSpecForProvider
 */
export interface PermissionSpecForProvider {
  /**
   * Whether the user is allowed to use SSH to communicate with the instance
   *
   * @schema PermissionSpecForProvider#allowSsh
   */
  readonly allowSsh?: boolean;

  /**
   * Whether the user is allowed to use sudo to elevate privileges
   *
   * @schema PermissionSpecForProvider#allowSudo
   */
  readonly allowSudo?: boolean;

  /**
   * The users permission level. Mus be one of deny, show, deploy, manage, iam_only
   *
   * @schema PermissionSpecForProvider#level
   */
  readonly level?: string;

  /**
   * The stack to set the permissions for
   *
   * @schema PermissionSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema PermissionSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: PermissionSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema PermissionSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: PermissionSpecForProviderStackIdSelector;

  /**
   * The user's IAM ARN to set permissions for
   *
   * @schema PermissionSpecForProvider#userArn
   */
  readonly userArn?: string;

  /**
   * Reference to a User in iam to populate userArn.
   *
   * @schema PermissionSpecForProvider#userArnRef
   */
  readonly userArnRef?: PermissionSpecForProviderUserArnRef;

  /**
   * Selector for a User in iam to populate userArn.
   *
   * @schema PermissionSpecForProvider#userArnSelector
   */
  readonly userArnSelector?: PermissionSpecForProviderUserArnSelector;

}

/**
 * Converts an object of type 'PermissionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProvider(obj: PermissionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSsh': obj.allowSsh,
    'allowSudo': obj.allowSudo,
    'level': obj.level,
    'stackId': obj.stackId,
    'stackIdRef': toJson_PermissionSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_PermissionSpecForProviderStackIdSelector(obj.stackIdSelector),
    'userArn': obj.userArn,
    'userArnRef': toJson_PermissionSpecForProviderUserArnRef(obj.userArnRef),
    'userArnSelector': toJson_PermissionSpecForProviderUserArnSelector(obj.userArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSpecManagementPolicy
 */
export enum PermissionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PermissionSpecProviderConfigRef
 */
export interface PermissionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecProviderConfigRef#policy
   */
  readonly policy?: PermissionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderConfigRef(obj: PermissionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PermissionSpecProviderRef
 */
export interface PermissionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecProviderRef#policy
   */
  readonly policy?: PermissionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderRef(obj: PermissionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PermissionSpecPublishConnectionDetailsTo
 */
export interface PermissionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsTo(obj: PermissionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PermissionSpecWriteConnectionSecretToRef
 */
export interface PermissionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecWriteConnectionSecretToRef(obj: PermissionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema PermissionSpecForProviderStackIdRef
 */
export interface PermissionSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecForProviderStackIdRef#policy
   */
  readonly policy?: PermissionSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderStackIdRef(obj: PermissionSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema PermissionSpecForProviderStackIdSelector
 */
export interface PermissionSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionSpecForProviderStackIdSelector#policy
   */
  readonly policy?: PermissionSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderStackIdSelector(obj: PermissionSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in iam to populate userArn.
 *
 * @schema PermissionSpecForProviderUserArnRef
 */
export interface PermissionSpecForProviderUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecForProviderUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecForProviderUserArnRef#policy
   */
  readonly policy?: PermissionSpecForProviderUserArnRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderUserArnRef(obj: PermissionSpecForProviderUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecForProviderUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in iam to populate userArn.
 *
 * @schema PermissionSpecForProviderUserArnSelector
 */
export interface PermissionSpecForProviderUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionSpecForProviderUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionSpecForProviderUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionSpecForProviderUserArnSelector#policy
   */
  readonly policy?: PermissionSpecForProviderUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderUserArnSelector(obj: PermissionSpecForProviderUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionSpecForProviderUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecProviderConfigRefPolicy
 */
export interface PermissionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderConfigRefPolicy(obj: PermissionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecProviderRefPolicy
 */
export interface PermissionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderRefPolicy(obj: PermissionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToConfigRef(obj: PermissionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionSpecPublishConnectionDetailsToMetadata
 */
export interface PermissionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToMetadata(obj: PermissionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecForProviderStackIdRefPolicy
 */
export interface PermissionSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderStackIdRefPolicy(obj: PermissionSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionSpecForProviderStackIdSelectorPolicy
 */
export interface PermissionSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderStackIdSelectorPolicy(obj: PermissionSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecForProviderUserArnRefPolicy
 */
export interface PermissionSpecForProviderUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderUserArnRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderUserArnRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderUserArnRefPolicy(obj: PermissionSpecForProviderUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionSpecForProviderUserArnSelectorPolicy
 */
export interface PermissionSpecForProviderUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderUserArnSelectorPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderUserArnSelectorPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderUserArnSelectorPolicy(obj: PermissionSpecForProviderUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecProviderConfigRefPolicyResolution
 */
export enum PermissionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecProviderConfigRefPolicyResolve
 */
export enum PermissionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecProviderRefPolicyResolution
 */
export enum PermissionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecProviderRefPolicyResolve
 */
export enum PermissionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderStackIdRefPolicyResolution
 */
export enum PermissionSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderStackIdRefPolicyResolve
 */
export enum PermissionSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderStackIdSelectorPolicyResolution
 */
export enum PermissionSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderStackIdSelectorPolicyResolve
 */
export enum PermissionSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderUserArnRefPolicyResolution
 */
export enum PermissionSpecForProviderUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderUserArnRefPolicyResolve
 */
export enum PermissionSpecForProviderUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderUserArnSelectorPolicyResolution
 */
export enum PermissionSpecForProviderUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderUserArnSelectorPolicyResolve
 */
export enum PermissionSpecForProviderUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PHPAppLayer is the Schema for the PHPAppLayers API. Provides an OpsWorks PHP application layer resource.
 *
 * @schema PHPAppLayer
 */
export class PhpAppLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PHPAppLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'PHPAppLayer',
  }

  /**
   * Renders a Kubernetes manifest for "PHPAppLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PhpAppLayerProps): any {
    return {
      ...PhpAppLayer.GVK,
      ...toJson_PhpAppLayerProps(props),
    };
  }

  /**
   * Defines a "PHPAppLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PhpAppLayerProps) {
    super(scope, id, {
      ...PhpAppLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PhpAppLayer.GVK,
      ...toJson_PhpAppLayerProps(resolved),
    };
  }
}

/**
 * PHPAppLayer is the Schema for the PHPAppLayers API. Provides an OpsWorks PHP application layer resource.
 *
 * @schema PHPAppLayer
 */
export interface PhpAppLayerProps {
  /**
   * @schema PHPAppLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PHPAppLayerSpec defines the desired state of PHPAppLayer
   *
   * @schema PHPAppLayer#spec
   */
  readonly spec: PhpAppLayerSpec;

}

/**
 * Converts an object of type 'PhpAppLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerProps(obj: PhpAppLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PhpAppLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PHPAppLayerSpec defines the desired state of PHPAppLayer
 *
 * @schema PhpAppLayerSpec
 */
export interface PhpAppLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PhpAppLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: PhpAppLayerSpecDeletionPolicy;

  /**
   * @schema PhpAppLayerSpec#forProvider
   */
  readonly forProvider: PhpAppLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PhpAppLayerSpec#managementPolicy
   */
  readonly managementPolicy?: PhpAppLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PhpAppLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: PhpAppLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PhpAppLayerSpec#providerRef
   */
  readonly providerRef?: PhpAppLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PhpAppLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PhpAppLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PhpAppLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PhpAppLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PhpAppLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpec(obj: PhpAppLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PhpAppLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PhpAppLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PhpAppLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PhpAppLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PhpAppLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PhpAppLayerSpecDeletionPolicy
 */
export enum PhpAppLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PhpAppLayerSpecForProvider
 */
export interface PhpAppLayerSpecForProvider {
  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema PhpAppLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema PhpAppLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema PhpAppLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * @schema PhpAppLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: PhpAppLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema PhpAppLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema PhpAppLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema PhpAppLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * Custom JSON attributes to apply to the layer.
   *
   * @schema PhpAppLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema PhpAppLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: PhpAppLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema PhpAppLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: PhpAppLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema PhpAppLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema PhpAppLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema PhpAppLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema PhpAppLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema PhpAppLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * ebs_volume blocks, as described below, will each create an EBS volume and connect it to the layer's instances.
   *
   * @schema PhpAppLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: PhpAppLayerSpecForProviderEbsVolume[];

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema PhpAppLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema PhpAppLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema PhpAppLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * @schema PhpAppLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: PhpAppLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * A human-readable name for the layer.
   *
   * @schema PhpAppLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema PhpAppLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema PhpAppLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: PhpAppLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema PhpAppLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: PhpAppLayerSpecForProviderStackIdSelector;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema PhpAppLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema PhpAppLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema PhpAppLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProvider(obj: PhpAppLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_PhpAppLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_PhpAppLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_PhpAppLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_PhpAppLayerSpecForProviderEbsVolume(y)),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_PhpAppLayerSpecForProviderLoadBasedAutoScaling(y)),
    'name': obj.name,
    'stackId': obj.stackId,
    'stackIdRef': toJson_PhpAppLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_PhpAppLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PhpAppLayerSpecManagementPolicy
 */
export enum PhpAppLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PhpAppLayerSpecProviderConfigRef
 */
export interface PhpAppLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PhpAppLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PhpAppLayerSpecProviderConfigRef#policy
   */
  readonly policy?: PhpAppLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PhpAppLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecProviderConfigRef(obj: PhpAppLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PhpAppLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PhpAppLayerSpecProviderRef
 */
export interface PhpAppLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PhpAppLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PhpAppLayerSpecProviderRef#policy
   */
  readonly policy?: PhpAppLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PhpAppLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecProviderRef(obj: PhpAppLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PhpAppLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PhpAppLayerSpecPublishConnectionDetailsTo
 */
export interface PhpAppLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PhpAppLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PhpAppLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PhpAppLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PhpAppLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PhpAppLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PhpAppLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecPublishConnectionDetailsTo(obj: PhpAppLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PhpAppLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PhpAppLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PhpAppLayerSpecWriteConnectionSecretToRef
 */
export interface PhpAppLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PhpAppLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PhpAppLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PhpAppLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecWriteConnectionSecretToRef(obj: PhpAppLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PhpAppLayerSpecForProviderCloudwatchConfiguration
 */
export interface PhpAppLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderCloudwatchConfiguration(obj: PhpAppLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface PhpAppLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderCustomSecurityGroupIdRefs(obj: PhpAppLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface PhpAppLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderCustomSecurityGroupIdSelector(obj: PhpAppLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PhpAppLayerSpecForProviderEbsVolume
 */
export interface PhpAppLayerSpecForProviderEbsVolume {
  /**
   * @schema PhpAppLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema PhpAppLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema PhpAppLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema PhpAppLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema PhpAppLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema PhpAppLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema PhpAppLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderEbsVolume(obj: PhpAppLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PhpAppLayerSpecForProviderLoadBasedAutoScaling
 */
export interface PhpAppLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderLoadBasedAutoScaling(obj: PhpAppLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema PhpAppLayerSpecForProviderStackIdRef
 */
export interface PhpAppLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PhpAppLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PhpAppLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: PhpAppLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderStackIdRef(obj: PhpAppLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PhpAppLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema PhpAppLayerSpecForProviderStackIdSelector
 */
export interface PhpAppLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PhpAppLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PhpAppLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PhpAppLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: PhpAppLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderStackIdSelector(obj: PhpAppLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PhpAppLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PhpAppLayerSpecProviderConfigRefPolicy
 */
export interface PhpAppLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhpAppLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PhpAppLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhpAppLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PhpAppLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PhpAppLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecProviderConfigRefPolicy(obj: PhpAppLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PhpAppLayerSpecProviderRefPolicy
 */
export interface PhpAppLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhpAppLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PhpAppLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhpAppLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PhpAppLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PhpAppLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecProviderRefPolicy(obj: PhpAppLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PhpAppLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface PhpAppLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PhpAppLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PhpAppLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PhpAppLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecPublishConnectionDetailsToConfigRef(obj: PhpAppLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PhpAppLayerSpecPublishConnectionDetailsToMetadata
 */
export interface PhpAppLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PhpAppLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PhpAppLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PhpAppLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PhpAppLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecPublishConnectionDetailsToMetadata(obj: PhpAppLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * A human-readable name for the layer.
   *
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * @schema PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: PhpAppLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: PhpAppLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: PhpAppLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PhpAppLayerSpecForProviderStackIdRefPolicy
 */
export interface PhpAppLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhpAppLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: PhpAppLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhpAppLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: PhpAppLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderStackIdRefPolicy(obj: PhpAppLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PhpAppLayerSpecForProviderStackIdSelectorPolicy
 */
export interface PhpAppLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhpAppLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: PhpAppLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhpAppLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: PhpAppLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PhpAppLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecForProviderStackIdSelectorPolicy(obj: PhpAppLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhpAppLayerSpecProviderConfigRefPolicyResolution
 */
export enum PhpAppLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhpAppLayerSpecProviderConfigRefPolicyResolve
 */
export enum PhpAppLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhpAppLayerSpecProviderRefPolicyResolution
 */
export enum PhpAppLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhpAppLayerSpecProviderRefPolicyResolve
 */
export enum PhpAppLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum PhpAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum PhpAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhpAppLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum PhpAppLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhpAppLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum PhpAppLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhpAppLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum PhpAppLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhpAppLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum PhpAppLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PhpAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RailsAppLayer is the Schema for the RailsAppLayers API. Provides an OpsWorks Ruby on Rails application layer resource.
 *
 * @schema RailsAppLayer
 */
export class RailsAppLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RailsAppLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'RailsAppLayer',
  }

  /**
   * Renders a Kubernetes manifest for "RailsAppLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RailsAppLayerProps): any {
    return {
      ...RailsAppLayer.GVK,
      ...toJson_RailsAppLayerProps(props),
    };
  }

  /**
   * Defines a "RailsAppLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RailsAppLayerProps) {
    super(scope, id, {
      ...RailsAppLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RailsAppLayer.GVK,
      ...toJson_RailsAppLayerProps(resolved),
    };
  }
}

/**
 * RailsAppLayer is the Schema for the RailsAppLayers API. Provides an OpsWorks Ruby on Rails application layer resource.
 *
 * @schema RailsAppLayer
 */
export interface RailsAppLayerProps {
  /**
   * @schema RailsAppLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RailsAppLayerSpec defines the desired state of RailsAppLayer
   *
   * @schema RailsAppLayer#spec
   */
  readonly spec: RailsAppLayerSpec;

}

/**
 * Converts an object of type 'RailsAppLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerProps(obj: RailsAppLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RailsAppLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RailsAppLayerSpec defines the desired state of RailsAppLayer
 *
 * @schema RailsAppLayerSpec
 */
export interface RailsAppLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RailsAppLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: RailsAppLayerSpecDeletionPolicy;

  /**
   * @schema RailsAppLayerSpec#forProvider
   */
  readonly forProvider: RailsAppLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RailsAppLayerSpec#managementPolicy
   */
  readonly managementPolicy?: RailsAppLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RailsAppLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: RailsAppLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RailsAppLayerSpec#providerRef
   */
  readonly providerRef?: RailsAppLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RailsAppLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RailsAppLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RailsAppLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RailsAppLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RailsAppLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpec(obj: RailsAppLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RailsAppLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RailsAppLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RailsAppLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RailsAppLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RailsAppLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RailsAppLayerSpecDeletionPolicy
 */
export enum RailsAppLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RailsAppLayerSpecForProvider
 */
export interface RailsAppLayerSpecForProvider {
  /**
   * Keyword for the app server to use. Defaults to "apache_passenger".
   *
   * @default apache_passenger".
   * @schema RailsAppLayerSpecForProvider#appServer
   */
  readonly appServer?: string;

  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema RailsAppLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema RailsAppLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema RailsAppLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * When OpsWorks is managing Bundler, which version to use. Defaults to "1.5.3".
   *
   * @default 1.5.3".
   * @schema RailsAppLayerSpecForProvider#bundlerVersion
   */
  readonly bundlerVersion?: string;

  /**
   * @schema RailsAppLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: RailsAppLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema RailsAppLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema RailsAppLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema RailsAppLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * Custom JSON attributes to apply to the layer.
   *
   * @schema RailsAppLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema RailsAppLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: RailsAppLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema RailsAppLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: RailsAppLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema RailsAppLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema RailsAppLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema RailsAppLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema RailsAppLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema RailsAppLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * ebs_volume blocks, as described below, will each create an EBS volume and connect it to the layer's instances.
   *
   * @schema RailsAppLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: RailsAppLayerSpecForProviderEbsVolume[];

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema RailsAppLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema RailsAppLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema RailsAppLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * @schema RailsAppLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: RailsAppLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * Whether OpsWorks should manage bundler. On by default.
   *
   * @schema RailsAppLayerSpecForProvider#manageBundler
   */
  readonly manageBundler?: boolean;

  /**
   * A human-readable name for the layer.
   *
   * @schema RailsAppLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The version of Passenger to use. Defaults to "4.0.46".
   *
   * @default 4.0.46".
   * @schema RailsAppLayerSpecForProvider#passengerVersion
   */
  readonly passengerVersion?: string;

  /**
   * The version of Ruby to use. Defaults to "2.0.0".
   *
   * @default 2.0.0".
   * @schema RailsAppLayerSpecForProvider#rubyVersion
   */
  readonly rubyVersion?: string;

  /**
   * The version of RubyGems to use. Defaults to "2.2.2".
   *
   * @default 2.2.2".
   * @schema RailsAppLayerSpecForProvider#rubygemsVersion
   */
  readonly rubygemsVersion?: string;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema RailsAppLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema RailsAppLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: RailsAppLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema RailsAppLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: RailsAppLayerSpecForProviderStackIdSelector;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema RailsAppLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema RailsAppLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema RailsAppLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProvider(obj: RailsAppLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appServer': obj.appServer,
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'bundlerVersion': obj.bundlerVersion,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_RailsAppLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_RailsAppLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_RailsAppLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_RailsAppLayerSpecForProviderEbsVolume(y)),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_RailsAppLayerSpecForProviderLoadBasedAutoScaling(y)),
    'manageBundler': obj.manageBundler,
    'name': obj.name,
    'passengerVersion': obj.passengerVersion,
    'rubyVersion': obj.rubyVersion,
    'rubygemsVersion': obj.rubygemsVersion,
    'stackId': obj.stackId,
    'stackIdRef': toJson_RailsAppLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_RailsAppLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RailsAppLayerSpecManagementPolicy
 */
export enum RailsAppLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RailsAppLayerSpecProviderConfigRef
 */
export interface RailsAppLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RailsAppLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RailsAppLayerSpecProviderConfigRef#policy
   */
  readonly policy?: RailsAppLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RailsAppLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecProviderConfigRef(obj: RailsAppLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RailsAppLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RailsAppLayerSpecProviderRef
 */
export interface RailsAppLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RailsAppLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RailsAppLayerSpecProviderRef#policy
   */
  readonly policy?: RailsAppLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RailsAppLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecProviderRef(obj: RailsAppLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RailsAppLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RailsAppLayerSpecPublishConnectionDetailsTo
 */
export interface RailsAppLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RailsAppLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RailsAppLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RailsAppLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RailsAppLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RailsAppLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RailsAppLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecPublishConnectionDetailsTo(obj: RailsAppLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RailsAppLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RailsAppLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RailsAppLayerSpecWriteConnectionSecretToRef
 */
export interface RailsAppLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RailsAppLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RailsAppLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RailsAppLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecWriteConnectionSecretToRef(obj: RailsAppLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RailsAppLayerSpecForProviderCloudwatchConfiguration
 */
export interface RailsAppLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderCloudwatchConfiguration(obj: RailsAppLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface RailsAppLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderCustomSecurityGroupIdRefs(obj: RailsAppLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface RailsAppLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderCustomSecurityGroupIdSelector(obj: RailsAppLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RailsAppLayerSpecForProviderEbsVolume
 */
export interface RailsAppLayerSpecForProviderEbsVolume {
  /**
   * @schema RailsAppLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema RailsAppLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema RailsAppLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema RailsAppLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema RailsAppLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema RailsAppLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema RailsAppLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderEbsVolume(obj: RailsAppLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RailsAppLayerSpecForProviderLoadBasedAutoScaling
 */
export interface RailsAppLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderLoadBasedAutoScaling(obj: RailsAppLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema RailsAppLayerSpecForProviderStackIdRef
 */
export interface RailsAppLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RailsAppLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RailsAppLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: RailsAppLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderStackIdRef(obj: RailsAppLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RailsAppLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema RailsAppLayerSpecForProviderStackIdSelector
 */
export interface RailsAppLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RailsAppLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RailsAppLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RailsAppLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: RailsAppLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderStackIdSelector(obj: RailsAppLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RailsAppLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RailsAppLayerSpecProviderConfigRefPolicy
 */
export interface RailsAppLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RailsAppLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RailsAppLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RailsAppLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RailsAppLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RailsAppLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecProviderConfigRefPolicy(obj: RailsAppLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RailsAppLayerSpecProviderRefPolicy
 */
export interface RailsAppLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RailsAppLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RailsAppLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RailsAppLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RailsAppLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RailsAppLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecProviderRefPolicy(obj: RailsAppLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RailsAppLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface RailsAppLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RailsAppLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RailsAppLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RailsAppLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecPublishConnectionDetailsToConfigRef(obj: RailsAppLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RailsAppLayerSpecPublishConnectionDetailsToMetadata
 */
export interface RailsAppLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RailsAppLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RailsAppLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RailsAppLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RailsAppLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecPublishConnectionDetailsToMetadata(obj: RailsAppLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * A human-readable name for the layer.
   *
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * @schema RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: RailsAppLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: RailsAppLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: RailsAppLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RailsAppLayerSpecForProviderStackIdRefPolicy
 */
export interface RailsAppLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RailsAppLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: RailsAppLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RailsAppLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: RailsAppLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderStackIdRefPolicy(obj: RailsAppLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RailsAppLayerSpecForProviderStackIdSelectorPolicy
 */
export interface RailsAppLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RailsAppLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: RailsAppLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RailsAppLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: RailsAppLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RailsAppLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecForProviderStackIdSelectorPolicy(obj: RailsAppLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RailsAppLayerSpecProviderConfigRefPolicyResolution
 */
export enum RailsAppLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RailsAppLayerSpecProviderConfigRefPolicyResolve
 */
export enum RailsAppLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RailsAppLayerSpecProviderRefPolicyResolution
 */
export enum RailsAppLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RailsAppLayerSpecProviderRefPolicyResolve
 */
export enum RailsAppLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum RailsAppLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum RailsAppLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RailsAppLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum RailsAppLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RailsAppLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum RailsAppLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RailsAppLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum RailsAppLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RailsAppLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum RailsAppLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RailsAppLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RDSDBInstance is the Schema for the RDSDBInstances API. Provides an OpsWorks RDS DB Instance resource.
 *
 * @schema RDSDBInstance
 */
export class RdsdbInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RDSDBInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'RDSDBInstance',
  }

  /**
   * Renders a Kubernetes manifest for "RDSDBInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RdsdbInstanceProps): any {
    return {
      ...RdsdbInstance.GVK,
      ...toJson_RdsdbInstanceProps(props),
    };
  }

  /**
   * Defines a "RDSDBInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RdsdbInstanceProps) {
    super(scope, id, {
      ...RdsdbInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RdsdbInstance.GVK,
      ...toJson_RdsdbInstanceProps(resolved),
    };
  }
}

/**
 * RDSDBInstance is the Schema for the RDSDBInstances API. Provides an OpsWorks RDS DB Instance resource.
 *
 * @schema RDSDBInstance
 */
export interface RdsdbInstanceProps {
  /**
   * @schema RDSDBInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RDSDBInstanceSpec defines the desired state of RDSDBInstance
   *
   * @schema RDSDBInstance#spec
   */
  readonly spec: RdsdbInstanceSpec;

}

/**
 * Converts an object of type 'RdsdbInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceProps(obj: RdsdbInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RdsdbInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RDSDBInstanceSpec defines the desired state of RDSDBInstance
 *
 * @schema RdsdbInstanceSpec
 */
export interface RdsdbInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RdsdbInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: RdsdbInstanceSpecDeletionPolicy;

  /**
   * @schema RdsdbInstanceSpec#forProvider
   */
  readonly forProvider: RdsdbInstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RdsdbInstanceSpec#managementPolicy
   */
  readonly managementPolicy?: RdsdbInstanceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RdsdbInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: RdsdbInstanceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RdsdbInstanceSpec#providerRef
   */
  readonly providerRef?: RdsdbInstanceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RdsdbInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RdsdbInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RdsdbInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RdsdbInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RdsdbInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpec(obj: RdsdbInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RdsdbInstanceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RdsdbInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RdsdbInstanceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RdsdbInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RdsdbInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RdsdbInstanceSpecDeletionPolicy
 */
export enum RdsdbInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RdsdbInstanceSpecForProvider
 */
export interface RdsdbInstanceSpecForProvider {
  /**
   * A db password
   *
   * @schema RdsdbInstanceSpecForProvider#dbPasswordSecretRef
   */
  readonly dbPasswordSecretRef?: RdsdbInstanceSpecForProviderDbPasswordSecretRef;

  /**
   * A db username
   *
   * @schema RdsdbInstanceSpecForProvider#dbUser
   */
  readonly dbUser?: string;

  /**
   * The db instance to register for this stack. Changing this will force a new resource.
   *
   * @schema RdsdbInstanceSpecForProvider#rdsDbInstanceArn
   */
  readonly rdsDbInstanceArn?: string;

  /**
   * Reference to a Instance in rds to populate rdsDbInstanceArn.
   *
   * @schema RdsdbInstanceSpecForProvider#rdsDbInstanceArnRef
   */
  readonly rdsDbInstanceArnRef?: RdsdbInstanceSpecForProviderRdsDbInstanceArnRef;

  /**
   * Selector for a Instance in rds to populate rdsDbInstanceArn.
   *
   * @schema RdsdbInstanceSpecForProvider#rdsDbInstanceArnSelector
   */
  readonly rdsDbInstanceArnSelector?: RdsdbInstanceSpecForProviderRdsDbInstanceArnSelector;

  /**
   * The stack to register a db instance for. Changing this will force a new resource.
   *
   * @schema RdsdbInstanceSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema RdsdbInstanceSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: RdsdbInstanceSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema RdsdbInstanceSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: RdsdbInstanceSpecForProviderStackIdSelector;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecForProvider(obj: RdsdbInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbPasswordSecretRef': toJson_RdsdbInstanceSpecForProviderDbPasswordSecretRef(obj.dbPasswordSecretRef),
    'dbUser': obj.dbUser,
    'rdsDbInstanceArn': obj.rdsDbInstanceArn,
    'rdsDbInstanceArnRef': toJson_RdsdbInstanceSpecForProviderRdsDbInstanceArnRef(obj.rdsDbInstanceArnRef),
    'rdsDbInstanceArnSelector': toJson_RdsdbInstanceSpecForProviderRdsDbInstanceArnSelector(obj.rdsDbInstanceArnSelector),
    'stackId': obj.stackId,
    'stackIdRef': toJson_RdsdbInstanceSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_RdsdbInstanceSpecForProviderStackIdSelector(obj.stackIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RdsdbInstanceSpecManagementPolicy
 */
export enum RdsdbInstanceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RdsdbInstanceSpecProviderConfigRef
 */
export interface RdsdbInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RdsdbInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RdsdbInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: RdsdbInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecProviderConfigRef(obj: RdsdbInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RdsdbInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RdsdbInstanceSpecProviderRef
 */
export interface RdsdbInstanceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RdsdbInstanceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RdsdbInstanceSpecProviderRef#policy
   */
  readonly policy?: RdsdbInstanceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecProviderRef(obj: RdsdbInstanceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RdsdbInstanceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RdsdbInstanceSpecPublishConnectionDetailsTo
 */
export interface RdsdbInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RdsdbInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RdsdbInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RdsdbInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RdsdbInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RdsdbInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecPublishConnectionDetailsTo(obj: RdsdbInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RdsdbInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RdsdbInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RdsdbInstanceSpecWriteConnectionSecretToRef
 */
export interface RdsdbInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RdsdbInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RdsdbInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecWriteConnectionSecretToRef(obj: RdsdbInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A db password
 *
 * @schema RdsdbInstanceSpecForProviderDbPasswordSecretRef
 */
export interface RdsdbInstanceSpecForProviderDbPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema RdsdbInstanceSpecForProviderDbPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema RdsdbInstanceSpecForProviderDbPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RdsdbInstanceSpecForProviderDbPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecForProviderDbPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecForProviderDbPasswordSecretRef(obj: RdsdbInstanceSpecForProviderDbPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in rds to populate rdsDbInstanceArn.
 *
 * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnRef
 */
export interface RdsdbInstanceSpecForProviderRdsDbInstanceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnRef#policy
   */
  readonly policy?: RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicy;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecForProviderRdsDbInstanceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecForProviderRdsDbInstanceArnRef(obj: RdsdbInstanceSpecForProviderRdsDbInstanceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in rds to populate rdsDbInstanceArn.
 *
 * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnSelector
 */
export interface RdsdbInstanceSpecForProviderRdsDbInstanceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnSelector#policy
   */
  readonly policy?: RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicy;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecForProviderRdsDbInstanceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecForProviderRdsDbInstanceArnSelector(obj: RdsdbInstanceSpecForProviderRdsDbInstanceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema RdsdbInstanceSpecForProviderStackIdRef
 */
export interface RdsdbInstanceSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RdsdbInstanceSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RdsdbInstanceSpecForProviderStackIdRef#policy
   */
  readonly policy?: RdsdbInstanceSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecForProviderStackIdRef(obj: RdsdbInstanceSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RdsdbInstanceSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema RdsdbInstanceSpecForProviderStackIdSelector
 */
export interface RdsdbInstanceSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RdsdbInstanceSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RdsdbInstanceSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RdsdbInstanceSpecForProviderStackIdSelector#policy
   */
  readonly policy?: RdsdbInstanceSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecForProviderStackIdSelector(obj: RdsdbInstanceSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RdsdbInstanceSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RdsdbInstanceSpecProviderConfigRefPolicy
 */
export interface RdsdbInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RdsdbInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RdsdbInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RdsdbInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RdsdbInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecProviderConfigRefPolicy(obj: RdsdbInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RdsdbInstanceSpecProviderRefPolicy
 */
export interface RdsdbInstanceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RdsdbInstanceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RdsdbInstanceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RdsdbInstanceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RdsdbInstanceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecProviderRefPolicy(obj: RdsdbInstanceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RdsdbInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface RdsdbInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RdsdbInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RdsdbInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecPublishConnectionDetailsToConfigRef(obj: RdsdbInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RdsdbInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface RdsdbInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RdsdbInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RdsdbInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RdsdbInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecPublishConnectionDetailsToMetadata(obj: RdsdbInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicy
 */
export interface RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicy#resolution
   */
  readonly resolution?: RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicy#resolve
   */
  readonly resolve?: RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicy(obj: RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicy
 */
export interface RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicy#resolution
   */
  readonly resolution?: RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicy#resolve
   */
  readonly resolve?: RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicy(obj: RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RdsdbInstanceSpecForProviderStackIdRefPolicy
 */
export interface RdsdbInstanceSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RdsdbInstanceSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: RdsdbInstanceSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RdsdbInstanceSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: RdsdbInstanceSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecForProviderStackIdRefPolicy(obj: RdsdbInstanceSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RdsdbInstanceSpecForProviderStackIdSelectorPolicy
 */
export interface RdsdbInstanceSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RdsdbInstanceSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: RdsdbInstanceSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RdsdbInstanceSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: RdsdbInstanceSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecForProviderStackIdSelectorPolicy(obj: RdsdbInstanceSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RdsdbInstanceSpecProviderConfigRefPolicyResolution
 */
export enum RdsdbInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RdsdbInstanceSpecProviderConfigRefPolicyResolve
 */
export enum RdsdbInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RdsdbInstanceSpecProviderRefPolicyResolution
 */
export enum RdsdbInstanceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RdsdbInstanceSpecProviderRefPolicyResolve
 */
export enum RdsdbInstanceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicyResolution
 */
export enum RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicyResolve
 */
export enum RdsdbInstanceSpecForProviderRdsDbInstanceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicyResolution
 */
export enum RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicyResolve
 */
export enum RdsdbInstanceSpecForProviderRdsDbInstanceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RdsdbInstanceSpecForProviderStackIdRefPolicyResolution
 */
export enum RdsdbInstanceSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RdsdbInstanceSpecForProviderStackIdRefPolicyResolve
 */
export enum RdsdbInstanceSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RdsdbInstanceSpecForProviderStackIdSelectorPolicyResolution
 */
export enum RdsdbInstanceSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RdsdbInstanceSpecForProviderStackIdSelectorPolicyResolve
 */
export enum RdsdbInstanceSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RdsdbInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Stack is the Schema for the Stacks API. Provides an OpsWorks stack resource.
 *
 * @schema Stack
 */
export class Stack extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stack"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'Stack',
  }

  /**
   * Renders a Kubernetes manifest for "Stack".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StackProps): any {
    return {
      ...Stack.GVK,
      ...toJson_StackProps(props),
    };
  }

  /**
   * Defines a "Stack" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StackProps) {
    super(scope, id, {
      ...Stack.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stack.GVK,
      ...toJson_StackProps(resolved),
    };
  }
}

/**
 * Stack is the Schema for the Stacks API. Provides an OpsWorks stack resource.
 *
 * @schema Stack
 */
export interface StackProps {
  /**
   * @schema Stack#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StackSpec defines the desired state of Stack
   *
   * @schema Stack#spec
   */
  readonly spec: StackSpec;

}

/**
 * Converts an object of type 'StackProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackProps(obj: StackProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StackSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StackSpec defines the desired state of Stack
 *
 * @schema StackSpec
 */
export interface StackSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSpec#deletionPolicy
   */
  readonly deletionPolicy?: StackSpecDeletionPolicy;

  /**
   * @schema StackSpec#forProvider
   */
  readonly forProvider: StackSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSpec#managementPolicy
   */
  readonly managementPolicy?: StackSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StackSpec#providerConfigRef
   */
  readonly providerConfigRef?: StackSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StackSpec#providerRef
   */
  readonly providerRef?: StackSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StackSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StackSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StackSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StackSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StackSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpec(obj: StackSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StackSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_StackSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StackSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StackSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StackSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSpecDeletionPolicy
 */
export enum StackSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StackSpecForProvider
 */
export interface StackSpecForProvider {
  /**
   * If set to "LATEST", OpsWorks will automatically install the latest version.
   *
   * @schema StackSpecForProvider#agentVersion
   */
  readonly agentVersion?: string;

  /**
   * If manage_berkshelf is enabled, the version of Berkshelf to use.
   *
   * @schema StackSpecForProvider#berkshelfVersion
   */
  readonly berkshelfVersion?: string;

  /**
   * Color to paint next to the stack's resources in the OpsWorks console.
   *
   * @schema StackSpecForProvider#color
   */
  readonly color?: string;

  /**
   * Name of the configuration manager to use. Defaults to "Chef".
   *
   * @default Chef".
   * @schema StackSpecForProvider#configurationManagerName
   */
  readonly configurationManagerName?: string;

  /**
   * Version of the configuration manager to use. Defaults to "11.4".
   *
   * @default 11.4".
   * @schema StackSpecForProvider#configurationManagerVersion
   */
  readonly configurationManagerVersion?: string;

  /**
   * When use_custom_cookbooks is set, provide this sub-object as described below.
   *
   * @schema StackSpecForProvider#customCookbooksSource
   */
  readonly customCookbooksSource?: StackSpecForProviderCustomCookbooksSource[];

  /**
   * User defined JSON passed to "Chef". Use a "here doc" for multiline JSON.
   *
   * @schema StackSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * Name of the availability zone where instances will be created by default. Cannot be set when vpc_id is set.
   *
   * @schema StackSpecForProvider#defaultAvailabilityZone
   */
  readonly defaultAvailabilityZone?: string;

  /**
   * The ARN of an IAM Instance Profile that created instances will have by default.
   *
   * @schema StackSpecForProvider#defaultInstanceProfileArn
   */
  readonly defaultInstanceProfileArn?: string;

  /**
   * Reference to a InstanceProfile in iam to populate defaultInstanceProfileArn.
   *
   * @schema StackSpecForProvider#defaultInstanceProfileArnRef
   */
  readonly defaultInstanceProfileArnRef?: StackSpecForProviderDefaultInstanceProfileArnRef;

  /**
   * Selector for a InstanceProfile in iam to populate defaultInstanceProfileArn.
   *
   * @schema StackSpecForProvider#defaultInstanceProfileArnSelector
   */
  readonly defaultInstanceProfileArnSelector?: StackSpecForProviderDefaultInstanceProfileArnSelector;

  /**
   * Name of OS that will be installed on instances by default.
   *
   * @schema StackSpecForProvider#defaultOs
   */
  readonly defaultOs?: string;

  /**
   * Name of the type of root device instances will have by default.
   *
   * @schema StackSpecForProvider#defaultRootDeviceType
   */
  readonly defaultRootDeviceType?: string;

  /**
   * Name of the SSH keypair that instances will have by default.
   *
   * @schema StackSpecForProvider#defaultSshKeyName
   */
  readonly defaultSshKeyName?: string;

  /**
   * ID of the subnet in which instances will be created by default. Required if vpc_id is set to a VPC other than the default VPC, and forbidden if it isn't.
   *
   * @schema StackSpecForProvider#defaultSubnetId
   */
  readonly defaultSubnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate defaultSubnetId.
   *
   * @schema StackSpecForProvider#defaultSubnetIdRef
   */
  readonly defaultSubnetIdRef?: StackSpecForProviderDefaultSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate defaultSubnetId.
   *
   * @schema StackSpecForProvider#defaultSubnetIdSelector
   */
  readonly defaultSubnetIdSelector?: StackSpecForProviderDefaultSubnetIdSelector;

  /**
   * Keyword representing the naming scheme that will be used for instance hostnames within this stack.
   *
   * @schema StackSpecForProvider#hostnameTheme
   */
  readonly hostnameTheme?: string;

  /**
   * Boolean value controlling whether Opsworks will run Berkshelf for this stack.
   *
   * @schema StackSpecForProvider#manageBerkshelf
   */
  readonly manageBerkshelf?: boolean;

  /**
   * The name of the stack.
   *
   * @schema StackSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The name of the region where the stack will exist.
   *
   * @schema StackSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of an IAM role that the OpsWorks service will act as.
   *
   * @schema StackSpecForProvider#serviceRoleArn
   */
  readonly serviceRoleArn?: string;

  /**
   * Reference to a Role in iam to populate serviceRoleArn.
   *
   * @schema StackSpecForProvider#serviceRoleArnRef
   */
  readonly serviceRoleArnRef?: StackSpecForProviderServiceRoleArnRef;

  /**
   * Selector for a Role in iam to populate serviceRoleArn.
   *
   * @schema StackSpecForProvider#serviceRoleArnSelector
   */
  readonly serviceRoleArnSelector?: StackSpecForProviderServiceRoleArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema StackSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Boolean value controlling whether the custom cookbook settings are enabled.
   *
   * @schema StackSpecForProvider#useCustomCookbooks
   */
  readonly useCustomCookbooks?: boolean;

  /**
   * Boolean value controlling whether the standard OpsWorks security groups apply to created instances.
   *
   * @schema StackSpecForProvider#useOpsworksSecurityGroups
   */
  readonly useOpsworksSecurityGroups?: boolean;

  /**
   * ID of the VPC that this stack belongs to. Defaults to the region's default VPC.
   *
   * @default the region's default VPC.
   * @schema StackSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema StackSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: StackSpecForProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema StackSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: StackSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'StackSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProvider(obj: StackSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agentVersion': obj.agentVersion,
    'berkshelfVersion': obj.berkshelfVersion,
    'color': obj.color,
    'configurationManagerName': obj.configurationManagerName,
    'configurationManagerVersion': obj.configurationManagerVersion,
    'customCookbooksSource': obj.customCookbooksSource?.map(y => toJson_StackSpecForProviderCustomCookbooksSource(y)),
    'customJson': obj.customJson,
    'defaultAvailabilityZone': obj.defaultAvailabilityZone,
    'defaultInstanceProfileArn': obj.defaultInstanceProfileArn,
    'defaultInstanceProfileArnRef': toJson_StackSpecForProviderDefaultInstanceProfileArnRef(obj.defaultInstanceProfileArnRef),
    'defaultInstanceProfileArnSelector': toJson_StackSpecForProviderDefaultInstanceProfileArnSelector(obj.defaultInstanceProfileArnSelector),
    'defaultOs': obj.defaultOs,
    'defaultRootDeviceType': obj.defaultRootDeviceType,
    'defaultSshKeyName': obj.defaultSshKeyName,
    'defaultSubnetId': obj.defaultSubnetId,
    'defaultSubnetIdRef': toJson_StackSpecForProviderDefaultSubnetIdRef(obj.defaultSubnetIdRef),
    'defaultSubnetIdSelector': toJson_StackSpecForProviderDefaultSubnetIdSelector(obj.defaultSubnetIdSelector),
    'hostnameTheme': obj.hostnameTheme,
    'manageBerkshelf': obj.manageBerkshelf,
    'name': obj.name,
    'region': obj.region,
    'serviceRoleArn': obj.serviceRoleArn,
    'serviceRoleArnRef': toJson_StackSpecForProviderServiceRoleArnRef(obj.serviceRoleArnRef),
    'serviceRoleArnSelector': toJson_StackSpecForProviderServiceRoleArnSelector(obj.serviceRoleArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useCustomCookbooks': obj.useCustomCookbooks,
    'useOpsworksSecurityGroups': obj.useOpsworksSecurityGroups,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_StackSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_StackSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSpecManagementPolicy
 */
export enum StackSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StackSpecProviderConfigRef
 */
export interface StackSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecProviderConfigRef#policy
   */
  readonly policy?: StackSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderConfigRef(obj: StackSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StackSpecProviderRef
 */
export interface StackSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecProviderRef#policy
   */
  readonly policy?: StackSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StackSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderRef(obj: StackSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StackSpecPublishConnectionDetailsTo
 */
export interface StackSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StackSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StackSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsTo(obj: StackSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StackSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StackSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StackSpecWriteConnectionSecretToRef
 */
export interface StackSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StackSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecWriteConnectionSecretToRef(obj: StackSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSpecForProviderCustomCookbooksSource
 */
export interface StackSpecForProviderCustomCookbooksSource {
  /**
   * Password to use when authenticating to the source.
   *
   * @schema StackSpecForProviderCustomCookbooksSource#passwordSecretRef
   */
  readonly passwordSecretRef?: StackSpecForProviderCustomCookbooksSourcePasswordSecretRef;

  /**
   * For sources that are version-aware, the revision to use.
   *
   * @schema StackSpecForProviderCustomCookbooksSource#revision
   */
  readonly revision?: string;

  /**
   * SSH key to use when authenticating to the source.
   *
   * @schema StackSpecForProviderCustomCookbooksSource#sshKeySecretRef
   */
  readonly sshKeySecretRef?: StackSpecForProviderCustomCookbooksSourceSshKeySecretRef;

  /**
   * The type of source to use. For example, "archive".
   *
   * @schema StackSpecForProviderCustomCookbooksSource#type
   */
  readonly type: string;

  /**
   * The URL where the cookbooks resource can be found.
   *
   * @schema StackSpecForProviderCustomCookbooksSource#url
   */
  readonly url: string;

  /**
   * Username to use when authenticating to the source.
   *
   * @schema StackSpecForProviderCustomCookbooksSource#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'StackSpecForProviderCustomCookbooksSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderCustomCookbooksSource(obj: StackSpecForProviderCustomCookbooksSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretRef': toJson_StackSpecForProviderCustomCookbooksSourcePasswordSecretRef(obj.passwordSecretRef),
    'revision': obj.revision,
    'sshKeySecretRef': toJson_StackSpecForProviderCustomCookbooksSourceSshKeySecretRef(obj.sshKeySecretRef),
    'type': obj.type,
    'url': obj.url,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a InstanceProfile in iam to populate defaultInstanceProfileArn.
 *
 * @schema StackSpecForProviderDefaultInstanceProfileArnRef
 */
export interface StackSpecForProviderDefaultInstanceProfileArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecForProviderDefaultInstanceProfileArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecForProviderDefaultInstanceProfileArnRef#policy
   */
  readonly policy?: StackSpecForProviderDefaultInstanceProfileArnRefPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderDefaultInstanceProfileArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderDefaultInstanceProfileArnRef(obj: StackSpecForProviderDefaultInstanceProfileArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecForProviderDefaultInstanceProfileArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a InstanceProfile in iam to populate defaultInstanceProfileArn.
 *
 * @schema StackSpecForProviderDefaultInstanceProfileArnSelector
 */
export interface StackSpecForProviderDefaultInstanceProfileArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StackSpecForProviderDefaultInstanceProfileArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSpecForProviderDefaultInstanceProfileArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSpecForProviderDefaultInstanceProfileArnSelector#policy
   */
  readonly policy?: StackSpecForProviderDefaultInstanceProfileArnSelectorPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderDefaultInstanceProfileArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderDefaultInstanceProfileArnSelector(obj: StackSpecForProviderDefaultInstanceProfileArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSpecForProviderDefaultInstanceProfileArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate defaultSubnetId.
 *
 * @schema StackSpecForProviderDefaultSubnetIdRef
 */
export interface StackSpecForProviderDefaultSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecForProviderDefaultSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecForProviderDefaultSubnetIdRef#policy
   */
  readonly policy?: StackSpecForProviderDefaultSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderDefaultSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderDefaultSubnetIdRef(obj: StackSpecForProviderDefaultSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecForProviderDefaultSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate defaultSubnetId.
 *
 * @schema StackSpecForProviderDefaultSubnetIdSelector
 */
export interface StackSpecForProviderDefaultSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StackSpecForProviderDefaultSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSpecForProviderDefaultSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSpecForProviderDefaultSubnetIdSelector#policy
   */
  readonly policy?: StackSpecForProviderDefaultSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderDefaultSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderDefaultSubnetIdSelector(obj: StackSpecForProviderDefaultSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSpecForProviderDefaultSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate serviceRoleArn.
 *
 * @schema StackSpecForProviderServiceRoleArnRef
 */
export interface StackSpecForProviderServiceRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecForProviderServiceRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecForProviderServiceRoleArnRef#policy
   */
  readonly policy?: StackSpecForProviderServiceRoleArnRefPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderServiceRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderServiceRoleArnRef(obj: StackSpecForProviderServiceRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecForProviderServiceRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate serviceRoleArn.
 *
 * @schema StackSpecForProviderServiceRoleArnSelector
 */
export interface StackSpecForProviderServiceRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StackSpecForProviderServiceRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSpecForProviderServiceRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSpecForProviderServiceRoleArnSelector#policy
   */
  readonly policy?: StackSpecForProviderServiceRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderServiceRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderServiceRoleArnSelector(obj: StackSpecForProviderServiceRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSpecForProviderServiceRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema StackSpecForProviderVpcIdRef
 */
export interface StackSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecForProviderVpcIdRef#policy
   */
  readonly policy?: StackSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderVpcIdRef(obj: StackSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema StackSpecForProviderVpcIdSelector
 */
export interface StackSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StackSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: StackSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderVpcIdSelector(obj: StackSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecProviderConfigRefPolicy
 */
export interface StackSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StackSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StackSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderConfigRefPolicy(obj: StackSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecProviderRefPolicy
 */
export interface StackSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StackSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StackSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderRefPolicy(obj: StackSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRef
 */
export interface StackSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StackSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToConfigRef(obj: StackSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StackSpecPublishConnectionDetailsToMetadata
 */
export interface StackSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToMetadata(obj: StackSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password to use when authenticating to the source.
 *
 * @schema StackSpecForProviderCustomCookbooksSourcePasswordSecretRef
 */
export interface StackSpecForProviderCustomCookbooksSourcePasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema StackSpecForProviderCustomCookbooksSourcePasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema StackSpecForProviderCustomCookbooksSourcePasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSpecForProviderCustomCookbooksSourcePasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSpecForProviderCustomCookbooksSourcePasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderCustomCookbooksSourcePasswordSecretRef(obj: StackSpecForProviderCustomCookbooksSourcePasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SSH key to use when authenticating to the source.
 *
 * @schema StackSpecForProviderCustomCookbooksSourceSshKeySecretRef
 */
export interface StackSpecForProviderCustomCookbooksSourceSshKeySecretRef {
  /**
   * The key to select.
   *
   * @schema StackSpecForProviderCustomCookbooksSourceSshKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema StackSpecForProviderCustomCookbooksSourceSshKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSpecForProviderCustomCookbooksSourceSshKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSpecForProviderCustomCookbooksSourceSshKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderCustomCookbooksSourceSshKeySecretRef(obj: StackSpecForProviderCustomCookbooksSourceSshKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecForProviderDefaultInstanceProfileArnRefPolicy
 */
export interface StackSpecForProviderDefaultInstanceProfileArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderDefaultInstanceProfileArnRefPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderDefaultInstanceProfileArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecForProviderDefaultInstanceProfileArnRefPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderDefaultInstanceProfileArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderDefaultInstanceProfileArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderDefaultInstanceProfileArnRefPolicy(obj: StackSpecForProviderDefaultInstanceProfileArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSpecForProviderDefaultInstanceProfileArnSelectorPolicy
 */
export interface StackSpecForProviderDefaultInstanceProfileArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderDefaultInstanceProfileArnSelectorPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderDefaultInstanceProfileArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecForProviderDefaultInstanceProfileArnSelectorPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderDefaultInstanceProfileArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderDefaultInstanceProfileArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderDefaultInstanceProfileArnSelectorPolicy(obj: StackSpecForProviderDefaultInstanceProfileArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecForProviderDefaultSubnetIdRefPolicy
 */
export interface StackSpecForProviderDefaultSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderDefaultSubnetIdRefPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderDefaultSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecForProviderDefaultSubnetIdRefPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderDefaultSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderDefaultSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderDefaultSubnetIdRefPolicy(obj: StackSpecForProviderDefaultSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSpecForProviderDefaultSubnetIdSelectorPolicy
 */
export interface StackSpecForProviderDefaultSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderDefaultSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderDefaultSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecForProviderDefaultSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderDefaultSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderDefaultSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderDefaultSubnetIdSelectorPolicy(obj: StackSpecForProviderDefaultSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecForProviderServiceRoleArnRefPolicy
 */
export interface StackSpecForProviderServiceRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderServiceRoleArnRefPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderServiceRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecForProviderServiceRoleArnRefPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderServiceRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderServiceRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderServiceRoleArnRefPolicy(obj: StackSpecForProviderServiceRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSpecForProviderServiceRoleArnSelectorPolicy
 */
export interface StackSpecForProviderServiceRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderServiceRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderServiceRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecForProviderServiceRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderServiceRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderServiceRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderServiceRoleArnSelectorPolicy(obj: StackSpecForProviderServiceRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecForProviderVpcIdRefPolicy
 */
export interface StackSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderVpcIdRefPolicy(obj: StackSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSpecForProviderVpcIdSelectorPolicy
 */
export interface StackSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderVpcIdSelectorPolicy(obj: StackSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecProviderConfigRefPolicyResolution
 */
export enum StackSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecProviderConfigRefPolicyResolve
 */
export enum StackSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecProviderRefPolicyResolution
 */
export enum StackSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecProviderRefPolicyResolve
 */
export enum StackSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StackSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StackSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StackSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToConfigRefPolicy(obj: StackSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderDefaultInstanceProfileArnRefPolicyResolution
 */
export enum StackSpecForProviderDefaultInstanceProfileArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecForProviderDefaultInstanceProfileArnRefPolicyResolve
 */
export enum StackSpecForProviderDefaultInstanceProfileArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderDefaultInstanceProfileArnSelectorPolicyResolution
 */
export enum StackSpecForProviderDefaultInstanceProfileArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecForProviderDefaultInstanceProfileArnSelectorPolicyResolve
 */
export enum StackSpecForProviderDefaultInstanceProfileArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderDefaultSubnetIdRefPolicyResolution
 */
export enum StackSpecForProviderDefaultSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecForProviderDefaultSubnetIdRefPolicyResolve
 */
export enum StackSpecForProviderDefaultSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderDefaultSubnetIdSelectorPolicyResolution
 */
export enum StackSpecForProviderDefaultSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecForProviderDefaultSubnetIdSelectorPolicyResolve
 */
export enum StackSpecForProviderDefaultSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderServiceRoleArnRefPolicyResolution
 */
export enum StackSpecForProviderServiceRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecForProviderServiceRoleArnRefPolicyResolve
 */
export enum StackSpecForProviderServiceRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderServiceRoleArnSelectorPolicyResolution
 */
export enum StackSpecForProviderServiceRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecForProviderServiceRoleArnSelectorPolicyResolve
 */
export enum StackSpecForProviderServiceRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderVpcIdRefPolicyResolution
 */
export enum StackSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecForProviderVpcIdRefPolicyResolve
 */
export enum StackSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum StackSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum StackSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StackSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StackSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StaticWebLayer is the Schema for the StaticWebLayers API. Provides an OpsWorks static web server layer resource.
 *
 * @schema StaticWebLayer
 */
export class StaticWebLayer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StaticWebLayer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'StaticWebLayer',
  }

  /**
   * Renders a Kubernetes manifest for "StaticWebLayer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StaticWebLayerProps): any {
    return {
      ...StaticWebLayer.GVK,
      ...toJson_StaticWebLayerProps(props),
    };
  }

  /**
   * Defines a "StaticWebLayer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StaticWebLayerProps) {
    super(scope, id, {
      ...StaticWebLayer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StaticWebLayer.GVK,
      ...toJson_StaticWebLayerProps(resolved),
    };
  }
}

/**
 * StaticWebLayer is the Schema for the StaticWebLayers API. Provides an OpsWorks static web server layer resource.
 *
 * @schema StaticWebLayer
 */
export interface StaticWebLayerProps {
  /**
   * @schema StaticWebLayer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StaticWebLayerSpec defines the desired state of StaticWebLayer
   *
   * @schema StaticWebLayer#spec
   */
  readonly spec: StaticWebLayerSpec;

}

/**
 * Converts an object of type 'StaticWebLayerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerProps(obj: StaticWebLayerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StaticWebLayerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StaticWebLayerSpec defines the desired state of StaticWebLayer
 *
 * @schema StaticWebLayerSpec
 */
export interface StaticWebLayerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StaticWebLayerSpec#deletionPolicy
   */
  readonly deletionPolicy?: StaticWebLayerSpecDeletionPolicy;

  /**
   * @schema StaticWebLayerSpec#forProvider
   */
  readonly forProvider: StaticWebLayerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StaticWebLayerSpec#managementPolicy
   */
  readonly managementPolicy?: StaticWebLayerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StaticWebLayerSpec#providerConfigRef
   */
  readonly providerConfigRef?: StaticWebLayerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StaticWebLayerSpec#providerRef
   */
  readonly providerRef?: StaticWebLayerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StaticWebLayerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StaticWebLayerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StaticWebLayerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StaticWebLayerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StaticWebLayerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpec(obj: StaticWebLayerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StaticWebLayerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_StaticWebLayerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StaticWebLayerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StaticWebLayerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StaticWebLayerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StaticWebLayerSpecDeletionPolicy
 */
export enum StaticWebLayerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StaticWebLayerSpecForProvider
 */
export interface StaticWebLayerSpecForProvider {
  /**
   * Whether to automatically assign an elastic IP address to the layer's instances.
   *
   * @schema StaticWebLayerSpecForProvider#autoAssignElasticIps
   */
  readonly autoAssignElasticIps?: boolean;

  /**
   * For stacks belonging to a VPC, whether to automatically assign a public IP address to each of the layer's instances.
   *
   * @schema StaticWebLayerSpecForProvider#autoAssignPublicIps
   */
  readonly autoAssignPublicIps?: boolean;

  /**
   * Whether to enable auto-healing for the layer.
   *
   * @schema StaticWebLayerSpecForProvider#autoHealing
   */
  readonly autoHealing?: boolean;

  /**
   * @schema StaticWebLayerSpecForProvider#cloudwatchConfiguration
   */
  readonly cloudwatchConfiguration?: StaticWebLayerSpecForProviderCloudwatchConfiguration[];

  /**
   * @schema StaticWebLayerSpecForProvider#customConfigureRecipes
   */
  readonly customConfigureRecipes?: string[];

  /**
   * @schema StaticWebLayerSpecForProvider#customDeployRecipes
   */
  readonly customDeployRecipes?: string[];

  /**
   * The ARN of an IAM profile that will be used for the layer's instances.
   *
   * @schema StaticWebLayerSpecForProvider#customInstanceProfileArn
   */
  readonly customInstanceProfileArn?: string;

  /**
   * @schema StaticWebLayerSpecForProvider#customJson
   */
  readonly customJson?: string;

  /**
   * References to SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema StaticWebLayerSpecForProvider#customSecurityGroupIdRefs
   */
  readonly customSecurityGroupIdRefs?: StaticWebLayerSpecForProviderCustomSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
   *
   * @schema StaticWebLayerSpecForProvider#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: StaticWebLayerSpecForProviderCustomSecurityGroupIdSelector;

  /**
   * Ids for a set of security groups to apply to the layer's instances.
   *
   * @schema StaticWebLayerSpecForProvider#customSecurityGroupIds
   */
  readonly customSecurityGroupIds?: string[];

  /**
   * @schema StaticWebLayerSpecForProvider#customSetupRecipes
   */
  readonly customSetupRecipes?: string[];

  /**
   * @schema StaticWebLayerSpecForProvider#customShutdownRecipes
   */
  readonly customShutdownRecipes?: string[];

  /**
   * @schema StaticWebLayerSpecForProvider#customUndeployRecipes
   */
  readonly customUndeployRecipes?: string[];

  /**
   * Whether to enable Elastic Load Balancing connection draining.
   *
   * @schema StaticWebLayerSpecForProvider#drainElbOnShutdown
   */
  readonly drainElbOnShutdown?: boolean;

  /**
   * ebs_volume blocks, as described below, will each create an EBS volume and connect it to the layer's instances.
   *
   * @schema StaticWebLayerSpecForProvider#ebsVolume
   */
  readonly ebsVolume?: StaticWebLayerSpecForProviderEbsVolume[];

  /**
   * Name of an Elastic Load Balancer to attach to this layer
   *
   * @schema StaticWebLayerSpecForProvider#elasticLoadBalancer
   */
  readonly elasticLoadBalancer?: string;

  /**
   * Whether to install OS and package updates on each instance when it boots.
   *
   * @schema StaticWebLayerSpecForProvider#installUpdatesOnBoot
   */
  readonly installUpdatesOnBoot?: boolean;

  /**
   * The time, in seconds, that OpsWorks will wait for Chef to complete after triggering the Shutdown event.
   *
   * @schema StaticWebLayerSpecForProvider#instanceShutdownTimeout
   */
  readonly instanceShutdownTimeout?: number;

  /**
   * @schema StaticWebLayerSpecForProvider#loadBasedAutoScaling
   */
  readonly loadBasedAutoScaling?: StaticWebLayerSpecForProviderLoadBasedAutoScaling[];

  /**
   * A human-readable name for the layer.
   *
   * @schema StaticWebLayerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * ID of the stack the layer will belong to.
   *
   * @schema StaticWebLayerSpecForProvider#stackId
   */
  readonly stackId?: string;

  /**
   * Reference to a Stack in opsworks to populate stackId.
   *
   * @schema StaticWebLayerSpecForProvider#stackIdRef
   */
  readonly stackIdRef?: StaticWebLayerSpecForProviderStackIdRef;

  /**
   * Selector for a Stack in opsworks to populate stackId.
   *
   * @schema StaticWebLayerSpecForProvider#stackIdSelector
   */
  readonly stackIdSelector?: StaticWebLayerSpecForProviderStackIdSelector;

  /**
   * Names of a set of system packages to install on the layer's instances.
   *
   * @schema StaticWebLayerSpecForProvider#systemPackages
   */
  readonly systemPackages?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema StaticWebLayerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether to use EBS-optimized instances.
   *
   * @schema StaticWebLayerSpecForProvider#useEbsOptimizedInstances
   */
  readonly useEbsOptimizedInstances?: boolean;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProvider(obj: StaticWebLayerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoAssignElasticIps': obj.autoAssignElasticIps,
    'autoAssignPublicIps': obj.autoAssignPublicIps,
    'autoHealing': obj.autoHealing,
    'cloudwatchConfiguration': obj.cloudwatchConfiguration?.map(y => toJson_StaticWebLayerSpecForProviderCloudwatchConfiguration(y)),
    'customConfigureRecipes': obj.customConfigureRecipes?.map(y => y),
    'customDeployRecipes': obj.customDeployRecipes?.map(y => y),
    'customInstanceProfileArn': obj.customInstanceProfileArn,
    'customJson': obj.customJson,
    'customSecurityGroupIdRefs': obj.customSecurityGroupIdRefs?.map(y => toJson_StaticWebLayerSpecForProviderCustomSecurityGroupIdRefs(y)),
    'customSecurityGroupIdSelector': toJson_StaticWebLayerSpecForProviderCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'customSecurityGroupIds': obj.customSecurityGroupIds?.map(y => y),
    'customSetupRecipes': obj.customSetupRecipes?.map(y => y),
    'customShutdownRecipes': obj.customShutdownRecipes?.map(y => y),
    'customUndeployRecipes': obj.customUndeployRecipes?.map(y => y),
    'drainElbOnShutdown': obj.drainElbOnShutdown,
    'ebsVolume': obj.ebsVolume?.map(y => toJson_StaticWebLayerSpecForProviderEbsVolume(y)),
    'elasticLoadBalancer': obj.elasticLoadBalancer,
    'installUpdatesOnBoot': obj.installUpdatesOnBoot,
    'instanceShutdownTimeout': obj.instanceShutdownTimeout,
    'loadBasedAutoScaling': obj.loadBasedAutoScaling?.map(y => toJson_StaticWebLayerSpecForProviderLoadBasedAutoScaling(y)),
    'name': obj.name,
    'stackId': obj.stackId,
    'stackIdRef': toJson_StaticWebLayerSpecForProviderStackIdRef(obj.stackIdRef),
    'stackIdSelector': toJson_StaticWebLayerSpecForProviderStackIdSelector(obj.stackIdSelector),
    'systemPackages': obj.systemPackages?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useEbsOptimizedInstances': obj.useEbsOptimizedInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StaticWebLayerSpecManagementPolicy
 */
export enum StaticWebLayerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StaticWebLayerSpecProviderConfigRef
 */
export interface StaticWebLayerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StaticWebLayerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StaticWebLayerSpecProviderConfigRef#policy
   */
  readonly policy?: StaticWebLayerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StaticWebLayerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecProviderConfigRef(obj: StaticWebLayerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StaticWebLayerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StaticWebLayerSpecProviderRef
 */
export interface StaticWebLayerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StaticWebLayerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StaticWebLayerSpecProviderRef#policy
   */
  readonly policy?: StaticWebLayerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StaticWebLayerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecProviderRef(obj: StaticWebLayerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StaticWebLayerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StaticWebLayerSpecPublishConnectionDetailsTo
 */
export interface StaticWebLayerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StaticWebLayerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StaticWebLayerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StaticWebLayerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StaticWebLayerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StaticWebLayerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StaticWebLayerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecPublishConnectionDetailsTo(obj: StaticWebLayerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StaticWebLayerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StaticWebLayerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StaticWebLayerSpecWriteConnectionSecretToRef
 */
export interface StaticWebLayerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StaticWebLayerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StaticWebLayerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StaticWebLayerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecWriteConnectionSecretToRef(obj: StaticWebLayerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StaticWebLayerSpecForProviderCloudwatchConfiguration
 */
export interface StaticWebLayerSpecForProviderCloudwatchConfiguration {
  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfiguration#logStreams
   */
  readonly logStreams?: StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams[];

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderCloudwatchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderCloudwatchConfiguration(obj: StaticWebLayerSpecForProviderCloudwatchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logStreams': obj.logStreams?.map(y => toJson_StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdRefs
 */
export interface StaticWebLayerSpecForProviderCustomSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdRefs#policy
   */
  readonly policy?: StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderCustomSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderCustomSecurityGroupIdRefs(obj: StaticWebLayerSpecForProviderCustomSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate customSecurityGroupIds.
 *
 * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdSelector
 */
export interface StaticWebLayerSpecForProviderCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderCustomSecurityGroupIdSelector(obj: StaticWebLayerSpecForProviderCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StaticWebLayerSpecForProviderEbsVolume
 */
export interface StaticWebLayerSpecForProviderEbsVolume {
  /**
   * @schema StaticWebLayerSpecForProviderEbsVolume#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * For PIOPS volumes, the IOPS per disk.
   *
   * @schema StaticWebLayerSpecForProviderEbsVolume#iops
   */
  readonly iops?: number;

  /**
   * The path to mount the EBS volume on the layer's instances.
   *
   * @schema StaticWebLayerSpecForProviderEbsVolume#mountPoint
   */
  readonly mountPoint: string;

  /**
   * The number of disks to use for the EBS volume.
   *
   * @schema StaticWebLayerSpecForProviderEbsVolume#numberOfDisks
   */
  readonly numberOfDisks: number;

  /**
   * The RAID level to use for the volume.
   *
   * @schema StaticWebLayerSpecForProviderEbsVolume#raidLevel
   */
  readonly raidLevel?: string;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema StaticWebLayerSpecForProviderEbsVolume#size
   */
  readonly size: number;

  /**
   * The type of volume to create. This may be standard (the default), io1 or gp2.
   *
   * @schema StaticWebLayerSpecForProviderEbsVolume#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderEbsVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderEbsVolume(obj: StaticWebLayerSpecForProviderEbsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'mountPoint': obj.mountPoint,
    'numberOfDisks': obj.numberOfDisks,
    'raidLevel': obj.raidLevel,
    'size': obj.size,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StaticWebLayerSpecForProviderLoadBasedAutoScaling
 */
export interface StaticWebLayerSpecForProviderLoadBasedAutoScaling {
  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScaling#downscaling
   */
  readonly downscaling?: StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling[];

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScaling#enable
   */
  readonly enable?: boolean;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScaling#upscaling
   */
  readonly upscaling?: StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling[];

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderLoadBasedAutoScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderLoadBasedAutoScaling(obj: StaticWebLayerSpecForProviderLoadBasedAutoScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downscaling': obj.downscaling?.map(y => toJson_StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling(y)),
    'enable': obj.enable,
    'upscaling': obj.upscaling?.map(y => toJson_StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in opsworks to populate stackId.
 *
 * @schema StaticWebLayerSpecForProviderStackIdRef
 */
export interface StaticWebLayerSpecForProviderStackIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StaticWebLayerSpecForProviderStackIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StaticWebLayerSpecForProviderStackIdRef#policy
   */
  readonly policy?: StaticWebLayerSpecForProviderStackIdRefPolicy;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderStackIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderStackIdRef(obj: StaticWebLayerSpecForProviderStackIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StaticWebLayerSpecForProviderStackIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in opsworks to populate stackId.
 *
 * @schema StaticWebLayerSpecForProviderStackIdSelector
 */
export interface StaticWebLayerSpecForProviderStackIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StaticWebLayerSpecForProviderStackIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StaticWebLayerSpecForProviderStackIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StaticWebLayerSpecForProviderStackIdSelector#policy
   */
  readonly policy?: StaticWebLayerSpecForProviderStackIdSelectorPolicy;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderStackIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderStackIdSelector(obj: StaticWebLayerSpecForProviderStackIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StaticWebLayerSpecForProviderStackIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StaticWebLayerSpecProviderConfigRefPolicy
 */
export interface StaticWebLayerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StaticWebLayerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StaticWebLayerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StaticWebLayerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StaticWebLayerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StaticWebLayerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecProviderConfigRefPolicy(obj: StaticWebLayerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StaticWebLayerSpecProviderRefPolicy
 */
export interface StaticWebLayerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StaticWebLayerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StaticWebLayerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StaticWebLayerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StaticWebLayerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StaticWebLayerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecProviderRefPolicy(obj: StaticWebLayerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StaticWebLayerSpecPublishConnectionDetailsToConfigRef
 */
export interface StaticWebLayerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StaticWebLayerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StaticWebLayerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StaticWebLayerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecPublishConnectionDetailsToConfigRef(obj: StaticWebLayerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StaticWebLayerSpecPublishConnectionDetailsToMetadata
 */
export interface StaticWebLayerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StaticWebLayerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StaticWebLayerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StaticWebLayerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StaticWebLayerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecPublishConnectionDetailsToMetadata(obj: StaticWebLayerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams
 */
export interface StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams {
  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#batchCount
   */
  readonly batchCount?: number;

  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#bufferDuration
   */
  readonly bufferDuration?: number;

  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#datetimeFormat
   */
  readonly datetimeFormat?: string;

  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#encoding
   */
  readonly encoding?: string;

  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#file
   */
  readonly file: string;

  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#fileFingerprintLines
   */
  readonly fileFingerprintLines?: string;

  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#initialPosition
   */
  readonly initialPosition?: string;

  /**
   * A human-readable name for the layer.
   *
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#logGroupName
   */
  readonly logGroupName: string;

  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#multilineStartPattern
   */
  readonly multilineStartPattern?: string;

  /**
   * @schema StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams(obj: StaticWebLayerSpecForProviderCloudwatchConfigurationLogStreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchCount': obj.batchCount,
    'batchSize': obj.batchSize,
    'bufferDuration': obj.bufferDuration,
    'datetimeFormat': obj.datetimeFormat,
    'encoding': obj.encoding,
    'file': obj.file,
    'fileFingerprintLines': obj.fileFingerprintLines,
    'initialPosition': obj.initialPosition,
    'logGroupName': obj.logGroupName,
    'multilineStartPattern': obj.multilineStartPattern,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicy
 */
export interface StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicy(obj: StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy
 */
export interface StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy(obj: StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling
 */
export interface StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling {
  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling(obj: StaticWebLayerSpecForProviderLoadBasedAutoScalingDownscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling
 */
export interface StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling {
  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling#alarms
   */
  readonly alarms?: string[];

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling#cpuThreshold
   */
  readonly cpuThreshold?: number;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling#ignoreMetricsTime
   */
  readonly ignoreMetricsTime?: number;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling#loadThreshold
   */
  readonly loadThreshold?: number;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling#memoryThreshold
   */
  readonly memoryThreshold?: number;

  /**
   * @schema StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling#thresholdsWaitTime
   */
  readonly thresholdsWaitTime?: number;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling(obj: StaticWebLayerSpecForProviderLoadBasedAutoScalingUpscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'cpuThreshold': obj.cpuThreshold,
    'ignoreMetricsTime': obj.ignoreMetricsTime,
    'instanceCount': obj.instanceCount,
    'loadThreshold': obj.loadThreshold,
    'memoryThreshold': obj.memoryThreshold,
    'thresholdsWaitTime': obj.thresholdsWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StaticWebLayerSpecForProviderStackIdRefPolicy
 */
export interface StaticWebLayerSpecForProviderStackIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StaticWebLayerSpecForProviderStackIdRefPolicy#resolution
   */
  readonly resolution?: StaticWebLayerSpecForProviderStackIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StaticWebLayerSpecForProviderStackIdRefPolicy#resolve
   */
  readonly resolve?: StaticWebLayerSpecForProviderStackIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderStackIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderStackIdRefPolicy(obj: StaticWebLayerSpecForProviderStackIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StaticWebLayerSpecForProviderStackIdSelectorPolicy
 */
export interface StaticWebLayerSpecForProviderStackIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StaticWebLayerSpecForProviderStackIdSelectorPolicy#resolution
   */
  readonly resolution?: StaticWebLayerSpecForProviderStackIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StaticWebLayerSpecForProviderStackIdSelectorPolicy#resolve
   */
  readonly resolve?: StaticWebLayerSpecForProviderStackIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StaticWebLayerSpecForProviderStackIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecForProviderStackIdSelectorPolicy(obj: StaticWebLayerSpecForProviderStackIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StaticWebLayerSpecProviderConfigRefPolicyResolution
 */
export enum StaticWebLayerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StaticWebLayerSpecProviderConfigRefPolicyResolve
 */
export enum StaticWebLayerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StaticWebLayerSpecProviderRefPolicyResolution
 */
export enum StaticWebLayerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StaticWebLayerSpecProviderRefPolicyResolve
 */
export enum StaticWebLayerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicy(obj: StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution
 */
export enum StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve
 */
export enum StaticWebLayerSpecForProviderCustomSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum StaticWebLayerSpecForProviderCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StaticWebLayerSpecForProviderStackIdRefPolicyResolution
 */
export enum StaticWebLayerSpecForProviderStackIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StaticWebLayerSpecForProviderStackIdRefPolicyResolve
 */
export enum StaticWebLayerSpecForProviderStackIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StaticWebLayerSpecForProviderStackIdSelectorPolicyResolution
 */
export enum StaticWebLayerSpecForProviderStackIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StaticWebLayerSpecForProviderStackIdSelectorPolicyResolve
 */
export enum StaticWebLayerSpecForProviderStackIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StaticWebLayerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserProfile is the Schema for the UserProfiles API. Provides an OpsWorks User Profile resource.
 *
 * @schema UserProfile
 */
export class UserProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opsworks.aws.upbound.io/v1beta1',
    kind: 'UserProfile',
  }

  /**
   * Renders a Kubernetes manifest for "UserProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserProfileProps): any {
    return {
      ...UserProfile.GVK,
      ...toJson_UserProfileProps(props),
    };
  }

  /**
   * Defines a "UserProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserProfileProps) {
    super(scope, id, {
      ...UserProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserProfile.GVK,
      ...toJson_UserProfileProps(resolved),
    };
  }
}

/**
 * UserProfile is the Schema for the UserProfiles API. Provides an OpsWorks User Profile resource.
 *
 * @schema UserProfile
 */
export interface UserProfileProps {
  /**
   * @schema UserProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserProfileSpec defines the desired state of UserProfile
   *
   * @schema UserProfile#spec
   */
  readonly spec: UserProfileSpec;

}

/**
 * Converts an object of type 'UserProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileProps(obj: UserProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserProfileSpec defines the desired state of UserProfile
 *
 * @schema UserProfileSpec
 */
export interface UserProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserProfileSpecDeletionPolicy;

  /**
   * @schema UserProfileSpec#forProvider
   */
  readonly forProvider: UserProfileSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserProfileSpec#managementPolicy
   */
  readonly managementPolicy?: UserProfileSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserProfileSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserProfileSpec#providerRef
   */
  readonly providerRef?: UserProfileSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpec(obj: UserProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserProfileSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_UserProfileSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserProfileSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserProfileSpecDeletionPolicy
 */
export enum UserProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserProfileSpecForProvider
 */
export interface UserProfileSpecForProvider {
  /**
   * Whether users can specify their own SSH public key through the My Settings page
   *
   * @schema UserProfileSpecForProvider#allowSelfManagement
   */
  readonly allowSelfManagement?: boolean;

  /**
   * The users public key
   *
   * @schema UserProfileSpecForProvider#sshPublicKey
   */
  readonly sshPublicKey?: string;

  /**
   * The ssh username, with witch this user wants to log in
   *
   * @schema UserProfileSpecForProvider#sshUsername
   */
  readonly sshUsername?: string;

  /**
   * The user's IAM ARN
   *
   * @schema UserProfileSpecForProvider#userArn
   */
  readonly userArn?: string;

  /**
   * Reference to a User in iam to populate userArn.
   *
   * @schema UserProfileSpecForProvider#userArnRef
   */
  readonly userArnRef?: UserProfileSpecForProviderUserArnRef;

  /**
   * Selector for a User in iam to populate userArn.
   *
   * @schema UserProfileSpecForProvider#userArnSelector
   */
  readonly userArnSelector?: UserProfileSpecForProviderUserArnSelector;

}

/**
 * Converts an object of type 'UserProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProvider(obj: UserProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSelfManagement': obj.allowSelfManagement,
    'sshPublicKey': obj.sshPublicKey,
    'sshUsername': obj.sshUsername,
    'userArn': obj.userArn,
    'userArnRef': toJson_UserProfileSpecForProviderUserArnRef(obj.userArnRef),
    'userArnSelector': toJson_UserProfileSpecForProviderUserArnSelector(obj.userArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserProfileSpecManagementPolicy
 */
export enum UserProfileSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserProfileSpecProviderConfigRef
 */
export interface UserProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserProfileSpecProviderConfigRef#policy
   */
  readonly policy?: UserProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecProviderConfigRef(obj: UserProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserProfileSpecProviderRef
 */
export interface UserProfileSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserProfileSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserProfileSpecProviderRef#policy
   */
  readonly policy?: UserProfileSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserProfileSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecProviderRef(obj: UserProfileSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserProfileSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserProfileSpecPublishConnectionDetailsTo
 */
export interface UserProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecPublishConnectionDetailsTo(obj: UserProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserProfileSpecWriteConnectionSecretToRef
 */
export interface UserProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecWriteConnectionSecretToRef(obj: UserProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in iam to populate userArn.
 *
 * @schema UserProfileSpecForProviderUserArnRef
 */
export interface UserProfileSpecForProviderUserArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserProfileSpecForProviderUserArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserProfileSpecForProviderUserArnRef#policy
   */
  readonly policy?: UserProfileSpecForProviderUserArnRefPolicy;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserArnRef(obj: UserProfileSpecForProviderUserArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserProfileSpecForProviderUserArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in iam to populate userArn.
 *
 * @schema UserProfileSpecForProviderUserArnSelector
 */
export interface UserProfileSpecForProviderUserArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserProfileSpecForProviderUserArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserProfileSpecForProviderUserArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserProfileSpecForProviderUserArnSelector#policy
   */
  readonly policy?: UserProfileSpecForProviderUserArnSelectorPolicy;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserArnSelector(obj: UserProfileSpecForProviderUserArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserProfileSpecForProviderUserArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserProfileSpecProviderConfigRefPolicy
 */
export interface UserProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecProviderConfigRefPolicy(obj: UserProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserProfileSpecProviderRefPolicy
 */
export interface UserProfileSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserProfileSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserProfileSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserProfileSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserProfileSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserProfileSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecProviderRefPolicy(obj: UserProfileSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface UserProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecPublishConnectionDetailsToConfigRef(obj: UserProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserProfileSpecPublishConnectionDetailsToMetadata
 */
export interface UserProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecPublishConnectionDetailsToMetadata(obj: UserProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserProfileSpecForProviderUserArnRefPolicy
 */
export interface UserProfileSpecForProviderUserArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserProfileSpecForProviderUserArnRefPolicy#resolution
   */
  readonly resolution?: UserProfileSpecForProviderUserArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserProfileSpecForProviderUserArnRefPolicy#resolve
   */
  readonly resolve?: UserProfileSpecForProviderUserArnRefPolicyResolve;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserArnRefPolicy(obj: UserProfileSpecForProviderUserArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserProfileSpecForProviderUserArnSelectorPolicy
 */
export interface UserProfileSpecForProviderUserArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserProfileSpecForProviderUserArnSelectorPolicy#resolution
   */
  readonly resolution?: UserProfileSpecForProviderUserArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserProfileSpecForProviderUserArnSelectorPolicy#resolve
   */
  readonly resolve?: UserProfileSpecForProviderUserArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserArnSelectorPolicy(obj: UserProfileSpecForProviderUserArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserProfileSpecProviderConfigRefPolicyResolution
 */
export enum UserProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserProfileSpecProviderConfigRefPolicyResolve
 */
export enum UserProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserProfileSpecProviderRefPolicyResolution
 */
export enum UserProfileSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserProfileSpecProviderRefPolicyResolve
 */
export enum UserProfileSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserProfileSpecForProviderUserArnRefPolicyResolution
 */
export enum UserProfileSpecForProviderUserArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserProfileSpecForProviderUserArnRefPolicyResolve
 */
export enum UserProfileSpecForProviderUserArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserProfileSpecForProviderUserArnSelectorPolicyResolution
 */
export enum UserProfileSpecForProviderUserArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserProfileSpecForProviderUserArnSelectorPolicyResolve
 */
export enum UserProfileSpecForProviderUserArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

