// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Channel is the Schema for the Channels API.
 *
 * @schema Channel
 */
export class Channel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Channel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'medialive.aws.upbound.io/v1beta1',
    kind: 'Channel',
  }

  /**
   * Renders a Kubernetes manifest for "Channel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ChannelProps): any {
    return {
      ...Channel.GVK,
      ...toJson_ChannelProps(props),
    };
  }

  /**
   * Defines a "Channel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ChannelProps) {
    super(scope, id, {
      ...Channel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Channel.GVK,
      ...toJson_ChannelProps(resolved),
    };
  }
}

/**
 * Channel is the Schema for the Channels API.
 *
 * @schema Channel
 */
export interface ChannelProps {
  /**
   * @schema Channel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ChannelSpec defines the desired state of Channel
   *
   * @schema Channel#spec
   */
  readonly spec: ChannelSpec;

}

/**
 * Converts an object of type 'ChannelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelProps(obj: ChannelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ChannelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ChannelSpec defines the desired state of Channel
 *
 * @schema ChannelSpec
 */
export interface ChannelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ChannelSpec#deletionPolicy
   */
  readonly deletionPolicy?: ChannelSpecDeletionPolicy;

  /**
   * @schema ChannelSpec#forProvider
   */
  readonly forProvider: ChannelSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ChannelSpec#managementPolicy
   */
  readonly managementPolicy?: ChannelSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ChannelSpec#providerConfigRef
   */
  readonly providerConfigRef?: ChannelSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ChannelSpec#providerRef
   */
  readonly providerRef?: ChannelSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ChannelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ChannelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ChannelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ChannelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ChannelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpec(obj: ChannelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ChannelSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ChannelSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ChannelSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ChannelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ChannelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ChannelSpecDeletionPolicy
 */
export enum ChannelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ChannelSpecForProvider
 */
export interface ChannelSpecForProvider {
  /**
   * Specification of CDI inputs for this channel. See CDI Input Specification for more details.
   *
   * @schema ChannelSpecForProvider#cdiInputSpecification
   */
  readonly cdiInputSpecification?: ChannelSpecForProviderCdiInputSpecification[];

  /**
   * Concise argument description.
   *
   * @schema ChannelSpecForProvider#channelClass
   */
  readonly channelClass?: string;

  /**
   * Destinations for channel. See Destinations for more details.
   *
   * @schema ChannelSpecForProvider#destinations
   */
  readonly destinations?: ChannelSpecForProviderDestinations[];

  /**
   * Encoder settings. See Encoder Settings for more details.
   *
   * @schema ChannelSpecForProvider#encoderSettings
   */
  readonly encoderSettings?: ChannelSpecForProviderEncoderSettings[];

  /**
   * Input attachments for the channel. See Input Attachments for more details.
   *
   * @schema ChannelSpecForProvider#inputAttachments
   */
  readonly inputAttachments?: ChannelSpecForProviderInputAttachments[];

  /**
   * Specification of network and file inputs for the channel.
   *
   * @schema ChannelSpecForProvider#inputSpecification
   */
  readonly inputSpecification?: ChannelSpecForProviderInputSpecification[];

  /**
   * The log level to write to Cloudwatch logs.
   *
   * @schema ChannelSpecForProvider#logLevel
   */
  readonly logLevel?: string;

  /**
   * Maintenance settings for this channel. See Maintenance for more details.
   *
   * @schema ChannelSpecForProvider#maintenance
   */
  readonly maintenance?: ChannelSpecForProviderMaintenance[];

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ChannelSpecForProvider#region
   */
  readonly region: string;

  /**
   * Concise argument description.
   *
   * @schema ChannelSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ChannelSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ChannelSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ChannelSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ChannelSpecForProviderRoleArnSelector;

  /**
   * Whether to start/stop channel. Default: false
   *
   * @schema ChannelSpecForProvider#startChannel
   */
  readonly startChannel?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ChannelSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Settings for the VPC outputs.
   *
   * @schema ChannelSpecForProvider#vpc
   */
  readonly vpc?: ChannelSpecForProviderVpc[];

}

/**
 * Converts an object of type 'ChannelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProvider(obj: ChannelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cdiInputSpecification': obj.cdiInputSpecification?.map(y => toJson_ChannelSpecForProviderCdiInputSpecification(y)),
    'channelClass': obj.channelClass,
    'destinations': obj.destinations?.map(y => toJson_ChannelSpecForProviderDestinations(y)),
    'encoderSettings': obj.encoderSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettings(y)),
    'inputAttachments': obj.inputAttachments?.map(y => toJson_ChannelSpecForProviderInputAttachments(y)),
    'inputSpecification': obj.inputSpecification?.map(y => toJson_ChannelSpecForProviderInputSpecification(y)),
    'logLevel': obj.logLevel,
    'maintenance': obj.maintenance?.map(y => toJson_ChannelSpecForProviderMaintenance(y)),
    'name': obj.name,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ChannelSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ChannelSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'startChannel': obj.startChannel,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpc': obj.vpc?.map(y => toJson_ChannelSpecForProviderVpc(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ChannelSpecManagementPolicy
 */
export enum ChannelSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ChannelSpecProviderConfigRef
 */
export interface ChannelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ChannelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ChannelSpecProviderConfigRef#policy
   */
  readonly policy?: ChannelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ChannelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecProviderConfigRef(obj: ChannelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ChannelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ChannelSpecProviderRef
 */
export interface ChannelSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ChannelSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ChannelSpecProviderRef#policy
   */
  readonly policy?: ChannelSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ChannelSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecProviderRef(obj: ChannelSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ChannelSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ChannelSpecPublishConnectionDetailsTo
 */
export interface ChannelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ChannelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ChannelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ChannelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ChannelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ChannelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ChannelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecPublishConnectionDetailsTo(obj: ChannelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ChannelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ChannelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ChannelSpecWriteConnectionSecretToRef
 */
export interface ChannelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ChannelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ChannelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ChannelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecWriteConnectionSecretToRef(obj: ChannelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderCdiInputSpecification
 */
export interface ChannelSpecForProviderCdiInputSpecification {
  /**
   * - Maximum CDI input resolution.
   *
   * @schema ChannelSpecForProviderCdiInputSpecification#resolution
   */
  readonly resolution: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderCdiInputSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderCdiInputSpecification(obj: ChannelSpecForProviderCdiInputSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderDestinations
 */
export interface ChannelSpecForProviderDestinations {
  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderDestinations#id
   */
  readonly id: string;

  /**
   * Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details.
   *
   * @schema ChannelSpecForProviderDestinations#mediaPackageSettings
   */
  readonly mediaPackageSettings?: ChannelSpecForProviderDestinationsMediaPackageSettings[];

  /**
   * Destination settings for a Multiplex output; one destination for both encoders. See Multiplex Settings for more details.
   *
   * @schema ChannelSpecForProviderDestinations#multiplexSettings
   */
  readonly multiplexSettings?: ChannelSpecForProviderDestinationsMultiplexSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderDestinations#settings
   */
  readonly settings?: ChannelSpecForProviderDestinationsSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderDestinations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderDestinations(obj: ChannelSpecForProviderDestinations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'mediaPackageSettings': obj.mediaPackageSettings?.map(y => toJson_ChannelSpecForProviderDestinationsMediaPackageSettings(y)),
    'multiplexSettings': obj.multiplexSettings?.map(y => toJson_ChannelSpecForProviderDestinationsMultiplexSettings(y)),
    'settings': obj.settings?.map(y => toJson_ChannelSpecForProviderDestinationsSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettings
 */
export interface ChannelSpecForProviderEncoderSettings {
  /**
   * Audio descriptions for the channel. See Audio Descriptions for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettings#audioDescriptions
   */
  readonly audioDescriptions?: ChannelSpecForProviderEncoderSettingsAudioDescriptions[];

  /**
   * Settings for ad avail blanking. See Avail Blanking for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettings#availBlanking
   */
  readonly availBlanking?: ChannelSpecForProviderEncoderSettingsAvailBlanking[];

  /**
   * Output groups for the channel. See Output Groups for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettings#outputGroups
   */
  readonly outputGroups: ChannelSpecForProviderEncoderSettingsOutputGroups[];

  /**
   * Contains settings used to acquire and adjust timecode information from inputs. See Timecode Config for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettings#timecodeConfig
   */
  readonly timecodeConfig: ChannelSpecForProviderEncoderSettingsTimecodeConfig[];

  /**
   * Video Descriptions. See Video Descriptions for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettings#videoDescriptions
   */
  readonly videoDescriptions?: ChannelSpecForProviderEncoderSettingsVideoDescriptions[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettings(obj: ChannelSpecForProviderEncoderSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioDescriptions': obj.audioDescriptions?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptions(y)),
    'availBlanking': obj.availBlanking?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAvailBlanking(y)),
    'outputGroups': obj.outputGroups?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroups(y)),
    'timecodeConfig': obj.timecodeConfig?.map(y => toJson_ChannelSpecForProviderEncoderSettingsTimecodeConfig(y)),
    'videoDescriptions': obj.videoDescriptions?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachments
 */
export interface ChannelSpecForProviderInputAttachments {
  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachments#automaticInputFailoverSettings
   */
  readonly automaticInputFailoverSettings?: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings[];

  /**
   * User-specified name for the attachment.
   *
   * @schema ChannelSpecForProviderInputAttachments#inputAttachmentName
   */
  readonly inputAttachmentName: string;

  /**
   * The ID of the input.
   *
   * @schema ChannelSpecForProviderInputAttachments#inputId
   */
  readonly inputId?: string;

  /**
   * Reference to a Input in medialive to populate inputId.
   *
   * @schema ChannelSpecForProviderInputAttachments#inputIdRef
   */
  readonly inputIdRef?: ChannelSpecForProviderInputAttachmentsInputIdRef;

  /**
   * Selector for a Input in medialive to populate inputId.
   *
   * @schema ChannelSpecForProviderInputAttachments#inputIdSelector
   */
  readonly inputIdSelector?: ChannelSpecForProviderInputAttachmentsInputIdSelector;

  /**
   * Settings of an input. See Input Settings for more details
   *
   * @schema ChannelSpecForProviderInputAttachments#inputSettings
   */
  readonly inputSettings?: ChannelSpecForProviderInputAttachmentsInputSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachments' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachments(obj: ChannelSpecForProviderInputAttachments | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automaticInputFailoverSettings': obj.automaticInputFailoverSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings(y)),
    'inputAttachmentName': obj.inputAttachmentName,
    'inputId': obj.inputId,
    'inputIdRef': toJson_ChannelSpecForProviderInputAttachmentsInputIdRef(obj.inputIdRef),
    'inputIdSelector': toJson_ChannelSpecForProviderInputAttachmentsInputIdSelector(obj.inputIdSelector),
    'inputSettings': obj.inputSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputSpecification
 */
export interface ChannelSpecForProviderInputSpecification {
  /**
   * @schema ChannelSpecForProviderInputSpecification#codec
   */
  readonly codec: string;

  /**
   * - Maximum CDI input resolution.
   *
   * @schema ChannelSpecForProviderInputSpecification#inputResolution
   */
  readonly inputResolution: string;

  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderInputSpecification#maximumBitrate
   */
  readonly maximumBitrate: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputSpecification(obj: ChannelSpecForProviderInputSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codec': obj.codec,
    'inputResolution': obj.inputResolution,
    'maximumBitrate': obj.maximumBitrate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderMaintenance
 */
export interface ChannelSpecForProviderMaintenance {
  /**
   * The day of the week to use for maintenance.
   *
   * @schema ChannelSpecForProviderMaintenance#maintenanceDay
   */
  readonly maintenanceDay: string;

  /**
   * The hour maintenance will start.
   *
   * @schema ChannelSpecForProviderMaintenance#maintenanceStartTime
   */
  readonly maintenanceStartTime: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderMaintenance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderMaintenance(obj: ChannelSpecForProviderMaintenance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maintenanceDay': obj.maintenanceDay,
    'maintenanceStartTime': obj.maintenanceStartTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ChannelSpecForProviderRoleArnRef
 */
export interface ChannelSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ChannelSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ChannelSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ChannelSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ChannelSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderRoleArnRef(obj: ChannelSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ChannelSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ChannelSpecForProviderRoleArnSelector
 */
export interface ChannelSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ChannelSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ChannelSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ChannelSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ChannelSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ChannelSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderRoleArnSelector(obj: ChannelSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ChannelSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderVpc
 */
export interface ChannelSpecForProviderVpc {
  /**
   * @schema ChannelSpecForProviderVpc#publicAddressAllocationIds
   */
  readonly publicAddressAllocationIds: string[];

  /**
   * @schema ChannelSpecForProviderVpc#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * @schema ChannelSpecForProviderVpc#subnetIds
   */
  readonly subnetIds: string[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderVpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderVpc(obj: ChannelSpecForProviderVpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicAddressAllocationIds': obj.publicAddressAllocationIds?.map(y => y),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ChannelSpecProviderConfigRefPolicy
 */
export interface ChannelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ChannelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ChannelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ChannelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ChannelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ChannelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecProviderConfigRefPolicy(obj: ChannelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ChannelSpecProviderRefPolicy
 */
export interface ChannelSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ChannelSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ChannelSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ChannelSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ChannelSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ChannelSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecProviderRefPolicy(obj: ChannelSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ChannelSpecPublishConnectionDetailsToConfigRef
 */
export interface ChannelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ChannelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ChannelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ChannelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ChannelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecPublishConnectionDetailsToConfigRef(obj: ChannelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ChannelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ChannelSpecPublishConnectionDetailsToMetadata
 */
export interface ChannelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ChannelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ChannelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ChannelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ChannelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecPublishConnectionDetailsToMetadata(obj: ChannelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderDestinationsMediaPackageSettings
 */
export interface ChannelSpecForProviderDestinationsMediaPackageSettings {
  /**
   * ID of the channel in MediaPackage that is the destination for this output group.
   *
   * @schema ChannelSpecForProviderDestinationsMediaPackageSettings#channelId
   */
  readonly channelId: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderDestinationsMediaPackageSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderDestinationsMediaPackageSettings(obj: ChannelSpecForProviderDestinationsMediaPackageSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channelId': obj.channelId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderDestinationsMultiplexSettings
 */
export interface ChannelSpecForProviderDestinationsMultiplexSettings {
  /**
   * The ID of the Multiplex that the encoder is providing output to.
   *
   * @schema ChannelSpecForProviderDestinationsMultiplexSettings#multiplexId
   */
  readonly multiplexId: string;

  /**
   * The program name of the Multiplex program that the encoder is providing output to.
   *
   * @schema ChannelSpecForProviderDestinationsMultiplexSettings#programName
   */
  readonly programName: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderDestinationsMultiplexSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderDestinationsMultiplexSettings(obj: ChannelSpecForProviderDestinationsMultiplexSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'multiplexId': obj.multiplexId,
    'programName': obj.programName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderDestinationsSettings
 */
export interface ChannelSpecForProviderDestinationsSettings {
  /**
   * Key used to extract the password from EC2 Parameter store.
   *
   * @schema ChannelSpecForProviderDestinationsSettings#passwordParam
   */
  readonly passwordParam?: string;

  /**
   * Stream name RTMP destinations (URLs of type rtmp://)
   *
   * @schema ChannelSpecForProviderDestinationsSettings#streamName
   */
  readonly streamName?: string;

  /**
   * A URL specifying a destination.
   *
   * @schema ChannelSpecForProviderDestinationsSettings#url
   */
  readonly url?: string;

  /**
   * Username for destination.
   *
   * @schema ChannelSpecForProviderDestinationsSettings#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderDestinationsSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderDestinationsSettings(obj: ChannelSpecForProviderDestinationsSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordParam': obj.passwordParam,
    'streamName': obj.streamName,
    'url': obj.url,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptions {
  /**
   * Advanced audio normalization settings. See Audio Normalization Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#audioNormalizationSettings
   */
  readonly audioNormalizationSettings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioNormalizationSettings[];

  /**
   * The name of the audio selector used as the source for this AudioDescription.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#audioSelectorName
   */
  readonly audioSelectorName: string;

  /**
   * Applies only if audioTypeControl is useConfigured. The values for audioType are defined in ISO-IEC 13818-1.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#audioType
   */
  readonly audioType?: string;

  /**
   * Determined how audio type is determined.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#audioTypeControl
   */
  readonly audioTypeControl?: string;

  /**
   * Settings to configure one or more solutions that insert audio watermarks in the audio encode. See Audio Watermark Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#audioWatermarkSettings
   */
  readonly audioWatermarkSettings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettings[];

  /**
   * Audio codec settings. See Audio Codec Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#codecSettings
   */
  readonly codecSettings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings[];

  /**
   * When specified this field indicates the three letter language code of the caption track to extract from the source.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#languageCode
   */
  readonly languageCode?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#languageCodeControl
   */
  readonly languageCodeControl?: string;

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#name
   */
  readonly name: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#remixSettings
   */
  readonly remixSettings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettings[];

  /**
   * Stream name RTMP destinations (URLs of type rtmp://)
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptions#streamName
   */
  readonly streamName?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptions(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioNormalizationSettings': obj.audioNormalizationSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioNormalizationSettings(y)),
    'audioSelectorName': obj.audioSelectorName,
    'audioType': obj.audioType,
    'audioTypeControl': obj.audioTypeControl,
    'audioWatermarkSettings': obj.audioWatermarkSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettings(y)),
    'codecSettings': obj.codecSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings(y)),
    'languageCode': obj.languageCode,
    'languageCodeControl': obj.languageCodeControl,
    'name': obj.name,
    'remixSettings': obj.remixSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettings(y)),
    'streamName': obj.streamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAvailBlanking
 */
export interface ChannelSpecForProviderEncoderSettingsAvailBlanking {
  /**
   * Blanking image to be used. See Avail Blanking Image for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAvailBlanking#availBlankingImage
   */
  readonly availBlankingImage?: ChannelSpecForProviderEncoderSettingsAvailBlankingAvailBlankingImage[];

  /**
   * When set to enabled, causes video, audio and captions to be blanked when insertion metadata is added.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAvailBlanking#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAvailBlanking' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAvailBlanking(obj: ChannelSpecForProviderEncoderSettingsAvailBlanking | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availBlankingImage': obj.availBlankingImage?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAvailBlankingAvailBlankingImage(y)),
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroups
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroups {
  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroups#name
   */
  readonly name?: string;

  /**
   * Settings associated with the output group. See Output Group Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroups#outputGroupSettings
   */
  readonly outputGroupSettings: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings[];

  /**
   * List of outputs. See Outputs for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroups#outputs
   */
  readonly outputs: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroups(obj: ChannelSpecForProviderEncoderSettingsOutputGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'outputGroupSettings': obj.outputGroupSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings(y)),
    'outputs': obj.outputs?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsTimecodeConfig
 */
export interface ChannelSpecForProviderEncoderSettingsTimecodeConfig {
  /**
   * The source for the timecode that will be associated with the events outputs.
   *
   * @schema ChannelSpecForProviderEncoderSettingsTimecodeConfig#source
   */
  readonly source: string;

  /**
   * Threshold in frames beyond which output timecode is resynchronized to the input timecode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsTimecodeConfig#syncThreshold
   */
  readonly syncThreshold?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsTimecodeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsTimecodeConfig(obj: ChannelSpecForProviderEncoderSettingsTimecodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
    'syncThreshold': obj.syncThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptions
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptions {
  /**
   * Audio codec settings. See Audio Codec Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptions#codecSettings
   */
  readonly codecSettings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettings[];

  /**
   * Output video height in pixels.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptions#height
   */
  readonly height?: number;

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptions#name
   */
  readonly name: string;

  /**
   * Indicate how to respond to the AFD values that might be in the input video.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptions#respondToAfd
   */
  readonly respondToAfd?: string;

  /**
   * Behavior on how to scale.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptions#scalingBehavior
   */
  readonly scalingBehavior?: string;

  /**
   * Changes the strength of the anti-alias filter used for scaling.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptions#sharpness
   */
  readonly sharpness?: number;

  /**
   * Output video width in pixels.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptions#width
   */
  readonly width?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptions(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codecSettings': obj.codecSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettings(y)),
    'height': obj.height,
    'name': obj.name,
    'respondToAfd': obj.respondToAfd,
    'scalingBehavior': obj.scalingBehavior,
    'sharpness': obj.sharpness,
    'width': obj.width,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings
 */
export interface ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings#errorClearTimeMsec
   */
  readonly errorClearTimeMsec?: number;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings#failoverCondition
   */
  readonly failoverCondition?: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverCondition[];

  /**
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings#inputPreference
   */
  readonly inputPreference?: string;

  /**
   * The ID of the input.
   *
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings#secondaryInputId
   */
  readonly secondaryInputId: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings(obj: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorClearTimeMsec': obj.errorClearTimeMsec,
    'failoverCondition': obj.failoverCondition?.map(y => toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverCondition(y)),
    'inputPreference': obj.inputPreference,
    'secondaryInputId': obj.secondaryInputId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Input in medialive to populate inputId.
 *
 * @schema ChannelSpecForProviderInputAttachmentsInputIdRef
 */
export interface ChannelSpecForProviderInputAttachmentsInputIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputIdRef#policy
   */
  readonly policy?: ChannelSpecForProviderInputAttachmentsInputIdRefPolicy;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputIdRef(obj: ChannelSpecForProviderInputAttachmentsInputIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ChannelSpecForProviderInputAttachmentsInputIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Input in medialive to populate inputId.
 *
 * @schema ChannelSpecForProviderInputAttachmentsInputIdSelector
 */
export interface ChannelSpecForProviderInputAttachmentsInputIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputIdSelector#policy
   */
  readonly policy?: ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicy;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputIdSelector(obj: ChannelSpecForProviderInputAttachmentsInputIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#audioSelector
   */
  readonly audioSelector?: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelector[];

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#captionSelector
   */
  readonly captionSelector?: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelector[];

  /**
   * Enable or disable the deblock filter when filtering.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#deblockFilter
   */
  readonly deblockFilter?: string;

  /**
   * Enable or disable the denoise filter when filtering.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#denoiseFilter
   */
  readonly denoiseFilter?: string;

  /**
   * Adjusts the magnitude of filtering from 1 (minimal) to 5 (strongest).
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#filterStrength
   */
  readonly filterStrength?: number;

  /**
   * Turns on the filter for the input.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#inputFilter
   */
  readonly inputFilter?: string;

  /**
   * Input settings. See Network Input Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#networkInputSettings
   */
  readonly networkInputSettings?: ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettings[];

  /**
   * PID from which to read SCTE-35 messages.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#scte35Pid
   */
  readonly scte35Pid?: number;

  /**
   * Specifies whether to extract applicable ancillary data from a SMPTE-2038 source in the input.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#smpte2038DataPreference
   */
  readonly smpte2038DataPreference?: string;

  /**
   * Loop input if it is a file.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#sourceEndBehavior
   */
  readonly sourceEndBehavior?: string;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettings#videoSelector
   */
  readonly videoSelector?: ChannelSpecForProviderInputAttachmentsInputSettingsVideoSelector[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioSelector': obj.audioSelector?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelector(y)),
    'captionSelector': obj.captionSelector?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelector(y)),
    'deblockFilter': obj.deblockFilter,
    'denoiseFilter': obj.denoiseFilter,
    'filterStrength': obj.filterStrength,
    'inputFilter': obj.inputFilter,
    'networkInputSettings': obj.networkInputSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettings(y)),
    'scte35Pid': obj.scte35Pid,
    'smpte2038DataPreference': obj.smpte2038DataPreference,
    'sourceEndBehavior': obj.sourceEndBehavior,
    'videoSelector': obj.videoSelector?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsVideoSelector(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ChannelSpecForProviderRoleArnRefPolicy
 */
export interface ChannelSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ChannelSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ChannelSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ChannelSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ChannelSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ChannelSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderRoleArnRefPolicy(obj: ChannelSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ChannelSpecForProviderRoleArnSelectorPolicy
 */
export interface ChannelSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ChannelSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ChannelSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ChannelSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ChannelSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ChannelSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderRoleArnSelectorPolicy(obj: ChannelSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ChannelSpecProviderConfigRefPolicyResolution
 */
export enum ChannelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ChannelSpecProviderConfigRefPolicyResolve
 */
export enum ChannelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ChannelSpecProviderRefPolicyResolution
 */
export enum ChannelSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ChannelSpecProviderRefPolicyResolve
 */
export enum ChannelSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ChannelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ChannelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ChannelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ChannelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ChannelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecPublishConnectionDetailsToConfigRefPolicy(obj: ChannelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioNormalizationSettings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioNormalizationSettings {
  /**
   * Audio normalization algorithm to use. itu17701 conforms to the CALM Act specification, itu17702 to the EBU R-128 specification.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioNormalizationSettings#algorithm
   */
  readonly algorithm?: string;

  /**
   * Algorithm control for the audio description.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioNormalizationSettings#algorithmControl
   */
  readonly algorithmControl?: string;

  /**
   * Target LKFS (loudness) to adjust volume to.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioNormalizationSettings#targetLkfs
   */
  readonly targetLkfs?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioNormalizationSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioNormalizationSettings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioNormalizationSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'algorithmControl': obj.algorithmControl,
    'targetLkfs': obj.targetLkfs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettings {
  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettings#nielsenWatermarksSettings
   */
  readonly nielsenWatermarksSettings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nielsenWatermarksSettings': obj.nielsenWatermarksSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings {
  /**
   * Aac Settings. See AAC Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings#aacSettings
   */
  readonly aacSettings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings[];

  /**
   * Ac3 Settings. See AC3 Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings#ac3Settings
   */
  readonly ac3Settings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings[];

  /**
   * - Eac3 Atmos Settings. See EAC3 Atmos Settings
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings#eac3AtmosSettings
   */
  readonly eac3AtmosSettings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings[];

  /**
   * - Eac3 Settings. See EAC3 Settings
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings#eac3Settings
   */
  readonly eac3Settings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings#mp2Settings
   */
  readonly mp2Settings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsMp2Settings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings#passThroughSettings
   */
  readonly passThroughSettings?: any[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings#wavSettings
   */
  readonly wavSettings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsWavSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aacSettings': obj.aacSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings(y)),
    'ac3Settings': obj.ac3Settings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings(y)),
    'eac3AtmosSettings': obj.eac3AtmosSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings(y)),
    'eac3Settings': obj.eac3Settings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings(y)),
    'mp2Settings': obj.mp2Settings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsMp2Settings(y)),
    'passThroughSettings': obj.passThroughSettings?.map(y => y),
    'wavSettings': obj.wavSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsWavSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettings#channelMappings
   */
  readonly channelMappings: ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappings[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettings#channelsIn
   */
  readonly channelsIn?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettings#channelsOut
   */
  readonly channelsOut?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channelMappings': obj.channelMappings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappings(y)),
    'channelsIn': obj.channelsIn,
    'channelsOut': obj.channelsOut,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAvailBlankingAvailBlankingImage
 */
export interface ChannelSpecForProviderEncoderSettingsAvailBlankingAvailBlankingImage {
  /**
   * Key used to extract the password from EC2 Parameter store.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAvailBlankingAvailBlankingImage#passwordParam
   */
  readonly passwordParam?: string;

  /**
   * Path to a file accessible to the live stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAvailBlankingAvailBlankingImage#uri
   */
  readonly uri: string;

  /**
   * Username for destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAvailBlankingAvailBlankingImage#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAvailBlankingAvailBlankingImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAvailBlankingAvailBlankingImage(obj: ChannelSpecForProviderEncoderSettingsAvailBlankingAvailBlankingImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordParam': obj.passwordParam,
    'uri': obj.uri,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings {
  /**
   * Archive group settings. See Archive Group Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings#archiveGroupSettings
   */
  readonly archiveGroupSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings#frameCaptureGroupSettings
   */
  readonly frameCaptureGroupSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings#hlsGroupSettings
   */
  readonly hlsGroupSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings[];

  /**
   * Media package group settings. See Media Package Group Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings#mediaPackageGroupSettings
   */
  readonly mediaPackageGroupSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings#msSmoothGroupSettings
   */
  readonly msSmoothGroupSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings#multiplexGroupSettings
   */
  readonly multiplexGroupSettings?: any[];

  /**
   * RTMP group settings. See RTMP Group Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings#rtmpGroupSettings
   */
  readonly rtmpGroupSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings#udpGroupSettings
   */
  readonly udpGroupSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsUdpGroupSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'archiveGroupSettings': obj.archiveGroupSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettings(y)),
    'frameCaptureGroupSettings': obj.frameCaptureGroupSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettings(y)),
    'hlsGroupSettings': obj.hlsGroupSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings(y)),
    'mediaPackageGroupSettings': obj.mediaPackageGroupSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettings(y)),
    'msSmoothGroupSettings': obj.msSmoothGroupSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings(y)),
    'multiplexGroupSettings': obj.multiplexGroupSettings?.map(y => y),
    'rtmpGroupSettings': obj.rtmpGroupSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings(y)),
    'udpGroupSettings': obj.udpGroupSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsUdpGroupSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs {
  /**
   * The names of the audio descriptions used as audio sources for the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs#audioDescriptionNames
   */
  readonly audioDescriptionNames?: string[];

  /**
   * The names of the caption descriptions used as caption sources for the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs#captionDescriptionNames
   */
  readonly captionDescriptionNames?: string[];

  /**
   * The name used to identify an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs#outputName
   */
  readonly outputName?: string;

  /**
   * Settings for output. See Output Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs#outputSettings
   */
  readonly outputSettings: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings[];

  /**
   * The name of the video description used as video source for the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs#videoDescriptionName
   */
  readonly videoDescriptionName?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioDescriptionNames': obj.audioDescriptionNames?.map(y => y),
    'captionDescriptionNames': obj.captionDescriptionNames?.map(y => y),
    'outputName': obj.outputName,
    'outputSettings': obj.outputSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings(y)),
    'videoDescriptionName': obj.videoDescriptionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettings {
  /**
   * Frame capture settings. See Frame Capture Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettings#frameCaptureSettings
   */
  readonly frameCaptureSettings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsFrameCaptureSettings[];

  /**
   * H264 settings. See H264 Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettings#h264Settings
   */
  readonly h264Settings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettings#h265Settings
   */
  readonly h265Settings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frameCaptureSettings': obj.frameCaptureSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsFrameCaptureSettings(y)),
    'h264Settings': obj.h264Settings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings(y)),
    'h265Settings': obj.h265Settings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverCondition
 */
export interface ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverCondition {
  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverCondition#failoverConditionSettings
   */
  readonly failoverConditionSettings?: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverCondition(obj: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failoverConditionSettings': obj.failoverConditionSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ChannelSpecForProviderInputAttachmentsInputIdRefPolicy
 */
export interface ChannelSpecForProviderInputAttachmentsInputIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputIdRefPolicy#resolution
   */
  readonly resolution?: ChannelSpecForProviderInputAttachmentsInputIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputIdRefPolicy#resolve
   */
  readonly resolve?: ChannelSpecForProviderInputAttachmentsInputIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputIdRefPolicy(obj: ChannelSpecForProviderInputAttachmentsInputIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicy
 */
export interface ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicy#resolution
   */
  readonly resolution?: ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicy#resolve
   */
  readonly resolve?: ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicy(obj: ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelector
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelector {
  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelector#name
   */
  readonly name: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelector#selectorSettings
   */
  readonly selectorSettings?: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelector(obj: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'selectorSettings': obj.selectorSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelector
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelector {
  /**
   * When specified this field indicates the three letter language code of the caption track to extract from the source.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelector#languageCode
   */
  readonly languageCode?: string;

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelector#name
   */
  readonly name: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelector#selectorSettings
   */
  readonly selectorSettings?: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelector(obj: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'languageCode': obj.languageCode,
    'name': obj.name,
    'selectorSettings': obj.selectorSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettings {
  /**
   * Specifies HLS input settings when the uri is for a HLS manifest. See HLS Input Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettings#hlsInputSettings
   */
  readonly hlsInputSettings?: ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings[];

  /**
   * Check HTTPS server certificates.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettings#serverValidation
   */
  readonly serverValidation?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hlsInputSettings': obj.hlsInputSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings(y)),
    'serverValidation': obj.serverValidation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsVideoSelector
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsVideoSelector {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsVideoSelector#colorSpace
   */
  readonly colorSpace?: string;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsVideoSelector#colorSpaceUsage
   */
  readonly colorSpaceUsage?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsVideoSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsVideoSelector(obj: ChannelSpecForProviderInputAttachmentsInputSettingsVideoSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'colorSpace': obj.colorSpace,
    'colorSpaceUsage': obj.colorSpaceUsage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ChannelSpecForProviderRoleArnRefPolicyResolution
 */
export enum ChannelSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ChannelSpecForProviderRoleArnRefPolicyResolve
 */
export enum ChannelSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ChannelSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ChannelSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ChannelSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ChannelSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettings {
  /**
   * Used to insert watermarks of type Nielsen CBET. See Nielsen CBET Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettings#nielsenCbetSettings
   */
  readonly nielsenCbetSettings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings[];

  /**
   * Distribution types to assign to the watermarks. Options are PROGRAM_CONTENT and FINAL_DISTRIBUTOR.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettings#nielsenDistributionType
   */
  readonly nielsenDistributionType?: string;

  /**
   * Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettings#nielsenNaesIiNwSettings
   */
  readonly nielsenNaesIiNwSettings?: ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nielsenCbetSettings': obj.nielsenCbetSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings(y)),
    'nielsenDistributionType': obj.nielsenDistributionType,
    'nielsenNaesIiNwSettings': obj.nielsenNaesIiNwSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings {
  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings#bitrate
   */
  readonly bitrate?: number;

  /**
   * Mono, Stereo, or 5.1 channel layout.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings#codingMode
   */
  readonly codingMode?: string;

  /**
   * Set to "broadcasterMixedAd" when input contains pre-mixed main audio + AD (narration) as a stereo pair.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings#inputType
   */
  readonly inputType?: string;

  /**
   * AAC profile.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings#profile
   */
  readonly profile?: string;

  /**
   * The rate control mode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings#rateControlMode
   */
  readonly rateControlMode?: string;

  /**
   * Sets LATM/LOAS AAC output for raw containers.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings#rawFormat
   */
  readonly rawFormat?: string;

  /**
   * Sample rate in Hz.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings#sampleRate
   */
  readonly sampleRate?: number;

  /**
   * Use MPEG-2 AAC audio instead of MPEG-4 AAC audio for raw or MPEG-2 Transport Stream containers.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings#spec
   */
  readonly spec?: string;

  /**
   * VBR Quality Level - Only used if rateControlMode is VBR.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings#vbrQuality
   */
  readonly vbrQuality?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAacSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bitrate': obj.bitrate,
    'codingMode': obj.codingMode,
    'inputType': obj.inputType,
    'profile': obj.profile,
    'rateControlMode': obj.rateControlMode,
    'rawFormat': obj.rawFormat,
    'sampleRate': obj.sampleRate,
    'spec': obj.spec,
    'vbrQuality': obj.vbrQuality,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings {
  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings#bitrate
   */
  readonly bitrate?: number;

  /**
   * Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings#bitstreamMode
   */
  readonly bitstreamMode?: string;

  /**
   * Mono, Stereo, or 5.1 channel layout.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings#codingMode
   */
  readonly codingMode?: string;

  /**
   * Sets the dialnorm of the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings#dialnorm
   */
  readonly dialnorm?: number;

  /**
   * If set to filmStandard, adds dynamic range compression signaling to the output bitstream as defined in the Dolby Digital specification.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings#drcProfile
   */
  readonly drcProfile?: string;

  /**
   * When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings#lfeFilter
   */
  readonly lfeFilter?: string;

  /**
   * Metadata control.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings#metadataControl
   */
  readonly metadataControl?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsAc3Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bitrate': obj.bitrate,
    'bitstreamMode': obj.bitstreamMode,
    'codingMode': obj.codingMode,
    'dialnorm': obj.dialnorm,
    'drcProfile': obj.drcProfile,
    'lfeFilter': obj.lfeFilter,
    'metadataControl': obj.metadataControl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings {
  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings#bitrate
   */
  readonly bitrate?: number;

  /**
   * Mono, Stereo, or 5.1 channel layout.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings#codingMode
   */
  readonly codingMode?: string;

  /**
   * Sets the dialnorm of the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings#dialnorm
   */
  readonly dialnorm?: number;

  /**
   * Sets the Dolby dynamic range compression profile.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings#drcLine
   */
  readonly drcLine?: string;

  /**
   * Sets the profile for heavy Dolby dynamic range compression.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings#drcRf
   */
  readonly drcRf?: string;

  /**
   * Height dimensional trim.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings#heightTrim
   */
  readonly heightTrim?: number;

  /**
   * Surround dimensional trim.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings#surroundTrim
   */
  readonly surroundTrim?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3AtmosSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bitrate': obj.bitrate,
    'codingMode': obj.codingMode,
    'dialnorm': obj.dialnorm,
    'drcLine': obj.drcLine,
    'drcRf': obj.drcRf,
    'heightTrim': obj.heightTrim,
    'surroundTrim': obj.surroundTrim,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings {
  /**
   * Sets the attenuation control.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#attenuationControl
   */
  readonly attenuationControl?: string;

  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#bitrate
   */
  readonly bitrate?: number;

  /**
   * Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#bitstreamMode
   */
  readonly bitstreamMode?: string;

  /**
   * Mono, Stereo, or 5.1 channel layout.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#codingMode
   */
  readonly codingMode?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#dcFilter
   */
  readonly dcFilter?: string;

  /**
   * Sets the dialnorm of the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#dialnorm
   */
  readonly dialnorm?: number;

  /**
   * Sets the Dolby dynamic range compression profile.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#drcLine
   */
  readonly drcLine?: string;

  /**
   * Sets the profile for heavy Dolby dynamic range compression.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#drcRf
   */
  readonly drcRf?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#lfeControl
   */
  readonly lfeControl?: string;

  /**
   * When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#lfeFilter
   */
  readonly lfeFilter?: string;

  /**
   * H264 level.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#loRoCenterMixLevel
   */
  readonly loRoCenterMixLevel?: number;

  /**
   * H264 level.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#loRoSurroundMixLevel
   */
  readonly loRoSurroundMixLevel?: number;

  /**
   * H264 level.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#ltRtCenterMixLevel
   */
  readonly ltRtCenterMixLevel?: number;

  /**
   * H264 level.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#ltRtSurroundMixLevel
   */
  readonly ltRtSurroundMixLevel?: number;

  /**
   * Metadata control.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#metadataControl
   */
  readonly metadataControl?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#passthroughControl
   */
  readonly passthroughControl?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#phaseControl
   */
  readonly phaseControl?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#stereoDownmix
   */
  readonly stereoDownmix?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#surroundExMode
   */
  readonly surroundExMode?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings#surroundMode
   */
  readonly surroundMode?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsEac3Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attenuationControl': obj.attenuationControl,
    'bitrate': obj.bitrate,
    'bitstreamMode': obj.bitstreamMode,
    'codingMode': obj.codingMode,
    'dcFilter': obj.dcFilter,
    'dialnorm': obj.dialnorm,
    'drcLine': obj.drcLine,
    'drcRf': obj.drcRf,
    'lfeControl': obj.lfeControl,
    'lfeFilter': obj.lfeFilter,
    'loRoCenterMixLevel': obj.loRoCenterMixLevel,
    'loRoSurroundMixLevel': obj.loRoSurroundMixLevel,
    'ltRtCenterMixLevel': obj.ltRtCenterMixLevel,
    'ltRtSurroundMixLevel': obj.ltRtSurroundMixLevel,
    'metadataControl': obj.metadataControl,
    'passthroughControl': obj.passthroughControl,
    'phaseControl': obj.phaseControl,
    'stereoDownmix': obj.stereoDownmix,
    'surroundExMode': obj.surroundExMode,
    'surroundMode': obj.surroundMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsMp2Settings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsMp2Settings {
  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsMp2Settings#bitrate
   */
  readonly bitrate?: number;

  /**
   * Mono, Stereo, or 5.1 channel layout.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsMp2Settings#codingMode
   */
  readonly codingMode?: string;

  /**
   * Sample rate in Hz.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsMp2Settings#sampleRate
   */
  readonly sampleRate?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsMp2Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsMp2Settings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsMp2Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bitrate': obj.bitrate,
    'codingMode': obj.codingMode,
    'sampleRate': obj.sampleRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsWavSettings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsWavSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsWavSettings#bitDepth
   */
  readonly bitDepth?: number;

  /**
   * Mono, Stereo, or 5.1 channel layout.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsWavSettings#codingMode
   */
  readonly codingMode?: string;

  /**
   * Sample rate in Hz.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsWavSettings#sampleRate
   */
  readonly sampleRate?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsWavSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsWavSettings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsCodecSettingsWavSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bitDepth': obj.bitDepth,
    'codingMode': obj.codingMode,
    'sampleRate': obj.sampleRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappings#inputChannelLevels
   */
  readonly inputChannelLevels: ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappingsInputChannelLevels[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappings#outputChannel
   */
  readonly outputChannel: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputChannelLevels': obj.inputChannelLevels?.map(y => toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappingsInputChannelLevels(y)),
    'outputChannel': obj.outputChannel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettings {
  /**
   * Parameters that control the interactions with the CDN. See Archive CDN Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettings#archiveCdnSettings
   */
  readonly archiveCdnSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettings[];

  /**
   * A director and base filename where archive files should be written. See Destination for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettings#destination
   */
  readonly destination: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsDestination[];

  /**
   * Number of seconds to write to archive file before closing and starting a new one.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettings#rolloverInterval
   */
  readonly rolloverInterval?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'archiveCdnSettings': obj.archiveCdnSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettings(y)),
    'destination': obj.destination?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsDestination(y)),
    'rolloverInterval': obj.rolloverInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettings {
  /**
   * A director and base filename where archive files should be written. See Destination for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettings#destination
   */
  readonly destination: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsDestination[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettings#frameCaptureCdnSettings
   */
  readonly frameCaptureCdnSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsDestination(y)),
    'frameCaptureCdnSettings': obj.frameCaptureCdnSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings {
  /**
   * The ad marker type for this output group.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#adMarkers
   */
  readonly adMarkers?: string[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#baseUrlContent
   */
  readonly baseUrlContent?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#baseUrlContent1
   */
  readonly baseUrlContent1?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#baseUrlManifest
   */
  readonly baseUrlManifest?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#baseUrlManifest1
   */
  readonly baseUrlManifest1?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#captionLanguageMappings
   */
  readonly captionLanguageMappings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappings[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#captionLanguageSetting
   */
  readonly captionLanguageSetting?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#clientCache
   */
  readonly clientCache?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#codecSpecification
   */
  readonly codecSpecification?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#constantIv
   */
  readonly constantIv?: string;

  /**
   * A director and base filename where archive files should be written. See Destination for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#destination
   */
  readonly destination: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsDestination[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#directoryStructure
   */
  readonly directoryStructure?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#discontinuityTags
   */
  readonly discontinuityTags?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#encryptionType
   */
  readonly encryptionType?: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#hlsCdnSettings
   */
  readonly hlsCdnSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#hlsId3SegmentTagging
   */
  readonly hlsId3SegmentTagging?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#iframeOnlyPlaylists
   */
  readonly iframeOnlyPlaylists?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#incompleteSegmentBehavior
   */
  readonly incompleteSegmentBehavior?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#indexNSegments
   */
  readonly indexNSegments?: number;

  /**
   * Controls the behavior of the RTMP group if input becomes unavailable.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#inputLossAction
   */
  readonly inputLossAction?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#ivInManifest
   */
  readonly ivInManifest?: string;

  /**
   * The source for the timecode that will be associated with the events outputs.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#ivSource
   */
  readonly ivSource?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#keepSegments
   */
  readonly keepSegments?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#keyFormat
   */
  readonly keyFormat?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#keyFormatVersions
   */
  readonly keyFormatVersions?: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#keyProviderSettings
   */
  readonly keyProviderSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettings[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#manifestCompression
   */
  readonly manifestCompression?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#manifestDurationFormat
   */
  readonly manifestDurationFormat?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#minSegmentLength
   */
  readonly minSegmentLength?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#mode
   */
  readonly mode?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#outputSelection
   */
  readonly outputSelection?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#programDateTime
   */
  readonly programDateTime?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#programDateTimeClock
   */
  readonly programDateTimeClock?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#programDateTimePeriod
   */
  readonly programDateTimePeriod?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#redundantManifest
   */
  readonly redundantManifest?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#segmentLength
   */
  readonly segmentLength?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#segmentsPerSubdirectory
   */
  readonly segmentsPerSubdirectory?: number;

  /**
   * - Maximum CDI input resolution.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#streamInfResolution
   */
  readonly streamInfResolution?: string;

  /**
   * Indicates ID3 frame that has the timecode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#timedMetadataId3Frame
   */
  readonly timedMetadataId3Frame?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#timedMetadataId3Period
   */
  readonly timedMetadataId3Period?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#timestampDeltaMilliseconds
   */
  readonly timestampDeltaMilliseconds?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings#tsFileMode
   */
  readonly tsFileMode?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adMarkers': obj.adMarkers?.map(y => y),
    'baseUrlContent': obj.baseUrlContent,
    'baseUrlContent1': obj.baseUrlContent1,
    'baseUrlManifest': obj.baseUrlManifest,
    'baseUrlManifest1': obj.baseUrlManifest1,
    'captionLanguageMappings': obj.captionLanguageMappings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappings(y)),
    'captionLanguageSetting': obj.captionLanguageSetting,
    'clientCache': obj.clientCache,
    'codecSpecification': obj.codecSpecification,
    'constantIv': obj.constantIv,
    'destination': obj.destination?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsDestination(y)),
    'directoryStructure': obj.directoryStructure,
    'discontinuityTags': obj.discontinuityTags,
    'encryptionType': obj.encryptionType,
    'hlsCdnSettings': obj.hlsCdnSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings(y)),
    'hlsId3SegmentTagging': obj.hlsId3SegmentTagging,
    'iframeOnlyPlaylists': obj.iframeOnlyPlaylists,
    'incompleteSegmentBehavior': obj.incompleteSegmentBehavior,
    'indexNSegments': obj.indexNSegments,
    'inputLossAction': obj.inputLossAction,
    'ivInManifest': obj.ivInManifest,
    'ivSource': obj.ivSource,
    'keepSegments': obj.keepSegments,
    'keyFormat': obj.keyFormat,
    'keyFormatVersions': obj.keyFormatVersions,
    'keyProviderSettings': obj.keyProviderSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettings(y)),
    'manifestCompression': obj.manifestCompression,
    'manifestDurationFormat': obj.manifestDurationFormat,
    'minSegmentLength': obj.minSegmentLength,
    'mode': obj.mode,
    'outputSelection': obj.outputSelection,
    'programDateTime': obj.programDateTime,
    'programDateTimeClock': obj.programDateTimeClock,
    'programDateTimePeriod': obj.programDateTimePeriod,
    'redundantManifest': obj.redundantManifest,
    'segmentLength': obj.segmentLength,
    'segmentsPerSubdirectory': obj.segmentsPerSubdirectory,
    'streamInfResolution': obj.streamInfResolution,
    'timedMetadataId3Frame': obj.timedMetadataId3Frame,
    'timedMetadataId3Period': obj.timedMetadataId3Period,
    'timestampDeltaMilliseconds': obj.timestampDeltaMilliseconds,
    'tsFileMode': obj.tsFileMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettings {
  /**
   * A director and base filename where archive files should be written. See Destination for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettings#destination
   */
  readonly destination: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettingsDestination[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettingsDestination(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings {
  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#acquisitionPointId
   */
  readonly acquisitionPointId?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#audioOnlyTimecodeControl
   */
  readonly audioOnlyTimecodeControl?: string;

  /**
   * Setting to allow self signed or verified RTMP certificates.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#certificateMode
   */
  readonly certificateMode?: string;

  /**
   * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#connectionRetryInterval
   */
  readonly connectionRetryInterval?: number;

  /**
   * A director and base filename where archive files should be written. See Destination for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#destination
   */
  readonly destination: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettingsDestination[];

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#eventId
   */
  readonly eventId?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#eventIdMode
   */
  readonly eventIdMode?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#eventStopBehavior
   */
  readonly eventStopBehavior?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#filecacheDuration
   */
  readonly filecacheDuration?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#fragmentLength
   */
  readonly fragmentLength?: number;

  /**
   * Controls the behavior of the RTMP group if input becomes unavailable.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#inputLossAction
   */
  readonly inputLossAction?: string;

  /**
   * Number of retry attempts.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#numRetries
   */
  readonly numRetries?: number;

  /**
   * Number of seconds to wait until a restart is initiated.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#restartDelay
   */
  readonly restartDelay?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#segmentationMode
   */
  readonly segmentationMode?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#sendDelayMs
   */
  readonly sendDelayMs?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#sparseTrackType
   */
  readonly sparseTrackType?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#streamManifestBehavior
   */
  readonly streamManifestBehavior?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#timestampOffset
   */
  readonly timestampOffset?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings#timestampOffsetMode
   */
  readonly timestampOffsetMode?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acquisitionPointId': obj.acquisitionPointId,
    'audioOnlyTimecodeControl': obj.audioOnlyTimecodeControl,
    'certificateMode': obj.certificateMode,
    'connectionRetryInterval': obj.connectionRetryInterval,
    'destination': obj.destination?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettingsDestination(y)),
    'eventId': obj.eventId,
    'eventIdMode': obj.eventIdMode,
    'eventStopBehavior': obj.eventStopBehavior,
    'filecacheDuration': obj.filecacheDuration,
    'fragmentLength': obj.fragmentLength,
    'inputLossAction': obj.inputLossAction,
    'numRetries': obj.numRetries,
    'restartDelay': obj.restartDelay,
    'segmentationMode': obj.segmentationMode,
    'sendDelayMs': obj.sendDelayMs,
    'sparseTrackType': obj.sparseTrackType,
    'streamManifestBehavior': obj.streamManifestBehavior,
    'timestampOffset': obj.timestampOffset,
    'timestampOffsetMode': obj.timestampOffsetMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings {
  /**
   * The ad marker type for this output group.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings#adMarkers
   */
  readonly adMarkers?: string[];

  /**
   * Authentication scheme to use when connecting with CDN.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings#authenticationScheme
   */
  readonly authenticationScheme?: string;

  /**
   * Controls behavior when content cache fills up.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings#cacheFullBehavior
   */
  readonly cacheFullBehavior?: string;

  /**
   * Cache length in seconds, is used to calculate buffer size.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings#cacheLength
   */
  readonly cacheLength?: number;

  /**
   * Controls the types of data that passes to onCaptionInfo outputs.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings#captionData
   */
  readonly captionData?: string;

  /**
   * Controls the behavior of the RTMP group if input becomes unavailable.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings#inputLossAction
   */
  readonly inputLossAction?: string;

  /**
   * Number of seconds to wait until a restart is initiated.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings#restartDelay
   */
  readonly restartDelay?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsRtmpGroupSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adMarkers': obj.adMarkers?.map(y => y),
    'authenticationScheme': obj.authenticationScheme,
    'cacheFullBehavior': obj.cacheFullBehavior,
    'cacheLength': obj.cacheLength,
    'captionData': obj.captionData,
    'inputLossAction': obj.inputLossAction,
    'restartDelay': obj.restartDelay,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsUdpGroupSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsUdpGroupSettings {
  /**
   * Controls the behavior of the RTMP group if input becomes unavailable.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsUdpGroupSettings#inputLossAction
   */
  readonly inputLossAction?: string;

  /**
   * Indicates ID3 frame that has the timecode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsUdpGroupSettings#timedMetadataId3Frame
   */
  readonly timedMetadataId3Frame?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsUdpGroupSettings#timedMetadataId3Period
   */
  readonly timedMetadataId3Period?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsUdpGroupSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsUdpGroupSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsUdpGroupSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputLossAction': obj.inputLossAction,
    'timedMetadataId3Frame': obj.timedMetadataId3Frame,
    'timedMetadataId3Period': obj.timedMetadataId3Period,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings {
  /**
   * Archive output settings. See Archive Output Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings#archiveOutputSettings
   */
  readonly archiveOutputSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettings[];

  /**
   * Settings for output. See Output Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings#frameCaptureOutputSettings
   */
  readonly frameCaptureOutputSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsFrameCaptureOutputSettings[];

  /**
   * Settings for output. See Output Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings#hlsOutputSettings
   */
  readonly hlsOutputSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings[];

  /**
   * Media package output settings. This can be set as an empty block.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings#mediaPackageOutputSettings
   */
  readonly mediaPackageOutputSettings?: any[];

  /**
   * Settings for output. See Output Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings#msSmoothOutputSettings
   */
  readonly msSmoothOutputSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMsSmoothOutputSettings[];

  /**
   * Multiplex output settings. See Multiplex Output Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings#multiplexOutputSettings
   */
  readonly multiplexOutputSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettings[];

  /**
   * RTMP output settings. See RTMP Output Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings#rtmpOutputSettings
   */
  readonly rtmpOutputSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings[];

  /**
   * UDP output settings. See UDP Output Settings for more details
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings#udpOutputSettings
   */
  readonly udpOutputSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'archiveOutputSettings': obj.archiveOutputSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettings(y)),
    'frameCaptureOutputSettings': obj.frameCaptureOutputSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsFrameCaptureOutputSettings(y)),
    'hlsOutputSettings': obj.hlsOutputSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings(y)),
    'mediaPackageOutputSettings': obj.mediaPackageOutputSettings?.map(y => y),
    'msSmoothOutputSettings': obj.msSmoothOutputSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMsSmoothOutputSettings(y)),
    'multiplexOutputSettings': obj.multiplexOutputSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettings(y)),
    'rtmpOutputSettings': obj.rtmpOutputSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings(y)),
    'udpOutputSettings': obj.udpOutputSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsFrameCaptureSettings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsFrameCaptureSettings {
  /**
   * The frequency at which to capture frames for inclusion in the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsFrameCaptureSettings#captureInterval
   */
  readonly captureInterval?: number;

  /**
   * Unit for the frame capture interval.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsFrameCaptureSettings#captureIntervalUnits
   */
  readonly captureIntervalUnits?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsFrameCaptureSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsFrameCaptureSettings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsFrameCaptureSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'captureInterval': obj.captureInterval,
    'captureIntervalUnits': obj.captureIntervalUnits,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings {
  /**
   * Enables or disables adaptive quantization.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#adaptiveQuantization
   */
  readonly adaptiveQuantization?: string;

  /**
   * Indicates that AFD values will be written into the output stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#afdSignaling
   */
  readonly afdSignaling?: string;

  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#bitrate
   */
  readonly bitrate?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#bufFillPct
   */
  readonly bufFillPct?: number;

  /**
   * Size of buffer in bits.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#bufSize
   */
  readonly bufSize?: number;

  /**
   * Includes color space metadata in the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#colorMetadata
   */
  readonly colorMetadata?: string;

  /**
   * Entropy encoding mode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#entropyEncoding
   */
  readonly entropyEncoding?: string;

  /**
   * Filters to apply to an encode. See H264 Filter Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#filterSettings
   */
  readonly filterSettings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettings[];

  /**
   * Four bit AFD value to write on all frames of video in the output stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#fixedAfd
   */
  readonly fixedAfd?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#flickerAq
   */
  readonly flickerAq?: string;

  /**
   * Controls whether coding is performed on a field basis or on a frame basis.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#forceFieldPictures
   */
  readonly forceFieldPictures?: string;

  /**
   * Indicates how the output video frame rate is specified.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#framerateControl
   */
  readonly framerateControl?: string;

  /**
   * Framerate denominator.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#framerateDenominator
   */
  readonly framerateDenominator?: number;

  /**
   * Framerate numerator.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#framerateNumerator
   */
  readonly framerateNumerator?: number;

  /**
   * GOP-B reference.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#gopBReference
   */
  readonly gopBReference?: string;

  /**
   * Frequency of closed GOPs.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#gopClosedCadence
   */
  readonly gopClosedCadence?: number;

  /**
   * Number of B-frames between reference frames.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#gopNumBFrames
   */
  readonly gopNumBFrames?: number;

  /**
   * GOP size in units of either frames of seconds per gop_size_units.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#gopSize
   */
  readonly gopSize?: number;

  /**
   * Indicates if the gop_size is specified in frames or seconds.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#gopSizeUnits
   */
  readonly gopSizeUnits?: string;

  /**
   * H264 level.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#level
   */
  readonly level?: string;

  /**
   * Amount of lookahead.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#lookAheadRateControl
   */
  readonly lookAheadRateControl?: string;

  /**
   * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#maxBitrate
   */
  readonly maxBitrate?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#minIInterval
   */
  readonly minIInterval?: number;

  /**
   * Number of reference frames to use.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#numRefFrames
   */
  readonly numRefFrames?: number;

  /**
   * Indicates how the output pixel aspect ratio is specified.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#parControl
   */
  readonly parControl?: string;

  /**
   * Pixel Aspect Ratio denominator.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#parDenominator
   */
  readonly parDenominator?: number;

  /**
   * Pixel Aspect Ratio numerator.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#parNumerator
   */
  readonly parNumerator?: number;

  /**
   * AAC profile.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#profile
   */
  readonly profile?: string;

  /**
   * Quality level.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#qualityLevel
   */
  readonly qualityLevel?: string;

  /**
   * Controls the target quality for the video encode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#qvbrQualityLevel
   */
  readonly qvbrQualityLevel?: number;

  /**
   * The rate control mode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#rateControlMode
   */
  readonly rateControlMode?: string;

  /**
   * Sets the scan type of the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#scanType
   */
  readonly scanType?: string;

  /**
   * Scene change detection.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#sceneChangeDetect
   */
  readonly sceneChangeDetect?: string;

  /**
   * Number of slices per picture.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#slices
   */
  readonly slices?: number;

  /**
   * Softness.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#softness
   */
  readonly softness?: number;

  /**
   * Makes adjustments within each frame based on spatial variation of content complexity.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#spatialAq
   */
  readonly spatialAq?: string;

  /**
   * Subgop length.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#subgopLength
   */
  readonly subgopLength?: string;

  /**
   * Produces a bitstream compliant with SMPTE RP-2027.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#syntax
   */
  readonly syntax?: string;

  /**
   * Makes adjustments within each frame based on temporal variation of content complexity.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#temporalAq
   */
  readonly temporalAq?: string;

  /**
   * Determines how timecodes should be inserted into the video elementary stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings#timecodeInsertion
   */
  readonly timecodeInsertion?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adaptiveQuantization': obj.adaptiveQuantization,
    'afdSignaling': obj.afdSignaling,
    'bitrate': obj.bitrate,
    'bufFillPct': obj.bufFillPct,
    'bufSize': obj.bufSize,
    'colorMetadata': obj.colorMetadata,
    'entropyEncoding': obj.entropyEncoding,
    'filterSettings': obj.filterSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettings(y)),
    'fixedAfd': obj.fixedAfd,
    'flickerAq': obj.flickerAq,
    'forceFieldPictures': obj.forceFieldPictures,
    'framerateControl': obj.framerateControl,
    'framerateDenominator': obj.framerateDenominator,
    'framerateNumerator': obj.framerateNumerator,
    'gopBReference': obj.gopBReference,
    'gopClosedCadence': obj.gopClosedCadence,
    'gopNumBFrames': obj.gopNumBFrames,
    'gopSize': obj.gopSize,
    'gopSizeUnits': obj.gopSizeUnits,
    'level': obj.level,
    'lookAheadRateControl': obj.lookAheadRateControl,
    'maxBitrate': obj.maxBitrate,
    'minIInterval': obj.minIInterval,
    'numRefFrames': obj.numRefFrames,
    'parControl': obj.parControl,
    'parDenominator': obj.parDenominator,
    'parNumerator': obj.parNumerator,
    'profile': obj.profile,
    'qualityLevel': obj.qualityLevel,
    'qvbrQualityLevel': obj.qvbrQualityLevel,
    'rateControlMode': obj.rateControlMode,
    'scanType': obj.scanType,
    'sceneChangeDetect': obj.sceneChangeDetect,
    'slices': obj.slices,
    'softness': obj.softness,
    'spatialAq': obj.spatialAq,
    'subgopLength': obj.subgopLength,
    'syntax': obj.syntax,
    'temporalAq': obj.temporalAq,
    'timecodeInsertion': obj.timecodeInsertion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings {
  /**
   * Enables or disables adaptive quantization.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#adaptiveQuantization
   */
  readonly adaptiveQuantization?: string;

  /**
   * Indicates that AFD values will be written into the output stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#afdSignaling
   */
  readonly afdSignaling?: string;

  /**
   * Whether or not EML should insert an Alternative Transfer Function SEI message.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#alternativeTransferFunction
   */
  readonly alternativeTransferFunction?: string;

  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#bitrate
   */
  readonly bitrate: number;

  /**
   * Size of buffer in bits.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#bufSize
   */
  readonly bufSize?: number;

  /**
   * Includes color space metadata in the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#colorMetadata
   */
  readonly colorMetadata?: string;

  /**
   * Define the color metadata for the output. H265 Color Space Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#colorSpaceSettings
   */
  readonly colorSpaceSettings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings[];

  /**
   * Filters to apply to an encode. See H264 Filter Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#filterSettings
   */
  readonly filterSettings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettings[];

  /**
   * Four bit AFD value to write on all frames of video in the output stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#fixedAfd
   */
  readonly fixedAfd?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#flickerAq
   */
  readonly flickerAq?: string;

  /**
   * Framerate denominator.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#framerateDenominator
   */
  readonly framerateDenominator: number;

  /**
   * Framerate numerator.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#framerateNumerator
   */
  readonly framerateNumerator: number;

  /**
   * Frequency of closed GOPs.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#gopClosedCadence
   */
  readonly gopClosedCadence?: number;

  /**
   * GOP size in units of either frames of seconds per gop_size_units.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#gopSize
   */
  readonly gopSize?: number;

  /**
   * Indicates if the gop_size is specified in frames or seconds.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#gopSizeUnits
   */
  readonly gopSizeUnits?: string;

  /**
   * H264 level.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#level
   */
  readonly level?: string;

  /**
   * Amount of lookahead.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#lookAheadRateControl
   */
  readonly lookAheadRateControl?: string;

  /**
   * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#maxBitrate
   */
  readonly maxBitrate?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#minIInterval
   */
  readonly minIInterval?: number;

  /**
   * Pixel Aspect Ratio denominator.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#parDenominator
   */
  readonly parDenominator?: number;

  /**
   * Pixel Aspect Ratio numerator.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#parNumerator
   */
  readonly parNumerator?: number;

  /**
   * AAC profile.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#profile
   */
  readonly profile?: string;

  /**
   * Controls the target quality for the video encode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#qvbrQualityLevel
   */
  readonly qvbrQualityLevel?: number;

  /**
   * The rate control mode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#rateControlMode
   */
  readonly rateControlMode?: string;

  /**
   * Sets the scan type of the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#scanType
   */
  readonly scanType?: string;

  /**
   * Scene change detection.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#sceneChangeDetect
   */
  readonly sceneChangeDetect?: string;

  /**
   * Number of slices per picture.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#slices
   */
  readonly slices?: number;

  /**
   * Set the H265 tier in the output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#tier
   */
  readonly tier?: string;

  /**
   * Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#timecodeBurninSettings
   */
  readonly timecodeBurninSettings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsTimecodeBurninSettings[];

  /**
   * Determines how timecodes should be inserted into the video elementary stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings#timecodeInsertion
   */
  readonly timecodeInsertion?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adaptiveQuantization': obj.adaptiveQuantization,
    'afdSignaling': obj.afdSignaling,
    'alternativeTransferFunction': obj.alternativeTransferFunction,
    'bitrate': obj.bitrate,
    'bufSize': obj.bufSize,
    'colorMetadata': obj.colorMetadata,
    'colorSpaceSettings': obj.colorSpaceSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings(y)),
    'filterSettings': obj.filterSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettings(y)),
    'fixedAfd': obj.fixedAfd,
    'flickerAq': obj.flickerAq,
    'framerateDenominator': obj.framerateDenominator,
    'framerateNumerator': obj.framerateNumerator,
    'gopClosedCadence': obj.gopClosedCadence,
    'gopSize': obj.gopSize,
    'gopSizeUnits': obj.gopSizeUnits,
    'level': obj.level,
    'lookAheadRateControl': obj.lookAheadRateControl,
    'maxBitrate': obj.maxBitrate,
    'minIInterval': obj.minIInterval,
    'parDenominator': obj.parDenominator,
    'parNumerator': obj.parNumerator,
    'profile': obj.profile,
    'qvbrQualityLevel': obj.qvbrQualityLevel,
    'rateControlMode': obj.rateControlMode,
    'scanType': obj.scanType,
    'sceneChangeDetect': obj.sceneChangeDetect,
    'slices': obj.slices,
    'tier': obj.tier,
    'timecodeBurninSettings': obj.timecodeBurninSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsTimecodeBurninSettings(y)),
    'timecodeInsertion': obj.timecodeInsertion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings
 */
export interface ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings {
  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings#audioSilenceSettings
   */
  readonly audioSilenceSettings?: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings#inputLossSettings
   */
  readonly inputLossSettings?: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings#videoBlackSettings
   */
  readonly videoBlackSettings?: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings(obj: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioSilenceSettings': obj.audioSilenceSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings(y)),
    'inputLossSettings': obj.inputLossSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings(y)),
    'videoBlackSettings': obj.videoBlackSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ChannelSpecForProviderInputAttachmentsInputIdRefPolicyResolution
 */
export enum ChannelSpecForProviderInputAttachmentsInputIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ChannelSpecForProviderInputAttachmentsInputIdRefPolicyResolve
 */
export enum ChannelSpecForProviderInputAttachmentsInputIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicyResolution
 */
export enum ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicyResolve
 */
export enum ChannelSpecForProviderInputAttachmentsInputIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings#audioHlsRenditionSelection
   */
  readonly audioHlsRenditionSelection?: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection[];

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings#audioLanguageSelection
   */
  readonly audioLanguageSelection?: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection[];

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings#audioPidSelection
   */
  readonly audioPidSelection?: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioPidSelection[];

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings#audioTrackSelection
   */
  readonly audioTrackSelection?: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioHlsRenditionSelection': obj.audioHlsRenditionSelection?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection(y)),
    'audioLanguageSelection': obj.audioLanguageSelection?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection(y)),
    'audioPidSelection': obj.audioPidSelection?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioPidSelection(y)),
    'audioTrackSelection': obj.audioTrackSelection?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings {
  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings#ancillarySourceSettings
   */
  readonly ancillarySourceSettings?: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings#dvbTdtSettings
   */
  readonly dvbTdtSettings?: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings#embeddedSourceSettings
   */
  readonly embeddedSourceSettings?: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings#scte20SourceSettings
   */
  readonly scte20SourceSettings?: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings#scte27SourceSettings
   */
  readonly scte27SourceSettings?: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings#teletextSourceSettings
   */
  readonly teletextSourceSettings?: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ancillarySourceSettings': obj.ancillarySourceSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings(y)),
    'dvbTdtSettings': obj.dvbTdtSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings(y)),
    'embeddedSourceSettings': obj.embeddedSourceSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings(y)),
    'scte20SourceSettings': obj.scte20SourceSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings(y)),
    'scte27SourceSettings': obj.scte27SourceSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings(y)),
    'teletextSourceSettings': obj.teletextSourceSettings?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings {
  /**
   * The bitrate is specified in bits per second, as in an HLS manifest.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings#bandwidth
   */
  readonly bandwidth?: number;

  /**
   * Buffer segments.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings#bufferSegments
   */
  readonly bufferSegments?: number;

  /**
   * The number of consecutive times that attempts to read a manifest or segment must fail before the input is considered unavailable.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings#retries
   */
  readonly retries?: number;

  /**
   * The number of seconds between retries when an attempt to read a manifest or segment fails.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings#retryInterval
   */
  readonly retryInterval?: number;

  /**
   * The source for the timecode that will be associated with the events outputs.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings#scte35Source
   */
  readonly scte35Source?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettingsNetworkInputSettingsHlsInputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bandwidth': obj.bandwidth,
    'bufferSegments': obj.bufferSegments,
    'retries': obj.retries,
    'retryInterval': obj.retryInterval,
    'scte35Source': obj.scte35Source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings#cbetCheckDigitString
   */
  readonly cbetCheckDigitString: string;

  /**
   * Determines the method of CBET insertion mode when prior encoding is detected on the same layer.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings#cbetStepaside
   */
  readonly cbetStepaside: string;

  /**
   * CBET source ID to use in the watermark.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings#csid
   */
  readonly csid: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cbetCheckDigitString': obj.cbetCheckDigitString,
    'cbetStepaside': obj.cbetStepaside,
    'csid': obj.csid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettings
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettings#checkDigitString
   */
  readonly checkDigitString: string;

  /**
   * The Nielsen Source ID to include in the watermark.
   *
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettings#sid
   */
  readonly sid: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettings(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkDigitString': obj.checkDigitString,
    'sid': obj.sid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappingsInputChannelLevels
 */
export interface ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappingsInputChannelLevels {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappingsInputChannelLevels#gain
   */
  readonly gain: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappingsInputChannelLevels#inputChannel
   */
  readonly inputChannel: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappingsInputChannelLevels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappingsInputChannelLevels(obj: ChannelSpecForProviderEncoderSettingsAudioDescriptionsRemixSettingsChannelMappingsInputChannelLevels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gain': obj.gain,
    'inputChannel': obj.inputChannel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettings {
  /**
   * Archive S3 Settings. See Archive S3 Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettings#archiveS3Settings
   */
  readonly archiveS3Settings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettingsArchiveS3Settings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'archiveS3Settings': obj.archiveS3Settings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettingsArchiveS3Settings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsDestination
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsDestination {
  /**
   * Reference ID for the destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsDestination#destinationRefId
   */
  readonly destinationRefId: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsDestination(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationRefId': obj.destinationRefId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsDestination
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsDestination {
  /**
   * Reference ID for the destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsDestination#destinationRefId
   */
  readonly destinationRefId: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsDestination(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationRefId': obj.destinationRefId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings {
  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings#frameCaptureS3Settings
   */
  readonly frameCaptureS3Settings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frameCaptureS3Settings': obj.frameCaptureS3Settings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappings#captionChannel
   */
  readonly captionChannel: number;

  /**
   * When specified this field indicates the three letter language code of the caption track to extract from the source.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappings#languageCode
   */
  readonly languageCode: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappings#languageDescription
   */
  readonly languageDescription: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsCaptionLanguageMappings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'captionChannel': obj.captionChannel,
    'languageCode': obj.languageCode,
    'languageDescription': obj.languageDescription,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsDestination
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsDestination {
  /**
   * Reference ID for the destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsDestination#destinationRefId
   */
  readonly destinationRefId: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsDestination(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationRefId': obj.destinationRefId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings {
  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings#hlsAkamaiSettings
   */
  readonly hlsAkamaiSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings#hlsBasicPutSettings
   */
  readonly hlsBasicPutSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings#hlsMediaStoreSettings
   */
  readonly hlsMediaStoreSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings#hlsS3Settings
   */
  readonly hlsS3Settings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsS3Settings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings#hlsWebdavSettings
   */
  readonly hlsWebdavSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hlsAkamaiSettings': obj.hlsAkamaiSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings(y)),
    'hlsBasicPutSettings': obj.hlsBasicPutSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings(y)),
    'hlsMediaStoreSettings': obj.hlsMediaStoreSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings(y)),
    'hlsS3Settings': obj.hlsS3Settings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsS3Settings(y)),
    'hlsWebdavSettings': obj.hlsWebdavSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettings {
  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettings#staticKeySettings
   */
  readonly staticKeySettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'staticKeySettings': obj.staticKeySettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettingsDestination
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettingsDestination {
  /**
   * Reference ID for the destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettingsDestination#destinationRefId
   */
  readonly destinationRefId: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettingsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettingsDestination(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMediaPackageGroupSettingsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationRefId': obj.destinationRefId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettingsDestination
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettingsDestination {
  /**
   * Reference ID for the destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettingsDestination#destinationRefId
   */
  readonly destinationRefId: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettingsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettingsDestination(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsMsSmoothGroupSettingsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationRefId': obj.destinationRefId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettings {
  /**
   * Settings specific to the container type of the file. See Container Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettings#containerSettings
   */
  readonly containerSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettings[];

  /**
   * Output file extension.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettings#extension
   */
  readonly extension?: string;

  /**
   * String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettings#nameModifier
   */
  readonly nameModifier?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerSettings': obj.containerSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettings(y)),
    'extension': obj.extension,
    'nameModifier': obj.nameModifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsFrameCaptureOutputSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsFrameCaptureOutputSettings {
  /**
   * String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsFrameCaptureOutputSettings#nameModifier
   */
  readonly nameModifier?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsFrameCaptureOutputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsFrameCaptureOutputSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsFrameCaptureOutputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameModifier': obj.nameModifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings#h265PackagingType
   */
  readonly h265PackagingType?: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings#hlsSettings
   */
  readonly hlsSettings: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings[];

  /**
   * String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings#nameModifier
   */
  readonly nameModifier?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings#segmentModifier
   */
  readonly segmentModifier?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h265PackagingType': obj.h265PackagingType,
    'hlsSettings': obj.hlsSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings(y)),
    'nameModifier': obj.nameModifier,
    'segmentModifier': obj.segmentModifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMsSmoothOutputSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMsSmoothOutputSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMsSmoothOutputSettings#h265PackagingType
   */
  readonly h265PackagingType?: string;

  /**
   * String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMsSmoothOutputSettings#nameModifier
   */
  readonly nameModifier?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMsSmoothOutputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMsSmoothOutputSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMsSmoothOutputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h265PackagingType': obj.h265PackagingType,
    'nameModifier': obj.nameModifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettings {
  /**
   * A director and base filename where archive files should be written. See Destination for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettings#destination
   */
  readonly destination: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettingsDestination[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettingsDestination(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings {
  /**
   * Setting to allow self signed or verified RTMP certificates.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings#certificateMode
   */
  readonly certificateMode?: string;

  /**
   * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings#connectionRetryInterval
   */
  readonly connectionRetryInterval?: number;

  /**
   * A director and base filename where archive files should be written. See Destination for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings#destination
   */
  readonly destination: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettingsDestination[];

  /**
   * Number of retry attempts.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings#numRetries
   */
  readonly numRetries?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateMode': obj.certificateMode,
    'connectionRetryInterval': obj.connectionRetryInterval,
    'destination': obj.destination?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettingsDestination(y)),
    'numRetries': obj.numRetries,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings {
  /**
   * UDP output buffering in milliseconds.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings#bufferMsec
   */
  readonly bufferMsec?: number;

  /**
   * Settings specific to the container type of the file. See Container Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings#containerSettings
   */
  readonly containerSettings: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettings[];

  /**
   * A director and base filename where archive files should be written. See Destination for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings#destination
   */
  readonly destination: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsDestination[];

  /**
   * Settings for output. See Output Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings#fecOutputSettings
   */
  readonly fecOutputSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsFecOutputSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferMsec': obj.bufferMsec,
    'containerSettings': obj.containerSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettings(y)),
    'destination': obj.destination?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsDestination(y)),
    'fecOutputSettings': obj.fecOutputSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsFecOutputSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettings {
  /**
   * Temporal filter settings. See Temporal Filter Settings
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettings#temporalFilterSettings
   */
  readonly temporalFilterSettings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'temporalFilterSettings': obj.temporalFilterSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings {
  /**
   * Sets the colorspace metadata to be passed through.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings#colorSpacePassthroughSettings
   */
  readonly colorSpacePassthroughSettings?: any[];

  /**
   * Set the colorspace to Dolby Vision81.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings#dolbyVision81Settings
   */
  readonly dolbyVision81Settings?: any[];

  /**
   * Set the colorspace to be HDR10. See H265 HDR10 Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings#hdr10Settings
   */
  readonly hdr10Settings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings[];

  /**
   * Set the colorspace to Rec. 601.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings#rec601Settings
   */
  readonly rec601Settings?: any[];

  /**
   * Set the colorspace to Rec. 709.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings#rec709Settings
   */
  readonly rec709Settings?: any[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'colorSpacePassthroughSettings': obj.colorSpacePassthroughSettings?.map(y => y),
    'dolbyVision81Settings': obj.dolbyVision81Settings?.map(y => y),
    'hdr10Settings': obj.hdr10Settings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings(y)),
    'rec601Settings': obj.rec601Settings?.map(y => y),
    'rec709Settings': obj.rec709Settings?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettings {
  /**
   * Temporal filter settings. See Temporal Filter Settings
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettings#temporalFilterSettings
   */
  readonly temporalFilterSettings?: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'temporalFilterSettings': obj.temporalFilterSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsTimecodeBurninSettings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsTimecodeBurninSettings {
  /**
   * Set a prefix on the burned in timecode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsTimecodeBurninSettings#prefix
   */
  readonly prefix?: string;

  /**
   * Sets the size of the burned in timecode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsTimecodeBurninSettings#timecodeBurninFontSize
   */
  readonly timecodeBurninFontSize?: string;

  /**
   * Sets the position of the burned in timecode.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsTimecodeBurninSettings#timecodeBurninPosition
   */
  readonly timecodeBurninPosition?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsTimecodeBurninSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsTimecodeBurninSettings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsTimecodeBurninSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'timecodeBurninFontSize': obj.timecodeBurninFontSize,
    'timecodeBurninPosition': obj.timecodeBurninPosition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings
 */
export interface ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings {
  /**
   * The name of the audio selector used as the source for this AudioDescription.
   *
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings#audioSelectorName
   */
  readonly audioSelectorName: string;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings#audioSilenceThresholdMsec
   */
  readonly audioSilenceThresholdMsec?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings(obj: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioSelectorName': obj.audioSelectorName,
    'audioSilenceThresholdMsec': obj.audioSilenceThresholdMsec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings
 */
export interface ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings#inputLossThresholdMsec
   */
  readonly inputLossThresholdMsec?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings(obj: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputLossThresholdMsec': obj.inputLossThresholdMsec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings
 */
export interface ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings#blackDetectThreshold
   */
  readonly blackDetectThreshold?: number;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings#videoBlackThresholdMsec
   */
  readonly videoBlackThresholdMsec?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings(obj: ChannelSpecForProviderInputAttachmentsAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blackDetectThreshold': obj.blackDetectThreshold,
    'videoBlackThresholdMsec': obj.videoBlackThresholdMsec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection {
  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection#groupId
   */
  readonly groupId: string;

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection(obj: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupId': obj.groupId,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection {
  /**
   * When specified this field indicates the three letter language code of the caption track to extract from the source.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection#languageCode
   */
  readonly languageCode: string;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection#languageSelectionPolicy
   */
  readonly languageSelectionPolicy?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection(obj: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'languageCode': obj.languageCode,
    'languageSelectionPolicy': obj.languageSelectionPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioPidSelection
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioPidSelection {
  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioPidSelection#pid
   */
  readonly pid: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioPidSelection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioPidSelection(obj: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioPidSelection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pid': obj.pid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection#track
   */
  readonly track: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection(obj: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'track': obj.track?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings#sourceAncillaryChannelNumber
   */
  readonly sourceAncillaryChannelNumber?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sourceAncillaryChannelNumber': obj.sourceAncillaryChannelNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings#ocrLanguage
   */
  readonly ocrLanguage?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings#pid
   */
  readonly pid?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsDvbTdtSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ocrLanguage': obj.ocrLanguage,
    'pid': obj.pid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings#convert608To708
   */
  readonly convert608To708?: string;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings#scte20Detection
   */
  readonly scte20Detection?: string;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings#source608ChannelNumber
   */
  readonly source608ChannelNumber?: number;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings#source608TrackNumber
   */
  readonly source608TrackNumber?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert608To708': obj.convert608To708,
    'scte20Detection': obj.scte20Detection,
    'source608ChannelNumber': obj.source608ChannelNumber,
    'source608TrackNumber': obj.source608TrackNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings#convert608To708
   */
  readonly convert608To708?: string;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings#source608ChannelNumber
   */
  readonly source608ChannelNumber?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert608To708': obj.convert608To708,
    'source608ChannelNumber': obj.source608ChannelNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings#ocrLanguage
   */
  readonly ocrLanguage?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings#pid
   */
  readonly pid?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ocrLanguage': obj.ocrLanguage,
    'pid': obj.pid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings#outputRectangle
   */
  readonly outputRectangle?: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle[];

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings#pageNumber
   */
  readonly pageNumber?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings(obj: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputRectangle': obj.outputRectangle?.map(y => toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle(y)),
    'pageNumber': obj.pageNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettingsArchiveS3Settings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettingsArchiveS3Settings {
  /**
   * Specify the canned ACL to apply to each S3 request.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettingsArchiveS3Settings#cannedAcl
   */
  readonly cannedAcl?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettingsArchiveS3Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettingsArchiveS3Settings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsArchiveGroupSettingsArchiveCdnSettingsArchiveS3Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cannedAcl': obj.cannedAcl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings {
  /**
   * Specify the canned ACL to apply to each S3 request.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings#cannedAcl
   */
  readonly cannedAcl?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cannedAcl': obj.cannedAcl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings {
  /**
   * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings#connectionRetryInterval
   */
  readonly connectionRetryInterval?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings#filecacheDuration
   */
  readonly filecacheDuration?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings#httpTransferMode
   */
  readonly httpTransferMode?: string;

  /**
   * Number of retry attempts.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings#numRetries
   */
  readonly numRetries?: number;

  /**
   * Number of seconds to wait until a restart is initiated.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings#restartDelay
   */
  readonly restartDelay?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings#salt
   */
  readonly salt?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings#token
   */
  readonly token?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsAkamaiSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionRetryInterval': obj.connectionRetryInterval,
    'filecacheDuration': obj.filecacheDuration,
    'httpTransferMode': obj.httpTransferMode,
    'numRetries': obj.numRetries,
    'restartDelay': obj.restartDelay,
    'salt': obj.salt,
    'token': obj.token,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings {
  /**
   * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings#connectionRetryInterval
   */
  readonly connectionRetryInterval?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings#filecacheDuration
   */
  readonly filecacheDuration?: number;

  /**
   * Number of retry attempts.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings#numRetries
   */
  readonly numRetries?: number;

  /**
   * Number of seconds to wait until a restart is initiated.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings#restartDelay
   */
  readonly restartDelay?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsBasicPutSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionRetryInterval': obj.connectionRetryInterval,
    'filecacheDuration': obj.filecacheDuration,
    'numRetries': obj.numRetries,
    'restartDelay': obj.restartDelay,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings {
  /**
   * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings#connectionRetryInterval
   */
  readonly connectionRetryInterval?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings#filecacheDuration
   */
  readonly filecacheDuration?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings#mediaStoreStorageClass
   */
  readonly mediaStoreStorageClass?: string;

  /**
   * Number of retry attempts.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings#numRetries
   */
  readonly numRetries?: number;

  /**
   * Number of seconds to wait until a restart is initiated.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings#restartDelay
   */
  readonly restartDelay?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsMediaStoreSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionRetryInterval': obj.connectionRetryInterval,
    'filecacheDuration': obj.filecacheDuration,
    'mediaStoreStorageClass': obj.mediaStoreStorageClass,
    'numRetries': obj.numRetries,
    'restartDelay': obj.restartDelay,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsS3Settings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsS3Settings {
  /**
   * Specify the canned ACL to apply to each S3 request.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsS3Settings#cannedAcl
   */
  readonly cannedAcl?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsS3Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsS3Settings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsS3Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cannedAcl': obj.cannedAcl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings {
  /**
   * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings#connectionRetryInterval
   */
  readonly connectionRetryInterval?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings#filecacheDuration
   */
  readonly filecacheDuration?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings#httpTransferMode
   */
  readonly httpTransferMode?: string;

  /**
   * Number of retry attempts.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings#numRetries
   */
  readonly numRetries?: number;

  /**
   * Number of seconds to wait until a restart is initiated.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings#restartDelay
   */
  readonly restartDelay?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsHlsCdnSettingsHlsWebdavSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionRetryInterval': obj.connectionRetryInterval,
    'filecacheDuration': obj.filecacheDuration,
    'httpTransferMode': obj.httpTransferMode,
    'numRetries': obj.numRetries,
    'restartDelay': obj.restartDelay,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettings#keyProviderServer
   */
  readonly keyProviderServer?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingsKeyProviderServer[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettings#staticKeyValue
   */
  readonly staticKeyValue: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyProviderServer': obj.keyProviderServer?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingsKeyProviderServer(y)),
    'staticKeyValue': obj.staticKeyValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettings {
  /**
   * M2ts Settings. See M2ts Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettings#m2tsSettings
   */
  readonly m2TsSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings[];

  /**
   * Raw Settings. This can be set as an empty block.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettings#rawSettings
   */
  readonly rawSettings?: any[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'm2tsSettings': obj.m2TsSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings(y)),
    'rawSettings': obj.rawSettings?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings {
  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings#audioOnlyHlsSettings
   */
  readonly audioOnlyHlsSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings#fmp4HlsSettings
   */
  readonly fmp4HlsSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings#frameCaptureHlsSettings
   */
  readonly frameCaptureHlsSettings?: any[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings#standardHlsSettings
   */
  readonly standardHlsSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioOnlyHlsSettings': obj.audioOnlyHlsSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings(y)),
    'fmp4HlsSettings': obj.fmp4HlsSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings(y)),
    'frameCaptureHlsSettings': obj.frameCaptureHlsSettings?.map(y => y),
    'standardHlsSettings': obj.standardHlsSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettingsDestination
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettingsDestination {
  /**
   * Reference ID for the destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettingsDestination#destinationRefId
   */
  readonly destinationRefId: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettingsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettingsDestination(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsMultiplexOutputSettingsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationRefId': obj.destinationRefId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettingsDestination
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettingsDestination {
  /**
   * Reference ID for the destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettingsDestination#destinationRefId
   */
  readonly destinationRefId: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettingsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettingsDestination(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsRtmpOutputSettingsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationRefId': obj.destinationRefId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettings {
  /**
   * M2ts Settings. See M2ts Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettings#m2tsSettings
   */
  readonly m2TsSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'm2tsSettings': obj.m2TsSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsDestination
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsDestination {
  /**
   * Reference ID for the destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsDestination#destinationRefId
   */
  readonly destinationRefId: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsDestination(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationRefId': obj.destinationRefId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsFecOutputSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsFecOutputSettings {
  /**
   * The height of the FEC protection matrix.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsFecOutputSettings#columnDepth
   */
  readonly columnDepth?: number;

  /**
   * Enables column only or column and row based FEC.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsFecOutputSettings#includeFec
   */
  readonly includeFec?: string;

  /**
   * The width of the FEC protection matrix.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsFecOutputSettings#rowLength
   */
  readonly rowLength?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsFecOutputSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsFecOutputSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsFecOutputSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columnDepth': obj.columnDepth,
    'includeFec': obj.includeFec,
    'rowLength': obj.rowLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings {
  /**
   * Post filter sharpening.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings#postFilterSharpening
   */
  readonly postFilterSharpening?: string;

  /**
   * Filter strength.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings#strength
   */
  readonly strength?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postFilterSharpening': obj.postFilterSharpening,
    'strength': obj.strength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings {
  /**
   * Sets the MaxCLL value for HDR10.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings#maxCll
   */
  readonly maxCll?: number;

  /**
   * Sets the MaxFALL value for HDR10.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings#maxFall
   */
  readonly maxFall?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCll': obj.maxCll,
    'maxFall': obj.maxFall,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings
 */
export interface ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings {
  /**
   * Post filter sharpening.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings#postFilterSharpening
   */
  readonly postFilterSharpening?: string;

  /**
   * Filter strength.
   *
   * @schema ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings#strength
   */
  readonly strength?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings(obj: ChannelSpecForProviderEncoderSettingsVideoDescriptionsCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postFilterSharpening': obj.postFilterSharpening,
    'strength': obj.strength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack {
  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack#track
   */
  readonly track: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack(obj: ChannelSpecForProviderInputAttachmentsInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'track': obj.track,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle
 */
export interface ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle {
  /**
   * Output video height in pixels.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle#height
   */
  readonly height: number;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle#leftOffset
   */
  readonly leftOffset: number;

  /**
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle#topOffset
   */
  readonly topOffset: number;

  /**
   * Output video width in pixels.
   *
   * @schema ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle#width
   */
  readonly width: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle(obj: ChannelSpecForProviderInputAttachmentsInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'height': obj.height,
    'leftOffset': obj.leftOffset,
    'topOffset': obj.topOffset,
    'width': obj.width,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingsKeyProviderServer
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingsKeyProviderServer {
  /**
   * Key used to extract the password from EC2 Parameter store.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingsKeyProviderServer#passwordParam
   */
  readonly passwordParam?: string;

  /**
   * Path to a file accessible to the live stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingsKeyProviderServer#uri
   */
  readonly uri: string;

  /**
   * Username for destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingsKeyProviderServer#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingsKeyProviderServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingsKeyProviderServer(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingsKeyProviderServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordParam': obj.passwordParam,
    'uri': obj.uri,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#absentInputAudioBehavior
   */
  readonly absentInputAudioBehavior?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#arib
   */
  readonly arib?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#aribCaptionsPid
   */
  readonly aribCaptionsPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#aribCaptionsPidControl
   */
  readonly aribCaptionsPidControl?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#audioBufferModel
   */
  readonly audioBufferModel?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#audioFramesPerPes
   */
  readonly audioFramesPerPes?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#audioPids
   */
  readonly audioPids?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#audioStreamType
   */
  readonly audioStreamType?: string;

  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#bitrate
   */
  readonly bitrate?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#bufferModel
   */
  readonly bufferModel?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#ccDescriptor
   */
  readonly ccDescriptor?: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#dvbNitSettings
   */
  readonly dvbNitSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#dvbSdtSettings
   */
  readonly dvbSdtSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#dvbSubPids
   */
  readonly dvbSubPids?: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#dvbTdtSettings
   */
  readonly dvbTdtSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings[];

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#dvbTeletextPid
   */
  readonly dvbTeletextPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#ebif
   */
  readonly ebif?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#ebpAudioInterval
   */
  readonly ebpAudioInterval?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#ebpLookaheadMs
   */
  readonly ebpLookaheadMs?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#ebpPlacement
   */
  readonly ebpPlacement?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#ecmPid
   */
  readonly ecmPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#esRateInPes
   */
  readonly esRateInPes?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#etvPlatformPid
   */
  readonly etvPlatformPid?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#etvSignalPid
   */
  readonly etvSignalPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#fragmentTime
   */
  readonly fragmentTime?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#klv
   */
  readonly klv?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#klvDataPids
   */
  readonly klvDataPids?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#nielsenId3Behavior
   */
  readonly nielsenId3Behavior?: string;

  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#nullPacketBitrate
   */
  readonly nullPacketBitrate?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#patInterval
   */
  readonly patInterval?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#pcrControl
   */
  readonly pcrControl?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#pcrPeriod
   */
  readonly pcrPeriod?: number;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#pcrPid
   */
  readonly pcrPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#pmtInterval
   */
  readonly pmtInterval?: number;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#pmtPid
   */
  readonly pmtPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#programNum
   */
  readonly programNum?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#rateMode
   */
  readonly rateMode?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#scte27Pids
   */
  readonly scte27Pids?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#scte35Control
   */
  readonly scte35Control?: string;

  /**
   * PID from which to read SCTE-35 messages.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#scte35Pid
   */
  readonly scte35Pid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#segmentationMarkers
   */
  readonly segmentationMarkers?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#segmentationStyle
   */
  readonly segmentationStyle?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#segmentationTime
   */
  readonly segmentationTime?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#timedMetadataBehavior
   */
  readonly timedMetadataBehavior?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#timedMetadataPid
   */
  readonly timedMetadataPid?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#transportStreamId
   */
  readonly transportStreamId?: number;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings#videoPid
   */
  readonly videoPid?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'absentInputAudioBehavior': obj.absentInputAudioBehavior,
    'arib': obj.arib,
    'aribCaptionsPid': obj.aribCaptionsPid,
    'aribCaptionsPidControl': obj.aribCaptionsPidControl,
    'audioBufferModel': obj.audioBufferModel,
    'audioFramesPerPes': obj.audioFramesPerPes,
    'audioPids': obj.audioPids,
    'audioStreamType': obj.audioStreamType,
    'bitrate': obj.bitrate,
    'bufferModel': obj.bufferModel,
    'ccDescriptor': obj.ccDescriptor,
    'dvbNitSettings': obj.dvbNitSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings(y)),
    'dvbSdtSettings': obj.dvbSdtSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings(y)),
    'dvbSubPids': obj.dvbSubPids,
    'dvbTdtSettings': obj.dvbTdtSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings(y)),
    'dvbTeletextPid': obj.dvbTeletextPid,
    'ebif': obj.ebif,
    'ebpAudioInterval': obj.ebpAudioInterval,
    'ebpLookaheadMs': obj.ebpLookaheadMs,
    'ebpPlacement': obj.ebpPlacement,
    'ecmPid': obj.ecmPid,
    'esRateInPes': obj.esRateInPes,
    'etvPlatformPid': obj.etvPlatformPid,
    'etvSignalPid': obj.etvSignalPid,
    'fragmentTime': obj.fragmentTime,
    'klv': obj.klv,
    'klvDataPids': obj.klvDataPids,
    'nielsenId3Behavior': obj.nielsenId3Behavior,
    'nullPacketBitrate': obj.nullPacketBitrate,
    'patInterval': obj.patInterval,
    'pcrControl': obj.pcrControl,
    'pcrPeriod': obj.pcrPeriod,
    'pcrPid': obj.pcrPid,
    'pmtInterval': obj.pmtInterval,
    'pmtPid': obj.pmtPid,
    'programNum': obj.programNum,
    'rateMode': obj.rateMode,
    'scte27Pids': obj.scte27Pids,
    'scte35Control': obj.scte35Control,
    'scte35Pid': obj.scte35Pid,
    'segmentationMarkers': obj.segmentationMarkers,
    'segmentationStyle': obj.segmentationStyle,
    'segmentationTime': obj.segmentationTime,
    'timedMetadataBehavior': obj.timedMetadataBehavior,
    'timedMetadataPid': obj.timedMetadataPid,
    'transportStreamId': obj.transportStreamId,
    'videoPid': obj.videoPid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings {
  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings#audioGroupId
   */
  readonly audioGroupId?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings#audioOnlyImage
   */
  readonly audioOnlyImage?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings#audioTrackType
   */
  readonly audioTrackType?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings#segmentType
   */
  readonly segmentType?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioGroupId': obj.audioGroupId,
    'audioOnlyImage': obj.audioOnlyImage?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage(y)),
    'audioTrackType': obj.audioTrackType,
    'segmentType': obj.segmentType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings#audioRenditionSets
   */
  readonly audioRenditionSets?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings#nielsenId3Behavior
   */
  readonly nielsenId3Behavior?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings#timedMetadataBehavior
   */
  readonly timedMetadataBehavior?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioRenditionSets': obj.audioRenditionSets,
    'nielsenId3Behavior': obj.nielsenId3Behavior,
    'timedMetadataBehavior': obj.timedMetadataBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings#audioRenditionSets
   */
  readonly audioRenditionSets?: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings#m3u8Settings
   */
  readonly m3U8Settings: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings[];

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioRenditionSets': obj.audioRenditionSets,
    'm3u8Settings': obj.m3U8Settings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#absentInputAudioBehavior
   */
  readonly absentInputAudioBehavior?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#arib
   */
  readonly arib?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#aribCaptionsPid
   */
  readonly aribCaptionsPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#aribCaptionsPidControl
   */
  readonly aribCaptionsPidControl?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#audioBufferModel
   */
  readonly audioBufferModel?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#audioFramesPerPes
   */
  readonly audioFramesPerPes?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#audioPids
   */
  readonly audioPids?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#audioStreamType
   */
  readonly audioStreamType?: string;

  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#bitrate
   */
  readonly bitrate?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#bufferModel
   */
  readonly bufferModel?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#ccDescriptor
   */
  readonly ccDescriptor?: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#dvbNitSettings
   */
  readonly dvbNitSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings[];

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#dvbSdtSettings
   */
  readonly dvbSdtSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings[];

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#dvbSubPids
   */
  readonly dvbSubPids?: string;

  /**
   * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#dvbTdtSettings
   */
  readonly dvbTdtSettings?: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings[];

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#dvbTeletextPid
   */
  readonly dvbTeletextPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#ebif
   */
  readonly ebif?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#ebpAudioInterval
   */
  readonly ebpAudioInterval?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#ebpLookaheadMs
   */
  readonly ebpLookaheadMs?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#ebpPlacement
   */
  readonly ebpPlacement?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#ecmPid
   */
  readonly ecmPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#esRateInPes
   */
  readonly esRateInPes?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#etvPlatformPid
   */
  readonly etvPlatformPid?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#etvSignalPid
   */
  readonly etvSignalPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#fragmentTime
   */
  readonly fragmentTime?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#klv
   */
  readonly klv?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#klvDataPids
   */
  readonly klvDataPids?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#nielsenId3Behavior
   */
  readonly nielsenId3Behavior?: string;

  /**
   * Average bitrate in bits/second.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#nullPacketBitrate
   */
  readonly nullPacketBitrate?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#patInterval
   */
  readonly patInterval?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#pcrControl
   */
  readonly pcrControl?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#pcrPeriod
   */
  readonly pcrPeriod?: number;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#pcrPid
   */
  readonly pcrPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#pmtInterval
   */
  readonly pmtInterval?: number;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#pmtPid
   */
  readonly pmtPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#programNum
   */
  readonly programNum?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#rateMode
   */
  readonly rateMode?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#scte27Pids
   */
  readonly scte27Pids?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#scte35Control
   */
  readonly scte35Control?: string;

  /**
   * PID from which to read SCTE-35 messages.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#scte35Pid
   */
  readonly scte35Pid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#segmentationMarkers
   */
  readonly segmentationMarkers?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#segmentationStyle
   */
  readonly segmentationStyle?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#segmentationTime
   */
  readonly segmentationTime?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#timedMetadataBehavior
   */
  readonly timedMetadataBehavior?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#timedMetadataPid
   */
  readonly timedMetadataPid?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#transportStreamId
   */
  readonly transportStreamId?: number;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings#videoPid
   */
  readonly videoPid?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'absentInputAudioBehavior': obj.absentInputAudioBehavior,
    'arib': obj.arib,
    'aribCaptionsPid': obj.aribCaptionsPid,
    'aribCaptionsPidControl': obj.aribCaptionsPidControl,
    'audioBufferModel': obj.audioBufferModel,
    'audioFramesPerPes': obj.audioFramesPerPes,
    'audioPids': obj.audioPids,
    'audioStreamType': obj.audioStreamType,
    'bitrate': obj.bitrate,
    'bufferModel': obj.bufferModel,
    'ccDescriptor': obj.ccDescriptor,
    'dvbNitSettings': obj.dvbNitSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings(y)),
    'dvbSdtSettings': obj.dvbSdtSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings(y)),
    'dvbSubPids': obj.dvbSubPids,
    'dvbTdtSettings': obj.dvbTdtSettings?.map(y => toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings(y)),
    'dvbTeletextPid': obj.dvbTeletextPid,
    'ebif': obj.ebif,
    'ebpAudioInterval': obj.ebpAudioInterval,
    'ebpLookaheadMs': obj.ebpLookaheadMs,
    'ebpPlacement': obj.ebpPlacement,
    'ecmPid': obj.ecmPid,
    'esRateInPes': obj.esRateInPes,
    'etvPlatformPid': obj.etvPlatformPid,
    'etvSignalPid': obj.etvSignalPid,
    'fragmentTime': obj.fragmentTime,
    'klv': obj.klv,
    'klvDataPids': obj.klvDataPids,
    'nielsenId3Behavior': obj.nielsenId3Behavior,
    'nullPacketBitrate': obj.nullPacketBitrate,
    'patInterval': obj.patInterval,
    'pcrControl': obj.pcrControl,
    'pcrPeriod': obj.pcrPeriod,
    'pcrPid': obj.pcrPid,
    'pmtInterval': obj.pmtInterval,
    'pmtPid': obj.pmtPid,
    'programNum': obj.programNum,
    'rateMode': obj.rateMode,
    'scte27Pids': obj.scte27Pids,
    'scte35Control': obj.scte35Control,
    'scte35Pid': obj.scte35Pid,
    'segmentationMarkers': obj.segmentationMarkers,
    'segmentationStyle': obj.segmentationStyle,
    'segmentationTime': obj.segmentationTime,
    'timedMetadataBehavior': obj.timedMetadataBehavior,
    'timedMetadataPid': obj.timedMetadataPid,
    'transportStreamId': obj.transportStreamId,
    'videoPid': obj.videoPid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings {
  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings#networkId
   */
  readonly networkId: number;

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings#networkName
   */
  readonly networkName: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings#repInterval
   */
  readonly repInterval?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkId': obj.networkId,
    'networkName': obj.networkName,
    'repInterval': obj.repInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings#outputSdt
   */
  readonly outputSdt?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings#repInterval
   */
  readonly repInterval?: number;

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings#serviceName
   */
  readonly serviceName?: string;

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings#serviceProviderName
   */
  readonly serviceProviderName?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputSdt': obj.outputSdt,
    'repInterval': obj.repInterval,
    'serviceName': obj.serviceName,
    'serviceProviderName': obj.serviceProviderName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings#repInterval
   */
  readonly repInterval?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsArchiveOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repInterval': obj.repInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage {
  /**
   * Key used to extract the password from EC2 Parameter store.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage#passwordParam
   */
  readonly passwordParam?: string;

  /**
   * Path to a file accessible to the live stream.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage#uri
   */
  readonly uri: string;

  /**
   * Username for destination.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordParam': obj.passwordParam,
    'uri': obj.uri,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#audioFramesPerPes
   */
  readonly audioFramesPerPes?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#audioPids
   */
  readonly audioPids?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#ecmPid
   */
  readonly ecmPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#nielsenId3Behavior
   */
  readonly nielsenId3Behavior?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#patInterval
   */
  readonly patInterval?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#pcrControl
   */
  readonly pcrControl?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#pcrPeriod
   */
  readonly pcrPeriod?: number;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#pcrPid
   */
  readonly pcrPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#pmtInterval
   */
  readonly pmtInterval?: number;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#pmtPid
   */
  readonly pmtPid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#programNum
   */
  readonly programNum?: number;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#scte35Behavior
   */
  readonly scte35Behavior?: string;

  /**
   * PID from which to read SCTE-35 messages.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#scte35Pid
   */
  readonly scte35Pid?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#timedMetadataBehavior
   */
  readonly timedMetadataBehavior?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#timedMetadataPid
   */
  readonly timedMetadataPid?: string;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#transportStreamId
   */
  readonly transportStreamId?: number;

  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings#videoPid
   */
  readonly videoPid?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3U8Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audioFramesPerPes': obj.audioFramesPerPes,
    'audioPids': obj.audioPids,
    'ecmPid': obj.ecmPid,
    'nielsenId3Behavior': obj.nielsenId3Behavior,
    'patInterval': obj.patInterval,
    'pcrControl': obj.pcrControl,
    'pcrPeriod': obj.pcrPeriod,
    'pcrPid': obj.pcrPid,
    'pmtInterval': obj.pmtInterval,
    'pmtPid': obj.pmtPid,
    'programNum': obj.programNum,
    'scte35Behavior': obj.scte35Behavior,
    'scte35Pid': obj.scte35Pid,
    'timedMetadataBehavior': obj.timedMetadataBehavior,
    'timedMetadataPid': obj.timedMetadataPid,
    'transportStreamId': obj.transportStreamId,
    'videoPid': obj.videoPid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings {
  /**
   * User-specified id. Ths is used in an output group or an output.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings#networkId
   */
  readonly networkId: number;

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings#networkName
   */
  readonly networkName: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings#repInterval
   */
  readonly repInterval?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbNitSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkId': obj.networkId,
    'networkName': obj.networkName,
    'repInterval': obj.repInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings#outputSdt
   */
  readonly outputSdt?: string;

  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings#repInterval
   */
  readonly repInterval?: number;

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings#serviceName
   */
  readonly serviceName?: string;

  /**
   * Name of the Channel.
   *
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings#serviceProviderName
   */
  readonly serviceProviderName?: string;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbSdtSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputSdt': obj.outputSdt,
    'repInterval': obj.repInterval,
    'serviceName': obj.serviceName,
    'serviceProviderName': obj.serviceProviderName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings
 */
export interface ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings {
  /**
   * @schema ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings#repInterval
   */
  readonly repInterval?: number;

}

/**
 * Converts an object of type 'ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings(obj: ChannelSpecForProviderEncoderSettingsOutputGroupsOutputsOutputSettingsUdpOutputSettingsContainerSettingsM2TsSettingsDvbTdtSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repInterval': obj.repInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Input is the Schema for the Inputs API.
 *
 * @schema Input
 */
export class Input extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Input"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'medialive.aws.upbound.io/v1beta1',
    kind: 'Input',
  }

  /**
   * Renders a Kubernetes manifest for "Input".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InputProps): any {
    return {
      ...Input.GVK,
      ...toJson_InputProps(props),
    };
  }

  /**
   * Defines a "Input" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InputProps) {
    super(scope, id, {
      ...Input.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Input.GVK,
      ...toJson_InputProps(resolved),
    };
  }
}

/**
 * Input is the Schema for the Inputs API.
 *
 * @schema Input
 */
export interface InputProps {
  /**
   * @schema Input#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InputSpec defines the desired state of Input
   *
   * @schema Input#spec
   */
  readonly spec: InputSpec;

}

/**
 * Converts an object of type 'InputProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputProps(obj: InputProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InputSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InputSpec defines the desired state of Input
 *
 * @schema InputSpec
 */
export interface InputSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InputSpec#deletionPolicy
   */
  readonly deletionPolicy?: InputSpecDeletionPolicy;

  /**
   * @schema InputSpec#forProvider
   */
  readonly forProvider: InputSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InputSpec#managementPolicy
   */
  readonly managementPolicy?: InputSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InputSpec#providerConfigRef
   */
  readonly providerConfigRef?: InputSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InputSpec#providerRef
   */
  readonly providerRef?: InputSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InputSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InputSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InputSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InputSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InputSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpec(obj: InputSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InputSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_InputSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InputSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InputSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InputSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InputSpecDeletionPolicy
 */
export enum InputSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InputSpecForProvider
 */
export interface InputSpecForProvider {
  /**
   * Destination settings for PUSH type inputs. See Destinations for more details.
   *
   * @schema InputSpecForProvider#destinations
   */
  readonly destinations?: InputSpecForProviderDestinations[];

  /**
   * Settings for the devices. See Input Devices for more details.
   *
   * @schema InputSpecForProvider#inputDevices
   */
  readonly inputDevices?: InputSpecForProviderInputDevices[];

  /**
   * List of input security groups.
   *
   * @schema InputSpecForProvider#inputSecurityGroups
   */
  readonly inputSecurityGroups?: string[];

  /**
   * A list of the MediaConnect Flows. See Media Connect Flows for more details.
   *
   * @schema InputSpecForProvider#mediaConnectFlows
   */
  readonly mediaConnectFlows?: InputSpecForProviderMediaConnectFlows[];

  /**
   * Name of the input.
   *
   * @schema InputSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InputSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the role this input assumes during and after creation.
   *
   * @schema InputSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema InputSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: InputSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema InputSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: InputSpecForProviderRoleArnSelector;

  /**
   * The source URLs for a PULL-type input. See Sources for more details.
   *
   * @schema InputSpecForProvider#sources
   */
  readonly sources?: InputSpecForProviderSources[];

  /**
   * Key-value map of resource tags.
   *
   * @schema InputSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The different types of inputs that AWS Elemental MediaLive supports.
   *
   * @schema InputSpecForProvider#type
   */
  readonly type?: string;

  /**
   * Settings for a private VPC Input. See VPC for more details.
   *
   * @schema InputSpecForProvider#vpc
   */
  readonly vpc?: InputSpecForProviderVpc[];

}

/**
 * Converts an object of type 'InputSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecForProvider(obj: InputSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinations': obj.destinations?.map(y => toJson_InputSpecForProviderDestinations(y)),
    'inputDevices': obj.inputDevices?.map(y => toJson_InputSpecForProviderInputDevices(y)),
    'inputSecurityGroups': obj.inputSecurityGroups?.map(y => y),
    'mediaConnectFlows': obj.mediaConnectFlows?.map(y => toJson_InputSpecForProviderMediaConnectFlows(y)),
    'name': obj.name,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_InputSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_InputSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'sources': obj.sources?.map(y => toJson_InputSpecForProviderSources(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'vpc': obj.vpc?.map(y => toJson_InputSpecForProviderVpc(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InputSpecManagementPolicy
 */
export enum InputSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InputSpecProviderConfigRef
 */
export interface InputSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InputSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InputSpecProviderConfigRef#policy
   */
  readonly policy?: InputSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InputSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecProviderConfigRef(obj: InputSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InputSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InputSpecProviderRef
 */
export interface InputSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InputSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InputSpecProviderRef#policy
   */
  readonly policy?: InputSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InputSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecProviderRef(obj: InputSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InputSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InputSpecPublishConnectionDetailsTo
 */
export interface InputSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InputSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InputSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InputSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InputSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InputSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InputSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecPublishConnectionDetailsTo(obj: InputSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InputSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InputSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InputSpecWriteConnectionSecretToRef
 */
export interface InputSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InputSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InputSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InputSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecWriteConnectionSecretToRef(obj: InputSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InputSpecForProviderDestinations
 */
export interface InputSpecForProviderDestinations {
  /**
   * A unique name for the location the RTMP stream is being pushed to.
   *
   * @schema InputSpecForProviderDestinations#streamName
   */
  readonly streamName: string;

}

/**
 * Converts an object of type 'InputSpecForProviderDestinations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecForProviderDestinations(obj: InputSpecForProviderDestinations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'streamName': obj.streamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InputSpecForProviderInputDevices
 */
export interface InputSpecForProviderInputDevices {
  /**
   * The unique ID for the device.
   *
   * @schema InputSpecForProviderInputDevices#id
   */
  readonly id: string;

}

/**
 * Converts an object of type 'InputSpecForProviderInputDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecForProviderInputDevices(obj: InputSpecForProviderInputDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InputSpecForProviderMediaConnectFlows
 */
export interface InputSpecForProviderMediaConnectFlows {
  /**
   * The ARN of the MediaConnect Flow
   *
   * @schema InputSpecForProviderMediaConnectFlows#flowArn
   */
  readonly flowArn: string;

}

/**
 * Converts an object of type 'InputSpecForProviderMediaConnectFlows' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecForProviderMediaConnectFlows(obj: InputSpecForProviderMediaConnectFlows | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flowArn': obj.flowArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema InputSpecForProviderRoleArnRef
 */
export interface InputSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema InputSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InputSpecForProviderRoleArnRef#policy
   */
  readonly policy?: InputSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'InputSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecForProviderRoleArnRef(obj: InputSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InputSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema InputSpecForProviderRoleArnSelector
 */
export interface InputSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InputSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InputSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InputSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: InputSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'InputSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecForProviderRoleArnSelector(obj: InputSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InputSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InputSpecForProviderSources
 */
export interface InputSpecForProviderSources {
  /**
   * The key used to extract the password from EC2 Parameter store.
   *
   * @schema InputSpecForProviderSources#passwordParam
   */
  readonly passwordParam: string;

  /**
   * The URL where the stream is pulled from.
   *
   * @schema InputSpecForProviderSources#url
   */
  readonly url: string;

  /**
   * The username for the input source.
   *
   * @schema InputSpecForProviderSources#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'InputSpecForProviderSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecForProviderSources(obj: InputSpecForProviderSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordParam': obj.passwordParam,
    'url': obj.url,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InputSpecForProviderVpc
 */
export interface InputSpecForProviderVpc {
  /**
   * A list of up to 5 EC2 VPC security group IDs to attach to the Input.
   *
   * @schema InputSpecForProviderVpc#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * A list of 2 VPC subnet IDs from the same VPC.
   *
   * @schema InputSpecForProviderVpc#subnetIds
   */
  readonly subnetIds: string[];

}

/**
 * Converts an object of type 'InputSpecForProviderVpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecForProviderVpc(obj: InputSpecForProviderVpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InputSpecProviderConfigRefPolicy
 */
export interface InputSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InputSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InputSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InputSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InputSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InputSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecProviderConfigRefPolicy(obj: InputSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InputSpecProviderRefPolicy
 */
export interface InputSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InputSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InputSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InputSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InputSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InputSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecProviderRefPolicy(obj: InputSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InputSpecPublishConnectionDetailsToConfigRef
 */
export interface InputSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InputSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InputSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InputSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InputSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecPublishConnectionDetailsToConfigRef(obj: InputSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InputSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InputSpecPublishConnectionDetailsToMetadata
 */
export interface InputSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InputSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InputSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InputSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InputSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecPublishConnectionDetailsToMetadata(obj: InputSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InputSpecForProviderRoleArnRefPolicy
 */
export interface InputSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InputSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: InputSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InputSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: InputSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'InputSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecForProviderRoleArnRefPolicy(obj: InputSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InputSpecForProviderRoleArnSelectorPolicy
 */
export interface InputSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InputSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: InputSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InputSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: InputSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InputSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecForProviderRoleArnSelectorPolicy(obj: InputSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InputSpecProviderConfigRefPolicyResolution
 */
export enum InputSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InputSpecProviderConfigRefPolicyResolve
 */
export enum InputSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InputSpecProviderRefPolicyResolution
 */
export enum InputSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InputSpecProviderRefPolicyResolve
 */
export enum InputSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InputSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InputSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InputSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InputSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InputSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InputSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InputSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSpecPublishConnectionDetailsToConfigRefPolicy(obj: InputSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InputSpecForProviderRoleArnRefPolicyResolution
 */
export enum InputSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InputSpecForProviderRoleArnRefPolicyResolve
 */
export enum InputSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InputSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum InputSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InputSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum InputSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InputSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InputSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InputSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InputSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InputSecurityGroup is the Schema for the InputSecurityGroups API.
 *
 * @schema InputSecurityGroup
 */
export class InputSecurityGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InputSecurityGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'medialive.aws.upbound.io/v1beta1',
    kind: 'InputSecurityGroup',
  }

  /**
   * Renders a Kubernetes manifest for "InputSecurityGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InputSecurityGroupProps): any {
    return {
      ...InputSecurityGroup.GVK,
      ...toJson_InputSecurityGroupProps(props),
    };
  }

  /**
   * Defines a "InputSecurityGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InputSecurityGroupProps) {
    super(scope, id, {
      ...InputSecurityGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InputSecurityGroup.GVK,
      ...toJson_InputSecurityGroupProps(resolved),
    };
  }
}

/**
 * InputSecurityGroup is the Schema for the InputSecurityGroups API.
 *
 * @schema InputSecurityGroup
 */
export interface InputSecurityGroupProps {
  /**
   * @schema InputSecurityGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InputSecurityGroupSpec defines the desired state of InputSecurityGroup
   *
   * @schema InputSecurityGroup#spec
   */
  readonly spec: InputSecurityGroupSpec;

}

/**
 * Converts an object of type 'InputSecurityGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupProps(obj: InputSecurityGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InputSecurityGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InputSecurityGroupSpec defines the desired state of InputSecurityGroup
 *
 * @schema InputSecurityGroupSpec
 */
export interface InputSecurityGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InputSecurityGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: InputSecurityGroupSpecDeletionPolicy;

  /**
   * @schema InputSecurityGroupSpec#forProvider
   */
  readonly forProvider: InputSecurityGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InputSecurityGroupSpec#managementPolicy
   */
  readonly managementPolicy?: InputSecurityGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InputSecurityGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: InputSecurityGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InputSecurityGroupSpec#providerRef
   */
  readonly providerRef?: InputSecurityGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InputSecurityGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InputSecurityGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InputSecurityGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InputSecurityGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InputSecurityGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpec(obj: InputSecurityGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InputSecurityGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_InputSecurityGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InputSecurityGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InputSecurityGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InputSecurityGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InputSecurityGroupSpecDeletionPolicy
 */
export enum InputSecurityGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InputSecurityGroupSpecForProvider
 */
export interface InputSecurityGroupSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InputSecurityGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema InputSecurityGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whitelist rules. See Whitelist Rules for more details.
   *
   * @schema InputSecurityGroupSpecForProvider#whitelistRules
   */
  readonly whitelistRules?: InputSecurityGroupSpecForProviderWhitelistRules[];

}

/**
 * Converts an object of type 'InputSecurityGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecForProvider(obj: InputSecurityGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'whitelistRules': obj.whitelistRules?.map(y => toJson_InputSecurityGroupSpecForProviderWhitelistRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InputSecurityGroupSpecManagementPolicy
 */
export enum InputSecurityGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InputSecurityGroupSpecProviderConfigRef
 */
export interface InputSecurityGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InputSecurityGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InputSecurityGroupSpecProviderConfigRef#policy
   */
  readonly policy?: InputSecurityGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InputSecurityGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecProviderConfigRef(obj: InputSecurityGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InputSecurityGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InputSecurityGroupSpecProviderRef
 */
export interface InputSecurityGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InputSecurityGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InputSecurityGroupSpecProviderRef#policy
   */
  readonly policy?: InputSecurityGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InputSecurityGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecProviderRef(obj: InputSecurityGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InputSecurityGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InputSecurityGroupSpecPublishConnectionDetailsTo
 */
export interface InputSecurityGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InputSecurityGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InputSecurityGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InputSecurityGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InputSecurityGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InputSecurityGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InputSecurityGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecPublishConnectionDetailsTo(obj: InputSecurityGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InputSecurityGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InputSecurityGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InputSecurityGroupSpecWriteConnectionSecretToRef
 */
export interface InputSecurityGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InputSecurityGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InputSecurityGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InputSecurityGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecWriteConnectionSecretToRef(obj: InputSecurityGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InputSecurityGroupSpecForProviderWhitelistRules
 */
export interface InputSecurityGroupSpecForProviderWhitelistRules {
  /**
   * The IPv4 CIDR that's whitelisted.
   *
   * @schema InputSecurityGroupSpecForProviderWhitelistRules#cidr
   */
  readonly cidr: string;

}

/**
 * Converts an object of type 'InputSecurityGroupSpecForProviderWhitelistRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecForProviderWhitelistRules(obj: InputSecurityGroupSpecForProviderWhitelistRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InputSecurityGroupSpecProviderConfigRefPolicy
 */
export interface InputSecurityGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InputSecurityGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InputSecurityGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InputSecurityGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InputSecurityGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InputSecurityGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecProviderConfigRefPolicy(obj: InputSecurityGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InputSecurityGroupSpecProviderRefPolicy
 */
export interface InputSecurityGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InputSecurityGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InputSecurityGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InputSecurityGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InputSecurityGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InputSecurityGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecProviderRefPolicy(obj: InputSecurityGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InputSecurityGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface InputSecurityGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InputSecurityGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InputSecurityGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InputSecurityGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecPublishConnectionDetailsToConfigRef(obj: InputSecurityGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InputSecurityGroupSpecPublishConnectionDetailsToMetadata
 */
export interface InputSecurityGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InputSecurityGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InputSecurityGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InputSecurityGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InputSecurityGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecPublishConnectionDetailsToMetadata(obj: InputSecurityGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InputSecurityGroupSpecProviderConfigRefPolicyResolution
 */
export enum InputSecurityGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InputSecurityGroupSpecProviderConfigRefPolicyResolve
 */
export enum InputSecurityGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InputSecurityGroupSpecProviderRefPolicyResolution
 */
export enum InputSecurityGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InputSecurityGroupSpecProviderRefPolicyResolve
 */
export enum InputSecurityGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InputSecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Multiplex is the Schema for the Multiplexs API.
 *
 * @schema Multiplex
 */
export class Multiplex extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Multiplex"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'medialive.aws.upbound.io/v1beta1',
    kind: 'Multiplex',
  }

  /**
   * Renders a Kubernetes manifest for "Multiplex".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MultiplexProps): any {
    return {
      ...Multiplex.GVK,
      ...toJson_MultiplexProps(props),
    };
  }

  /**
   * Defines a "Multiplex" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MultiplexProps) {
    super(scope, id, {
      ...Multiplex.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Multiplex.GVK,
      ...toJson_MultiplexProps(resolved),
    };
  }
}

/**
 * Multiplex is the Schema for the Multiplexs API.
 *
 * @schema Multiplex
 */
export interface MultiplexProps {
  /**
   * @schema Multiplex#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MultiplexSpec defines the desired state of Multiplex
   *
   * @schema Multiplex#spec
   */
  readonly spec: MultiplexSpec;

}

/**
 * Converts an object of type 'MultiplexProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexProps(obj: MultiplexProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MultiplexSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MultiplexSpec defines the desired state of Multiplex
 *
 * @schema MultiplexSpec
 */
export interface MultiplexSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MultiplexSpec#deletionPolicy
   */
  readonly deletionPolicy?: MultiplexSpecDeletionPolicy;

  /**
   * @schema MultiplexSpec#forProvider
   */
  readonly forProvider: MultiplexSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MultiplexSpec#managementPolicy
   */
  readonly managementPolicy?: MultiplexSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MultiplexSpec#providerConfigRef
   */
  readonly providerConfigRef?: MultiplexSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MultiplexSpec#providerRef
   */
  readonly providerRef?: MultiplexSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MultiplexSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MultiplexSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MultiplexSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MultiplexSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MultiplexSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpec(obj: MultiplexSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MultiplexSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MultiplexSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MultiplexSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MultiplexSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MultiplexSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MultiplexSpecDeletionPolicy
 */
export enum MultiplexSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MultiplexSpecForProvider
 */
export interface MultiplexSpecForProvider {
  /**
   * A list of availability zones. You must specify exactly two.
   *
   * @schema MultiplexSpecForProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * Multiplex settings. See Multiplex Settings for more details.
   *
   * @schema MultiplexSpecForProvider#multiplexSettings
   */
  readonly multiplexSettings?: MultiplexSpecForProviderMultiplexSettings[];

  /**
   * name of Multiplex.
   *
   * @schema MultiplexSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MultiplexSpecForProvider#region
   */
  readonly region: string;

  /**
   * Whether to start the Multiplex. Defaults to false.
   *
   * @default false.
   * @schema MultiplexSpecForProvider#startMultiplex
   */
  readonly startMultiplex?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema MultiplexSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'MultiplexSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecForProvider(obj: MultiplexSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'multiplexSettings': obj.multiplexSettings?.map(y => toJson_MultiplexSpecForProviderMultiplexSettings(y)),
    'name': obj.name,
    'region': obj.region,
    'startMultiplex': obj.startMultiplex,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MultiplexSpecManagementPolicy
 */
export enum MultiplexSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MultiplexSpecProviderConfigRef
 */
export interface MultiplexSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MultiplexSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MultiplexSpecProviderConfigRef#policy
   */
  readonly policy?: MultiplexSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MultiplexSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecProviderConfigRef(obj: MultiplexSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MultiplexSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MultiplexSpecProviderRef
 */
export interface MultiplexSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MultiplexSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MultiplexSpecProviderRef#policy
   */
  readonly policy?: MultiplexSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MultiplexSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecProviderRef(obj: MultiplexSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MultiplexSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MultiplexSpecPublishConnectionDetailsTo
 */
export interface MultiplexSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MultiplexSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MultiplexSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MultiplexSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MultiplexSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MultiplexSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MultiplexSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecPublishConnectionDetailsTo(obj: MultiplexSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MultiplexSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MultiplexSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MultiplexSpecWriteConnectionSecretToRef
 */
export interface MultiplexSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MultiplexSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MultiplexSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MultiplexSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecWriteConnectionSecretToRef(obj: MultiplexSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MultiplexSpecForProviderMultiplexSettings
 */
export interface MultiplexSpecForProviderMultiplexSettings {
  /**
   * Maximum video buffer delay.
   *
   * @schema MultiplexSpecForProviderMultiplexSettings#maximumVideoBufferDelayMilliseconds
   */
  readonly maximumVideoBufferDelayMilliseconds?: number;

  /**
   * Transport stream bit rate.
   *
   * @schema MultiplexSpecForProviderMultiplexSettings#transportStreamBitrate
   */
  readonly transportStreamBitrate: number;

  /**
   * Unique ID for each multiplex.
   *
   * @schema MultiplexSpecForProviderMultiplexSettings#transportStreamId
   */
  readonly transportStreamId: number;

  /**
   * Transport stream reserved bit rate.
   *
   * @schema MultiplexSpecForProviderMultiplexSettings#transportStreamReservedBitrate
   */
  readonly transportStreamReservedBitrate?: number;

}

/**
 * Converts an object of type 'MultiplexSpecForProviderMultiplexSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecForProviderMultiplexSettings(obj: MultiplexSpecForProviderMultiplexSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumVideoBufferDelayMilliseconds': obj.maximumVideoBufferDelayMilliseconds,
    'transportStreamBitrate': obj.transportStreamBitrate,
    'transportStreamId': obj.transportStreamId,
    'transportStreamReservedBitrate': obj.transportStreamReservedBitrate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MultiplexSpecProviderConfigRefPolicy
 */
export interface MultiplexSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiplexSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MultiplexSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiplexSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MultiplexSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MultiplexSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecProviderConfigRefPolicy(obj: MultiplexSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MultiplexSpecProviderRefPolicy
 */
export interface MultiplexSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiplexSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MultiplexSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiplexSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MultiplexSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MultiplexSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecProviderRefPolicy(obj: MultiplexSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MultiplexSpecPublishConnectionDetailsToConfigRef
 */
export interface MultiplexSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MultiplexSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MultiplexSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MultiplexSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MultiplexSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecPublishConnectionDetailsToConfigRef(obj: MultiplexSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MultiplexSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MultiplexSpecPublishConnectionDetailsToMetadata
 */
export interface MultiplexSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MultiplexSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MultiplexSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MultiplexSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MultiplexSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecPublishConnectionDetailsToMetadata(obj: MultiplexSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiplexSpecProviderConfigRefPolicyResolution
 */
export enum MultiplexSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiplexSpecProviderConfigRefPolicyResolve
 */
export enum MultiplexSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiplexSpecProviderRefPolicyResolution
 */
export enum MultiplexSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiplexSpecProviderRefPolicyResolve
 */
export enum MultiplexSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MultiplexSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MultiplexSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiplexSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MultiplexSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiplexSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MultiplexSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MultiplexSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiplexSpecPublishConnectionDetailsToConfigRefPolicy(obj: MultiplexSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiplexSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MultiplexSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiplexSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MultiplexSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

