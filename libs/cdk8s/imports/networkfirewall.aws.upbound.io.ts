// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Firewall is the Schema for the Firewalls API. Provides an AWS Network Firewall Firewall resource.
 *
 * @schema Firewall
 */
export class Firewall extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Firewall"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkfirewall.aws.upbound.io/v1beta1',
    kind: 'Firewall',
  }

  /**
   * Renders a Kubernetes manifest for "Firewall".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FirewallProps): any {
    return {
      ...Firewall.GVK,
      ...toJson_FirewallProps(props),
    };
  }

  /**
   * Defines a "Firewall" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FirewallProps) {
    super(scope, id, {
      ...Firewall.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Firewall.GVK,
      ...toJson_FirewallProps(resolved),
    };
  }
}

/**
 * Firewall is the Schema for the Firewalls API. Provides an AWS Network Firewall Firewall resource.
 *
 * @schema Firewall
 */
export interface FirewallProps {
  /**
   * @schema Firewall#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FirewallSpec defines the desired state of Firewall
   *
   * @schema Firewall#spec
   */
  readonly spec: FirewallSpec;

}

/**
 * Converts an object of type 'FirewallProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallProps(obj: FirewallProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FirewallSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FirewallSpec defines the desired state of Firewall
 *
 * @schema FirewallSpec
 */
export interface FirewallSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FirewallSpec#deletionPolicy
   */
  readonly deletionPolicy?: FirewallSpecDeletionPolicy;

  /**
   * @schema FirewallSpec#forProvider
   */
  readonly forProvider: FirewallSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FirewallSpec#managementPolicy
   */
  readonly managementPolicy?: FirewallSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FirewallSpec#providerConfigRef
   */
  readonly providerConfigRef?: FirewallSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FirewallSpec#providerRef
   */
  readonly providerRef?: FirewallSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FirewallSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FirewallSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FirewallSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FirewallSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FirewallSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpec(obj: FirewallSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FirewallSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_FirewallSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FirewallSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FirewallSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FirewallSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FirewallSpecDeletionPolicy
 */
export enum FirewallSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FirewallSpecForProvider
 */
export interface FirewallSpecForProvider {
  /**
   * A boolean flag indicating whether it is possible to delete the firewall. Defaults to false.
   *
   * @default false.
   * @schema FirewallSpecForProvider#deleteProtection
   */
  readonly deleteProtection?: boolean;

  /**
   * A friendly description of the firewall.
   *
   * @schema FirewallSpecForProvider#description
   */
  readonly description?: string;

  /**
   * KMS encryption configuration settings. See Encryption Configuration below for details.
   *
   * @schema FirewallSpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: FirewallSpecForProviderEncryptionConfiguration[];

  /**
   * The Amazon Resource Name (ARN) of the VPC Firewall policy.
   *
   * @schema FirewallSpecForProvider#firewallPolicyArn
   */
  readonly firewallPolicyArn?: string;

  /**
   * Reference to a FirewallPolicy in networkfirewall to populate firewallPolicyArn.
   *
   * @schema FirewallSpecForProvider#firewallPolicyArnRef
   */
  readonly firewallPolicyArnRef?: FirewallSpecForProviderFirewallPolicyArnRef;

  /**
   * Selector for a FirewallPolicy in networkfirewall to populate firewallPolicyArn.
   *
   * @schema FirewallSpecForProvider#firewallPolicyArnSelector
   */
  readonly firewallPolicyArnSelector?: FirewallSpecForProviderFirewallPolicyArnSelector;

  /**
   * (Option) A boolean flag indicating whether it is possible to change the associated firewall policy. Defaults to false.
   *
   * @default false.
   * @schema FirewallSpecForProvider#firewallPolicyChangeProtection
   */
  readonly firewallPolicyChangeProtection?: boolean;

  /**
   * A friendly name of the firewall.
   *
   * @schema FirewallSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FirewallSpecForProvider#region
   */
  readonly region: string;

  /**
   * A boolean flag indicating whether it is possible to change the associated subnet(s). Defaults to false.
   *
   * @default false.
   * @schema FirewallSpecForProvider#subnetChangeProtection
   */
  readonly subnetChangeProtection?: boolean;

  /**
   * Set of configuration blocks describing the public subnets. Each subnet must belong to a different Availability Zone in the VPC. AWS Network Firewall creates a firewall endpoint in each subnet. See Subnet Mapping below for details.
   *
   * @schema FirewallSpecForProvider#subnetMapping
   */
  readonly subnetMapping?: FirewallSpecForProviderSubnetMapping[];

  /**
   * Key-value map of resource tags.
   *
   * @schema FirewallSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The unique identifier of the VPC where AWS Network Firewall should create the firewall.
   *
   * @schema FirewallSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema FirewallSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: FirewallSpecForProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema FirewallSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: FirewallSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'FirewallSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProvider(obj: FirewallSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteProtection': obj.deleteProtection,
    'description': obj.description,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_FirewallSpecForProviderEncryptionConfiguration(y)),
    'firewallPolicyArn': obj.firewallPolicyArn,
    'firewallPolicyArnRef': toJson_FirewallSpecForProviderFirewallPolicyArnRef(obj.firewallPolicyArnRef),
    'firewallPolicyArnSelector': toJson_FirewallSpecForProviderFirewallPolicyArnSelector(obj.firewallPolicyArnSelector),
    'firewallPolicyChangeProtection': obj.firewallPolicyChangeProtection,
    'name': obj.name,
    'region': obj.region,
    'subnetChangeProtection': obj.subnetChangeProtection,
    'subnetMapping': obj.subnetMapping?.map(y => toJson_FirewallSpecForProviderSubnetMapping(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_FirewallSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_FirewallSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FirewallSpecManagementPolicy
 */
export enum FirewallSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FirewallSpecProviderConfigRef
 */
export interface FirewallSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecProviderConfigRef#policy
   */
  readonly policy?: FirewallSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecProviderConfigRef(obj: FirewallSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FirewallSpecProviderRef
 */
export interface FirewallSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecProviderRef#policy
   */
  readonly policy?: FirewallSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecProviderRef(obj: FirewallSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FirewallSpecPublishConnectionDetailsTo
 */
export interface FirewallSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FirewallSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FirewallSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FirewallSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FirewallSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FirewallSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsTo(obj: FirewallSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FirewallSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FirewallSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FirewallSpecWriteConnectionSecretToRef
 */
export interface FirewallSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FirewallSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FirewallSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FirewallSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecWriteConnectionSecretToRef(obj: FirewallSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallSpecForProviderEncryptionConfiguration
 */
export interface FirewallSpecForProviderEncryptionConfiguration {
  /**
   * The ID of the customer managed key. You can use any of the key identifiers that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
   *
   * @schema FirewallSpecForProviderEncryptionConfiguration#keyId
   */
  readonly keyId?: string;

  /**
   * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are CUSTOMER_KMS and AWS_OWNED_KMS_KEY.
   *
   * @schema FirewallSpecForProviderEncryptionConfiguration#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'FirewallSpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderEncryptionConfiguration(obj: FirewallSpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a FirewallPolicy in networkfirewall to populate firewallPolicyArn.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnRef
 */
export interface FirewallSpecForProviderFirewallPolicyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnRef#policy
   */
  readonly policy?: FirewallSpecForProviderFirewallPolicyArnRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderFirewallPolicyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderFirewallPolicyArnRef(obj: FirewallSpecForProviderFirewallPolicyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecForProviderFirewallPolicyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a FirewallPolicy in networkfirewall to populate firewallPolicyArn.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnSelector
 */
export interface FirewallSpecForProviderFirewallPolicyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnSelector#policy
   */
  readonly policy?: FirewallSpecForProviderFirewallPolicyArnSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderFirewallPolicyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderFirewallPolicyArnSelector(obj: FirewallSpecForProviderFirewallPolicyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallSpecForProviderFirewallPolicyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallSpecForProviderSubnetMapping
 */
export interface FirewallSpecForProviderSubnetMapping {
  /**
   * The subnet's IP address type. Valida values: "DUALSTACK", "IPV4".
   *
   * @schema FirewallSpecForProviderSubnetMapping#ipAddressType
   */
  readonly ipAddressType?: string;

  /**
   * The unique identifier for the subnet.
   *
   * @schema FirewallSpecForProviderSubnetMapping#subnetId
   */
  readonly subnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate subnetId.
   *
   * @schema FirewallSpecForProviderSubnetMapping#subnetIdRef
   */
  readonly subnetIdRef?: FirewallSpecForProviderSubnetMappingSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate subnetId.
   *
   * @schema FirewallSpecForProviderSubnetMapping#subnetIdSelector
   */
  readonly subnetIdSelector?: FirewallSpecForProviderSubnetMappingSubnetIdSelector;

}

/**
 * Converts an object of type 'FirewallSpecForProviderSubnetMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderSubnetMapping(obj: FirewallSpecForProviderSubnetMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddressType': obj.ipAddressType,
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_FirewallSpecForProviderSubnetMappingSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_FirewallSpecForProviderSubnetMappingSubnetIdSelector(obj.subnetIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema FirewallSpecForProviderVpcIdRef
 */
export interface FirewallSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecForProviderVpcIdRef#policy
   */
  readonly policy?: FirewallSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderVpcIdRef(obj: FirewallSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema FirewallSpecForProviderVpcIdSelector
 */
export interface FirewallSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: FirewallSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderVpcIdSelector(obj: FirewallSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecProviderConfigRefPolicy
 */
export interface FirewallSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecProviderConfigRefPolicy(obj: FirewallSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecProviderRefPolicy
 */
export interface FirewallSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecProviderRefPolicy(obj: FirewallSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRef
 */
export interface FirewallSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FirewallSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsToConfigRef(obj: FirewallSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FirewallSpecPublishConnectionDetailsToMetadata
 */
export interface FirewallSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FirewallSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsToMetadata(obj: FirewallSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnRefPolicy
 */
export interface FirewallSpecForProviderFirewallPolicyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderFirewallPolicyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderFirewallPolicyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderFirewallPolicyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderFirewallPolicyArnRefPolicy(obj: FirewallSpecForProviderFirewallPolicyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnSelectorPolicy
 */
export interface FirewallSpecForProviderFirewallPolicyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnSelectorPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnSelectorPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderFirewallPolicyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderFirewallPolicyArnSelectorPolicy(obj: FirewallSpecForProviderFirewallPolicyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate subnetId.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdRef
 */
export interface FirewallSpecForProviderSubnetMappingSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdRef#policy
   */
  readonly policy?: FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderSubnetMappingSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderSubnetMappingSubnetIdRef(obj: FirewallSpecForProviderSubnetMappingSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate subnetId.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelector
 */
export interface FirewallSpecForProviderSubnetMappingSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelector#policy
   */
  readonly policy?: FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderSubnetMappingSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderSubnetMappingSubnetIdSelector(obj: FirewallSpecForProviderSubnetMappingSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecForProviderVpcIdRefPolicy
 */
export interface FirewallSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderVpcIdRefPolicy(obj: FirewallSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallSpecForProviderVpcIdSelectorPolicy
 */
export interface FirewallSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderVpcIdSelectorPolicy(obj: FirewallSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecProviderConfigRefPolicyResolution
 */
export enum FirewallSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecProviderConfigRefPolicyResolve
 */
export enum FirewallSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecProviderRefPolicyResolution
 */
export enum FirewallSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecProviderRefPolicyResolve
 */
export enum FirewallSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FirewallSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsToConfigRefPolicy(obj: FirewallSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnRefPolicyResolution
 */
export enum FirewallSpecForProviderFirewallPolicyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnRefPolicyResolve
 */
export enum FirewallSpecForProviderFirewallPolicyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolution
 */
export enum FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolve
 */
export enum FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy
 */
export interface FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy(obj: FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy
 */
export interface FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy(obj: FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderVpcIdRefPolicyResolution
 */
export enum FirewallSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderVpcIdRefPolicyResolve
 */
export enum FirewallSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum FirewallSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum FirewallSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolution
 */
export enum FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolve
 */
export enum FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolution
 */
export enum FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolve
 */
export enum FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FirewallPolicy is the Schema for the FirewallPolicys API. Provides an AWS Network Firewall Policy resource.
 *
 * @schema FirewallPolicy
 */
export class FirewallPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FirewallPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkfirewall.aws.upbound.io/v1beta1',
    kind: 'FirewallPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "FirewallPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FirewallPolicyProps): any {
    return {
      ...FirewallPolicy.GVK,
      ...toJson_FirewallPolicyProps(props),
    };
  }

  /**
   * Defines a "FirewallPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FirewallPolicyProps) {
    super(scope, id, {
      ...FirewallPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FirewallPolicy.GVK,
      ...toJson_FirewallPolicyProps(resolved),
    };
  }
}

/**
 * FirewallPolicy is the Schema for the FirewallPolicys API. Provides an AWS Network Firewall Policy resource.
 *
 * @schema FirewallPolicy
 */
export interface FirewallPolicyProps {
  /**
   * @schema FirewallPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FirewallPolicySpec defines the desired state of FirewallPolicy
   *
   * @schema FirewallPolicy#spec
   */
  readonly spec: FirewallPolicySpec;

}

/**
 * Converts an object of type 'FirewallPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicyProps(obj: FirewallPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FirewallPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FirewallPolicySpec defines the desired state of FirewallPolicy
 *
 * @schema FirewallPolicySpec
 */
export interface FirewallPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FirewallPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: FirewallPolicySpecDeletionPolicy;

  /**
   * @schema FirewallPolicySpec#forProvider
   */
  readonly forProvider: FirewallPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FirewallPolicySpec#managementPolicy
   */
  readonly managementPolicy?: FirewallPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FirewallPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: FirewallPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FirewallPolicySpec#providerRef
   */
  readonly providerRef?: FirewallPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FirewallPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FirewallPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FirewallPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FirewallPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FirewallPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpec(obj: FirewallPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FirewallPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_FirewallPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FirewallPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FirewallPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FirewallPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FirewallPolicySpecDeletionPolicy
 */
export enum FirewallPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FirewallPolicySpecForProvider
 */
export interface FirewallPolicySpecForProvider {
  /**
   * A friendly description of the firewall policy.
   *
   * @schema FirewallPolicySpecForProvider#description
   */
  readonly description?: string;

  /**
   * KMS encryption configuration settings. See Encryption Configuration below for details.
   *
   * @schema FirewallPolicySpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: FirewallPolicySpecForProviderEncryptionConfiguration[];

  /**
   * A configuration block describing the rule groups and policy actions to use in the firewall policy. See Firewall Policy below for details.
   *
   * @schema FirewallPolicySpecForProvider#firewallPolicy
   */
  readonly firewallPolicy?: FirewallPolicySpecForProviderFirewallPolicy[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FirewallPolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FirewallPolicySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FirewallPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProvider(obj: FirewallPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_FirewallPolicySpecForProviderEncryptionConfiguration(y)),
    'firewallPolicy': obj.firewallPolicy?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicy(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FirewallPolicySpecManagementPolicy
 */
export enum FirewallPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FirewallPolicySpecProviderConfigRef
 */
export interface FirewallPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallPolicySpecProviderConfigRef#policy
   */
  readonly policy?: FirewallPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecProviderConfigRef(obj: FirewallPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FirewallPolicySpecProviderRef
 */
export interface FirewallPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallPolicySpecProviderRef#policy
   */
  readonly policy?: FirewallPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecProviderRef(obj: FirewallPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsTo
 */
export interface FirewallPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FirewallPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FirewallPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecPublishConnectionDetailsTo(obj: FirewallPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FirewallPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FirewallPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FirewallPolicySpecWriteConnectionSecretToRef
 */
export interface FirewallPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FirewallPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FirewallPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecWriteConnectionSecretToRef(obj: FirewallPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderEncryptionConfiguration
 */
export interface FirewallPolicySpecForProviderEncryptionConfiguration {
  /**
   * The ID of the customer managed key. You can use any of the key identifiers that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
   *
   * @schema FirewallPolicySpecForProviderEncryptionConfiguration#keyId
   */
  readonly keyId?: string;

  /**
   * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are CUSTOMER_KMS and AWS_OWNED_KMS_KEY.
   *
   * @schema FirewallPolicySpecForProviderEncryptionConfiguration#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderEncryptionConfiguration(obj: FirewallPolicySpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicy
 */
export interface FirewallPolicySpecForProviderFirewallPolicy {
  /**
   * Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a stateful_engine_options block with a rule_order value of STRICT_ORDER. You can specify one of either or neither values of aws:drop_strict or aws:drop_established, as well as any combination of aws:alert_strict and aws:alert_established.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statefulDefaultActions
   */
  readonly statefulDefaultActions?: string[];

  /**
   * A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statefulEngineOptions
   */
  readonly statefulEngineOptions?: FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions[];

  /**
   * Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statefulRuleGroupReference
   */
  readonly statefulRuleGroupReference?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference[];

  /**
   * Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's stateless_default_actions. See Stateless Custom Action below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statelessCustomAction
   */
  readonly statelessCustomAction?: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction[];

  /**
   * Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: aws:drop, aws:pass, or aws:forward_to_sfe. In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify aws:forward_to_sfe.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statelessDefaultActions
   */
  readonly statelessDefaultActions: string[];

  /**
   * Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: aws:drop, aws:pass, or aws:forward_to_sfe. In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify aws:forward_to_sfe.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statelessFragmentDefaultActions
   */
  readonly statelessFragmentDefaultActions: string[];

  /**
   * Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statelessRuleGroupReference
   */
  readonly statelessRuleGroupReference?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference[];

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicy(obj: FirewallPolicySpecForProviderFirewallPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'statefulDefaultActions': obj.statefulDefaultActions?.map(y => y),
    'statefulEngineOptions': obj.statefulEngineOptions?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions(y)),
    'statefulRuleGroupReference': obj.statefulRuleGroupReference?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference(y)),
    'statelessCustomAction': obj.statelessCustomAction?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction(y)),
    'statelessDefaultActions': obj.statelessDefaultActions?.map(y => y),
    'statelessFragmentDefaultActions': obj.statelessFragmentDefaultActions?.map(y => y),
    'statelessRuleGroupReference': obj.statelessRuleGroupReference?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallPolicySpecProviderConfigRefPolicy
 */
export interface FirewallPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecProviderConfigRefPolicy(obj: FirewallPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallPolicySpecProviderRefPolicy
 */
export interface FirewallPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecProviderRefPolicy(obj: FirewallPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface FirewallPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecPublishConnectionDetailsToConfigRef(obj: FirewallPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsToMetadata
 */
export interface FirewallPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecPublishConnectionDetailsToMetadata(obj: FirewallPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions {
  /**
   * Indicates how to manage the order of stateful rule evaluation for the policy. Default value: DEFAULT_ACTION_ORDER. Valid values: DEFAULT_ACTION_ORDER, STRICT_ORDER.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions#ruleOrder
   */
  readonly ruleOrder: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ruleOrder': obj.ruleOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference {
  /**
   * Configuration block for override values
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference#override
   */
  readonly override?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride[];

  /**
   * An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference#priority
   */
  readonly priority?: number;

  /**
   * The Amazon Resource Name (ARN) of the stateless rule group.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a RuleGroup in networkfirewall to populate resourceArn.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference#resourceArnRef
   */
  readonly resourceArnRef?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef;

  /**
   * Selector for a RuleGroup in networkfirewall to populate resourceArn.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference#resourceArnSelector
   */
  readonly resourceArnSelector?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'override': obj.override?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride(y)),
    'priority': obj.priority,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction {
  /**
   * A configuration block describing the custom action associated with the action_name. See Action Definition below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction#actionDefinition
   */
  readonly actionDefinition: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition[];

  /**
   * A friendly name of the custom action.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction#actionName
   */
  readonly actionName: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionDefinition': obj.actionDefinition?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition(y)),
    'actionName': obj.actionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference {
  /**
   * An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference#priority
   */
  readonly priority: number;

  /**
   * The Amazon Resource Name (ARN) of the stateless rule group.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a RuleGroup in networkfirewall to populate resourceArn.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference#resourceArnRef
   */
  readonly resourceArnRef?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef;

  /**
   * Selector for a RuleGroup in networkfirewall to populate resourceArn.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference#resourceArnSelector
   */
  readonly resourceArnSelector?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'priority': obj.priority,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecProviderConfigRefPolicyResolution
 */
export enum FirewallPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecProviderConfigRefPolicyResolve
 */
export enum FirewallPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecProviderRefPolicyResolution
 */
export enum FirewallPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecProviderRefPolicyResolve
 */
export enum FirewallPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride {
  /**
   * The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride#action
   */
  readonly action?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RuleGroup in networkfirewall to populate resourceArn.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef#policy
   */
  readonly policy?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RuleGroup in networkfirewall to populate resourceArn.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector#policy
   */
  readonly policy?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition {
  /**
   * A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition#publishMetricAction
   */
  readonly publishMetricAction: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction[];

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publishMetricAction': obj.publishMetricAction?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RuleGroup in networkfirewall to populate resourceArn.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef#policy
   */
  readonly policy?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RuleGroup in networkfirewall to populate resourceArn.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector#policy
   */
  readonly policy?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction {
  /**
   * Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction#dimension
   */
  readonly dimension: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension[];

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimension': obj.dimension?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolution
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolve
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolution
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolve
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension {
  /**
   * The string value to use in the custom metric dimension.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolution
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolve
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolution
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolve
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LoggingConfiguration is the Schema for the LoggingConfigurations API. Provides an AWS Network Firewall Logging Configuration resource.
 *
 * @schema LoggingConfiguration
 */
export class LoggingConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LoggingConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkfirewall.aws.upbound.io/v1beta1',
    kind: 'LoggingConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "LoggingConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LoggingConfigurationProps): any {
    return {
      ...LoggingConfiguration.GVK,
      ...toJson_LoggingConfigurationProps(props),
    };
  }

  /**
   * Defines a "LoggingConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LoggingConfigurationProps) {
    super(scope, id, {
      ...LoggingConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LoggingConfiguration.GVK,
      ...toJson_LoggingConfigurationProps(resolved),
    };
  }
}

/**
 * LoggingConfiguration is the Schema for the LoggingConfigurations API. Provides an AWS Network Firewall Logging Configuration resource.
 *
 * @schema LoggingConfiguration
 */
export interface LoggingConfigurationProps {
  /**
   * @schema LoggingConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LoggingConfigurationSpec defines the desired state of LoggingConfiguration
   *
   * @schema LoggingConfiguration#spec
   */
  readonly spec: LoggingConfigurationSpec;

}

/**
 * Converts an object of type 'LoggingConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationProps(obj: LoggingConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LoggingConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LoggingConfigurationSpec defines the desired state of LoggingConfiguration
 *
 * @schema LoggingConfigurationSpec
 */
export interface LoggingConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LoggingConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: LoggingConfigurationSpecDeletionPolicy;

  /**
   * @schema LoggingConfigurationSpec#forProvider
   */
  readonly forProvider: LoggingConfigurationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LoggingConfigurationSpec#managementPolicy
   */
  readonly managementPolicy?: LoggingConfigurationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LoggingConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: LoggingConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LoggingConfigurationSpec#providerRef
   */
  readonly providerRef?: LoggingConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LoggingConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LoggingConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LoggingConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LoggingConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LoggingConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpec(obj: LoggingConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LoggingConfigurationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LoggingConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LoggingConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LoggingConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LoggingConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LoggingConfigurationSpecDeletionPolicy
 */
export enum LoggingConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LoggingConfigurationSpecForProvider
 */
export interface LoggingConfigurationSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the Network Firewall firewall.
   *
   * @schema LoggingConfigurationSpecForProvider#firewallArn
   */
  readonly firewallArn?: string;

  /**
   * Reference to a Firewall in networkfirewall to populate firewallArn.
   *
   * @schema LoggingConfigurationSpecForProvider#firewallArnRef
   */
  readonly firewallArnRef?: LoggingConfigurationSpecForProviderFirewallArnRef;

  /**
   * Selector for a Firewall in networkfirewall to populate firewallArn.
   *
   * @schema LoggingConfigurationSpecForProvider#firewallArnSelector
   */
  readonly firewallArnSelector?: LoggingConfigurationSpecForProviderFirewallArnSelector;

  /**
   * A configuration block describing how AWS Network Firewall performs logging for a firewall. See Logging Configuration below for details.
   *
   * @schema LoggingConfigurationSpecForProvider#loggingConfiguration
   */
  readonly loggingConfiguration?: LoggingConfigurationSpecForProviderLoggingConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LoggingConfigurationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProvider(obj: LoggingConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'firewallArn': obj.firewallArn,
    'firewallArnRef': toJson_LoggingConfigurationSpecForProviderFirewallArnRef(obj.firewallArnRef),
    'firewallArnSelector': toJson_LoggingConfigurationSpecForProviderFirewallArnSelector(obj.firewallArnSelector),
    'loggingConfiguration': obj.loggingConfiguration?.map(y => toJson_LoggingConfigurationSpecForProviderLoggingConfiguration(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LoggingConfigurationSpecManagementPolicy
 */
export enum LoggingConfigurationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LoggingConfigurationSpecProviderConfigRef
 */
export interface LoggingConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoggingConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoggingConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: LoggingConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecProviderConfigRef(obj: LoggingConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoggingConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LoggingConfigurationSpecProviderRef
 */
export interface LoggingConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoggingConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoggingConfigurationSpecProviderRef#policy
   */
  readonly policy?: LoggingConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecProviderRef(obj: LoggingConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoggingConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsTo
 */
export interface LoggingConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LoggingConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LoggingConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecPublishConnectionDetailsTo(obj: LoggingConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LoggingConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LoggingConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LoggingConfigurationSpecWriteConnectionSecretToRef
 */
export interface LoggingConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LoggingConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LoggingConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecWriteConnectionSecretToRef(obj: LoggingConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Firewall in networkfirewall to populate firewallArn.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnRef
 */
export interface LoggingConfigurationSpecForProviderFirewallArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnRef#policy
   */
  readonly policy?: LoggingConfigurationSpecForProviderFirewallArnRefPolicy;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderFirewallArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderFirewallArnRef(obj: LoggingConfigurationSpecForProviderFirewallArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoggingConfigurationSpecForProviderFirewallArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Firewall in networkfirewall to populate firewallArn.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnSelector
 */
export interface LoggingConfigurationSpecForProviderFirewallArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnSelector#policy
   */
  readonly policy?: LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderFirewallArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderFirewallArnSelector(obj: LoggingConfigurationSpecForProviderFirewallArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LoggingConfigurationSpecForProviderLoggingConfiguration
 */
export interface LoggingConfigurationSpecForProviderLoggingConfiguration {
  /**
   * Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for FLOW logs and one for ALERT logs.
   *
   * @schema LoggingConfigurationSpecForProviderLoggingConfiguration#logDestinationConfig
   */
  readonly logDestinationConfig: LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig[];

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderLoggingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderLoggingConfiguration(obj: LoggingConfigurationSpecForProviderLoggingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDestinationConfig': obj.logDestinationConfig?.map(y => toJson_LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LoggingConfigurationSpecProviderConfigRefPolicy
 */
export interface LoggingConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LoggingConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LoggingConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecProviderConfigRefPolicy(obj: LoggingConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LoggingConfigurationSpecProviderRefPolicy
 */
export interface LoggingConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LoggingConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LoggingConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecProviderRefPolicy(obj: LoggingConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface LoggingConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecPublishConnectionDetailsToConfigRef(obj: LoggingConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface LoggingConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecPublishConnectionDetailsToMetadata(obj: LoggingConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnRefPolicy
 */
export interface LoggingConfigurationSpecForProviderFirewallArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnRefPolicy#resolution
   */
  readonly resolution?: LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnRefPolicy#resolve
   */
  readonly resolve?: LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderFirewallArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderFirewallArnRefPolicy(obj: LoggingConfigurationSpecForProviderFirewallArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy
 */
export interface LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy#resolution
   */
  readonly resolution?: LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy#resolve
   */
  readonly resolve?: LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy(obj: LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig
 */
export interface LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig {
  /**
   * A map describing the logging destination for the chosen log_destination_type.
   *
   * @schema LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig#logDestination
   */
  readonly logDestination: { [key: string]: string };

  /**
   * The location to send logs to. Valid values: S3, CloudWatchLogs, KinesisDataFirehose.
   *
   * @schema LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig#logDestinationType
   */
  readonly logDestinationType: string;

  /**
   * The type of log to send. Valid values: ALERT or FLOW. Alert logs report traffic that matches a StatefulRule with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
   *
   * @schema LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig#logType
   */
  readonly logType: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig(obj: LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDestination': ((obj.logDestination) === undefined) ? undefined : (Object.entries(obj.logDestination).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'logDestinationType': obj.logDestinationType,
    'logType': obj.logType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum LoggingConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum LoggingConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingConfigurationSpecProviderRefPolicyResolution
 */
export enum LoggingConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingConfigurationSpecProviderRefPolicyResolve
 */
export enum LoggingConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolution
 */
export enum LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolve
 */
export enum LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolution
 */
export enum LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolve
 */
export enum LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RuleGroup is the Schema for the RuleGroups API. Provides an AWS Network Firewall Rule Group resource.
 *
 * @schema RuleGroup
 */
export class RuleGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RuleGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkfirewall.aws.upbound.io/v1beta1',
    kind: 'RuleGroup',
  }

  /**
   * Renders a Kubernetes manifest for "RuleGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuleGroupProps): any {
    return {
      ...RuleGroup.GVK,
      ...toJson_RuleGroupProps(props),
    };
  }

  /**
   * Defines a "RuleGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuleGroupProps) {
    super(scope, id, {
      ...RuleGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RuleGroup.GVK,
      ...toJson_RuleGroupProps(resolved),
    };
  }
}

/**
 * RuleGroup is the Schema for the RuleGroups API. Provides an AWS Network Firewall Rule Group resource.
 *
 * @schema RuleGroup
 */
export interface RuleGroupProps {
  /**
   * @schema RuleGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuleGroupSpec defines the desired state of RuleGroup
   *
   * @schema RuleGroup#spec
   */
  readonly spec: RuleGroupSpec;

}

/**
 * Converts an object of type 'RuleGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupProps(obj: RuleGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuleGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuleGroupSpec defines the desired state of RuleGroup
 *
 * @schema RuleGroupSpec
 */
export interface RuleGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuleGroupSpecDeletionPolicy;

  /**
   * @schema RuleGroupSpec#forProvider
   */
  readonly forProvider: RuleGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleGroupSpec#managementPolicy
   */
  readonly managementPolicy?: RuleGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuleGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuleGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RuleGroupSpec#providerRef
   */
  readonly providerRef?: RuleGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuleGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuleGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuleGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuleGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuleGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpec(obj: RuleGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuleGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RuleGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RuleGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RuleGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuleGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleGroupSpecDeletionPolicy
 */
export enum RuleGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RuleGroupSpecForProvider
 */
export interface RuleGroupSpecForProvider {
  /**
   * The maximum number of operating resources that this rule group can use. For a stateless rule group, the capacity required is the sum of the capacity requirements of the individual rules. For a stateful rule group, the minimum capacity required is the number of individual rules.
   *
   * @schema RuleGroupSpecForProvider#capacity
   */
  readonly capacity?: number;

  /**
   * A friendly description of the rule group.
   *
   * @schema RuleGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * KMS encryption configuration settings. See Encryption Configuration below for details.
   *
   * @schema RuleGroupSpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: RuleGroupSpecForProviderEncryptionConfiguration[];

  /**
   * A friendly name of the rule group.
   *
   * @schema RuleGroupSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RuleGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * A configuration block that defines the rule group rules. Required unless rules is specified. See Rule Group below for details.
   *
   * @schema RuleGroupSpecForProvider#ruleGroup
   */
  readonly ruleGroup?: RuleGroupSpecForProviderRuleGroup[];

  /**
   * The stateful rule group rules specifications in Suricata file format, with one rule per line. Use this to import your existing Suricata compatible rule groups. Required unless rule_group is specified.
   *
   * @schema RuleGroupSpecForProvider#rules
   */
  readonly rules?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RuleGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether the rule group is stateless (containing stateless rules) or stateful (containing stateful rules). Valid values include: STATEFUL or STATELESS.
   *
   * @schema RuleGroupSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProvider(obj: RuleGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacity': obj.capacity,
    'description': obj.description,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_RuleGroupSpecForProviderEncryptionConfiguration(y)),
    'name': obj.name,
    'region': obj.region,
    'ruleGroup': obj.ruleGroup?.map(y => toJson_RuleGroupSpecForProviderRuleGroup(y)),
    'rules': obj.rules,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleGroupSpecManagementPolicy
 */
export enum RuleGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuleGroupSpecProviderConfigRef
 */
export interface RuleGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupSpecProviderConfigRef#policy
   */
  readonly policy?: RuleGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecProviderConfigRef(obj: RuleGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RuleGroupSpecProviderRef
 */
export interface RuleGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupSpecProviderRef#policy
   */
  readonly policy?: RuleGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecProviderRef(obj: RuleGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsTo
 */
export interface RuleGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuleGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuleGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuleGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecPublishConnectionDetailsTo(obj: RuleGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuleGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuleGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuleGroupSpecWriteConnectionSecretToRef
 */
export interface RuleGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuleGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuleGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuleGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecWriteConnectionSecretToRef(obj: RuleGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderEncryptionConfiguration
 */
export interface RuleGroupSpecForProviderEncryptionConfiguration {
  /**
   * The ID of the customer managed key. You can use any of the key identifiers that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
   *
   * @schema RuleGroupSpecForProviderEncryptionConfiguration#keyId
   */
  readonly keyId?: string;

  /**
   * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are CUSTOMER_KMS and AWS_OWNED_KMS_KEY.
   *
   * @schema RuleGroupSpecForProviderEncryptionConfiguration#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderEncryptionConfiguration(obj: RuleGroupSpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroup
 */
export interface RuleGroupSpecForProviderRuleGroup {
  /**
   * A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 reference_sets in a rule_group. See the AWS documentation for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroup#referenceSets
   */
  readonly referenceSets?: RuleGroupSpecForProviderRuleGroupReferenceSets[];

  /**
   * A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for stateful rule groups. See Rule Variables below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroup#ruleVariables
   */
  readonly ruleVariables?: RuleGroupSpecForProviderRuleGroupRuleVariables[];

  /**
   * A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroup#rulesSource
   */
  readonly rulesSource: RuleGroupSpecForProviderRuleGroupRulesSource[];

  /**
   * A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroup#statefulRuleOptions
   */
  readonly statefulRuleOptions?: RuleGroupSpecForProviderRuleGroupStatefulRuleOptions[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroup(obj: RuleGroupSpecForProviderRuleGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'referenceSets': obj.referenceSets?.map(y => toJson_RuleGroupSpecForProviderRuleGroupReferenceSets(y)),
    'ruleVariables': obj.ruleVariables?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRuleVariables(y)),
    'rulesSource': obj.rulesSource?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSource(y)),
    'statefulRuleOptions': obj.statefulRuleOptions?.map(y => toJson_RuleGroupSpecForProviderRuleGroupStatefulRuleOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupSpecProviderConfigRefPolicy
 */
export interface RuleGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuleGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuleGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecProviderConfigRefPolicy(obj: RuleGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupSpecProviderRefPolicy
 */
export interface RuleGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RuleGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RuleGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecProviderRefPolicy(obj: RuleGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface RuleGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecPublishConnectionDetailsToConfigRef(obj: RuleGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsToMetadata
 */
export interface RuleGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecPublishConnectionDetailsToMetadata(obj: RuleGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSets
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSets {
  /**
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSets#ipSetReferences
   */
  readonly ipSetReferences?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSets(obj: RuleGroupSpecForProviderRuleGroupReferenceSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSetReferences': obj.ipSetReferences?.map(y => toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRuleVariables
 */
export interface RuleGroupSpecForProviderRuleGroupRuleVariables {
  /**
   * Set of configuration blocks that define IP address information. See IP Sets below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariables#ipSets
   */
  readonly ipSets?: RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets[];

  /**
   * Set of configuration blocks that define port range information. See Port Sets below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariables#portSets
   */
  readonly portSets?: RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRuleVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRuleVariables(obj: RuleGroupSpecForProviderRuleGroupRuleVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSets': obj.ipSets?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets(y)),
    'portSets': obj.portSets?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSource
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSource {
  /**
   * A configuration block containing stateful inspection criteria for a domain list rule group. See Rules Source List below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSource#rulesSourceList
   */
  readonly rulesSourceList?: RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList[];

  /**
   * The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain stateful inspection criteria and the action to take for traffic that matches the criteria.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSource#rulesString
   */
  readonly rulesString?: string;

  /**
   * Set of configuration blocks containing stateful inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSource#statefulRule
   */
  readonly statefulRule?: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule[];

  /**
   * A configuration block containing stateless inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSource#statelessRulesAndCustomActions
   */
  readonly statelessRulesAndCustomActions?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSource(obj: RuleGroupSpecForProviderRuleGroupRulesSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rulesSourceList': obj.rulesSourceList?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList(y)),
    'rulesString': obj.rulesString,
    'statefulRule': obj.statefulRule?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule(y)),
    'statelessRulesAndCustomActions': obj.statelessRulesAndCustomActions?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupStatefulRuleOptions
 */
export interface RuleGroupSpecForProviderRuleGroupStatefulRuleOptions {
  /**
   * Indicates how to manage the order of the rule evaluation for the rule group. Default value: DEFAULT_ACTION_ORDER. Valid values: DEFAULT_ACTION_ORDER, STRICT_ORDER.
   *
   * @schema RuleGroupSpecForProviderRuleGroupStatefulRuleOptions#ruleOrder
   */
  readonly ruleOrder: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupStatefulRuleOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupStatefulRuleOptions(obj: RuleGroupSpecForProviderRuleGroupStatefulRuleOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ruleOrder': obj.ruleOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupSpecProviderConfigRefPolicyResolution
 */
export enum RuleGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupSpecProviderConfigRefPolicyResolve
 */
export enum RuleGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupSpecProviderRefPolicyResolution
 */
export enum RuleGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupSpecProviderRefPolicyResolve
 */
export enum RuleGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences {
  /**
   * Set of configuration blocks that define the IP Reference information. See IP Set Reference below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences#ipSetReference
   */
  readonly ipSetReference: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference[];

  /**
   * An unique alphanumeric string to identify the port_set.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSetReference': obj.ipSetReference?.map(y => toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference(y)),
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets
 */
export interface RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets {
  /**
   * A configuration block that defines a set of IP addresses. See IP Set below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets#ipSet
   */
  readonly ipSet: RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet[];

  /**
   * An unique alphanumeric string to identify the port_set.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets(obj: RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSet': obj.ipSet?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet(y)),
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets
 */
export interface RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets {
  /**
   * An unique alphanumeric string to identify the port_set.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets#key
   */
  readonly key: string;

  /**
   * A configuration block that defines a set of port ranges. See Port Set below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets#portSet
   */
  readonly portSet: RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets(obj: RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'portSet': obj.portSet?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList {
  /**
   * String value to specify whether domains in the target list are allowed or denied access. Valid values: ALLOWLIST, DENYLIST.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList#generatedRulesType
   */
  readonly generatedRulesType: string;

  /**
   * Set of types of domain specifications that are provided in the targets argument. Valid values: HTTP_HOST, TLS_SNI.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList#targetTypes
   */
  readonly targetTypes: string[];

  /**
   * Set of domains that you want to inspect for in your traffic flows.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList#targets
   */
  readonly targets: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList(obj: RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatedRulesType': obj.generatedRulesType,
    'targetTypes': obj.targetTypes?.map(y => y),
    'targets': obj.targets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule {
  /**
   * Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: ALERT, DROP or PASS.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule#action
   */
  readonly action: string;

  /**
   * A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule#header
   */
  readonly header: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader[];

  /**
   * Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule#ruleOption
   */
  readonly ruleOption: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'header': obj.header?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader(y)),
    'ruleOption': obj.ruleOption?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions {
  /**
   * Set of configuration blocks containing custom action definitions that are available for use by the set of stateless rule. See Custom Action below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions#customAction
   */
  readonly customAction?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction[];

  /**
   * Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions#statelessRule
   */
  readonly statelessRule: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customAction': obj.customAction?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction(y)),
    'statelessRule': obj.statelessRule?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference {
  /**
   * Set of Managed Prefix IP ARN(s)
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference#referenceArn
   */
  readonly referenceArn?: string;

  /**
   * Reference to a ManagedPrefixList in ec2 to populate referenceArn.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference#referenceArnRef
   */
  readonly referenceArnRef?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef;

  /**
   * Selector for a ManagedPrefixList in ec2 to populate referenceArn.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference#referenceArnSelector
   */
  readonly referenceArnSelector?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'referenceArn': obj.referenceArn,
    'referenceArnRef': toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef(obj.referenceArnRef),
    'referenceArnSelector': toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector(obj.referenceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet
 */
export interface RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet {
  /**
   * Set of port ranges.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet#definition
   */
  readonly definition: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet(obj: RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definition': obj.definition?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet
 */
export interface RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet {
  /**
   * Set of port ranges.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet#definition
   */
  readonly definition: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet(obj: RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definition': obj.definition?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader {
  /**
   * Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#destination
   */
  readonly destination: string;

  /**
   * Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#destinationPort
   */
  readonly destinationPort: string;

  /**
   * The direction of traffic flow to inspect. Valid values: ANY or FORWARD.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#direction
   */
  readonly direction: string;

  /**
   * The protocol to inspect. Valid values: IP, TCP, UDP, ICMP, HTTP, FTP, TLS, SMB, DNS, DCERPC, SSH, SMTP, IMAP, MSN, KRB5, IKEV2, TFTP, NTP, DHCP.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#protocol
   */
  readonly protocol: string;

  /**
   * Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#source
   */
  readonly source: string;

  /**
   * Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#sourcePort
   */
  readonly sourcePort: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination,
    'destinationPort': obj.destinationPort,
    'direction': obj.direction,
    'protocol': obj.protocol,
    'source': obj.source,
    'sourcePort': obj.sourcePort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption {
  /**
   * Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection. See Snort General Rule Options or Suricata Rule Options for more details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption#keyword
   */
  readonly keyword: string;

  /**
   * Set of strings for additional settings to use in stateful rule inspection.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption#settings
   */
  readonly settings?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyword': obj.keyword,
    'settings': obj.settings?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction {
  /**
   * A configuration block describing the custom action associated with the action_name. See Action Definition below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction#actionDefinition
   */
  readonly actionDefinition: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition[];

  /**
   * A friendly name of the custom action.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction#actionName
   */
  readonly actionName: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionDefinition': obj.actionDefinition?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition(y)),
    'actionName': obj.actionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule {
  /**
   * A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule#priority
   */
  readonly priority: number;

  /**
   * A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule#ruleDefinition
   */
  readonly ruleDefinition: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'priority': obj.priority,
    'ruleDefinition': obj.ruleDefinition?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ManagedPrefixList in ec2 to populate referenceArn.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef#policy
   */
  readonly policy?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ManagedPrefixList in ec2 to populate referenceArn.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector#policy
   */
  readonly policy?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition {
  /**
   * A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition#publishMetricAction
   */
  readonly publishMetricAction: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publishMetricAction': obj.publishMetricAction?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition {
  /**
   * Set of actions to take on a packet that matches one of the stateless rule definition's match_attributes. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: aws:pass, aws:drop, aws:forward_to_sfe.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition#actions
   */
  readonly actions: string[];

  /**
   * A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition#matchAttributes
   */
  readonly matchAttributes: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => y),
    'matchAttributes': obj.matchAttributes?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy#resolution
   */
  readonly resolution?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy#resolve
   */
  readonly resolve?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy#resolution
   */
  readonly resolution?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy#resolve
   */
  readonly resolve?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction {
  /**
   * Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction#dimension
   */
  readonly dimension: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimension': obj.dimension?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes {
  /**
   * Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#destination
   */
  readonly destination?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination[];

  /**
   * Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#destinationPort
   */
  readonly destinationPort?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort[];

  /**
   * Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#protocols
   */
  readonly protocols?: number[];

  /**
   * Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#source
   */
  readonly source?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource[];

  /**
   * Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#sourcePort
   */
  readonly sourcePort?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort[];

  /**
   * Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#tcpFlag
   */
  readonly tcpFlag?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination(y)),
    'destinationPort': obj.destinationPort?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort(y)),
    'protocols': obj.protocols?.map(y => y),
    'source': obj.source?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource(y)),
    'sourcePort': obj.sourcePort?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort(y)),
    'tcpFlag': obj.tcpFlag?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolution
 */
export enum RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolve
 */
export enum RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolution
 */
export enum RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolve
 */
export enum RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension {
  /**
   * The value to use in the custom metric dimension.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination {
  /**
   * An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination#addressDefinition
   */
  readonly addressDefinition: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressDefinition': obj.addressDefinition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort {
  /**
   * The lower limit of the port range. This must be less than or equal to the to_port.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort#fromPort
   */
  readonly fromPort: number;

  /**
   * The upper limit of the port range. This must be greater than or equal to the from_port.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort#toPort
   */
  readonly toPort?: number;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'toPort': obj.toPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource {
  /**
   * An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource#addressDefinition
   */
  readonly addressDefinition: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressDefinition': obj.addressDefinition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort {
  /**
   * The lower limit of the port range. This must be less than or equal to the to_port.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort#fromPort
   */
  readonly fromPort: number;

  /**
   * The upper limit of the port range. This must be greater than or equal to the from_port.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort#toPort
   */
  readonly toPort?: number;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'toPort': obj.toPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag {
  /**
   * Set of flags to look for in a packet. This setting can only specify values that are also specified in masks. Valid values: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag#flags
   */
  readonly flags: string[];

  /**
   * Set of flags to consider in the inspection. To inspect all flags, leave this empty. Valid values: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag#masks
   */
  readonly masks?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flags': obj.flags?.map(y => y),
    'masks': obj.masks?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

