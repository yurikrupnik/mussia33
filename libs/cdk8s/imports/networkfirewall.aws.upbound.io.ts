// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Firewall is the Schema for the Firewalls API. Provides an AWS Network Firewall Firewall resource.
 *
 * @schema Firewall
 */
export class Firewall extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Firewall"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkfirewall.aws.upbound.io/v1beta1',
    kind: 'Firewall',
  }

  /**
   * Renders a Kubernetes manifest for "Firewall".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FirewallProps): any {
    return {
      ...Firewall.GVK,
      ...toJson_FirewallProps(props),
    };
  }

  /**
   * Defines a "Firewall" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FirewallProps) {
    super(scope, id, {
      ...Firewall.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Firewall.GVK,
      ...toJson_FirewallProps(resolved),
    };
  }
}

/**
 * Firewall is the Schema for the Firewalls API. Provides an AWS Network Firewall Firewall resource.
 *
 * @schema Firewall
 */
export interface FirewallProps {
  /**
   * @schema Firewall#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FirewallSpec defines the desired state of Firewall
   *
   * @schema Firewall#spec
   */
  readonly spec: FirewallSpec;

}

/**
 * Converts an object of type 'FirewallProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallProps(obj: FirewallProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FirewallSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FirewallSpec defines the desired state of Firewall
 *
 * @schema FirewallSpec
 */
export interface FirewallSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FirewallSpec#deletionPolicy
   */
  readonly deletionPolicy?: FirewallSpecDeletionPolicy;

  /**
   * @schema FirewallSpec#forProvider
   */
  readonly forProvider: FirewallSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FirewallSpec#initProvider
   */
  readonly initProvider?: FirewallSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FirewallSpec#managementPolicies
   */
  readonly managementPolicies?: FirewallSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FirewallSpec#providerConfigRef
   */
  readonly providerConfigRef?: FirewallSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FirewallSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FirewallSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FirewallSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FirewallSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FirewallSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpec(obj: FirewallSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FirewallSpecForProvider(obj.forProvider),
    'initProvider': toJson_FirewallSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FirewallSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FirewallSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FirewallSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FirewallSpecDeletionPolicy
 */
export enum FirewallSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FirewallSpecForProvider
 */
export interface FirewallSpecForProvider {
  /**
   * A boolean flag indicating whether it is possible to delete the firewall. Defaults to false.
   *
   * @default false.
   * @schema FirewallSpecForProvider#deleteProtection
   */
  readonly deleteProtection?: boolean;

  /**
   * A friendly description of the firewall.
   *
   * @schema FirewallSpecForProvider#description
   */
  readonly description?: string;

  /**
   * KMS encryption configuration settings. See Encryption Configuration below for details.
   *
   * @schema FirewallSpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: FirewallSpecForProviderEncryptionConfiguration[];

  /**
   * The Amazon Resource Name (ARN) of the VPC Firewall policy.
   *
   * @schema FirewallSpecForProvider#firewallPolicyArn
   */
  readonly firewallPolicyArn?: string;

  /**
   * Reference to a FirewallPolicy in networkfirewall to populate firewallPolicyArn.
   *
   * @schema FirewallSpecForProvider#firewallPolicyArnRef
   */
  readonly firewallPolicyArnRef?: FirewallSpecForProviderFirewallPolicyArnRef;

  /**
   * Selector for a FirewallPolicy in networkfirewall to populate firewallPolicyArn.
   *
   * @schema FirewallSpecForProvider#firewallPolicyArnSelector
   */
  readonly firewallPolicyArnSelector?: FirewallSpecForProviderFirewallPolicyArnSelector;

  /**
   * (Option) A boolean flag indicating whether it is possible to change the associated firewall policy. Defaults to false.
   *
   * @default false.
   * @schema FirewallSpecForProvider#firewallPolicyChangeProtection
   */
  readonly firewallPolicyChangeProtection?: boolean;

  /**
   * A friendly name of the firewall.
   *
   * @schema FirewallSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FirewallSpecForProvider#region
   */
  readonly region: string;

  /**
   * A boolean flag indicating whether it is possible to change the associated subnet(s). Defaults to false.
   *
   * @default false.
   * @schema FirewallSpecForProvider#subnetChangeProtection
   */
  readonly subnetChangeProtection?: boolean;

  /**
   * Set of configuration blocks describing the public subnets. Each subnet must belong to a different Availability Zone in the VPC. AWS Network Firewall creates a firewall endpoint in each subnet. See Subnet Mapping below for details.
   *
   * @schema FirewallSpecForProvider#subnetMapping
   */
  readonly subnetMapping?: FirewallSpecForProviderSubnetMapping[];

  /**
   * Key-value map of resource tags.
   *
   * @schema FirewallSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The unique identifier of the VPC where AWS Network Firewall should create the firewall.
   *
   * @schema FirewallSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema FirewallSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: FirewallSpecForProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema FirewallSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: FirewallSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'FirewallSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProvider(obj: FirewallSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteProtection': obj.deleteProtection,
    'description': obj.description,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_FirewallSpecForProviderEncryptionConfiguration(y)),
    'firewallPolicyArn': obj.firewallPolicyArn,
    'firewallPolicyArnRef': toJson_FirewallSpecForProviderFirewallPolicyArnRef(obj.firewallPolicyArnRef),
    'firewallPolicyArnSelector': toJson_FirewallSpecForProviderFirewallPolicyArnSelector(obj.firewallPolicyArnSelector),
    'firewallPolicyChangeProtection': obj.firewallPolicyChangeProtection,
    'name': obj.name,
    'region': obj.region,
    'subnetChangeProtection': obj.subnetChangeProtection,
    'subnetMapping': obj.subnetMapping?.map(y => toJson_FirewallSpecForProviderSubnetMapping(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_FirewallSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_FirewallSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FirewallSpecInitProvider
 */
export interface FirewallSpecInitProvider {
  /**
   * A boolean flag indicating whether it is possible to delete the firewall. Defaults to false.
   *
   * @default false.
   * @schema FirewallSpecInitProvider#deleteProtection
   */
  readonly deleteProtection?: boolean;

  /**
   * A friendly description of the firewall.
   *
   * @schema FirewallSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * KMS encryption configuration settings. See Encryption Configuration below for details.
   *
   * @schema FirewallSpecInitProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: FirewallSpecInitProviderEncryptionConfiguration[];

  /**
   * (Option) A boolean flag indicating whether it is possible to change the associated firewall policy. Defaults to false.
   *
   * @default false.
   * @schema FirewallSpecInitProvider#firewallPolicyChangeProtection
   */
  readonly firewallPolicyChangeProtection?: boolean;

  /**
   * A friendly name of the firewall.
   *
   * @schema FirewallSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * A boolean flag indicating whether it is possible to change the associated subnet(s). Defaults to false.
   *
   * @default false.
   * @schema FirewallSpecInitProvider#subnetChangeProtection
   */
  readonly subnetChangeProtection?: boolean;

  /**
   * Set of configuration blocks describing the public subnets. Each subnet must belong to a different Availability Zone in the VPC. AWS Network Firewall creates a firewall endpoint in each subnet. See Subnet Mapping below for details.
   *
   * @schema FirewallSpecInitProvider#subnetMapping
   */
  readonly subnetMapping?: FirewallSpecInitProviderSubnetMapping[];

  /**
   * Key-value map of resource tags.
   *
   * @schema FirewallSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FirewallSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecInitProvider(obj: FirewallSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteProtection': obj.deleteProtection,
    'description': obj.description,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_FirewallSpecInitProviderEncryptionConfiguration(y)),
    'firewallPolicyChangeProtection': obj.firewallPolicyChangeProtection,
    'name': obj.name,
    'subnetChangeProtection': obj.subnetChangeProtection,
    'subnetMapping': obj.subnetMapping?.map(y => toJson_FirewallSpecInitProviderSubnetMapping(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FirewallSpecManagementPolicies
 */
export enum FirewallSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FirewallSpecProviderConfigRef
 */
export interface FirewallSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecProviderConfigRef#policy
   */
  readonly policy?: FirewallSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecProviderConfigRef(obj: FirewallSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FirewallSpecPublishConnectionDetailsTo
 */
export interface FirewallSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FirewallSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FirewallSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FirewallSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FirewallSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FirewallSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsTo(obj: FirewallSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FirewallSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FirewallSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FirewallSpecWriteConnectionSecretToRef
 */
export interface FirewallSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FirewallSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FirewallSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FirewallSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecWriteConnectionSecretToRef(obj: FirewallSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallSpecForProviderEncryptionConfiguration
 */
export interface FirewallSpecForProviderEncryptionConfiguration {
  /**
   * The ID of the customer managed key. You can use any of the key identifiers that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
   *
   * @schema FirewallSpecForProviderEncryptionConfiguration#keyId
   */
  readonly keyId?: string;

  /**
   * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are CUSTOMER_KMS and AWS_OWNED_KMS_KEY.
   *
   * @schema FirewallSpecForProviderEncryptionConfiguration#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FirewallSpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderEncryptionConfiguration(obj: FirewallSpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a FirewallPolicy in networkfirewall to populate firewallPolicyArn.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnRef
 */
export interface FirewallSpecForProviderFirewallPolicyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnRef#policy
   */
  readonly policy?: FirewallSpecForProviderFirewallPolicyArnRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderFirewallPolicyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderFirewallPolicyArnRef(obj: FirewallSpecForProviderFirewallPolicyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecForProviderFirewallPolicyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a FirewallPolicy in networkfirewall to populate firewallPolicyArn.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnSelector
 */
export interface FirewallSpecForProviderFirewallPolicyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnSelector#policy
   */
  readonly policy?: FirewallSpecForProviderFirewallPolicyArnSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderFirewallPolicyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderFirewallPolicyArnSelector(obj: FirewallSpecForProviderFirewallPolicyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallSpecForProviderFirewallPolicyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallSpecForProviderSubnetMapping
 */
export interface FirewallSpecForProviderSubnetMapping {
  /**
   * The subnet's IP address type. Valida values: "DUALSTACK", "IPV4".
   *
   * @schema FirewallSpecForProviderSubnetMapping#ipAddressType
   */
  readonly ipAddressType?: string;

  /**
   * The unique identifier for the subnet.
   *
   * @schema FirewallSpecForProviderSubnetMapping#subnetId
   */
  readonly subnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate subnetId.
   *
   * @schema FirewallSpecForProviderSubnetMapping#subnetIdRef
   */
  readonly subnetIdRef?: FirewallSpecForProviderSubnetMappingSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate subnetId.
   *
   * @schema FirewallSpecForProviderSubnetMapping#subnetIdSelector
   */
  readonly subnetIdSelector?: FirewallSpecForProviderSubnetMappingSubnetIdSelector;

}

/**
 * Converts an object of type 'FirewallSpecForProviderSubnetMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderSubnetMapping(obj: FirewallSpecForProviderSubnetMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddressType': obj.ipAddressType,
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_FirewallSpecForProviderSubnetMappingSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_FirewallSpecForProviderSubnetMappingSubnetIdSelector(obj.subnetIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema FirewallSpecForProviderVpcIdRef
 */
export interface FirewallSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecForProviderVpcIdRef#policy
   */
  readonly policy?: FirewallSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderVpcIdRef(obj: FirewallSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema FirewallSpecForProviderVpcIdSelector
 */
export interface FirewallSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: FirewallSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderVpcIdSelector(obj: FirewallSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallSpecInitProviderEncryptionConfiguration
 */
export interface FirewallSpecInitProviderEncryptionConfiguration {
  /**
   * The ID of the customer managed key. You can use any of the key identifiers that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
   *
   * @schema FirewallSpecInitProviderEncryptionConfiguration#keyId
   */
  readonly keyId?: string;

  /**
   * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are CUSTOMER_KMS and AWS_OWNED_KMS_KEY.
   *
   * @schema FirewallSpecInitProviderEncryptionConfiguration#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FirewallSpecInitProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecInitProviderEncryptionConfiguration(obj: FirewallSpecInitProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallSpecInitProviderSubnetMapping
 */
export interface FirewallSpecInitProviderSubnetMapping {
  /**
   * The subnet's IP address type. Valida values: "DUALSTACK", "IPV4".
   *
   * @schema FirewallSpecInitProviderSubnetMapping#ipAddressType
   */
  readonly ipAddressType?: string;

}

/**
 * Converts an object of type 'FirewallSpecInitProviderSubnetMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecInitProviderSubnetMapping(obj: FirewallSpecInitProviderSubnetMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddressType': obj.ipAddressType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecProviderConfigRefPolicy
 */
export interface FirewallSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecProviderConfigRefPolicy(obj: FirewallSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRef
 */
export interface FirewallSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FirewallSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsToConfigRef(obj: FirewallSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FirewallSpecPublishConnectionDetailsToMetadata
 */
export interface FirewallSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FirewallSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsToMetadata(obj: FirewallSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnRefPolicy
 */
export interface FirewallSpecForProviderFirewallPolicyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderFirewallPolicyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderFirewallPolicyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderFirewallPolicyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderFirewallPolicyArnRefPolicy(obj: FirewallSpecForProviderFirewallPolicyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnSelectorPolicy
 */
export interface FirewallSpecForProviderFirewallPolicyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnSelectorPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderFirewallPolicyArnSelectorPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderFirewallPolicyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderFirewallPolicyArnSelectorPolicy(obj: FirewallSpecForProviderFirewallPolicyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate subnetId.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdRef
 */
export interface FirewallSpecForProviderSubnetMappingSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdRef#policy
   */
  readonly policy?: FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderSubnetMappingSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderSubnetMappingSubnetIdRef(obj: FirewallSpecForProviderSubnetMappingSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate subnetId.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelector
 */
export interface FirewallSpecForProviderSubnetMappingSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelector#policy
   */
  readonly policy?: FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallSpecForProviderSubnetMappingSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderSubnetMappingSubnetIdSelector(obj: FirewallSpecForProviderSubnetMappingSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecForProviderVpcIdRefPolicy
 */
export interface FirewallSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderVpcIdRefPolicy(obj: FirewallSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallSpecForProviderVpcIdSelectorPolicy
 */
export interface FirewallSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderVpcIdSelectorPolicy(obj: FirewallSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecProviderConfigRefPolicyResolution
 */
export enum FirewallSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecProviderConfigRefPolicyResolve
 */
export enum FirewallSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FirewallSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsToConfigRefPolicy(obj: FirewallSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnRefPolicyResolution
 */
export enum FirewallSpecForProviderFirewallPolicyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnRefPolicyResolve
 */
export enum FirewallSpecForProviderFirewallPolicyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolution
 */
export enum FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolve
 */
export enum FirewallSpecForProviderFirewallPolicyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy
 */
export interface FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy(obj: FirewallSpecForProviderSubnetMappingSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy
 */
export interface FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy(obj: FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderVpcIdRefPolicyResolution
 */
export enum FirewallSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderVpcIdRefPolicyResolve
 */
export enum FirewallSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum FirewallSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum FirewallSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolution
 */
export enum FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolve
 */
export enum FirewallSpecForProviderSubnetMappingSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolution
 */
export enum FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolve
 */
export enum FirewallSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FirewallPolicy is the Schema for the FirewallPolicys API. Provides an AWS Network Firewall Policy resource.
 *
 * @schema FirewallPolicy
 */
export class FirewallPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FirewallPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkfirewall.aws.upbound.io/v1beta1',
    kind: 'FirewallPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "FirewallPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FirewallPolicyProps): any {
    return {
      ...FirewallPolicy.GVK,
      ...toJson_FirewallPolicyProps(props),
    };
  }

  /**
   * Defines a "FirewallPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FirewallPolicyProps) {
    super(scope, id, {
      ...FirewallPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FirewallPolicy.GVK,
      ...toJson_FirewallPolicyProps(resolved),
    };
  }
}

/**
 * FirewallPolicy is the Schema for the FirewallPolicys API. Provides an AWS Network Firewall Policy resource.
 *
 * @schema FirewallPolicy
 */
export interface FirewallPolicyProps {
  /**
   * @schema FirewallPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FirewallPolicySpec defines the desired state of FirewallPolicy
   *
   * @schema FirewallPolicy#spec
   */
  readonly spec: FirewallPolicySpec;

}

/**
 * Converts an object of type 'FirewallPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicyProps(obj: FirewallPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FirewallPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FirewallPolicySpec defines the desired state of FirewallPolicy
 *
 * @schema FirewallPolicySpec
 */
export interface FirewallPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FirewallPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: FirewallPolicySpecDeletionPolicy;

  /**
   * @schema FirewallPolicySpec#forProvider
   */
  readonly forProvider: FirewallPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FirewallPolicySpec#initProvider
   */
  readonly initProvider?: FirewallPolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FirewallPolicySpec#managementPolicies
   */
  readonly managementPolicies?: FirewallPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FirewallPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: FirewallPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FirewallPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FirewallPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FirewallPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FirewallPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FirewallPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpec(obj: FirewallPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FirewallPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_FirewallPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FirewallPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FirewallPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FirewallPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FirewallPolicySpecDeletionPolicy
 */
export enum FirewallPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FirewallPolicySpecForProvider
 */
export interface FirewallPolicySpecForProvider {
  /**
   * A friendly description of the firewall policy.
   *
   * @schema FirewallPolicySpecForProvider#description
   */
  readonly description?: string;

  /**
   * KMS encryption configuration settings. See Encryption Configuration below for details.
   *
   * @schema FirewallPolicySpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: FirewallPolicySpecForProviderEncryptionConfiguration[];

  /**
   * A configuration block describing the rule groups and policy actions to use in the firewall policy. See Firewall Policy below for details.
   *
   * @schema FirewallPolicySpecForProvider#firewallPolicy
   */
  readonly firewallPolicy?: FirewallPolicySpecForProviderFirewallPolicy[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FirewallPolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FirewallPolicySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FirewallPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProvider(obj: FirewallPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_FirewallPolicySpecForProviderEncryptionConfiguration(y)),
    'firewallPolicy': obj.firewallPolicy?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicy(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FirewallPolicySpecInitProvider
 */
export interface FirewallPolicySpecInitProvider {
  /**
   * A friendly description of the firewall policy.
   *
   * @schema FirewallPolicySpecInitProvider#description
   */
  readonly description?: string;

  /**
   * KMS encryption configuration settings. See Encryption Configuration below for details.
   *
   * @schema FirewallPolicySpecInitProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: FirewallPolicySpecInitProviderEncryptionConfiguration[];

  /**
   * A configuration block describing the rule groups and policy actions to use in the firewall policy. See Firewall Policy below for details.
   *
   * @schema FirewallPolicySpecInitProvider#firewallPolicy
   */
  readonly firewallPolicy?: FirewallPolicySpecInitProviderFirewallPolicy[];

  /**
   * Key-value map of resource tags.
   *
   * @schema FirewallPolicySpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProvider(obj: FirewallPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_FirewallPolicySpecInitProviderEncryptionConfiguration(y)),
    'firewallPolicy': obj.firewallPolicy?.map(y => toJson_FirewallPolicySpecInitProviderFirewallPolicy(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FirewallPolicySpecManagementPolicies
 */
export enum FirewallPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FirewallPolicySpecProviderConfigRef
 */
export interface FirewallPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallPolicySpecProviderConfigRef#policy
   */
  readonly policy?: FirewallPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecProviderConfigRef(obj: FirewallPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsTo
 */
export interface FirewallPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FirewallPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FirewallPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecPublishConnectionDetailsTo(obj: FirewallPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FirewallPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FirewallPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FirewallPolicySpecWriteConnectionSecretToRef
 */
export interface FirewallPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FirewallPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FirewallPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecWriteConnectionSecretToRef(obj: FirewallPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderEncryptionConfiguration
 */
export interface FirewallPolicySpecForProviderEncryptionConfiguration {
  /**
   * The ID of the customer managed key. You can use any of the key identifiers that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
   *
   * @schema FirewallPolicySpecForProviderEncryptionConfiguration#keyId
   */
  readonly keyId?: string;

  /**
   * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are CUSTOMER_KMS and AWS_OWNED_KMS_KEY.
   *
   * @schema FirewallPolicySpecForProviderEncryptionConfiguration#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderEncryptionConfiguration(obj: FirewallPolicySpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicy
 */
export interface FirewallPolicySpecForProviderFirewallPolicy {
  /**
   * Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a stateful_engine_options block with a rule_order value of STRICT_ORDER. You can specify one of either or neither values of aws:drop_strict or aws:drop_established, as well as any combination of aws:alert_strict and aws:alert_established.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statefulDefaultActions
   */
  readonly statefulDefaultActions?: string[];

  /**
   * A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statefulEngineOptions
   */
  readonly statefulEngineOptions?: FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions[];

  /**
   * Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statefulRuleGroupReference
   */
  readonly statefulRuleGroupReference?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference[];

  /**
   * Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's stateless_default_actions. See Stateless Custom Action below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statelessCustomAction
   */
  readonly statelessCustomAction?: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction[];

  /**
   * Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: aws:drop, aws:pass, or aws:forward_to_sfe. In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify aws:forward_to_sfe.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statelessDefaultActions
   */
  readonly statelessDefaultActions?: string[];

  /**
   * Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: aws:drop, aws:pass, or aws:forward_to_sfe. In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify aws:forward_to_sfe.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statelessFragmentDefaultActions
   */
  readonly statelessFragmentDefaultActions?: string[];

  /**
   * Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicy#statelessRuleGroupReference
   */
  readonly statelessRuleGroupReference?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference[];

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicy(obj: FirewallPolicySpecForProviderFirewallPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'statefulDefaultActions': obj.statefulDefaultActions?.map(y => y),
    'statefulEngineOptions': obj.statefulEngineOptions?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions(y)),
    'statefulRuleGroupReference': obj.statefulRuleGroupReference?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference(y)),
    'statelessCustomAction': obj.statelessCustomAction?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction(y)),
    'statelessDefaultActions': obj.statelessDefaultActions?.map(y => y),
    'statelessFragmentDefaultActions': obj.statelessFragmentDefaultActions?.map(y => y),
    'statelessRuleGroupReference': obj.statelessRuleGroupReference?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecInitProviderEncryptionConfiguration
 */
export interface FirewallPolicySpecInitProviderEncryptionConfiguration {
  /**
   * The ID of the customer managed key. You can use any of the key identifiers that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
   *
   * @schema FirewallPolicySpecInitProviderEncryptionConfiguration#keyId
   */
  readonly keyId?: string;

  /**
   * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are CUSTOMER_KMS and AWS_OWNED_KMS_KEY.
   *
   * @schema FirewallPolicySpecInitProviderEncryptionConfiguration#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProviderEncryptionConfiguration(obj: FirewallPolicySpecInitProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecInitProviderFirewallPolicy
 */
export interface FirewallPolicySpecInitProviderFirewallPolicy {
  /**
   * Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a stateful_engine_options block with a rule_order value of STRICT_ORDER. You can specify one of either or neither values of aws:drop_strict or aws:drop_established, as well as any combination of aws:alert_strict and aws:alert_established.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicy#statefulDefaultActions
   */
  readonly statefulDefaultActions?: string[];

  /**
   * A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicy#statefulEngineOptions
   */
  readonly statefulEngineOptions?: FirewallPolicySpecInitProviderFirewallPolicyStatefulEngineOptions[];

  /**
   * Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicy#statefulRuleGroupReference
   */
  readonly statefulRuleGroupReference?: FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReference[];

  /**
   * Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's stateless_default_actions. See Stateless Custom Action below for details.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicy#statelessCustomAction
   */
  readonly statelessCustomAction?: FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomAction[];

  /**
   * Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: aws:drop, aws:pass, or aws:forward_to_sfe. In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify aws:forward_to_sfe.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicy#statelessDefaultActions
   */
  readonly statelessDefaultActions?: string[];

  /**
   * Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: aws:drop, aws:pass, or aws:forward_to_sfe. In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify aws:forward_to_sfe.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicy#statelessFragmentDefaultActions
   */
  readonly statelessFragmentDefaultActions?: string[];

  /**
   * Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicy#statelessRuleGroupReference
   */
  readonly statelessRuleGroupReference?: FirewallPolicySpecInitProviderFirewallPolicyStatelessRuleGroupReference[];

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProviderFirewallPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProviderFirewallPolicy(obj: FirewallPolicySpecInitProviderFirewallPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'statefulDefaultActions': obj.statefulDefaultActions?.map(y => y),
    'statefulEngineOptions': obj.statefulEngineOptions?.map(y => toJson_FirewallPolicySpecInitProviderFirewallPolicyStatefulEngineOptions(y)),
    'statefulRuleGroupReference': obj.statefulRuleGroupReference?.map(y => toJson_FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReference(y)),
    'statelessCustomAction': obj.statelessCustomAction?.map(y => toJson_FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomAction(y)),
    'statelessDefaultActions': obj.statelessDefaultActions?.map(y => y),
    'statelessFragmentDefaultActions': obj.statelessFragmentDefaultActions?.map(y => y),
    'statelessRuleGroupReference': obj.statelessRuleGroupReference?.map(y => toJson_FirewallPolicySpecInitProviderFirewallPolicyStatelessRuleGroupReference(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallPolicySpecProviderConfigRefPolicy
 */
export interface FirewallPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecProviderConfigRefPolicy(obj: FirewallPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface FirewallPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecPublishConnectionDetailsToConfigRef(obj: FirewallPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsToMetadata
 */
export interface FirewallPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecPublishConnectionDetailsToMetadata(obj: FirewallPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions {
  /**
   * Indicates how to manage the order of stateful rule evaluation for the policy. Default value: DEFAULT_ACTION_ORDER. Valid values: DEFAULT_ACTION_ORDER, STRICT_ORDER.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions#ruleOrder
   */
  readonly ruleOrder?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulEngineOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ruleOrder': obj.ruleOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference {
  /**
   * Configuration block for override values
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference#override
   */
  readonly override?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride[];

  /**
   * An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference#priority
   */
  readonly priority?: number;

  /**
   * The Amazon Resource Name (ARN) of the stateless rule group.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a RuleGroup in networkfirewall to populate resourceArn.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference#resourceArnRef
   */
  readonly resourceArnRef?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef;

  /**
   * Selector for a RuleGroup in networkfirewall to populate resourceArn.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference#resourceArnSelector
   */
  readonly resourceArnSelector?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'override': obj.override?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride(y)),
    'priority': obj.priority,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction {
  /**
   * A configuration block describing the custom action associated with the action_name. See Action Definition below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction#actionDefinition
   */
  readonly actionDefinition?: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition[];

  /**
   * A friendly name of the custom action.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction#actionName
   */
  readonly actionName?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionDefinition': obj.actionDefinition?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition(y)),
    'actionName': obj.actionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference {
  /**
   * An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference#priority
   */
  readonly priority?: number;

  /**
   * The Amazon Resource Name (ARN) of the stateless rule group.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a RuleGroup in networkfirewall to populate resourceArn.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference#resourceArnRef
   */
  readonly resourceArnRef?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef;

  /**
   * Selector for a RuleGroup in networkfirewall to populate resourceArn.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference#resourceArnSelector
   */
  readonly resourceArnSelector?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'priority': obj.priority,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecInitProviderFirewallPolicyStatefulEngineOptions
 */
export interface FirewallPolicySpecInitProviderFirewallPolicyStatefulEngineOptions {
  /**
   * Indicates how to manage the order of stateful rule evaluation for the policy. Default value: DEFAULT_ACTION_ORDER. Valid values: DEFAULT_ACTION_ORDER, STRICT_ORDER.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicyStatefulEngineOptions#ruleOrder
   */
  readonly ruleOrder?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProviderFirewallPolicyStatefulEngineOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProviderFirewallPolicyStatefulEngineOptions(obj: FirewallPolicySpecInitProviderFirewallPolicyStatefulEngineOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ruleOrder': obj.ruleOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReference
 */
export interface FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReference {
  /**
   * Configuration block for override values
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReference#override
   */
  readonly override?: FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReferenceOverride[];

  /**
   * An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReference#priority
   */
  readonly priority?: number;

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReference(obj: FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'override': obj.override?.map(y => toJson_FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReferenceOverride(y)),
    'priority': obj.priority,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomAction
 */
export interface FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomAction {
  /**
   * A configuration block describing the custom action associated with the action_name. See Action Definition below for details.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomAction#actionDefinition
   */
  readonly actionDefinition?: FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinition[];

  /**
   * A friendly name of the custom action.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomAction#actionName
   */
  readonly actionName?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomAction(obj: FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionDefinition': obj.actionDefinition?.map(y => toJson_FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinition(y)),
    'actionName': obj.actionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessRuleGroupReference
 */
export interface FirewallPolicySpecInitProviderFirewallPolicyStatelessRuleGroupReference {
  /**
   * An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessRuleGroupReference#priority
   */
  readonly priority?: number;

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProviderFirewallPolicyStatelessRuleGroupReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProviderFirewallPolicyStatelessRuleGroupReference(obj: FirewallPolicySpecInitProviderFirewallPolicyStatelessRuleGroupReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'priority': obj.priority,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecProviderConfigRefPolicyResolution
 */
export enum FirewallPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecProviderConfigRefPolicyResolve
 */
export enum FirewallPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride {
  /**
   * The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride#action
   */
  readonly action?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RuleGroup in networkfirewall to populate resourceArn.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef#policy
   */
  readonly policy?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RuleGroup in networkfirewall to populate resourceArn.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector#policy
   */
  readonly policy?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition {
  /**
   * A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition#publishMetricAction
   */
  readonly publishMetricAction?: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction[];

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publishMetricAction': obj.publishMetricAction?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RuleGroup in networkfirewall to populate resourceArn.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef#policy
   */
  readonly policy?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RuleGroup in networkfirewall to populate resourceArn.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector#policy
   */
  readonly policy?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReferenceOverride
 */
export interface FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReferenceOverride {
  /**
   * The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReferenceOverride#action
   */
  readonly action?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReferenceOverride' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReferenceOverride(obj: FirewallPolicySpecInitProviderFirewallPolicyStatefulRuleGroupReferenceOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinition
 */
export interface FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinition {
  /**
   * A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinition#publishMetricAction
   */
  readonly publishMetricAction?: FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction[];

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinition(obj: FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publishMetricAction': obj.publishMetricAction?.map(y => toJson_FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FirewallPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy(obj: FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction {
  /**
   * Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction#dimension
   */
  readonly dimension?: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension[];

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimension': obj.dimension?.map(y => toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction
 */
export interface FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction {
  /**
   * Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction#dimension
   */
  readonly dimension?: FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension[];

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction(obj: FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimension': obj.dimension?.map(y => toJson_FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolution
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolve
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolution
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolve
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatefulRuleGroupReferenceResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension
 */
export interface FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension {
  /**
   * The string value to use in the custom metric dimension.
   *
   * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension(obj: FirewallPolicySpecForProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolution
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolve
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolution
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolve
 */
export enum FirewallPolicySpecForProviderFirewallPolicyStatelessRuleGroupReferenceResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension
 */
export interface FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension {
  /**
   * The string value to use in the custom metric dimension.
   *
   * @schema FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension(obj: FirewallPolicySpecInitProviderFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * LoggingConfiguration is the Schema for the LoggingConfigurations API. Provides an AWS Network Firewall Logging Configuration resource.
 *
 * @schema LoggingConfiguration
 */
export class LoggingConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LoggingConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkfirewall.aws.upbound.io/v1beta1',
    kind: 'LoggingConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "LoggingConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LoggingConfigurationProps): any {
    return {
      ...LoggingConfiguration.GVK,
      ...toJson_LoggingConfigurationProps(props),
    };
  }

  /**
   * Defines a "LoggingConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LoggingConfigurationProps) {
    super(scope, id, {
      ...LoggingConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LoggingConfiguration.GVK,
      ...toJson_LoggingConfigurationProps(resolved),
    };
  }
}

/**
 * LoggingConfiguration is the Schema for the LoggingConfigurations API. Provides an AWS Network Firewall Logging Configuration resource.
 *
 * @schema LoggingConfiguration
 */
export interface LoggingConfigurationProps {
  /**
   * @schema LoggingConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LoggingConfigurationSpec defines the desired state of LoggingConfiguration
   *
   * @schema LoggingConfiguration#spec
   */
  readonly spec: LoggingConfigurationSpec;

}

/**
 * Converts an object of type 'LoggingConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationProps(obj: LoggingConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LoggingConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LoggingConfigurationSpec defines the desired state of LoggingConfiguration
 *
 * @schema LoggingConfigurationSpec
 */
export interface LoggingConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LoggingConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: LoggingConfigurationSpecDeletionPolicy;

  /**
   * @schema LoggingConfigurationSpec#forProvider
   */
  readonly forProvider: LoggingConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema LoggingConfigurationSpec#initProvider
   */
  readonly initProvider?: LoggingConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LoggingConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: LoggingConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LoggingConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: LoggingConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LoggingConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LoggingConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LoggingConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LoggingConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LoggingConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpec(obj: LoggingConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LoggingConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_LoggingConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LoggingConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LoggingConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LoggingConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LoggingConfigurationSpecDeletionPolicy
 */
export enum LoggingConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LoggingConfigurationSpecForProvider
 */
export interface LoggingConfigurationSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the Network Firewall firewall.
   *
   * @schema LoggingConfigurationSpecForProvider#firewallArn
   */
  readonly firewallArn?: string;

  /**
   * Reference to a Firewall in networkfirewall to populate firewallArn.
   *
   * @schema LoggingConfigurationSpecForProvider#firewallArnRef
   */
  readonly firewallArnRef?: LoggingConfigurationSpecForProviderFirewallArnRef;

  /**
   * Selector for a Firewall in networkfirewall to populate firewallArn.
   *
   * @schema LoggingConfigurationSpecForProvider#firewallArnSelector
   */
  readonly firewallArnSelector?: LoggingConfigurationSpecForProviderFirewallArnSelector;

  /**
   * A configuration block describing how AWS Network Firewall performs logging for a firewall. See Logging Configuration below for details.
   *
   * @schema LoggingConfigurationSpecForProvider#loggingConfiguration
   */
  readonly loggingConfiguration?: LoggingConfigurationSpecForProviderLoggingConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LoggingConfigurationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProvider(obj: LoggingConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'firewallArn': obj.firewallArn,
    'firewallArnRef': toJson_LoggingConfigurationSpecForProviderFirewallArnRef(obj.firewallArnRef),
    'firewallArnSelector': toJson_LoggingConfigurationSpecForProviderFirewallArnSelector(obj.firewallArnSelector),
    'loggingConfiguration': obj.loggingConfiguration?.map(y => toJson_LoggingConfigurationSpecForProviderLoggingConfiguration(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema LoggingConfigurationSpecInitProvider
 */
export interface LoggingConfigurationSpecInitProvider {
  /**
   * A configuration block describing how AWS Network Firewall performs logging for a firewall. See Logging Configuration below for details.
   *
   * @schema LoggingConfigurationSpecInitProvider#loggingConfiguration
   */
  readonly loggingConfiguration?: LoggingConfigurationSpecInitProviderLoggingConfiguration[];

}

/**
 * Converts an object of type 'LoggingConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecInitProvider(obj: LoggingConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggingConfiguration': obj.loggingConfiguration?.map(y => toJson_LoggingConfigurationSpecInitProviderLoggingConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LoggingConfigurationSpecManagementPolicies
 */
export enum LoggingConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LoggingConfigurationSpecProviderConfigRef
 */
export interface LoggingConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoggingConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoggingConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: LoggingConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecProviderConfigRef(obj: LoggingConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoggingConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsTo
 */
export interface LoggingConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LoggingConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LoggingConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecPublishConnectionDetailsTo(obj: LoggingConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LoggingConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LoggingConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LoggingConfigurationSpecWriteConnectionSecretToRef
 */
export interface LoggingConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LoggingConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LoggingConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecWriteConnectionSecretToRef(obj: LoggingConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Firewall in networkfirewall to populate firewallArn.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnRef
 */
export interface LoggingConfigurationSpecForProviderFirewallArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnRef#policy
   */
  readonly policy?: LoggingConfigurationSpecForProviderFirewallArnRefPolicy;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderFirewallArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderFirewallArnRef(obj: LoggingConfigurationSpecForProviderFirewallArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoggingConfigurationSpecForProviderFirewallArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Firewall in networkfirewall to populate firewallArn.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnSelector
 */
export interface LoggingConfigurationSpecForProviderFirewallArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnSelector#policy
   */
  readonly policy?: LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderFirewallArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderFirewallArnSelector(obj: LoggingConfigurationSpecForProviderFirewallArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LoggingConfigurationSpecForProviderLoggingConfiguration
 */
export interface LoggingConfigurationSpecForProviderLoggingConfiguration {
  /**
   * Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for FLOW logs and one for ALERT logs.
   *
   * @schema LoggingConfigurationSpecForProviderLoggingConfiguration#logDestinationConfig
   */
  readonly logDestinationConfig?: LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig[];

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderLoggingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderLoggingConfiguration(obj: LoggingConfigurationSpecForProviderLoggingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDestinationConfig': obj.logDestinationConfig?.map(y => toJson_LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LoggingConfigurationSpecInitProviderLoggingConfiguration
 */
export interface LoggingConfigurationSpecInitProviderLoggingConfiguration {
  /**
   * Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for FLOW logs and one for ALERT logs.
   *
   * @schema LoggingConfigurationSpecInitProviderLoggingConfiguration#logDestinationConfig
   */
  readonly logDestinationConfig?: LoggingConfigurationSpecInitProviderLoggingConfigurationLogDestinationConfig[];

}

/**
 * Converts an object of type 'LoggingConfigurationSpecInitProviderLoggingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecInitProviderLoggingConfiguration(obj: LoggingConfigurationSpecInitProviderLoggingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDestinationConfig': obj.logDestinationConfig?.map(y => toJson_LoggingConfigurationSpecInitProviderLoggingConfigurationLogDestinationConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LoggingConfigurationSpecProviderConfigRefPolicy
 */
export interface LoggingConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LoggingConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LoggingConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecProviderConfigRefPolicy(obj: LoggingConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface LoggingConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecPublishConnectionDetailsToConfigRef(obj: LoggingConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface LoggingConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecPublishConnectionDetailsToMetadata(obj: LoggingConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnRefPolicy
 */
export interface LoggingConfigurationSpecForProviderFirewallArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnRefPolicy#resolution
   */
  readonly resolution?: LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnRefPolicy#resolve
   */
  readonly resolve?: LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderFirewallArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderFirewallArnRefPolicy(obj: LoggingConfigurationSpecForProviderFirewallArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy
 */
export interface LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy#resolution
   */
  readonly resolution?: LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy#resolve
   */
  readonly resolve?: LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy(obj: LoggingConfigurationSpecForProviderFirewallArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig
 */
export interface LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig {
  /**
   * A map describing the logging destination for the chosen log_destination_type.
   *
   * @schema LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig#logDestination
   */
  readonly logDestination?: { [key: string]: string };

  /**
   * The location to send logs to. Valid values: S3, CloudWatchLogs, KinesisDataFirehose.
   *
   * @schema LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig#logDestinationType
   */
  readonly logDestinationType?: string;

  /**
   * The type of log to send. Valid values: ALERT or FLOW. Alert logs report traffic that matches a StatefulRule with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
   *
   * @schema LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig#logType
   */
  readonly logType?: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig(obj: LoggingConfigurationSpecForProviderLoggingConfigurationLogDestinationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDestination': ((obj.logDestination) === undefined) ? undefined : (Object.entries(obj.logDestination).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'logDestinationType': obj.logDestinationType,
    'logType': obj.logType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LoggingConfigurationSpecInitProviderLoggingConfigurationLogDestinationConfig
 */
export interface LoggingConfigurationSpecInitProviderLoggingConfigurationLogDestinationConfig {
  /**
   * A map describing the logging destination for the chosen log_destination_type.
   *
   * @schema LoggingConfigurationSpecInitProviderLoggingConfigurationLogDestinationConfig#logDestination
   */
  readonly logDestination?: { [key: string]: string };

  /**
   * The location to send logs to. Valid values: S3, CloudWatchLogs, KinesisDataFirehose.
   *
   * @schema LoggingConfigurationSpecInitProviderLoggingConfigurationLogDestinationConfig#logDestinationType
   */
  readonly logDestinationType?: string;

  /**
   * The type of log to send. Valid values: ALERT or FLOW. Alert logs report traffic that matches a StatefulRule with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
   *
   * @schema LoggingConfigurationSpecInitProviderLoggingConfigurationLogDestinationConfig#logType
   */
  readonly logType?: string;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecInitProviderLoggingConfigurationLogDestinationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecInitProviderLoggingConfigurationLogDestinationConfig(obj: LoggingConfigurationSpecInitProviderLoggingConfigurationLogDestinationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDestination': ((obj.logDestination) === undefined) ? undefined : (Object.entries(obj.logDestination).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'logDestinationType': obj.logDestinationType,
    'logType': obj.logType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum LoggingConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum LoggingConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolution
 */
export enum LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolve
 */
export enum LoggingConfigurationSpecForProviderFirewallArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolution
 */
export enum LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolve
 */
export enum LoggingConfigurationSpecForProviderFirewallArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LoggingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RuleGroup is the Schema for the RuleGroups API. Provides an AWS Network Firewall Rule Group resource.
 *
 * @schema RuleGroup
 */
export class RuleGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RuleGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkfirewall.aws.upbound.io/v1beta1',
    kind: 'RuleGroup',
  }

  /**
   * Renders a Kubernetes manifest for "RuleGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuleGroupProps): any {
    return {
      ...RuleGroup.GVK,
      ...toJson_RuleGroupProps(props),
    };
  }

  /**
   * Defines a "RuleGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuleGroupProps) {
    super(scope, id, {
      ...RuleGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RuleGroup.GVK,
      ...toJson_RuleGroupProps(resolved),
    };
  }
}

/**
 * RuleGroup is the Schema for the RuleGroups API. Provides an AWS Network Firewall Rule Group resource.
 *
 * @schema RuleGroup
 */
export interface RuleGroupProps {
  /**
   * @schema RuleGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuleGroupSpec defines the desired state of RuleGroup
   *
   * @schema RuleGroup#spec
   */
  readonly spec: RuleGroupSpec;

}

/**
 * Converts an object of type 'RuleGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupProps(obj: RuleGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuleGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuleGroupSpec defines the desired state of RuleGroup
 *
 * @schema RuleGroupSpec
 */
export interface RuleGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuleGroupSpecDeletionPolicy;

  /**
   * @schema RuleGroupSpec#forProvider
   */
  readonly forProvider: RuleGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RuleGroupSpec#initProvider
   */
  readonly initProvider?: RuleGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RuleGroupSpec#managementPolicies
   */
  readonly managementPolicies?: RuleGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuleGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuleGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuleGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuleGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuleGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuleGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuleGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpec(obj: RuleGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuleGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_RuleGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RuleGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RuleGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuleGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleGroupSpecDeletionPolicy
 */
export enum RuleGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RuleGroupSpecForProvider
 */
export interface RuleGroupSpecForProvider {
  /**
   * The maximum number of operating resources that this rule group can use. For a stateless rule group, the capacity required is the sum of the capacity requirements of the individual rules. For a stateful rule group, the minimum capacity required is the number of individual rules.
   *
   * @schema RuleGroupSpecForProvider#capacity
   */
  readonly capacity?: number;

  /**
   * A friendly description of the rule group.
   *
   * @schema RuleGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * KMS encryption configuration settings. See Encryption Configuration below for details.
   *
   * @schema RuleGroupSpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: RuleGroupSpecForProviderEncryptionConfiguration[];

  /**
   * A friendly name of the rule group.
   *
   * @schema RuleGroupSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RuleGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * A configuration block that defines the rule group rules. Required unless rules is specified. See Rule Group below for details.
   *
   * @schema RuleGroupSpecForProvider#ruleGroup
   */
  readonly ruleGroup?: RuleGroupSpecForProviderRuleGroup[];

  /**
   * The stateful rule group rules specifications in Suricata file format, with one rule per line. Use this to import your existing Suricata compatible rule groups. Required unless rule_group is specified.
   *
   * @schema RuleGroupSpecForProvider#rules
   */
  readonly rules?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RuleGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether the rule group is stateless (containing stateless rules) or stateful (containing stateful rules). Valid values include: STATEFUL or STATELESS.
   *
   * @schema RuleGroupSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProvider(obj: RuleGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacity': obj.capacity,
    'description': obj.description,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_RuleGroupSpecForProviderEncryptionConfiguration(y)),
    'name': obj.name,
    'region': obj.region,
    'ruleGroup': obj.ruleGroup?.map(y => toJson_RuleGroupSpecForProviderRuleGroup(y)),
    'rules': obj.rules,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RuleGroupSpecInitProvider
 */
export interface RuleGroupSpecInitProvider {
  /**
   * The maximum number of operating resources that this rule group can use. For a stateless rule group, the capacity required is the sum of the capacity requirements of the individual rules. For a stateful rule group, the minimum capacity required is the number of individual rules.
   *
   * @schema RuleGroupSpecInitProvider#capacity
   */
  readonly capacity?: number;

  /**
   * A friendly description of the rule group.
   *
   * @schema RuleGroupSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * KMS encryption configuration settings. See Encryption Configuration below for details.
   *
   * @schema RuleGroupSpecInitProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: RuleGroupSpecInitProviderEncryptionConfiguration[];

  /**
   * A friendly name of the rule group.
   *
   * @schema RuleGroupSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * A configuration block that defines the rule group rules. Required unless rules is specified. See Rule Group below for details.
   *
   * @schema RuleGroupSpecInitProvider#ruleGroup
   */
  readonly ruleGroup?: RuleGroupSpecInitProviderRuleGroup[];

  /**
   * The stateful rule group rules specifications in Suricata file format, with one rule per line. Use this to import your existing Suricata compatible rule groups. Required unless rule_group is specified.
   *
   * @schema RuleGroupSpecInitProvider#rules
   */
  readonly rules?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RuleGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Whether the rule group is stateless (containing stateless rules) or stateful (containing stateful rules). Valid values include: STATEFUL or STATELESS.
   *
   * @schema RuleGroupSpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProvider(obj: RuleGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacity': obj.capacity,
    'description': obj.description,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_RuleGroupSpecInitProviderEncryptionConfiguration(y)),
    'name': obj.name,
    'ruleGroup': obj.ruleGroup?.map(y => toJson_RuleGroupSpecInitProviderRuleGroup(y)),
    'rules': obj.rules,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RuleGroupSpecManagementPolicies
 */
export enum RuleGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuleGroupSpecProviderConfigRef
 */
export interface RuleGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupSpecProviderConfigRef#policy
   */
  readonly policy?: RuleGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecProviderConfigRef(obj: RuleGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsTo
 */
export interface RuleGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuleGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuleGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuleGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecPublishConnectionDetailsTo(obj: RuleGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuleGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuleGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuleGroupSpecWriteConnectionSecretToRef
 */
export interface RuleGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuleGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuleGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuleGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecWriteConnectionSecretToRef(obj: RuleGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderEncryptionConfiguration
 */
export interface RuleGroupSpecForProviderEncryptionConfiguration {
  /**
   * The ID of the customer managed key. You can use any of the key identifiers that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
   *
   * @schema RuleGroupSpecForProviderEncryptionConfiguration#keyId
   */
  readonly keyId?: string;

  /**
   * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are CUSTOMER_KMS and AWS_OWNED_KMS_KEY.
   *
   * @schema RuleGroupSpecForProviderEncryptionConfiguration#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderEncryptionConfiguration(obj: RuleGroupSpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroup
 */
export interface RuleGroupSpecForProviderRuleGroup {
  /**
   * A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 reference_sets in a rule_group. See the AWS documentation for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroup#referenceSets
   */
  readonly referenceSets?: RuleGroupSpecForProviderRuleGroupReferenceSets[];

  /**
   * A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for stateful rule groups. See Rule Variables below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroup#ruleVariables
   */
  readonly ruleVariables?: RuleGroupSpecForProviderRuleGroupRuleVariables[];

  /**
   * A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroup#rulesSource
   */
  readonly rulesSource?: RuleGroupSpecForProviderRuleGroupRulesSource[];

  /**
   * A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroup#statefulRuleOptions
   */
  readonly statefulRuleOptions?: RuleGroupSpecForProviderRuleGroupStatefulRuleOptions[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroup(obj: RuleGroupSpecForProviderRuleGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'referenceSets': obj.referenceSets?.map(y => toJson_RuleGroupSpecForProviderRuleGroupReferenceSets(y)),
    'ruleVariables': obj.ruleVariables?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRuleVariables(y)),
    'rulesSource': obj.rulesSource?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSource(y)),
    'statefulRuleOptions': obj.statefulRuleOptions?.map(y => toJson_RuleGroupSpecForProviderRuleGroupStatefulRuleOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderEncryptionConfiguration
 */
export interface RuleGroupSpecInitProviderEncryptionConfiguration {
  /**
   * The ID of the customer managed key. You can use any of the key identifiers that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
   *
   * @schema RuleGroupSpecInitProviderEncryptionConfiguration#keyId
   */
  readonly keyId?: string;

  /**
   * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are CUSTOMER_KMS and AWS_OWNED_KMS_KEY.
   *
   * @schema RuleGroupSpecInitProviderEncryptionConfiguration#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderEncryptionConfiguration(obj: RuleGroupSpecInitProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroup
 */
export interface RuleGroupSpecInitProviderRuleGroup {
  /**
   * A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 reference_sets in a rule_group. See the AWS documentation for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroup#referenceSets
   */
  readonly referenceSets?: RuleGroupSpecInitProviderRuleGroupReferenceSets[];

  /**
   * A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for stateful rule groups. See Rule Variables below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroup#ruleVariables
   */
  readonly ruleVariables?: RuleGroupSpecInitProviderRuleGroupRuleVariables[];

  /**
   * A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroup#rulesSource
   */
  readonly rulesSource?: RuleGroupSpecInitProviderRuleGroupRulesSource[];

  /**
   * A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroup#statefulRuleOptions
   */
  readonly statefulRuleOptions?: RuleGroupSpecInitProviderRuleGroupStatefulRuleOptions[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroup(obj: RuleGroupSpecInitProviderRuleGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'referenceSets': obj.referenceSets?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupReferenceSets(y)),
    'ruleVariables': obj.ruleVariables?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRuleVariables(y)),
    'rulesSource': obj.rulesSource?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSource(y)),
    'statefulRuleOptions': obj.statefulRuleOptions?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupStatefulRuleOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupSpecProviderConfigRefPolicy
 */
export interface RuleGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuleGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuleGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecProviderConfigRefPolicy(obj: RuleGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface RuleGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecPublishConnectionDetailsToConfigRef(obj: RuleGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsToMetadata
 */
export interface RuleGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecPublishConnectionDetailsToMetadata(obj: RuleGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSets
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSets {
  /**
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSets#ipSetReferences
   */
  readonly ipSetReferences?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSets(obj: RuleGroupSpecForProviderRuleGroupReferenceSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSetReferences': obj.ipSetReferences?.map(y => toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRuleVariables
 */
export interface RuleGroupSpecForProviderRuleGroupRuleVariables {
  /**
   * Set of configuration blocks that define IP address information. See IP Sets below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariables#ipSets
   */
  readonly ipSets?: RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets[];

  /**
   * Set of configuration blocks that define port range information. See Port Sets below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariables#portSets
   */
  readonly portSets?: RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRuleVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRuleVariables(obj: RuleGroupSpecForProviderRuleGroupRuleVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSets': obj.ipSets?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets(y)),
    'portSets': obj.portSets?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSource
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSource {
  /**
   * A configuration block containing stateful inspection criteria for a domain list rule group. See Rules Source List below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSource#rulesSourceList
   */
  readonly rulesSourceList?: RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList[];

  /**
   * The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain stateful inspection criteria and the action to take for traffic that matches the criteria.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSource#rulesString
   */
  readonly rulesString?: string;

  /**
   * Set of configuration blocks containing stateful inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSource#statefulRule
   */
  readonly statefulRule?: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule[];

  /**
   * A configuration block containing stateless inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSource#statelessRulesAndCustomActions
   */
  readonly statelessRulesAndCustomActions?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSource(obj: RuleGroupSpecForProviderRuleGroupRulesSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rulesSourceList': obj.rulesSourceList?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList(y)),
    'rulesString': obj.rulesString,
    'statefulRule': obj.statefulRule?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule(y)),
    'statelessRulesAndCustomActions': obj.statelessRulesAndCustomActions?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupStatefulRuleOptions
 */
export interface RuleGroupSpecForProviderRuleGroupStatefulRuleOptions {
  /**
   * Indicates how to manage the order of the rule evaluation for the rule group. Default value: DEFAULT_ACTION_ORDER. Valid values: DEFAULT_ACTION_ORDER, STRICT_ORDER.
   *
   * @schema RuleGroupSpecForProviderRuleGroupStatefulRuleOptions#ruleOrder
   */
  readonly ruleOrder?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupStatefulRuleOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupStatefulRuleOptions(obj: RuleGroupSpecForProviderRuleGroupStatefulRuleOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ruleOrder': obj.ruleOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupReferenceSets
 */
export interface RuleGroupSpecInitProviderRuleGroupReferenceSets {
  /**
   * @schema RuleGroupSpecInitProviderRuleGroupReferenceSets#ipSetReferences
   */
  readonly ipSetReferences?: RuleGroupSpecInitProviderRuleGroupReferenceSetsIpSetReferences[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupReferenceSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupReferenceSets(obj: RuleGroupSpecInitProviderRuleGroupReferenceSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSetReferences': obj.ipSetReferences?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupReferenceSetsIpSetReferences(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRuleVariables
 */
export interface RuleGroupSpecInitProviderRuleGroupRuleVariables {
  /**
   * Set of configuration blocks that define IP address information. See IP Sets below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRuleVariables#ipSets
   */
  readonly ipSets?: RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSets[];

  /**
   * Set of configuration blocks that define port range information. See Port Sets below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRuleVariables#portSets
   */
  readonly portSets?: RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSets[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRuleVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRuleVariables(obj: RuleGroupSpecInitProviderRuleGroupRuleVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSets': obj.ipSets?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSets(y)),
    'portSets': obj.portSets?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSource
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSource {
  /**
   * A configuration block containing stateful inspection criteria for a domain list rule group. See Rules Source List below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSource#rulesSourceList
   */
  readonly rulesSourceList?: RuleGroupSpecInitProviderRuleGroupRulesSourceRulesSourceList[];

  /**
   * The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain stateful inspection criteria and the action to take for traffic that matches the criteria.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSource#rulesString
   */
  readonly rulesString?: string;

  /**
   * Set of configuration blocks containing stateful inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSource#statefulRule
   */
  readonly statefulRule?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRule[];

  /**
   * A configuration block containing stateless inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSource#statelessRulesAndCustomActions
   */
  readonly statelessRulesAndCustomActions?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActions[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSource(obj: RuleGroupSpecInitProviderRuleGroupRulesSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rulesSourceList': obj.rulesSourceList?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceRulesSourceList(y)),
    'rulesString': obj.rulesString,
    'statefulRule': obj.statefulRule?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRule(y)),
    'statelessRulesAndCustomActions': obj.statelessRulesAndCustomActions?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupStatefulRuleOptions
 */
export interface RuleGroupSpecInitProviderRuleGroupStatefulRuleOptions {
  /**
   * Indicates how to manage the order of the rule evaluation for the rule group. Default value: DEFAULT_ACTION_ORDER. Valid values: DEFAULT_ACTION_ORDER, STRICT_ORDER.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupStatefulRuleOptions#ruleOrder
   */
  readonly ruleOrder?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupStatefulRuleOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupStatefulRuleOptions(obj: RuleGroupSpecInitProviderRuleGroupStatefulRuleOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ruleOrder': obj.ruleOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupSpecProviderConfigRefPolicyResolution
 */
export enum RuleGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupSpecProviderConfigRefPolicyResolve
 */
export enum RuleGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuleGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences {
  /**
   * Set of configuration blocks that define the IP Reference information. See IP Set Reference below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences#ipSetReference
   */
  readonly ipSetReference?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference[];

  /**
   * An unique alphanumeric string to identify the port_set.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSetReference': obj.ipSetReference?.map(y => toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference(y)),
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets
 */
export interface RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets {
  /**
   * A configuration block that defines a set of IP addresses. See IP Set below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets#ipSet
   */
  readonly ipSet?: RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet[];

  /**
   * An unique alphanumeric string to identify the port_set.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets(obj: RuleGroupSpecForProviderRuleGroupRuleVariablesIpSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSet': obj.ipSet?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet(y)),
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets
 */
export interface RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets {
  /**
   * An unique alphanumeric string to identify the port_set.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets#key
   */
  readonly key?: string;

  /**
   * A configuration block that defines a set of port ranges. See Port Set below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets#portSet
   */
  readonly portSet?: RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets(obj: RuleGroupSpecForProviderRuleGroupRuleVariablesPortSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'portSet': obj.portSet?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList {
  /**
   * String value to specify whether domains in the target list are allowed or denied access. Valid values: ALLOWLIST, DENYLIST.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList#generatedRulesType
   */
  readonly generatedRulesType?: string;

  /**
   * Set of types of domain specifications that are provided in the targets argument. Valid values: HTTP_HOST, TLS_SNI.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList#targetTypes
   */
  readonly targetTypes?: string[];

  /**
   * Set of domains that you want to inspect for in your traffic flows.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList#targets
   */
  readonly targets?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList(obj: RuleGroupSpecForProviderRuleGroupRulesSourceRulesSourceList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatedRulesType': obj.generatedRulesType,
    'targetTypes': obj.targetTypes?.map(y => y),
    'targets': obj.targets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule {
  /**
   * Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: ALERT, DROP or PASS.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule#action
   */
  readonly action?: string;

  /**
   * A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule#header
   */
  readonly header?: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader[];

  /**
   * Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule#ruleOption
   */
  readonly ruleOption?: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'header': obj.header?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader(y)),
    'ruleOption': obj.ruleOption?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions {
  /**
   * Set of configuration blocks containing custom action definitions that are available for use by the set of stateless rule. See Custom Action below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions#customAction
   */
  readonly customAction?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction[];

  /**
   * Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions#statelessRule
   */
  readonly statelessRule?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customAction': obj.customAction?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction(y)),
    'statelessRule': obj.statelessRule?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupReferenceSetsIpSetReferences
 */
export interface RuleGroupSpecInitProviderRuleGroupReferenceSetsIpSetReferences {
  /**
   * Set of configuration blocks that define the IP Reference information. See IP Set Reference below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupReferenceSetsIpSetReferences#ipSetReference
   */
  readonly ipSetReference?: any[];

  /**
   * An unique alphanumeric string to identify the port_set.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupReferenceSetsIpSetReferences#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupReferenceSetsIpSetReferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupReferenceSetsIpSetReferences(obj: RuleGroupSpecInitProviderRuleGroupReferenceSetsIpSetReferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSetReference': obj.ipSetReference?.map(y => y),
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSets
 */
export interface RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSets {
  /**
   * A configuration block that defines a set of IP addresses. See IP Set below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSets#ipSet
   */
  readonly ipSet?: RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSetsIpSet[];

  /**
   * An unique alphanumeric string to identify the port_set.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSets#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSets(obj: RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSet': obj.ipSet?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSetsIpSet(y)),
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSets
 */
export interface RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSets {
  /**
   * An unique alphanumeric string to identify the port_set.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSets#key
   */
  readonly key?: string;

  /**
   * A configuration block that defines a set of port ranges. See Port Set below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSets#portSet
   */
  readonly portSet?: RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSetsPortSet[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSets(obj: RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'portSet': obj.portSet?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSetsPortSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceRulesSourceList
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceRulesSourceList {
  /**
   * String value to specify whether domains in the target list are allowed or denied access. Valid values: ALLOWLIST, DENYLIST.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceRulesSourceList#generatedRulesType
   */
  readonly generatedRulesType?: string;

  /**
   * Set of types of domain specifications that are provided in the targets argument. Valid values: HTTP_HOST, TLS_SNI.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceRulesSourceList#targetTypes
   */
  readonly targetTypes?: string[];

  /**
   * Set of domains that you want to inspect for in your traffic flows.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceRulesSourceList#targets
   */
  readonly targets?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceRulesSourceList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceRulesSourceList(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceRulesSourceList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatedRulesType': obj.generatedRulesType,
    'targetTypes': obj.targetTypes?.map(y => y),
    'targets': obj.targets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRule
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRule {
  /**
   * Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: ALERT, DROP or PASS.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRule#action
   */
  readonly action?: string;

  /**
   * A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRule#header
   */
  readonly header?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader[];

  /**
   * Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRule#ruleOption
   */
  readonly ruleOption?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleRuleOption[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRule(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'header': obj.header?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader(y)),
    'ruleOption': obj.ruleOption?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleRuleOption(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActions
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActions {
  /**
   * Set of configuration blocks containing custom action definitions that are available for use by the set of stateless rule. See Custom Action below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActions#customAction
   */
  readonly customAction?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction[];

  /**
   * Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActions#statelessRule
   */
  readonly statelessRule?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActions(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customAction': obj.customAction?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction(y)),
    'statelessRule': obj.statelessRule?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuleGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference {
  /**
   * Set of Managed Prefix IP ARN(s)
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference#referenceArn
   */
  readonly referenceArn?: string;

  /**
   * Reference to a ManagedPrefixList in ec2 to populate referenceArn.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference#referenceArnRef
   */
  readonly referenceArnRef?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef;

  /**
   * Selector for a ManagedPrefixList in ec2 to populate referenceArn.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference#referenceArnSelector
   */
  readonly referenceArnSelector?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'referenceArn': obj.referenceArn,
    'referenceArnRef': toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef(obj.referenceArnRef),
    'referenceArnSelector': toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector(obj.referenceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet
 */
export interface RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet {
  /**
   * Set of port ranges.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet#definition
   */
  readonly definition?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet(obj: RuleGroupSpecForProviderRuleGroupRuleVariablesIpSetsIpSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definition': obj.definition?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet
 */
export interface RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet {
  /**
   * Set of port ranges.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet#definition
   */
  readonly definition?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet(obj: RuleGroupSpecForProviderRuleGroupRuleVariablesPortSetsPortSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definition': obj.definition?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader {
  /**
   * Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#destination
   */
  readonly destination?: string;

  /**
   * Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#destinationPort
   */
  readonly destinationPort?: string;

  /**
   * The direction of traffic flow to inspect. Valid values: ANY or FORWARD.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#direction
   */
  readonly direction?: string;

  /**
   * The protocol to inspect. Valid values: IP, TCP, UDP, ICMP, HTTP, FTP, TLS, SMB, DNS, DCERPC, SSH, SMTP, IMAP, MSN, KRB5, IKEV2, TFTP, NTP, DHCP.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#protocol
   */
  readonly protocol?: string;

  /**
   * Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#source
   */
  readonly source?: string;

  /**
   * Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader#sourcePort
   */
  readonly sourcePort?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination,
    'destinationPort': obj.destinationPort,
    'direction': obj.direction,
    'protocol': obj.protocol,
    'source': obj.source,
    'sourcePort': obj.sourcePort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption {
  /**
   * Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection. See Snort General Rule Options or Suricata Rule Options for more details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption#keyword
   */
  readonly keyword?: string;

  /**
   * Set of strings for additional settings to use in stateful rule inspection.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption#settings
   */
  readonly settings?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatefulRuleRuleOption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyword': obj.keyword,
    'settings': obj.settings?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction {
  /**
   * A configuration block describing the custom action associated with the action_name. See Action Definition below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction#actionDefinition
   */
  readonly actionDefinition?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition[];

  /**
   * A friendly name of the custom action.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction#actionName
   */
  readonly actionName?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionDefinition': obj.actionDefinition?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition(y)),
    'actionName': obj.actionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule {
  /**
   * A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule#priority
   */
  readonly priority?: number;

  /**
   * A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule#ruleDefinition
   */
  readonly ruleDefinition?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'priority': obj.priority,
    'ruleDefinition': obj.ruleDefinition?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSetsIpSet
 */
export interface RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSetsIpSet {
  /**
   * Set of port ranges.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSetsIpSet#definition
   */
  readonly definition?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSetsIpSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSetsIpSet(obj: RuleGroupSpecInitProviderRuleGroupRuleVariablesIpSetsIpSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definition': obj.definition?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSetsPortSet
 */
export interface RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSetsPortSet {
  /**
   * Set of port ranges.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSetsPortSet#definition
   */
  readonly definition?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSetsPortSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSetsPortSet(obj: RuleGroupSpecInitProviderRuleGroupRuleVariablesPortSetsPortSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definition': obj.definition?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader {
  /**
   * Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader#destination
   */
  readonly destination?: string;

  /**
   * Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader#destinationPort
   */
  readonly destinationPort?: string;

  /**
   * The direction of traffic flow to inspect. Valid values: ANY or FORWARD.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader#direction
   */
  readonly direction?: string;

  /**
   * The protocol to inspect. Valid values: IP, TCP, UDP, ICMP, HTTP, FTP, TLS, SMB, DNS, DCERPC, SSH, SMTP, IMAP, MSN, KRB5, IKEV2, TFTP, NTP, DHCP.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader#protocol
   */
  readonly protocol?: string;

  /**
   * Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader#source
   */
  readonly source?: string;

  /**
   * Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader#sourcePort
   */
  readonly sourcePort?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination,
    'destinationPort': obj.destinationPort,
    'direction': obj.direction,
    'protocol': obj.protocol,
    'source': obj.source,
    'sourcePort': obj.sourcePort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleRuleOption
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleRuleOption {
  /**
   * Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection. See Snort General Rule Options or Suricata Rule Options for more details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleRuleOption#keyword
   */
  readonly keyword?: string;

  /**
   * Set of strings for additional settings to use in stateful rule inspection.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleRuleOption#settings
   */
  readonly settings?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleRuleOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleRuleOption(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatefulRuleRuleOption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyword': obj.keyword,
    'settings': obj.settings?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction {
  /**
   * A configuration block describing the custom action associated with the action_name. See Action Definition below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction#actionDefinition
   */
  readonly actionDefinition?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition[];

  /**
   * A friendly name of the custom action.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction#actionName
   */
  readonly actionName?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionDefinition': obj.actionDefinition?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition(y)),
    'actionName': obj.actionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule {
  /**
   * A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule#priority
   */
  readonly priority?: number;

  /**
   * A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule#ruleDefinition
   */
  readonly ruleDefinition?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'priority': obj.priority,
    'ruleDefinition': obj.ruleDefinition?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ManagedPrefixList in ec2 to populate referenceArn.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef#policy
   */
  readonly policy?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ManagedPrefixList in ec2 to populate referenceArn.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector#policy
   */
  readonly policy?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition {
  /**
   * A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition#publishMetricAction
   */
  readonly publishMetricAction?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publishMetricAction': obj.publishMetricAction?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition {
  /**
   * Set of actions to take on a packet that matches one of the stateless rule definition's match_attributes. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: aws:pass, aws:drop, aws:forward_to_sfe.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition#actions
   */
  readonly actions?: string[];

  /**
   * A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition#matchAttributes
   */
  readonly matchAttributes?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => y),
    'matchAttributes': obj.matchAttributes?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition {
  /**
   * A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition#publishMetricAction
   */
  readonly publishMetricAction?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publishMetricAction': obj.publishMetricAction?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition {
  /**
   * Set of actions to take on a packet that matches one of the stateless rule definition's match_attributes. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: aws:pass, aws:drop, aws:forward_to_sfe.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition#actions
   */
  readonly actions?: string[];

  /**
   * A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition#matchAttributes
   */
  readonly matchAttributes?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => y),
    'matchAttributes': obj.matchAttributes?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy#resolution
   */
  readonly resolution?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy#resolve
   */
  readonly resolve?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy
 */
export interface RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy#resolution
   */
  readonly resolution?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy#resolve
   */
  readonly resolve?: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy(obj: RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction {
  /**
   * Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction#dimension
   */
  readonly dimension?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimension': obj.dimension?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes {
  /**
   * Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#destination
   */
  readonly destination?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination[];

  /**
   * Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#destinationPort
   */
  readonly destinationPort?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort[];

  /**
   * Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#protocols
   */
  readonly protocols?: number[];

  /**
   * Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#source
   */
  readonly source?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource[];

  /**
   * Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#sourcePort
   */
  readonly sourcePort?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort[];

  /**
   * Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#tcpFlag
   */
  readonly tcpFlag?: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination(y)),
    'destinationPort': obj.destinationPort?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort(y)),
    'protocols': obj.protocols?.map(y => y),
    'source': obj.source?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource(y)),
    'sourcePort': obj.sourcePort?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort(y)),
    'tcpFlag': obj.tcpFlag?.map(y => toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction {
  /**
   * Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction#dimension
   */
  readonly dimension?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimension': obj.dimension?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes {
  /**
   * Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#destination
   */
  readonly destination?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination[];

  /**
   * Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#destinationPort
   */
  readonly destinationPort?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort[];

  /**
   * Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#protocols
   */
  readonly protocols?: number[];

  /**
   * Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#source
   */
  readonly source?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource[];

  /**
   * Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#sourcePort
   */
  readonly sourcePort?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort[];

  /**
   * Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes#tcpFlag
   */
  readonly tcpFlag?: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination(y)),
    'destinationPort': obj.destinationPort?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort(y)),
    'protocols': obj.protocols?.map(y => y),
    'source': obj.source?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource(y)),
    'sourcePort': obj.sourcePort?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort(y)),
    'tcpFlag': obj.tcpFlag?.map(y => toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolution
 */
export enum RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolve
 */
export enum RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolution
 */
export enum RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolve
 */
export enum RuleGroupSpecForProviderRuleGroupReferenceSetsIpSetReferencesIpSetReferenceReferenceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension {
  /**
   * The value to use in the custom metric dimension.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination {
  /**
   * An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination#addressDefinition
   */
  readonly addressDefinition?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressDefinition': obj.addressDefinition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort {
  /**
   * The lower limit of the port range. This must be less than or equal to the to_port.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort#fromPort
   */
  readonly fromPort?: number;

  /**
   * The upper limit of the port range. This must be greater than or equal to the from_port.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort#toPort
   */
  readonly toPort?: number;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'toPort': obj.toPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource {
  /**
   * An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource#addressDefinition
   */
  readonly addressDefinition?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressDefinition': obj.addressDefinition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort {
  /**
   * The lower limit of the port range. This must be less than or equal to the to_port.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort#fromPort
   */
  readonly fromPort?: number;

  /**
   * The upper limit of the port range. This must be greater than or equal to the from_port.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort#toPort
   */
  readonly toPort?: number;

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'toPort': obj.toPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag
 */
export interface RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag {
  /**
   * Set of flags to look for in a packet. This setting can only specify values that are also specified in masks. Valid values: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag#flags
   */
  readonly flags?: string[];

  /**
   * Set of flags to consider in the inspection. To inspect all flags, leave this empty. Valid values: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR.
   *
   * @schema RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag#masks
   */
  readonly masks?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag(obj: RuleGroupSpecForProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flags': obj.flags?.map(y => y),
    'masks': obj.masks?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension {
  /**
   * The value to use in the custom metric dimension.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination {
  /**
   * An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination#addressDefinition
   */
  readonly addressDefinition?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressDefinition': obj.addressDefinition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort {
  /**
   * The lower limit of the port range. This must be less than or equal to the to_port.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort#fromPort
   */
  readonly fromPort?: number;

  /**
   * The upper limit of the port range. This must be greater than or equal to the from_port.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort#toPort
   */
  readonly toPort?: number;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'toPort': obj.toPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource {
  /**
   * An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource#addressDefinition
   */
  readonly addressDefinition?: string;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressDefinition': obj.addressDefinition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort {
  /**
   * The lower limit of the port range. This must be less than or equal to the to_port.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort#fromPort
   */
  readonly fromPort?: number;

  /**
   * The upper limit of the port range. This must be greater than or equal to the from_port.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort#toPort
   */
  readonly toPort?: number;

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'toPort': obj.toPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag
 */
export interface RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag {
  /**
   * Set of flags to look for in a packet. This setting can only specify values that are also specified in masks. Valid values: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag#flags
   */
  readonly flags?: string[];

  /**
   * Set of flags to consider in the inspection. To inspect all flags, leave this empty. Valid values: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR.
   *
   * @schema RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag#masks
   */
  readonly masks?: string[];

}

/**
 * Converts an object of type 'RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag(obj: RuleGroupSpecInitProviderRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flags': obj.flags?.map(y => y),
    'masks': obj.masks?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

