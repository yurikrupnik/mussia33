// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Function is the Schema for the Functions API. Creates a new Cloud Function.
 *
 * @schema Function
 */
export class Function extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Function"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfunctions.gcp.upbound.io/v1beta1',
    kind: 'Function',
  }

  /**
   * Renders a Kubernetes manifest for "Function".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionProps): any {
    return {
      ...Function.GVK,
      ...toJson_FunctionProps(props),
    };
  }

  /**
   * Defines a "Function" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionProps) {
    super(scope, id, {
      ...Function.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Function.GVK,
      ...toJson_FunctionProps(resolved),
    };
  }
}

/**
 * Function is the Schema for the Functions API. Creates a new Cloud Function.
 *
 * @schema Function
 */
export interface FunctionProps {
  /**
   * @schema Function#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionSpec defines the desired state of Function
   *
   * @schema Function#spec
   */
  readonly spec: FunctionSpec;

}

/**
 * Converts an object of type 'FunctionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionProps(obj: FunctionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionSpec defines the desired state of Function
 *
 * @schema FunctionSpec
 */
export interface FunctionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema FunctionSpec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionSpecDeletionPolicy;

  /**
   * @schema FunctionSpec#forProvider
   */
  readonly forProvider: FunctionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionSpec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FunctionSpec#providerRef
   */
  readonly providerRef?: FunctionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpec(obj: FunctionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_FunctionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FunctionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FunctionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema FunctionSpecDeletionPolicy
 */
export enum FunctionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FunctionSpecForProvider
 */
export interface FunctionSpecForProvider {
  /**
   * Memory (in MB), available to the function. Default value is 256. Possible values include 128, 256, 512, 1024, etc.
   *
   * @schema FunctionSpecForProvider#availableMemoryMb
   */
  readonly availableMemoryMb?: number;

  /**
   * A set of key/value environment variable pairs available during build time.
   *
   * @schema FunctionSpecForProvider#buildEnvironmentVariables
   */
  readonly buildEnvironmentVariables?: { [key: string]: string };

  /**
   * @schema FunctionSpecForProvider#buildWorkerPool
   */
  readonly buildWorkerPool?: string;

  /**
   * Description of the function.
   *
   * @schema FunctionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Docker Registry to use for storing the function's Docker images. Allowed values are CONTAINER_REGISTRY (default) and ARTIFACT_REGISTRY.
   *
   * @schema FunctionSpecForProvider#dockerRegistry
   */
  readonly dockerRegistry?: string;

  /**
   * User managed repository created in Artifact Registry optionally with a customer managed encryption key. If specified, deployments will use Artifact Registry. This is the repository to which the function docker image will be pushed after it is built by Cloud Build. If unspecified, Container Registry will be used by default, unless specified otherwise by other means.
   *
   * @schema FunctionSpecForProvider#dockerRepository
   */
  readonly dockerRepository?: string;

  /**
   * Name of the function that will be executed when the Google Cloud Function is triggered.
   *
   * @schema FunctionSpecForProvider#entryPoint
   */
  readonly entryPoint?: string;

  /**
   * A set of key/value environment variable pairs to assign to the function.
   *
   * @schema FunctionSpecForProvider#environmentVariables
   */
  readonly environmentVariables?: { [key: string]: string };

  /**
   * A source that fires events in response to a condition in another service. Structure is documented below. Cannot be used with trigger_http.
   *
   * @schema FunctionSpecForProvider#eventTrigger
   */
  readonly eventTrigger?: FunctionSpecForProviderEventTrigger[];

  /**
   * The security level for the function. The following options are available:
   *
   * @schema FunctionSpecForProvider#httpsTriggerSecurityLevel
   */
  readonly httpsTriggerSecurityLevel?: string;

  /**
   * URL which triggers function execution. Returned only if trigger_http is used.
   *
   * @schema FunctionSpecForProvider#httpsTriggerUrl
   */
  readonly httpsTriggerUrl?: string;

  /**
   * String value that controls what traffic can reach the function. Allowed values are ALLOW_ALL, ALLOW_INTERNAL_AND_GCLB and ALLOW_INTERNAL_ONLY. Check ingress documentation to see the impact of each settings value. Changes to this field will recreate the cloud function.
   *
   * @schema FunctionSpecForProvider#ingressSettings
   */
  readonly ingressSettings?: string;

  /**
   * Resource name of a KMS crypto key (managed by the user) used to encrypt/decrypt function resources. It must match the pattern projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}. If specified, you must also provide an artifact registry repository using the docker_repository field that was created with the same KMS crypto key. Before deploying, please complete all pre-requisites described in https://cloud.google.com/functions/docs/securing/cmek#granting_service_accounts_access_to_the_key
   *
   * @schema FunctionSpecForProvider#kmsKeyName
   */
  readonly kmsKeyName?: string;

  /**
   * A set of key/value label pairs to assign to the function. Label keys must follow the requirements at https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements.
   *
   * @schema FunctionSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The limit on the maximum number of function instances that may coexist at a given time.
   *
   * @schema FunctionSpecForProvider#maxInstances
   */
  readonly maxInstances?: number;

  /**
   * The limit on the minimum number of function instances that may coexist at a given time.
   *
   * @schema FunctionSpecForProvider#minInstances
   */
  readonly minInstances?: number;

  /**
   * Project of the function. If it is not provided, the provider project is used.
   *
   * @schema FunctionSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Region of function. If it is not provided, the provider region is used.
   *
   * @schema FunctionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The runtime in which the function is going to run. Eg. "nodejs16", "python39", "dotnet3", "go116", "java11", "ruby30", "php74", etc. Check the official doc for the up-to-date list.
   *
   * @schema FunctionSpecForProvider#runtime
   */
  readonly runtime: string;

  /**
   * Secret environment variables configuration. Structure is documented below.
   *
   * @schema FunctionSpecForProvider#secretEnvironmentVariables
   */
  readonly secretEnvironmentVariables?: FunctionSpecForProviderSecretEnvironmentVariables[];

  /**
   * Secret volumes configuration. Structure is documented below.
   *
   * @schema FunctionSpecForProvider#secretVolumes
   */
  readonly secretVolumes?: FunctionSpecForProviderSecretVolumes[];

  /**
   * If provided, the self-provided service account to run the function with.
   *
   * @schema FunctionSpecForProvider#serviceAccountEmail
   */
  readonly serviceAccountEmail?: string;

  /**
   * The GCS bucket containing the zip archive which contains the function.
   *
   * @schema FunctionSpecForProvider#sourceArchiveBucket
   */
  readonly sourceArchiveBucket?: string;

  /**
   * Reference to a Bucket in storage to populate sourceArchiveBucket.
   *
   * @schema FunctionSpecForProvider#sourceArchiveBucketRef
   */
  readonly sourceArchiveBucketRef?: FunctionSpecForProviderSourceArchiveBucketRef;

  /**
   * Selector for a Bucket in storage to populate sourceArchiveBucket.
   *
   * @schema FunctionSpecForProvider#sourceArchiveBucketSelector
   */
  readonly sourceArchiveBucketSelector?: FunctionSpecForProviderSourceArchiveBucketSelector;

  /**
   * The source archive object (file) in archive bucket.
   *
   * @schema FunctionSpecForProvider#sourceArchiveObject
   */
  readonly sourceArchiveObject?: string;

  /**
   * Reference to a BucketObject in storage to populate sourceArchiveObject.
   *
   * @schema FunctionSpecForProvider#sourceArchiveObjectRef
   */
  readonly sourceArchiveObjectRef?: FunctionSpecForProviderSourceArchiveObjectRef;

  /**
   * Selector for a BucketObject in storage to populate sourceArchiveObject.
   *
   * @schema FunctionSpecForProvider#sourceArchiveObjectSelector
   */
  readonly sourceArchiveObjectSelector?: FunctionSpecForProviderSourceArchiveObjectSelector;

  /**
   * Represents parameters related to source repository where a function is hosted. Cannot be set alongside source_archive_bucket or source_archive_object. Structure is documented below. It must match the pattern projects/{project}/locations/{location}/repositories/{repository}.*
   *
   * @schema FunctionSpecForProvider#sourceRepository
   */
  readonly sourceRepository?: FunctionSpecForProviderSourceRepository[];

  /**
   * Timeout (in seconds) for the function. Default value is 60 seconds. Cannot be more than 540 seconds.
   *
   * @schema FunctionSpecForProvider#timeout
   */
  readonly timeout?: number;

  /**
   * Boolean variable. Any HTTP request (of a supported type) to the endpoint will trigger function execution. Supported HTTP request types are: POST, PUT, GET, DELETE, and OPTIONS. Endpoint is returned as https_trigger_url. Cannot be used with event_trigger.
   *
   * @schema FunctionSpecForProvider#triggerHttp
   */
  readonly triggerHttp?: boolean;

  /**
   * The VPC Network Connector that this cloud function can connect to. It should be set up as fully-qualified URI. The format of this field is projects/_/locations/_/connectors/*.
   *
   * @schema FunctionSpecForProvider#vpcConnector
   */
  readonly vpcConnector?: string;

  /**
   * The egress settings for the connector, controlling what traffic is diverted through it. Allowed values are ALL_TRAFFIC and PRIVATE_RANGES_ONLY. Defaults to PRIVATE_RANGES_ONLY. If unset, this field preserves the previously set value.
   *
   * @default PRIVATE_RANGES_ONLY. If unset, this field preserves the previously set value.
   * @schema FunctionSpecForProvider#vpcConnectorEgressSettings
   */
  readonly vpcConnectorEgressSettings?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProvider(obj: FunctionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availableMemoryMb': obj.availableMemoryMb,
    'buildEnvironmentVariables': ((obj.buildEnvironmentVariables) === undefined) ? undefined : (Object.entries(obj.buildEnvironmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'buildWorkerPool': obj.buildWorkerPool,
    'description': obj.description,
    'dockerRegistry': obj.dockerRegistry,
    'dockerRepository': obj.dockerRepository,
    'entryPoint': obj.entryPoint,
    'environmentVariables': ((obj.environmentVariables) === undefined) ? undefined : (Object.entries(obj.environmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'eventTrigger': obj.eventTrigger?.map(y => toJson_FunctionSpecForProviderEventTrigger(y)),
    'httpsTriggerSecurityLevel': obj.httpsTriggerSecurityLevel,
    'httpsTriggerUrl': obj.httpsTriggerUrl,
    'ingressSettings': obj.ingressSettings,
    'kmsKeyName': obj.kmsKeyName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'maxInstances': obj.maxInstances,
    'minInstances': obj.minInstances,
    'project': obj.project,
    'region': obj.region,
    'runtime': obj.runtime,
    'secretEnvironmentVariables': obj.secretEnvironmentVariables?.map(y => toJson_FunctionSpecForProviderSecretEnvironmentVariables(y)),
    'secretVolumes': obj.secretVolumes?.map(y => toJson_FunctionSpecForProviderSecretVolumes(y)),
    'serviceAccountEmail': obj.serviceAccountEmail,
    'sourceArchiveBucket': obj.sourceArchiveBucket,
    'sourceArchiveBucketRef': toJson_FunctionSpecForProviderSourceArchiveBucketRef(obj.sourceArchiveBucketRef),
    'sourceArchiveBucketSelector': toJson_FunctionSpecForProviderSourceArchiveBucketSelector(obj.sourceArchiveBucketSelector),
    'sourceArchiveObject': obj.sourceArchiveObject,
    'sourceArchiveObjectRef': toJson_FunctionSpecForProviderSourceArchiveObjectRef(obj.sourceArchiveObjectRef),
    'sourceArchiveObjectSelector': toJson_FunctionSpecForProviderSourceArchiveObjectSelector(obj.sourceArchiveObjectSelector),
    'sourceRepository': obj.sourceRepository?.map(y => toJson_FunctionSpecForProviderSourceRepository(y)),
    'timeout': obj.timeout,
    'triggerHttp': obj.triggerHttp,
    'vpcConnector': obj.vpcConnector,
    'vpcConnectorEgressSettings': obj.vpcConnectorEgressSettings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionSpecProviderConfigRef
 */
export interface FunctionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecProviderConfigRef#policy
   */
  readonly policy?: FunctionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRef(obj: FunctionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FunctionSpecProviderRef
 */
export interface FunctionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecProviderRef#policy
   */
  readonly policy?: FunctionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderRef(obj: FunctionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionSpecPublishConnectionDetailsTo
 */
export interface FunctionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsTo(obj: FunctionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionSpecWriteConnectionSecretToRef
 */
export interface FunctionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecWriteConnectionSecretToRef(obj: FunctionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderEventTrigger
 */
export interface FunctionSpecForProviderEventTrigger {
  /**
   * The type of event to observe. For example: "google.storage.object.finalize". See the documentation on calling Cloud Functions for a full reference of accepted triggers.
   *
   * @schema FunctionSpecForProviderEventTrigger#eventType
   */
  readonly eventType: string;

  /**
   * Specifies policy for failed executions. Structure is documented below.
   *
   * @schema FunctionSpecForProviderEventTrigger#failurePolicy
   */
  readonly failurePolicy?: FunctionSpecForProviderEventTriggerFailurePolicy[];

  /**
   * Required. The name or partial URI of the resource from which to observe events. For example, "myBucket" or "projects/my-project/topics/my-topic"
   *
   * @schema FunctionSpecForProviderEventTrigger#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTrigger(obj: FunctionSpecForProviderEventTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType,
    'failurePolicy': obj.failurePolicy?.map(y => toJson_FunctionSpecForProviderEventTriggerFailurePolicy(y)),
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderSecretEnvironmentVariables
 */
export interface FunctionSpecForProviderSecretEnvironmentVariables {
  /**
   * Name of the environment variable.
   *
   * @schema FunctionSpecForProviderSecretEnvironmentVariables#key
   */
  readonly key: string;

  /**
   * Project identifier (due to a known limitation, only project number is supported by this field) of the project that contains the secret. If not set, it will be populated with the function's project, assuming that the secret exists in the same project as of the function.
   *
   * @schema FunctionSpecForProviderSecretEnvironmentVariables#projectId
   */
  readonly projectId?: string;

  /**
   * ID of the secret in secret manager (not the full resource name).
   *
   * @schema FunctionSpecForProviderSecretEnvironmentVariables#secret
   */
  readonly secret: string;

  /**
   * Version of the secret (version number or the string "latest"). It is recommended to use a numeric version for secret environment variables as any updates to the secret value is not reflected until new clones start.
   *
   * @schema FunctionSpecForProviderSecretEnvironmentVariables#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSecretEnvironmentVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSecretEnvironmentVariables(obj: FunctionSpecForProviderSecretEnvironmentVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'projectId': obj.projectId,
    'secret': obj.secret,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderSecretVolumes
 */
export interface FunctionSpecForProviderSecretVolumes {
  /**
   * The path within the container to mount the secret volume. For example, setting the mount_path as "/etc/secrets" would mount the secret value files under the "/etc/secrets" directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount paths: "/etc/secrets" Restricted mount paths: "/cloudsql", "/dev/log", "/pod", "/proc", "/var/log".
   *
   * @schema FunctionSpecForProviderSecretVolumes#mountPath
   */
  readonly mountPath: string;

  /**
   * Project identifier (due to a known limitation, only project number is supported by this field) of the project that contains the secret. If not set, it will be populated with the function's project, assuming that the secret exists in the same project as of the function.
   *
   * @schema FunctionSpecForProviderSecretVolumes#projectId
   */
  readonly projectId?: string;

  /**
   * ID of the secret in secret manager (not the full resource name).
   *
   * @schema FunctionSpecForProviderSecretVolumes#secret
   */
  readonly secret: string;

  /**
   * List of secret versions to mount for this secret. If empty, the "latest" version of the secret will be made available in a file named after the secret under the mount point. Structure is documented below.
   *
   * @schema FunctionSpecForProviderSecretVolumes#versions
   */
  readonly versions?: FunctionSpecForProviderSecretVolumesVersions[];

}

/**
 * Converts an object of type 'FunctionSpecForProviderSecretVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSecretVolumes(obj: FunctionSpecForProviderSecretVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'projectId': obj.projectId,
    'secret': obj.secret,
    'versions': obj.versions?.map(y => toJson_FunctionSpecForProviderSecretVolumesVersions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate sourceArchiveBucket.
 *
 * @schema FunctionSpecForProviderSourceArchiveBucketRef
 */
export interface FunctionSpecForProviderSourceArchiveBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderSourceArchiveBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderSourceArchiveBucketRef#policy
   */
  readonly policy?: FunctionSpecForProviderSourceArchiveBucketRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSourceArchiveBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSourceArchiveBucketRef(obj: FunctionSpecForProviderSourceArchiveBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderSourceArchiveBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate sourceArchiveBucket.
 *
 * @schema FunctionSpecForProviderSourceArchiveBucketSelector
 */
export interface FunctionSpecForProviderSourceArchiveBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderSourceArchiveBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderSourceArchiveBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderSourceArchiveBucketSelector#policy
   */
  readonly policy?: FunctionSpecForProviderSourceArchiveBucketSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSourceArchiveBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSourceArchiveBucketSelector(obj: FunctionSpecForProviderSourceArchiveBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderSourceArchiveBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a BucketObject in storage to populate sourceArchiveObject.
 *
 * @schema FunctionSpecForProviderSourceArchiveObjectRef
 */
export interface FunctionSpecForProviderSourceArchiveObjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderSourceArchiveObjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderSourceArchiveObjectRef#policy
   */
  readonly policy?: FunctionSpecForProviderSourceArchiveObjectRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSourceArchiveObjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSourceArchiveObjectRef(obj: FunctionSpecForProviderSourceArchiveObjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderSourceArchiveObjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a BucketObject in storage to populate sourceArchiveObject.
 *
 * @schema FunctionSpecForProviderSourceArchiveObjectSelector
 */
export interface FunctionSpecForProviderSourceArchiveObjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderSourceArchiveObjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderSourceArchiveObjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderSourceArchiveObjectSelector#policy
   */
  readonly policy?: FunctionSpecForProviderSourceArchiveObjectSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSourceArchiveObjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSourceArchiveObjectSelector(obj: FunctionSpecForProviderSourceArchiveObjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderSourceArchiveObjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderSourceRepository
 */
export interface FunctionSpecForProviderSourceRepository {
  /**
   * The URL pointing to the hosted repository where the function is defined. There are supported Cloud Source Repository URLs in the following formats:
   *
   * @schema FunctionSpecForProviderSourceRepository#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSourceRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSourceRepository(obj: FunctionSpecForProviderSourceRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecProviderConfigRefPolicy
 */
export interface FunctionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRefPolicy(obj: FunctionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecProviderRefPolicy
 */
export interface FunctionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderRefPolicy(obj: FunctionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj: FunctionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToMetadata
 */
export interface FunctionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj: FunctionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderEventTriggerFailurePolicy
 */
export interface FunctionSpecForProviderEventTriggerFailurePolicy {
  /**
   * Whether the function should be retried on failure. Defaults to false.
   *
   * @default false.
   * @schema FunctionSpecForProviderEventTriggerFailurePolicy#retry
   */
  readonly retry: boolean;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerFailurePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerFailurePolicy(obj: FunctionSpecForProviderEventTriggerFailurePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'retry': obj.retry,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderSecretVolumesVersions
 */
export interface FunctionSpecForProviderSecretVolumesVersions {
  /**
   * Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mount_path as "/etc/secrets" and path as "/secret_foo" would mount the secret value file at "/etc/secrets/secret_foo".
   *
   * @schema FunctionSpecForProviderSecretVolumesVersions#path
   */
  readonly path: string;

  /**
   * Version of the secret (version number or the string "latest"). It is preferable to use "latest" version with secret volumes as secret value changes are reflected immediately.
   *
   * @schema FunctionSpecForProviderSecretVolumesVersions#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSecretVolumesVersions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSecretVolumesVersions(obj: FunctionSpecForProviderSecretVolumesVersions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderSourceArchiveBucketRefPolicy
 */
export interface FunctionSpecForProviderSourceArchiveBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderSourceArchiveBucketRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderSourceArchiveBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderSourceArchiveBucketRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderSourceArchiveBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSourceArchiveBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSourceArchiveBucketRefPolicy(obj: FunctionSpecForProviderSourceArchiveBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderSourceArchiveBucketSelectorPolicy
 */
export interface FunctionSpecForProviderSourceArchiveBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderSourceArchiveBucketSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderSourceArchiveBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderSourceArchiveBucketSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderSourceArchiveBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSourceArchiveBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSourceArchiveBucketSelectorPolicy(obj: FunctionSpecForProviderSourceArchiveBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderSourceArchiveObjectRefPolicy
 */
export interface FunctionSpecForProviderSourceArchiveObjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderSourceArchiveObjectRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderSourceArchiveObjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderSourceArchiveObjectRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderSourceArchiveObjectRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSourceArchiveObjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSourceArchiveObjectRefPolicy(obj: FunctionSpecForProviderSourceArchiveObjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderSourceArchiveObjectSelectorPolicy
 */
export interface FunctionSpecForProviderSourceArchiveObjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderSourceArchiveObjectSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderSourceArchiveObjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderSourceArchiveObjectSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderSourceArchiveObjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSourceArchiveObjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSourceArchiveObjectSelectorPolicy(obj: FunctionSpecForProviderSourceArchiveObjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolution
 */
export enum FunctionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolve
 */
export enum FunctionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecProviderRefPolicyResolution
 */
export enum FunctionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecProviderRefPolicyResolve
 */
export enum FunctionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderSourceArchiveBucketRefPolicyResolution
 */
export enum FunctionSpecForProviderSourceArchiveBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderSourceArchiveBucketRefPolicyResolve
 */
export enum FunctionSpecForProviderSourceArchiveBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderSourceArchiveBucketSelectorPolicyResolution
 */
export enum FunctionSpecForProviderSourceArchiveBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderSourceArchiveBucketSelectorPolicyResolve
 */
export enum FunctionSpecForProviderSourceArchiveBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderSourceArchiveObjectRefPolicyResolution
 */
export enum FunctionSpecForProviderSourceArchiveObjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderSourceArchiveObjectRefPolicyResolve
 */
export enum FunctionSpecForProviderSourceArchiveObjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderSourceArchiveObjectSelectorPolicyResolution
 */
export enum FunctionSpecForProviderSourceArchiveObjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderSourceArchiveObjectSelectorPolicyResolve
 */
export enum FunctionSpecForProviderSourceArchiveObjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FunctionIAMMember is the Schema for the FunctionIAMMembers API. <no value>
 *
 * @schema FunctionIAMMember
 */
export class FunctionIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FunctionIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfunctions.gcp.upbound.io/v1beta1',
    kind: 'FunctionIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "FunctionIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionIamMemberProps): any {
    return {
      ...FunctionIamMember.GVK,
      ...toJson_FunctionIamMemberProps(props),
    };
  }

  /**
   * Defines a "FunctionIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionIamMemberProps) {
    super(scope, id, {
      ...FunctionIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FunctionIamMember.GVK,
      ...toJson_FunctionIamMemberProps(resolved),
    };
  }
}

/**
 * FunctionIAMMember is the Schema for the FunctionIAMMembers API. <no value>
 *
 * @schema FunctionIAMMember
 */
export interface FunctionIamMemberProps {
  /**
   * @schema FunctionIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionIAMMemberSpec defines the desired state of FunctionIAMMember
   *
   * @schema FunctionIAMMember#spec
   */
  readonly spec: FunctionIamMemberSpec;

}

/**
 * Converts an object of type 'FunctionIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberProps(obj: FunctionIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionIAMMemberSpec defines the desired state of FunctionIAMMember
 *
 * @schema FunctionIamMemberSpec
 */
export interface FunctionIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema FunctionIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionIamMemberSpecDeletionPolicy;

  /**
   * @schema FunctionIamMemberSpec#forProvider
   */
  readonly forProvider: FunctionIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FunctionIamMemberSpec#providerRef
   */
  readonly providerRef?: FunctionIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpec(obj: FunctionIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_FunctionIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FunctionIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FunctionIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema FunctionIamMemberSpecDeletionPolicy
 */
export enum FunctionIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FunctionIamMemberSpecForProvider
 */
export interface FunctionIamMemberSpecForProvider {
  /**
   * @schema FunctionIamMemberSpecForProvider#cloudFunction
   */
  readonly cloudFunction?: string;

  /**
   * Reference to a Function to populate cloudFunction.
   *
   * @schema FunctionIamMemberSpecForProvider#cloudFunctionRef
   */
  readonly cloudFunctionRef?: FunctionIamMemberSpecForProviderCloudFunctionRef;

  /**
   * Selector for a Function to populate cloudFunction.
   *
   * @schema FunctionIamMemberSpecForProvider#cloudFunctionSelector
   */
  readonly cloudFunctionSelector?: FunctionIamMemberSpecForProviderCloudFunctionSelector;

  /**
   * @schema FunctionIamMemberSpecForProvider#condition
   */
  readonly condition?: FunctionIamMemberSpecForProviderCondition[];

  /**
   * @schema FunctionIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema FunctionIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema FunctionIamMemberSpecForProvider#region
   */
  readonly region?: string;

  /**
   * @schema FunctionIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecForProvider(obj: FunctionIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudFunction': obj.cloudFunction,
    'cloudFunctionRef': toJson_FunctionIamMemberSpecForProviderCloudFunctionRef(obj.cloudFunctionRef),
    'cloudFunctionSelector': toJson_FunctionIamMemberSpecForProviderCloudFunctionSelector(obj.cloudFunctionSelector),
    'condition': obj.condition?.map(y => toJson_FunctionIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'region': obj.region,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionIamMemberSpecProviderConfigRef
 */
export interface FunctionIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: FunctionIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecProviderConfigRef(obj: FunctionIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FunctionIamMemberSpecProviderRef
 */
export interface FunctionIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionIamMemberSpecProviderRef#policy
   */
  readonly policy?: FunctionIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecProviderRef(obj: FunctionIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionIamMemberSpecPublishConnectionDetailsTo
 */
export interface FunctionIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecPublishConnectionDetailsTo(obj: FunctionIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionIamMemberSpecWriteConnectionSecretToRef
 */
export interface FunctionIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecWriteConnectionSecretToRef(obj: FunctionIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function to populate cloudFunction.
 *
 * @schema FunctionIamMemberSpecForProviderCloudFunctionRef
 */
export interface FunctionIamMemberSpecForProviderCloudFunctionRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionIamMemberSpecForProviderCloudFunctionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionIamMemberSpecForProviderCloudFunctionRef#policy
   */
  readonly policy?: FunctionIamMemberSpecForProviderCloudFunctionRefPolicy;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecForProviderCloudFunctionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecForProviderCloudFunctionRef(obj: FunctionIamMemberSpecForProviderCloudFunctionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionIamMemberSpecForProviderCloudFunctionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function to populate cloudFunction.
 *
 * @schema FunctionIamMemberSpecForProviderCloudFunctionSelector
 */
export interface FunctionIamMemberSpecForProviderCloudFunctionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionIamMemberSpecForProviderCloudFunctionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionIamMemberSpecForProviderCloudFunctionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionIamMemberSpecForProviderCloudFunctionSelector#policy
   */
  readonly policy?: FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecForProviderCloudFunctionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecForProviderCloudFunctionSelector(obj: FunctionIamMemberSpecForProviderCloudFunctionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionIamMemberSpecForProviderCondition
 */
export interface FunctionIamMemberSpecForProviderCondition {
  /**
   * @schema FunctionIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema FunctionIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema FunctionIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecForProviderCondition(obj: FunctionIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionIamMemberSpecProviderConfigRefPolicy
 */
export interface FunctionIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecProviderConfigRefPolicy(obj: FunctionIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionIamMemberSpecProviderRefPolicy
 */
export interface FunctionIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FunctionIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FunctionIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecProviderRefPolicy(obj: FunctionIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecPublishConnectionDetailsToConfigRef(obj: FunctionIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface FunctionIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecPublishConnectionDetailsToMetadata(obj: FunctionIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionIamMemberSpecForProviderCloudFunctionRefPolicy
 */
export interface FunctionIamMemberSpecForProviderCloudFunctionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionIamMemberSpecForProviderCloudFunctionRefPolicy#resolution
   */
  readonly resolution?: FunctionIamMemberSpecForProviderCloudFunctionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionIamMemberSpecForProviderCloudFunctionRefPolicy#resolve
   */
  readonly resolve?: FunctionIamMemberSpecForProviderCloudFunctionRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecForProviderCloudFunctionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecForProviderCloudFunctionRefPolicy(obj: FunctionIamMemberSpecForProviderCloudFunctionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicy
 */
export interface FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicy#resolution
   */
  readonly resolution?: FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicy#resolve
   */
  readonly resolve?: FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicy(obj: FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum FunctionIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum FunctionIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionIamMemberSpecProviderRefPolicyResolution
 */
export enum FunctionIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionIamMemberSpecProviderRefPolicyResolve
 */
export enum FunctionIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionIamMemberSpecForProviderCloudFunctionRefPolicyResolution
 */
export enum FunctionIamMemberSpecForProviderCloudFunctionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionIamMemberSpecForProviderCloudFunctionRefPolicyResolve
 */
export enum FunctionIamMemberSpecForProviderCloudFunctionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicyResolution
 */
export enum FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicyResolve
 */
export enum FunctionIamMemberSpecForProviderCloudFunctionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

