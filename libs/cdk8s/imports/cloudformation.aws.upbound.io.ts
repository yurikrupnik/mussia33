// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Stack is the Schema for the Stacks API. Provides a CloudFormation Stack resource.
 *
 * @schema Stack
 */
export class Stack extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stack"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudformation.aws.upbound.io/v1beta1',
    kind: 'Stack',
  }

  /**
   * Renders a Kubernetes manifest for "Stack".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StackProps): any {
    return {
      ...Stack.GVK,
      ...toJson_StackProps(props),
    };
  }

  /**
   * Defines a "Stack" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StackProps) {
    super(scope, id, {
      ...Stack.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stack.GVK,
      ...toJson_StackProps(resolved),
    };
  }
}

/**
 * Stack is the Schema for the Stacks API. Provides a CloudFormation Stack resource.
 *
 * @schema Stack
 */
export interface StackProps {
  /**
   * @schema Stack#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StackSpec defines the desired state of Stack
   *
   * @schema Stack#spec
   */
  readonly spec: StackSpec;

}

/**
 * Converts an object of type 'StackProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackProps(obj: StackProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StackSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StackSpec defines the desired state of Stack
 *
 * @schema StackSpec
 */
export interface StackSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSpec#deletionPolicy
   */
  readonly deletionPolicy?: StackSpecDeletionPolicy;

  /**
   * @schema StackSpec#forProvider
   */
  readonly forProvider: StackSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSpec#managementPolicy
   */
  readonly managementPolicy?: StackSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StackSpec#providerConfigRef
   */
  readonly providerConfigRef?: StackSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StackSpec#providerRef
   */
  readonly providerRef?: StackSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StackSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StackSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StackSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StackSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StackSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpec(obj: StackSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StackSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_StackSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StackSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StackSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StackSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSpecDeletionPolicy
 */
export enum StackSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StackSpecForProvider
 */
export interface StackSpecForProvider {
  /**
   * A list of capabilities. Valid values: CAPABILITY_IAM, CAPABILITY_NAMED_IAM, or CAPABILITY_AUTO_EXPAND
   *
   * @schema StackSpecForProvider#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Set to true to disable rollback of the stack if stack creation failed. Conflicts with on_failure.
   *
   * @schema StackSpecForProvider#disableRollback
   */
  readonly disableRollback?: boolean;

  /**
   * The ARN of an IAM role that AWS CloudFormation assumes to create the stack. If you don't specify a value, AWS CloudFormation uses the role that was previously associated with the stack. If no role is available, AWS CloudFormation uses a temporary session that is generated from your user credentials.
   *
   * @schema StackSpecForProvider#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate iamRoleArn.
   *
   * @schema StackSpecForProvider#iamRoleArnRef
   */
  readonly iamRoleArnRef?: StackSpecForProviderIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate iamRoleArn.
   *
   * @schema StackSpecForProvider#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: StackSpecForProviderIamRoleArnSelector;

  /**
   * Stack name.
   *
   * @schema StackSpecForProvider#name
   */
  readonly name: string;

  /**
   * A list of SNS topic ARNs to publish stack related events.
   *
   * @schema StackSpecForProvider#notificationArns
   */
  readonly notificationArns?: string[];

  /**
   * Action to be taken if stack creation fails. This must be one of: DO_NOTHING, ROLLBACK, or DELETE. Conflicts with disable_rollback.
   *
   * @schema StackSpecForProvider#onFailure
   */
  readonly onFailure?: string;

  /**
   * A map of Parameter structures that specify input parameters for the stack.
   *
   * @schema StackSpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Structure containing the stack policy body. Conflicts w/ policy_url.
   *
   * @schema StackSpecForProvider#policyBody
   */
  readonly policyBody?: string;

  /**
   * Location of a file containing the stack policy. Conflicts w/ policy_body.
   *
   * @schema StackSpecForProvider#policyUrl
   */
  readonly policyUrl?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StackSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StackSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Structure containing the template body (max size: 51,200 bytes).
   *
   * @schema StackSpecForProvider#templateBody
   */
  readonly templateBody?: string;

  /**
   * Location of a file containing the template body (max size: 460,800 bytes).
   *
   * @schema StackSpecForProvider#templateUrl
   */
  readonly templateUrl?: string;

  /**
   * The amount of time that can pass before the stack status becomes CREATE_FAILED.
   *
   * @schema StackSpecForProvider#timeoutInMinutes
   */
  readonly timeoutInMinutes?: number;

}

/**
 * Converts an object of type 'StackSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProvider(obj: StackSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capabilities': obj.capabilities?.map(y => y),
    'disableRollback': obj.disableRollback,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_StackSpecForProviderIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_StackSpecForProviderIamRoleArnSelector(obj.iamRoleArnSelector),
    'name': obj.name,
    'notificationArns': obj.notificationArns?.map(y => y),
    'onFailure': obj.onFailure,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policyBody': obj.policyBody,
    'policyUrl': obj.policyUrl,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateBody': obj.templateBody,
    'templateUrl': obj.templateUrl,
    'timeoutInMinutes': obj.timeoutInMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSpecManagementPolicy
 */
export enum StackSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StackSpecProviderConfigRef
 */
export interface StackSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecProviderConfigRef#policy
   */
  readonly policy?: StackSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderConfigRef(obj: StackSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StackSpecProviderRef
 */
export interface StackSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecProviderRef#policy
   */
  readonly policy?: StackSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StackSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderRef(obj: StackSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StackSpecPublishConnectionDetailsTo
 */
export interface StackSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StackSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StackSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsTo(obj: StackSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StackSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StackSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StackSpecWriteConnectionSecretToRef
 */
export interface StackSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StackSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecWriteConnectionSecretToRef(obj: StackSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRoleArn.
 *
 * @schema StackSpecForProviderIamRoleArnRef
 */
export interface StackSpecForProviderIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecForProviderIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecForProviderIamRoleArnRef#policy
   */
  readonly policy?: StackSpecForProviderIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderIamRoleArnRef(obj: StackSpecForProviderIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecForProviderIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRoleArn.
 *
 * @schema StackSpecForProviderIamRoleArnSelector
 */
export interface StackSpecForProviderIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StackSpecForProviderIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSpecForProviderIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSpecForProviderIamRoleArnSelector#policy
   */
  readonly policy?: StackSpecForProviderIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderIamRoleArnSelector(obj: StackSpecForProviderIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSpecForProviderIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecProviderConfigRefPolicy
 */
export interface StackSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StackSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StackSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderConfigRefPolicy(obj: StackSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecProviderRefPolicy
 */
export interface StackSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StackSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StackSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderRefPolicy(obj: StackSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRef
 */
export interface StackSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StackSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToConfigRef(obj: StackSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StackSpecPublishConnectionDetailsToMetadata
 */
export interface StackSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToMetadata(obj: StackSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecForProviderIamRoleArnRefPolicy
 */
export interface StackSpecForProviderIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecForProviderIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderIamRoleArnRefPolicy(obj: StackSpecForProviderIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSpecForProviderIamRoleArnSelectorPolicy
 */
export interface StackSpecForProviderIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecForProviderIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderIamRoleArnSelectorPolicy(obj: StackSpecForProviderIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecProviderConfigRefPolicyResolution
 */
export enum StackSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecProviderConfigRefPolicyResolve
 */
export enum StackSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecProviderRefPolicyResolution
 */
export enum StackSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecProviderRefPolicyResolve
 */
export enum StackSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StackSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StackSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StackSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToConfigRefPolicy(obj: StackSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderIamRoleArnRefPolicyResolution
 */
export enum StackSpecForProviderIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecForProviderIamRoleArnRefPolicyResolve
 */
export enum StackSpecForProviderIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderIamRoleArnSelectorPolicyResolution
 */
export enum StackSpecForProviderIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecForProviderIamRoleArnSelectorPolicyResolve
 */
export enum StackSpecForProviderIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StackSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StackSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StackSet is the Schema for the StackSets API. Manages a CloudFormation StackSet.
 *
 * @schema StackSet
 */
export class StackSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StackSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudformation.aws.upbound.io/v1beta1',
    kind: 'StackSet',
  }

  /**
   * Renders a Kubernetes manifest for "StackSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StackSetProps): any {
    return {
      ...StackSet.GVK,
      ...toJson_StackSetProps(props),
    };
  }

  /**
   * Defines a "StackSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StackSetProps) {
    super(scope, id, {
      ...StackSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StackSet.GVK,
      ...toJson_StackSetProps(resolved),
    };
  }
}

/**
 * StackSet is the Schema for the StackSets API. Manages a CloudFormation StackSet.
 *
 * @schema StackSet
 */
export interface StackSetProps {
  /**
   * @schema StackSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StackSetSpec defines the desired state of StackSet
   *
   * @schema StackSet#spec
   */
  readonly spec: StackSetSpec;

}

/**
 * Converts an object of type 'StackSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetProps(obj: StackSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StackSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StackSetSpec defines the desired state of StackSet
 *
 * @schema StackSetSpec
 */
export interface StackSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: StackSetSpecDeletionPolicy;

  /**
   * @schema StackSetSpec#forProvider
   */
  readonly forProvider: StackSetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSetSpec#managementPolicy
   */
  readonly managementPolicy?: StackSetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StackSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: StackSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StackSetSpec#providerRef
   */
  readonly providerRef?: StackSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StackSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StackSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StackSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StackSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StackSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpec(obj: StackSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StackSetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_StackSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StackSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StackSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StackSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSetSpecDeletionPolicy
 */
export enum StackSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StackSetSpecForProvider
 */
export interface StackSetSpecForProvider {
  /**
   * Amazon Resource Number (ARN) of the IAM Role in the administrator account. This must be defined when using the SELF_MANAGED permission model.
   *
   * @schema StackSetSpecForProvider#administrationRoleArn
   */
  readonly administrationRoleArn?: string;

  /**
   * Reference to a Role in iam to populate administrationRoleArn.
   *
   * @schema StackSetSpecForProvider#administrationRoleArnRef
   */
  readonly administrationRoleArnRef?: StackSetSpecForProviderAdministrationRoleArnRef;

  /**
   * Selector for a Role in iam to populate administrationRoleArn.
   *
   * @schema StackSetSpecForProvider#administrationRoleArnSelector
   */
  readonly administrationRoleArnSelector?: StackSetSpecForProviderAdministrationRoleArnSelector;

  /**
   * Configuration block containing the auto-deployment model for your StackSet. This can only be defined when using the SERVICE_MANAGED permission model.
   *
   * @schema StackSetSpecForProvider#autoDeployment
   */
  readonly autoDeployment?: StackSetSpecForProviderAutoDeployment[];

  /**
   * Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account. Valid values: SELF (default), DELEGATED_ADMIN.
   *
   * @schema StackSetSpecForProvider#callAs
   */
  readonly callAs?: string;

  /**
   * A list of capabilities. Valid values: CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_AUTO_EXPAND.
   *
   * @schema StackSetSpecForProvider#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Description of the StackSet.
   *
   * @schema StackSetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Name of the IAM Role in all target accounts for StackSet operations. Defaults to AWSCloudFormationStackSetExecutionRole when using the SELF_MANAGED permission model. This should not be defined when using the SERVICE_MANAGED permission model.
   *
   * @default AWSCloudFormationStackSetExecutionRole when using the SELF_MANAGED permission model. This should not be defined when using the SERVICE_MANAGED permission model.
   * @schema StackSetSpecForProvider#executionRoleName
   */
  readonly executionRoleName?: string;

  /**
   * Preferences for how AWS CloudFormation performs a stack set update.
   *
   * @schema StackSetSpecForProvider#operationPreferences
   */
  readonly operationPreferences?: StackSetSpecForProviderOperationPreferences[];

  /**
   * Key-value map of input parameters for the StackSet template. All template parameters, including those with a Default, must be configured or ignored with lifecycle configuration block ignore_changes argument. All NoEcho template parameters must be ignored with the lifecycle configuration block ignore_changes argument.
   *
   * @schema StackSetSpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Describes how the IAM roles required for your StackSet are created. Valid values: SELF_MANAGED (default), SERVICE_MANAGED.
   *
   * @schema StackSetSpecForProvider#permissionModel
   */
  readonly permissionModel?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StackSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StackSetSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * String containing the CloudFormation template body. Maximum size: 51,200 bytes. Conflicts with template_url.
   *
   * @schema StackSetSpecForProvider#templateBody
   */
  readonly templateBody?: string;

  /**
   * String containing the location of a file containing the CloudFormation template body. The URL must point to a template that is located in an Amazon S3 bucket. Maximum location file size: 460,800 bytes. Conflicts with template_body.
   *
   * @schema StackSetSpecForProvider#templateUrl
   */
  readonly templateUrl?: string;

}

/**
 * Converts an object of type 'StackSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProvider(obj: StackSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'administrationRoleArn': obj.administrationRoleArn,
    'administrationRoleArnRef': toJson_StackSetSpecForProviderAdministrationRoleArnRef(obj.administrationRoleArnRef),
    'administrationRoleArnSelector': toJson_StackSetSpecForProviderAdministrationRoleArnSelector(obj.administrationRoleArnSelector),
    'autoDeployment': obj.autoDeployment?.map(y => toJson_StackSetSpecForProviderAutoDeployment(y)),
    'callAs': obj.callAs,
    'capabilities': obj.capabilities?.map(y => y),
    'description': obj.description,
    'executionRoleName': obj.executionRoleName,
    'operationPreferences': obj.operationPreferences?.map(y => toJson_StackSetSpecForProviderOperationPreferences(y)),
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'permissionModel': obj.permissionModel,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateBody': obj.templateBody,
    'templateUrl': obj.templateUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSetSpecManagementPolicy
 */
export enum StackSetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StackSetSpecProviderConfigRef
 */
export interface StackSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetSpecProviderConfigRef#policy
   */
  readonly policy?: StackSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecProviderConfigRef(obj: StackSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StackSetSpecProviderRef
 */
export interface StackSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetSpecProviderRef#policy
   */
  readonly policy?: StackSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StackSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecProviderRef(obj: StackSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StackSetSpecPublishConnectionDetailsTo
 */
export interface StackSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StackSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StackSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StackSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StackSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StackSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StackSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecPublishConnectionDetailsTo(obj: StackSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StackSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StackSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StackSetSpecWriteConnectionSecretToRef
 */
export interface StackSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StackSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecWriteConnectionSecretToRef(obj: StackSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate administrationRoleArn.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnRef
 */
export interface StackSetSpecForProviderAdministrationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnRef#policy
   */
  readonly policy?: StackSetSpecForProviderAdministrationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'StackSetSpecForProviderAdministrationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderAdministrationRoleArnRef(obj: StackSetSpecForProviderAdministrationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetSpecForProviderAdministrationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate administrationRoleArn.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnSelector
 */
export interface StackSetSpecForProviderAdministrationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnSelector#policy
   */
  readonly policy?: StackSetSpecForProviderAdministrationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'StackSetSpecForProviderAdministrationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderAdministrationRoleArnSelector(obj: StackSetSpecForProviderAdministrationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSetSpecForProviderAdministrationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetSpecForProviderAutoDeployment
 */
export interface StackSetSpecForProviderAutoDeployment {
  /**
   * Whether or not auto-deployment is enabled.
   *
   * @schema StackSetSpecForProviderAutoDeployment#enabled
   */
  readonly enabled?: boolean;

  /**
   * Whether or not to retain stacks when the account is removed.
   *
   * @schema StackSetSpecForProviderAutoDeployment#retainStacksOnAccountRemoval
   */
  readonly retainStacksOnAccountRemoval?: boolean;

}

/**
 * Converts an object of type 'StackSetSpecForProviderAutoDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderAutoDeployment(obj: StackSetSpecForProviderAutoDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'retainStacksOnAccountRemoval': obj.retainStacksOnAccountRemoval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetSpecForProviderOperationPreferences
 */
export interface StackSetSpecForProviderOperationPreferences {
  /**
   * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetSpecForProviderOperationPreferences#failureToleranceCount
   */
  readonly failureToleranceCount?: number;

  /**
   * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetSpecForProviderOperationPreferences#failureTolerancePercentage
   */
  readonly failureTolerancePercentage?: number;

  /**
   * The maximum number of accounts in which to perform this operation at one time.
   *
   * @schema StackSetSpecForProviderOperationPreferences#maxConcurrentCount
   */
  readonly maxConcurrentCount?: number;

  /**
   * The maximum percentage of accounts in which to perform this operation at one time.
   *
   * @schema StackSetSpecForProviderOperationPreferences#maxConcurrentPercentage
   */
  readonly maxConcurrentPercentage?: number;

  /**
   * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time.
   *
   * @schema StackSetSpecForProviderOperationPreferences#regionConcurrencyType
   */
  readonly regionConcurrencyType?: string;

  /**
   * The order of the Regions in where you want to perform the stack operation.
   *
   * @schema StackSetSpecForProviderOperationPreferences#regionOrder
   */
  readonly regionOrder?: string[];

}

/**
 * Converts an object of type 'StackSetSpecForProviderOperationPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderOperationPreferences(obj: StackSetSpecForProviderOperationPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureToleranceCount': obj.failureToleranceCount,
    'failureTolerancePercentage': obj.failureTolerancePercentage,
    'maxConcurrentCount': obj.maxConcurrentCount,
    'maxConcurrentPercentage': obj.maxConcurrentPercentage,
    'regionConcurrencyType': obj.regionConcurrencyType,
    'regionOrder': obj.regionOrder?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetSpecProviderConfigRefPolicy
 */
export interface StackSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StackSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StackSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecProviderConfigRefPolicy(obj: StackSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetSpecProviderRefPolicy
 */
export interface StackSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StackSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StackSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecProviderRefPolicy(obj: StackSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StackSetSpecPublishConnectionDetailsToConfigRef
 */
export interface StackSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StackSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecPublishConnectionDetailsToConfigRef(obj: StackSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StackSetSpecPublishConnectionDetailsToMetadata
 */
export interface StackSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StackSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StackSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecPublishConnectionDetailsToMetadata(obj: StackSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnRefPolicy
 */
export interface StackSetSpecForProviderAdministrationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnRefPolicy#resolution
   */
  readonly resolution?: StackSetSpecForProviderAdministrationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnRefPolicy#resolve
   */
  readonly resolve?: StackSetSpecForProviderAdministrationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecForProviderAdministrationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderAdministrationRoleArnRefPolicy(obj: StackSetSpecForProviderAdministrationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnSelectorPolicy
 */
export interface StackSetSpecForProviderAdministrationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecForProviderAdministrationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderAdministrationRoleArnSelectorPolicy(obj: StackSetSpecForProviderAdministrationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecProviderConfigRefPolicyResolution
 */
export enum StackSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSetSpecProviderConfigRefPolicyResolve
 */
export enum StackSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecProviderRefPolicyResolution
 */
export enum StackSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSetSpecProviderRefPolicyResolve
 */
export enum StackSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StackSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StackSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: StackSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnRefPolicyResolution
 */
export enum StackSetSpecForProviderAdministrationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnRefPolicyResolve
 */
export enum StackSetSpecForProviderAdministrationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolution
 */
export enum StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolve
 */
export enum StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

