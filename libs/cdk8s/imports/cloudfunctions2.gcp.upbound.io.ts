// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Function is the Schema for the Functions API. A Cloud Function that contains user computation executed in response to an event.
 *
 * @schema Function
 */
export class Function extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Function"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfunctions2.gcp.upbound.io/v1beta1',
    kind: 'Function',
  }

  /**
   * Renders a Kubernetes manifest for "Function".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionProps): any {
    return {
      ...Function.GVK,
      ...toJson_FunctionProps(props),
    };
  }

  /**
   * Defines a "Function" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionProps) {
    super(scope, id, {
      ...Function.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Function.GVK,
      ...toJson_FunctionProps(resolved),
    };
  }
}

/**
 * Function is the Schema for the Functions API. A Cloud Function that contains user computation executed in response to an event.
 *
 * @schema Function
 */
export interface FunctionProps {
  /**
   * @schema Function#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionSpec defines the desired state of Function
   *
   * @schema Function#spec
   */
  readonly spec: FunctionSpec;

}

/**
 * Converts an object of type 'FunctionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionProps(obj: FunctionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionSpec defines the desired state of Function
 *
 * @schema FunctionSpec
 */
export interface FunctionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FunctionSpec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionSpecDeletionPolicy;

  /**
   * @schema FunctionSpec#forProvider
   */
  readonly forProvider: FunctionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FunctionSpec#initProvider
   */
  readonly initProvider?: FunctionSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FunctionSpec#managementPolicies
   */
  readonly managementPolicies?: FunctionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionSpec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpec(obj: FunctionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionSpecForProvider(obj.forProvider),
    'initProvider': toJson_FunctionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FunctionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FunctionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FunctionSpecDeletionPolicy
 */
export enum FunctionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FunctionSpecForProvider
 */
export interface FunctionSpecForProvider {
  /**
   * Describes the Build step of the function that builds a container from the given source. Structure is documented below.
   *
   * @schema FunctionSpecForProvider#buildConfig
   */
  readonly buildConfig?: FunctionSpecForProviderBuildConfig[];

  /**
   * User-provided description of a function.
   *
   * @schema FunctionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * An Eventarc trigger managed by Google Cloud Functions that fires events in response to a condition in another service. Structure is documented below.
   *
   * @schema FunctionSpecForProvider#eventTrigger
   */
  readonly eventTrigger?: FunctionSpecForProviderEventTrigger[];

  /**
   * A set of key/value label pairs associated with this Cloud Function.
   *
   * @schema FunctionSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The location of this cloud function.
   *
   * @schema FunctionSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema FunctionSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Describes the Service being deployed. Structure is documented below.
   *
   * @schema FunctionSpecForProvider#serviceConfig
   */
  readonly serviceConfig?: FunctionSpecForProviderServiceConfig[];

}

/**
 * Converts an object of type 'FunctionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProvider(obj: FunctionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buildConfig': obj.buildConfig?.map(y => toJson_FunctionSpecForProviderBuildConfig(y)),
    'description': obj.description,
    'eventTrigger': obj.eventTrigger?.map(y => toJson_FunctionSpecForProviderEventTrigger(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'project': obj.project,
    'serviceConfig': obj.serviceConfig?.map(y => toJson_FunctionSpecForProviderServiceConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FunctionSpecInitProvider
 */
export interface FunctionSpecInitProvider {
  /**
   * Describes the Build step of the function that builds a container from the given source. Structure is documented below.
   *
   * @schema FunctionSpecInitProvider#buildConfig
   */
  readonly buildConfig?: FunctionSpecInitProviderBuildConfig[];

  /**
   * User-provided description of a function.
   *
   * @schema FunctionSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * An Eventarc trigger managed by Google Cloud Functions that fires events in response to a condition in another service. Structure is documented below.
   *
   * @schema FunctionSpecInitProvider#eventTrigger
   */
  readonly eventTrigger?: FunctionSpecInitProviderEventTrigger[];

  /**
   * A set of key/value label pairs associated with this Cloud Function.
   *
   * @schema FunctionSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema FunctionSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Describes the Service being deployed. Structure is documented below.
   *
   * @schema FunctionSpecInitProvider#serviceConfig
   */
  readonly serviceConfig?: FunctionSpecInitProviderServiceConfig[];

}

/**
 * Converts an object of type 'FunctionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProvider(obj: FunctionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buildConfig': obj.buildConfig?.map(y => toJson_FunctionSpecInitProviderBuildConfig(y)),
    'description': obj.description,
    'eventTrigger': obj.eventTrigger?.map(y => toJson_FunctionSpecInitProviderEventTrigger(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'serviceConfig': obj.serviceConfig?.map(y => toJson_FunctionSpecInitProviderServiceConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FunctionSpecManagementPolicies
 */
export enum FunctionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionSpecProviderConfigRef
 */
export interface FunctionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecProviderConfigRef#policy
   */
  readonly policy?: FunctionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRef(obj: FunctionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionSpecPublishConnectionDetailsTo
 */
export interface FunctionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsTo(obj: FunctionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionSpecWriteConnectionSecretToRef
 */
export interface FunctionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecWriteConnectionSecretToRef(obj: FunctionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderBuildConfig
 */
export interface FunctionSpecForProviderBuildConfig {
  /**
   * User managed repository created in Artifact Registry optionally with a customer managed encryption key.
   *
   * @schema FunctionSpecForProviderBuildConfig#dockerRepository
   */
  readonly dockerRepository?: string;

  /**
   * The name of the function (as defined in source code) that will be executed. Defaults to the resource name suffix, if not specified. For backward compatibility, if function with given name is not found, then the system will try to use function named "function". For Node.js this is name of a function exported by the module specified in source_location.
   *
   * @default the resource name suffix, if not specified. For backward compatibility, if function with given name is not found, then the system will try to use function named "function". For Node.js this is name of a function exported by the module specified in source_location.
   * @schema FunctionSpecForProviderBuildConfig#entryPoint
   */
  readonly entryPoint?: string;

  /**
   * User-provided build-time environment variables for the function.
   *
   * @schema FunctionSpecForProviderBuildConfig#environmentVariables
   */
  readonly environmentVariables?: { [key: string]: string };

  /**
   * The runtime in which to run the function. Required when deploying a new function, optional when updating an existing function.
   *
   * @schema FunctionSpecForProviderBuildConfig#runtime
   */
  readonly runtime?: string;

  /**
   * The location of the function source code. Structure is documented below.
   *
   * @schema FunctionSpecForProviderBuildConfig#source
   */
  readonly source?: FunctionSpecForProviderBuildConfigSource[];

  /**
   * Name of the Cloud Build Custom Worker Pool that should be used to build the function.
   *
   * @schema FunctionSpecForProviderBuildConfig#workerPool
   */
  readonly workerPool?: string;

  /**
   * Reference to a WorkerPool in cloudbuild to populate workerPool.
   *
   * @schema FunctionSpecForProviderBuildConfig#workerPoolRef
   */
  readonly workerPoolRef?: FunctionSpecForProviderBuildConfigWorkerPoolRef;

  /**
   * Selector for a WorkerPool in cloudbuild to populate workerPool.
   *
   * @schema FunctionSpecForProviderBuildConfig#workerPoolSelector
   */
  readonly workerPoolSelector?: FunctionSpecForProviderBuildConfigWorkerPoolSelector;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfig(obj: FunctionSpecForProviderBuildConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dockerRepository': obj.dockerRepository,
    'entryPoint': obj.entryPoint,
    'environmentVariables': ((obj.environmentVariables) === undefined) ? undefined : (Object.entries(obj.environmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'runtime': obj.runtime,
    'source': obj.source?.map(y => toJson_FunctionSpecForProviderBuildConfigSource(y)),
    'workerPool': obj.workerPool,
    'workerPoolRef': toJson_FunctionSpecForProviderBuildConfigWorkerPoolRef(obj.workerPoolRef),
    'workerPoolSelector': toJson_FunctionSpecForProviderBuildConfigWorkerPoolSelector(obj.workerPoolSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderEventTrigger
 */
export interface FunctionSpecForProviderEventTrigger {
  /**
   * Criteria used to filter events. Structure is documented below.
   *
   * @schema FunctionSpecForProviderEventTrigger#eventFilters
   */
  readonly eventFilters?: FunctionSpecForProviderEventTriggerEventFilters[];

  /**
   * Required. The type of event to observe.
   *
   * @schema FunctionSpecForProviderEventTrigger#eventType
   */
  readonly eventType?: string;

  /**
   * The name of a Pub/Sub topic in the same project that will be used as the transport topic for the event delivery.
   *
   * @schema FunctionSpecForProviderEventTrigger#pubsubTopic
   */
  readonly pubsubTopic?: string;

  /**
   * Reference to a Topic in pubsub to populate pubsubTopic.
   *
   * @schema FunctionSpecForProviderEventTrigger#pubsubTopicRef
   */
  readonly pubsubTopicRef?: FunctionSpecForProviderEventTriggerPubsubTopicRef;

  /**
   * Selector for a Topic in pubsub to populate pubsubTopic.
   *
   * @schema FunctionSpecForProviderEventTrigger#pubsubTopicSelector
   */
  readonly pubsubTopicSelector?: FunctionSpecForProviderEventTriggerPubsubTopicSelector;

  /**
   * Describes the retry policy in case of function's execution failure. Retried execution is charged as any other execution. Possible values are: RETRY_POLICY_UNSPECIFIED, RETRY_POLICY_DO_NOT_RETRY, RETRY_POLICY_RETRY.
   *
   * @schema FunctionSpecForProviderEventTrigger#retryPolicy
   */
  readonly retryPolicy?: string;

  /**
   * The email of the service account for this function.
   *
   * @schema FunctionSpecForProviderEventTrigger#serviceAccountEmail
   */
  readonly serviceAccountEmail?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
   *
   * @schema FunctionSpecForProviderEventTrigger#serviceAccountEmailRef
   */
  readonly serviceAccountEmailRef?: FunctionSpecForProviderEventTriggerServiceAccountEmailRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
   *
   * @schema FunctionSpecForProviderEventTrigger#serviceAccountEmailSelector
   */
  readonly serviceAccountEmailSelector?: FunctionSpecForProviderEventTriggerServiceAccountEmailSelector;

  /**
   * The region that the trigger will be in. The trigger will only receive events originating in this region. It can be the same region as the function, a different region or multi-region, or the global region. If not provided, defaults to the same region as the function.
   *
   * @schema FunctionSpecForProviderEventTrigger#triggerRegion
   */
  readonly triggerRegion?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTrigger(obj: FunctionSpecForProviderEventTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventFilters': obj.eventFilters?.map(y => toJson_FunctionSpecForProviderEventTriggerEventFilters(y)),
    'eventType': obj.eventType,
    'pubsubTopic': obj.pubsubTopic,
    'pubsubTopicRef': toJson_FunctionSpecForProviderEventTriggerPubsubTopicRef(obj.pubsubTopicRef),
    'pubsubTopicSelector': toJson_FunctionSpecForProviderEventTriggerPubsubTopicSelector(obj.pubsubTopicSelector),
    'retryPolicy': obj.retryPolicy,
    'serviceAccountEmail': obj.serviceAccountEmail,
    'serviceAccountEmailRef': toJson_FunctionSpecForProviderEventTriggerServiceAccountEmailRef(obj.serviceAccountEmailRef),
    'serviceAccountEmailSelector': toJson_FunctionSpecForProviderEventTriggerServiceAccountEmailSelector(obj.serviceAccountEmailSelector),
    'triggerRegion': obj.triggerRegion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderServiceConfig
 */
export interface FunctionSpecForProviderServiceConfig {
  /**
   * Whether 100% of traffic is routed to the latest revision. Defaults to true.
   *
   * @default true.
   * @schema FunctionSpecForProviderServiceConfig#allTrafficOnLatestRevision
   */
  readonly allTrafficOnLatestRevision?: boolean;

  /**
   * The number of CPUs used in a single container instance. Default value is calculated from available memory.
   *
   * @schema FunctionSpecForProviderServiceConfig#availableCpu
   */
  readonly availableCpu?: string;

  /**
   * The amount of memory available for a function. Defaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is supplied the value is interpreted as bytes.
   *
   * @default 256M. Supported units are k, M, G, Mi, Gi. If no unit is supplied the value is interpreted as bytes.
   * @schema FunctionSpecForProviderServiceConfig#availableMemory
   */
  readonly availableMemory?: string;

  /**
   * Environment variables that shall be available during function execution.
   *
   * @schema FunctionSpecForProviderServiceConfig#environmentVariables
   */
  readonly environmentVariables?: { [key: string]: string };

  /**
   * Available ingress settings. Defaults to "ALLOW_ALL" if unspecified. Default value is ALLOW_ALL. Possible values are: ALLOW_ALL, ALLOW_INTERNAL_ONLY, ALLOW_INTERNAL_AND_GCLB.
   *
   * @default ALLOW_ALL" if unspecified. Default value is ALLOW_ALL. Possible values are: ALLOW_ALL, ALLOW_INTERNAL_ONLY, ALLOW_INTERNAL_AND_GCLB.
   * @schema FunctionSpecForProviderServiceConfig#ingressSettings
   */
  readonly ingressSettings?: string;

  /**
   * The limit on the maximum number of function instances that may coexist at a given time.
   *
   * @schema FunctionSpecForProviderServiceConfig#maxInstanceCount
   */
  readonly maxInstanceCount?: number;

  /**
   * Sets the maximum number of concurrent requests that each instance can receive. Defaults to 1.
   *
   * @default 1.
   * @schema FunctionSpecForProviderServiceConfig#maxInstanceRequestConcurrency
   */
  readonly maxInstanceRequestConcurrency?: number;

  /**
   * The limit on the minimum number of function instances that may coexist at a given time.
   *
   * @schema FunctionSpecForProviderServiceConfig#minInstanceCount
   */
  readonly minInstanceCount?: number;

  /**
   * Secret environment variables configuration. Structure is documented below.
   *
   * @schema FunctionSpecForProviderServiceConfig#secretEnvironmentVariables
   */
  readonly secretEnvironmentVariables?: FunctionSpecForProviderServiceConfigSecretEnvironmentVariables[];

  /**
   * Secret volumes configuration. Structure is documented below.
   *
   * @schema FunctionSpecForProviderServiceConfig#secretVolumes
   */
  readonly secretVolumes?: FunctionSpecForProviderServiceConfigSecretVolumes[];

  /**
   * Name of the service associated with a Function.
   *
   * @schema FunctionSpecForProviderServiceConfig#service
   */
  readonly service?: string;

  /**
   * The email of the service account for this function.
   *
   * @schema FunctionSpecForProviderServiceConfig#serviceAccountEmail
   */
  readonly serviceAccountEmail?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
   *
   * @schema FunctionSpecForProviderServiceConfig#serviceAccountEmailRef
   */
  readonly serviceAccountEmailRef?: FunctionSpecForProviderServiceConfigServiceAccountEmailRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
   *
   * @schema FunctionSpecForProviderServiceConfig#serviceAccountEmailSelector
   */
  readonly serviceAccountEmailSelector?: FunctionSpecForProviderServiceConfigServiceAccountEmailSelector;

  /**
   * The function execution timeout. Execution is considered failed and can be terminated if the function is not completed at the end of the timeout period. Defaults to 60 seconds.
   *
   * @default 60 seconds.
   * @schema FunctionSpecForProviderServiceConfig#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * The Serverless VPC Access connector that this cloud function can connect to.
   *
   * @schema FunctionSpecForProviderServiceConfig#vpcConnector
   */
  readonly vpcConnector?: string;

  /**
   * Available egress settings. Possible values are: VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED, PRIVATE_RANGES_ONLY, ALL_TRAFFIC.
   *
   * @schema FunctionSpecForProviderServiceConfig#vpcConnectorEgressSettings
   */
  readonly vpcConnectorEgressSettings?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfig(obj: FunctionSpecForProviderServiceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allTrafficOnLatestRevision': obj.allTrafficOnLatestRevision,
    'availableCpu': obj.availableCpu,
    'availableMemory': obj.availableMemory,
    'environmentVariables': ((obj.environmentVariables) === undefined) ? undefined : (Object.entries(obj.environmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ingressSettings': obj.ingressSettings,
    'maxInstanceCount': obj.maxInstanceCount,
    'maxInstanceRequestConcurrency': obj.maxInstanceRequestConcurrency,
    'minInstanceCount': obj.minInstanceCount,
    'secretEnvironmentVariables': obj.secretEnvironmentVariables?.map(y => toJson_FunctionSpecForProviderServiceConfigSecretEnvironmentVariables(y)),
    'secretVolumes': obj.secretVolumes?.map(y => toJson_FunctionSpecForProviderServiceConfigSecretVolumes(y)),
    'service': obj.service,
    'serviceAccountEmail': obj.serviceAccountEmail,
    'serviceAccountEmailRef': toJson_FunctionSpecForProviderServiceConfigServiceAccountEmailRef(obj.serviceAccountEmailRef),
    'serviceAccountEmailSelector': toJson_FunctionSpecForProviderServiceConfigServiceAccountEmailSelector(obj.serviceAccountEmailSelector),
    'timeoutSeconds': obj.timeoutSeconds,
    'vpcConnector': obj.vpcConnector,
    'vpcConnectorEgressSettings': obj.vpcConnectorEgressSettings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecInitProviderBuildConfig
 */
export interface FunctionSpecInitProviderBuildConfig {
  /**
   * User managed repository created in Artifact Registry optionally with a customer managed encryption key.
   *
   * @schema FunctionSpecInitProviderBuildConfig#dockerRepository
   */
  readonly dockerRepository?: string;

  /**
   * The name of the function (as defined in source code) that will be executed. Defaults to the resource name suffix, if not specified. For backward compatibility, if function with given name is not found, then the system will try to use function named "function". For Node.js this is name of a function exported by the module specified in source_location.
   *
   * @default the resource name suffix, if not specified. For backward compatibility, if function with given name is not found, then the system will try to use function named "function". For Node.js this is name of a function exported by the module specified in source_location.
   * @schema FunctionSpecInitProviderBuildConfig#entryPoint
   */
  readonly entryPoint?: string;

  /**
   * User-provided build-time environment variables for the function.
   *
   * @schema FunctionSpecInitProviderBuildConfig#environmentVariables
   */
  readonly environmentVariables?: { [key: string]: string };

  /**
   * The runtime in which to run the function. Required when deploying a new function, optional when updating an existing function.
   *
   * @schema FunctionSpecInitProviderBuildConfig#runtime
   */
  readonly runtime?: string;

  /**
   * The location of the function source code. Structure is documented below.
   *
   * @schema FunctionSpecInitProviderBuildConfig#source
   */
  readonly source?: FunctionSpecInitProviderBuildConfigSource[];

}

/**
 * Converts an object of type 'FunctionSpecInitProviderBuildConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProviderBuildConfig(obj: FunctionSpecInitProviderBuildConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dockerRepository': obj.dockerRepository,
    'entryPoint': obj.entryPoint,
    'environmentVariables': ((obj.environmentVariables) === undefined) ? undefined : (Object.entries(obj.environmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'runtime': obj.runtime,
    'source': obj.source?.map(y => toJson_FunctionSpecInitProviderBuildConfigSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecInitProviderEventTrigger
 */
export interface FunctionSpecInitProviderEventTrigger {
  /**
   * Criteria used to filter events. Structure is documented below.
   *
   * @schema FunctionSpecInitProviderEventTrigger#eventFilters
   */
  readonly eventFilters?: FunctionSpecInitProviderEventTriggerEventFilters[];

  /**
   * Required. The type of event to observe.
   *
   * @schema FunctionSpecInitProviderEventTrigger#eventType
   */
  readonly eventType?: string;

  /**
   * Describes the retry policy in case of function's execution failure. Retried execution is charged as any other execution. Possible values are: RETRY_POLICY_UNSPECIFIED, RETRY_POLICY_DO_NOT_RETRY, RETRY_POLICY_RETRY.
   *
   * @schema FunctionSpecInitProviderEventTrigger#retryPolicy
   */
  readonly retryPolicy?: string;

  /**
   * The region that the trigger will be in. The trigger will only receive events originating in this region. It can be the same region as the function, a different region or multi-region, or the global region. If not provided, defaults to the same region as the function.
   *
   * @schema FunctionSpecInitProviderEventTrigger#triggerRegion
   */
  readonly triggerRegion?: string;

}

/**
 * Converts an object of type 'FunctionSpecInitProviderEventTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProviderEventTrigger(obj: FunctionSpecInitProviderEventTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventFilters': obj.eventFilters?.map(y => toJson_FunctionSpecInitProviderEventTriggerEventFilters(y)),
    'eventType': obj.eventType,
    'retryPolicy': obj.retryPolicy,
    'triggerRegion': obj.triggerRegion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecInitProviderServiceConfig
 */
export interface FunctionSpecInitProviderServiceConfig {
  /**
   * Whether 100% of traffic is routed to the latest revision. Defaults to true.
   *
   * @default true.
   * @schema FunctionSpecInitProviderServiceConfig#allTrafficOnLatestRevision
   */
  readonly allTrafficOnLatestRevision?: boolean;

  /**
   * The number of CPUs used in a single container instance. Default value is calculated from available memory.
   *
   * @schema FunctionSpecInitProviderServiceConfig#availableCpu
   */
  readonly availableCpu?: string;

  /**
   * The amount of memory available for a function. Defaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is supplied the value is interpreted as bytes.
   *
   * @default 256M. Supported units are k, M, G, Mi, Gi. If no unit is supplied the value is interpreted as bytes.
   * @schema FunctionSpecInitProviderServiceConfig#availableMemory
   */
  readonly availableMemory?: string;

  /**
   * Environment variables that shall be available during function execution.
   *
   * @schema FunctionSpecInitProviderServiceConfig#environmentVariables
   */
  readonly environmentVariables?: { [key: string]: string };

  /**
   * Available ingress settings. Defaults to "ALLOW_ALL" if unspecified. Default value is ALLOW_ALL. Possible values are: ALLOW_ALL, ALLOW_INTERNAL_ONLY, ALLOW_INTERNAL_AND_GCLB.
   *
   * @default ALLOW_ALL" if unspecified. Default value is ALLOW_ALL. Possible values are: ALLOW_ALL, ALLOW_INTERNAL_ONLY, ALLOW_INTERNAL_AND_GCLB.
   * @schema FunctionSpecInitProviderServiceConfig#ingressSettings
   */
  readonly ingressSettings?: string;

  /**
   * The limit on the maximum number of function instances that may coexist at a given time.
   *
   * @schema FunctionSpecInitProviderServiceConfig#maxInstanceCount
   */
  readonly maxInstanceCount?: number;

  /**
   * Sets the maximum number of concurrent requests that each instance can receive. Defaults to 1.
   *
   * @default 1.
   * @schema FunctionSpecInitProviderServiceConfig#maxInstanceRequestConcurrency
   */
  readonly maxInstanceRequestConcurrency?: number;

  /**
   * The limit on the minimum number of function instances that may coexist at a given time.
   *
   * @schema FunctionSpecInitProviderServiceConfig#minInstanceCount
   */
  readonly minInstanceCount?: number;

  /**
   * Secret environment variables configuration. Structure is documented below.
   *
   * @schema FunctionSpecInitProviderServiceConfig#secretEnvironmentVariables
   */
  readonly secretEnvironmentVariables?: FunctionSpecInitProviderServiceConfigSecretEnvironmentVariables[];

  /**
   * Secret volumes configuration. Structure is documented below.
   *
   * @schema FunctionSpecInitProviderServiceConfig#secretVolumes
   */
  readonly secretVolumes?: FunctionSpecInitProviderServiceConfigSecretVolumes[];

  /**
   * Name of the service associated with a Function.
   *
   * @schema FunctionSpecInitProviderServiceConfig#service
   */
  readonly service?: string;

  /**
   * The function execution timeout. Execution is considered failed and can be terminated if the function is not completed at the end of the timeout period. Defaults to 60 seconds.
   *
   * @default 60 seconds.
   * @schema FunctionSpecInitProviderServiceConfig#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * The Serverless VPC Access connector that this cloud function can connect to.
   *
   * @schema FunctionSpecInitProviderServiceConfig#vpcConnector
   */
  readonly vpcConnector?: string;

  /**
   * Available egress settings. Possible values are: VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED, PRIVATE_RANGES_ONLY, ALL_TRAFFIC.
   *
   * @schema FunctionSpecInitProviderServiceConfig#vpcConnectorEgressSettings
   */
  readonly vpcConnectorEgressSettings?: string;

}

/**
 * Converts an object of type 'FunctionSpecInitProviderServiceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProviderServiceConfig(obj: FunctionSpecInitProviderServiceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allTrafficOnLatestRevision': obj.allTrafficOnLatestRevision,
    'availableCpu': obj.availableCpu,
    'availableMemory': obj.availableMemory,
    'environmentVariables': ((obj.environmentVariables) === undefined) ? undefined : (Object.entries(obj.environmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ingressSettings': obj.ingressSettings,
    'maxInstanceCount': obj.maxInstanceCount,
    'maxInstanceRequestConcurrency': obj.maxInstanceRequestConcurrency,
    'minInstanceCount': obj.minInstanceCount,
    'secretEnvironmentVariables': obj.secretEnvironmentVariables?.map(y => toJson_FunctionSpecInitProviderServiceConfigSecretEnvironmentVariables(y)),
    'secretVolumes': obj.secretVolumes?.map(y => toJson_FunctionSpecInitProviderServiceConfigSecretVolumes(y)),
    'service': obj.service,
    'timeoutSeconds': obj.timeoutSeconds,
    'vpcConnector': obj.vpcConnector,
    'vpcConnectorEgressSettings': obj.vpcConnectorEgressSettings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecProviderConfigRefPolicy
 */
export interface FunctionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRefPolicy(obj: FunctionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj: FunctionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToMetadata
 */
export interface FunctionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj: FunctionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderBuildConfigSource
 */
export interface FunctionSpecForProviderBuildConfigSource {
  /**
   * If provided, get the source from this location in a Cloud Source Repository. Structure is documented below.
   *
   * @schema FunctionSpecForProviderBuildConfigSource#repoSource
   */
  readonly repoSource?: FunctionSpecForProviderBuildConfigSourceRepoSource[];

  /**
   * If provided, get the source from this location in Google Cloud Storage. Structure is documented below.
   *
   * @schema FunctionSpecForProviderBuildConfigSource#storageSource
   */
  readonly storageSource?: FunctionSpecForProviderBuildConfigSourceStorageSource[];

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSource(obj: FunctionSpecForProviderBuildConfigSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repoSource': obj.repoSource?.map(y => toJson_FunctionSpecForProviderBuildConfigSourceRepoSource(y)),
    'storageSource': obj.storageSource?.map(y => toJson_FunctionSpecForProviderBuildConfigSourceStorageSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a WorkerPool in cloudbuild to populate workerPool.
 *
 * @schema FunctionSpecForProviderBuildConfigWorkerPoolRef
 */
export interface FunctionSpecForProviderBuildConfigWorkerPoolRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderBuildConfigWorkerPoolRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderBuildConfigWorkerPoolRef#policy
   */
  readonly policy?: FunctionSpecForProviderBuildConfigWorkerPoolRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigWorkerPoolRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigWorkerPoolRef(obj: FunctionSpecForProviderBuildConfigWorkerPoolRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderBuildConfigWorkerPoolRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a WorkerPool in cloudbuild to populate workerPool.
 *
 * @schema FunctionSpecForProviderBuildConfigWorkerPoolSelector
 */
export interface FunctionSpecForProviderBuildConfigWorkerPoolSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderBuildConfigWorkerPoolSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderBuildConfigWorkerPoolSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderBuildConfigWorkerPoolSelector#policy
   */
  readonly policy?: FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigWorkerPoolSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigWorkerPoolSelector(obj: FunctionSpecForProviderBuildConfigWorkerPoolSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderEventTriggerEventFilters
 */
export interface FunctionSpecForProviderEventTriggerEventFilters {
  /**
   * 'Required. The name of a CloudEvents attribute. Currently, only a subset of attributes are supported for filtering. Use the gcloud eventarc providers describe command to learn more about events and their attributes. Do not filter for the 'type' attribute here, as this is already achieved by the resource's event_type attribute.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFilters#attribute
   */
  readonly attribute?: string;

  /**
   * Optional. The operator used for matching the events with the value of the filter. If not specified, only events that have an exact key-value pair specified in the filter are matched. The only allowed value is match-path-pattern. See documentation on path patterns here'
   *
   * @schema FunctionSpecForProviderEventTriggerEventFilters#operator
   */
  readonly operator?: string;

  /**
   * Required. The value for the attribute. If the operator field is set as match-path-pattern, this value can be a path pattern instead of an exact value.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFilters#value
   */
  readonly value?: string;

  /**
   * Reference to a Bucket in storage to populate value.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFilters#valueRef
   */
  readonly valueRef?: FunctionSpecForProviderEventTriggerEventFiltersValueRef;

  /**
   * Selector for a Bucket in storage to populate value.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFilters#valueSelector
   */
  readonly valueSelector?: FunctionSpecForProviderEventTriggerEventFiltersValueSelector;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerEventFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerEventFilters(obj: FunctionSpecForProviderEventTriggerEventFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attribute': obj.attribute,
    'operator': obj.operator,
    'value': obj.value,
    'valueRef': toJson_FunctionSpecForProviderEventTriggerEventFiltersValueRef(obj.valueRef),
    'valueSelector': toJson_FunctionSpecForProviderEventTriggerEventFiltersValueSelector(obj.valueSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in pubsub to populate pubsubTopic.
 *
 * @schema FunctionSpecForProviderEventTriggerPubsubTopicRef
 */
export interface FunctionSpecForProviderEventTriggerPubsubTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderEventTriggerPubsubTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderEventTriggerPubsubTopicRef#policy
   */
  readonly policy?: FunctionSpecForProviderEventTriggerPubsubTopicRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerPubsubTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerPubsubTopicRef(obj: FunctionSpecForProviderEventTriggerPubsubTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderEventTriggerPubsubTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in pubsub to populate pubsubTopic.
 *
 * @schema FunctionSpecForProviderEventTriggerPubsubTopicSelector
 */
export interface FunctionSpecForProviderEventTriggerPubsubTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderEventTriggerPubsubTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderEventTriggerPubsubTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderEventTriggerPubsubTopicSelector#policy
   */
  readonly policy?: FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerPubsubTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerPubsubTopicSelector(obj: FunctionSpecForProviderEventTriggerPubsubTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
 *
 * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailRef
 */
export interface FunctionSpecForProviderEventTriggerServiceAccountEmailRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailRef#policy
   */
  readonly policy?: FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerServiceAccountEmailRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerServiceAccountEmailRef(obj: FunctionSpecForProviderEventTriggerServiceAccountEmailRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
 *
 * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailSelector
 */
export interface FunctionSpecForProviderEventTriggerServiceAccountEmailSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailSelector#policy
   */
  readonly policy?: FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerServiceAccountEmailSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerServiceAccountEmailSelector(obj: FunctionSpecForProviderEventTriggerServiceAccountEmailSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariables
 */
export interface FunctionSpecForProviderServiceConfigSecretEnvironmentVariables {
  /**
   * Name of the environment variable.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariables#key
   */
  readonly key?: string;

  /**
   * Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariables#projectId
   */
  readonly projectId?: string;

  /**
   * Name of the secret in secret manager (not the full resource name).
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariables#secret
   */
  readonly secret?: string;

  /**
   * Reference to a Secret in secretmanager to populate secret.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariables#secretRef
   */
  readonly secretRef?: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRef;

  /**
   * Selector for a Secret in secretmanager to populate secret.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariables#secretSelector
   */
  readonly secretSelector?: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelector;

  /**
   * Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariables#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretEnvironmentVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretEnvironmentVariables(obj: FunctionSpecForProviderServiceConfigSecretEnvironmentVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'projectId': obj.projectId,
    'secret': obj.secret,
    'secretRef': toJson_FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRef(obj.secretRef),
    'secretSelector': toJson_FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelector(obj.secretSelector),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderServiceConfigSecretVolumes
 */
export interface FunctionSpecForProviderServiceConfigSecretVolumes {
  /**
   * The path within the container to mount the secret volume. For example, setting the mountPath as /etc/secrets would mount the secret value files under the /etc/secrets directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount path: /etc/secrets
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumes#mountPath
   */
  readonly mountPath?: string;

  /**
   * Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumes#projectId
   */
  readonly projectId?: string;

  /**
   * Name of the secret in secret manager (not the full resource name).
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumes#secret
   */
  readonly secret?: string;

  /**
   * Reference to a Secret in secretmanager to populate secret.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumes#secretRef
   */
  readonly secretRef?: FunctionSpecForProviderServiceConfigSecretVolumesSecretRef;

  /**
   * Selector for a Secret in secretmanager to populate secret.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumes#secretSelector
   */
  readonly secretSelector?: FunctionSpecForProviderServiceConfigSecretVolumesSecretSelector;

  /**
   * List of secret versions to mount for this secret. If empty, the latest version of the secret will be made available in a file named after the secret under the mount point.' Structure is documented below.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumes#versions
   */
  readonly versions?: FunctionSpecForProviderServiceConfigSecretVolumesVersions[];

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretVolumes(obj: FunctionSpecForProviderServiceConfigSecretVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'projectId': obj.projectId,
    'secret': obj.secret,
    'secretRef': toJson_FunctionSpecForProviderServiceConfigSecretVolumesSecretRef(obj.secretRef),
    'secretSelector': toJson_FunctionSpecForProviderServiceConfigSecretVolumesSecretSelector(obj.secretSelector),
    'versions': obj.versions?.map(y => toJson_FunctionSpecForProviderServiceConfigSecretVolumesVersions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
 *
 * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailRef
 */
export interface FunctionSpecForProviderServiceConfigServiceAccountEmailRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailRef#policy
   */
  readonly policy?: FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigServiceAccountEmailRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigServiceAccountEmailRef(obj: FunctionSpecForProviderServiceConfigServiceAccountEmailRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
 *
 * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailSelector
 */
export interface FunctionSpecForProviderServiceConfigServiceAccountEmailSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailSelector#policy
   */
  readonly policy?: FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigServiceAccountEmailSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigServiceAccountEmailSelector(obj: FunctionSpecForProviderServiceConfigServiceAccountEmailSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecInitProviderBuildConfigSource
 */
export interface FunctionSpecInitProviderBuildConfigSource {
  /**
   * If provided, get the source from this location in a Cloud Source Repository. Structure is documented below.
   *
   * @schema FunctionSpecInitProviderBuildConfigSource#repoSource
   */
  readonly repoSource?: FunctionSpecInitProviderBuildConfigSourceRepoSource[];

  /**
   * If provided, get the source from this location in Google Cloud Storage. Structure is documented below.
   *
   * @schema FunctionSpecInitProviderBuildConfigSource#storageSource
   */
  readonly storageSource?: FunctionSpecInitProviderBuildConfigSourceStorageSource[];

}

/**
 * Converts an object of type 'FunctionSpecInitProviderBuildConfigSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProviderBuildConfigSource(obj: FunctionSpecInitProviderBuildConfigSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repoSource': obj.repoSource?.map(y => toJson_FunctionSpecInitProviderBuildConfigSourceRepoSource(y)),
    'storageSource': obj.storageSource?.map(y => toJson_FunctionSpecInitProviderBuildConfigSourceStorageSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecInitProviderEventTriggerEventFilters
 */
export interface FunctionSpecInitProviderEventTriggerEventFilters {
  /**
   * 'Required. The name of a CloudEvents attribute. Currently, only a subset of attributes are supported for filtering. Use the gcloud eventarc providers describe command to learn more about events and their attributes. Do not filter for the 'type' attribute here, as this is already achieved by the resource's event_type attribute.
   *
   * @schema FunctionSpecInitProviderEventTriggerEventFilters#attribute
   */
  readonly attribute?: string;

  /**
   * Optional. The operator used for matching the events with the value of the filter. If not specified, only events that have an exact key-value pair specified in the filter are matched. The only allowed value is match-path-pattern. See documentation on path patterns here'
   *
   * @schema FunctionSpecInitProviderEventTriggerEventFilters#operator
   */
  readonly operator?: string;

}

/**
 * Converts an object of type 'FunctionSpecInitProviderEventTriggerEventFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProviderEventTriggerEventFilters(obj: FunctionSpecInitProviderEventTriggerEventFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attribute': obj.attribute,
    'operator': obj.operator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecInitProviderServiceConfigSecretEnvironmentVariables
 */
export interface FunctionSpecInitProviderServiceConfigSecretEnvironmentVariables {
  /**
   * Name of the environment variable.
   *
   * @schema FunctionSpecInitProviderServiceConfigSecretEnvironmentVariables#key
   */
  readonly key?: string;

  /**
   * Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
   *
   * @schema FunctionSpecInitProviderServiceConfigSecretEnvironmentVariables#projectId
   */
  readonly projectId?: string;

  /**
   * Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
   *
   * @schema FunctionSpecInitProviderServiceConfigSecretEnvironmentVariables#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'FunctionSpecInitProviderServiceConfigSecretEnvironmentVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProviderServiceConfigSecretEnvironmentVariables(obj: FunctionSpecInitProviderServiceConfigSecretEnvironmentVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'projectId': obj.projectId,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecInitProviderServiceConfigSecretVolumes
 */
export interface FunctionSpecInitProviderServiceConfigSecretVolumes {
  /**
   * The path within the container to mount the secret volume. For example, setting the mountPath as /etc/secrets would mount the secret value files under the /etc/secrets directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount path: /etc/secrets
   *
   * @schema FunctionSpecInitProviderServiceConfigSecretVolumes#mountPath
   */
  readonly mountPath?: string;

  /**
   * Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
   *
   * @schema FunctionSpecInitProviderServiceConfigSecretVolumes#projectId
   */
  readonly projectId?: string;

  /**
   * List of secret versions to mount for this secret. If empty, the latest version of the secret will be made available in a file named after the secret under the mount point.' Structure is documented below.
   *
   * @schema FunctionSpecInitProviderServiceConfigSecretVolumes#versions
   */
  readonly versions?: FunctionSpecInitProviderServiceConfigSecretVolumesVersions[];

}

/**
 * Converts an object of type 'FunctionSpecInitProviderServiceConfigSecretVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProviderServiceConfigSecretVolumes(obj: FunctionSpecInitProviderServiceConfigSecretVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'projectId': obj.projectId,
    'versions': obj.versions?.map(y => toJson_FunctionSpecInitProviderServiceConfigSecretVolumesVersions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolution
 */
export enum FunctionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolve
 */
export enum FunctionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderBuildConfigSourceRepoSource
 */
export interface FunctionSpecForProviderBuildConfigSourceRepoSource {
  /**
   * Regex matching branches to build.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceRepoSource#branchName
   */
  readonly branchName?: string;

  /**
   * Regex matching tags to build.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceRepoSource#commitSha
   */
  readonly commitSha?: string;

  /**
   * Directory, relative to the source root, in which to run the build.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceRepoSource#dir
   */
  readonly dir?: string;

  /**
   * Only trigger a build if the revision regex does NOT match the revision regex.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceRepoSource#invertRegex
   */
  readonly invertRegex?: boolean;

  /**
   * Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceRepoSource#projectId
   */
  readonly projectId?: string;

  /**
   * Name of the Cloud Source Repository.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceRepoSource#repoName
   */
  readonly repoName?: string;

  /**
   * Regex matching tags to build.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceRepoSource#tagName
   */
  readonly tagName?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSourceRepoSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSourceRepoSource(obj: FunctionSpecForProviderBuildConfigSourceRepoSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branchName': obj.branchName,
    'commitSha': obj.commitSha,
    'dir': obj.dir,
    'invertRegex': obj.invertRegex,
    'projectId': obj.projectId,
    'repoName': obj.repoName,
    'tagName': obj.tagName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSource
 */
export interface FunctionSpecForProviderBuildConfigSourceStorageSource {
  /**
   * Google Cloud Storage bucket containing the source
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSource#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSource#bucketRef
   */
  readonly bucketRef?: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSource#bucketSelector
   */
  readonly bucketSelector?: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelector;

  /**
   * Google Cloud Storage generation for the object. If the generation is omitted, the latest generation will be used.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSource#generation
   */
  readonly generation?: number;

  /**
   * Google Cloud Storage object containing the source.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSource#object
   */
  readonly object?: string;

  /**
   * Reference to a BucketObject in storage to populate object.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSource#objectRef
   */
  readonly objectRef?: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRef;

  /**
   * Selector for a BucketObject in storage to populate object.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSource#objectSelector
   */
  readonly objectSelector?: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelector;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSourceStorageSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSourceStorageSource(obj: FunctionSpecForProviderBuildConfigSourceStorageSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRef(obj.bucketRef),
    'bucketSelector': toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelector(obj.bucketSelector),
    'generation': obj.generation,
    'object': obj.object,
    'objectRef': toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRef(obj.objectRef),
    'objectSelector': toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelector(obj.objectSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderBuildConfigWorkerPoolRefPolicy
 */
export interface FunctionSpecForProviderBuildConfigWorkerPoolRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderBuildConfigWorkerPoolRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderBuildConfigWorkerPoolRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderBuildConfigWorkerPoolRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderBuildConfigWorkerPoolRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigWorkerPoolRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigWorkerPoolRefPolicy(obj: FunctionSpecForProviderBuildConfigWorkerPoolRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicy
 */
export interface FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicy(obj: FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate value.
 *
 * @schema FunctionSpecForProviderEventTriggerEventFiltersValueRef
 */
export interface FunctionSpecForProviderEventTriggerEventFiltersValueRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFiltersValueRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFiltersValueRef#policy
   */
  readonly policy?: FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerEventFiltersValueRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerEventFiltersValueRef(obj: FunctionSpecForProviderEventTriggerEventFiltersValueRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate value.
 *
 * @schema FunctionSpecForProviderEventTriggerEventFiltersValueSelector
 */
export interface FunctionSpecForProviderEventTriggerEventFiltersValueSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFiltersValueSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFiltersValueSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFiltersValueSelector#policy
   */
  readonly policy?: FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerEventFiltersValueSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerEventFiltersValueSelector(obj: FunctionSpecForProviderEventTriggerEventFiltersValueSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderEventTriggerPubsubTopicRefPolicy
 */
export interface FunctionSpecForProviderEventTriggerPubsubTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderEventTriggerPubsubTopicRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderEventTriggerPubsubTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderEventTriggerPubsubTopicRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderEventTriggerPubsubTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerPubsubTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerPubsubTopicRefPolicy(obj: FunctionSpecForProviderEventTriggerPubsubTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicy
 */
export interface FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicy(obj: FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicy
 */
export interface FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicy(obj: FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicy
 */
export interface FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicy(obj: FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretmanager to populate secret.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRef
 */
export interface FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRef#policy
   */
  readonly policy?: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRef(obj: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretmanager to populate secret.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelector
 */
export interface FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelector#policy
   */
  readonly policy?: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelector(obj: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretmanager to populate secret.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretRef
 */
export interface FunctionSpecForProviderServiceConfigSecretVolumesSecretRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretRef#policy
   */
  readonly policy?: FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretVolumesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretVolumesSecretRef(obj: FunctionSpecForProviderServiceConfigSecretVolumesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretmanager to populate secret.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretSelector
 */
export interface FunctionSpecForProviderServiceConfigSecretVolumesSecretSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretSelector#policy
   */
  readonly policy?: FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretVolumesSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretVolumesSecretSelector(obj: FunctionSpecForProviderServiceConfigSecretVolumesSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderServiceConfigSecretVolumesVersions
 */
export interface FunctionSpecForProviderServiceConfigSecretVolumesVersions {
  /**
   * Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mountPath as '/etc/secrets' and path as secret_foo would mount the secret value file at /etc/secrets/secret_foo.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesVersions#path
   */
  readonly path?: string;

  /**
   * Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesVersions#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretVolumesVersions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretVolumesVersions(obj: FunctionSpecForProviderServiceConfigSecretVolumesVersions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicy
 */
export interface FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicy(obj: FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicy
 */
export interface FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicy(obj: FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecInitProviderBuildConfigSourceRepoSource
 */
export interface FunctionSpecInitProviderBuildConfigSourceRepoSource {
  /**
   * Regex matching branches to build.
   *
   * @schema FunctionSpecInitProviderBuildConfigSourceRepoSource#branchName
   */
  readonly branchName?: string;

  /**
   * Regex matching tags to build.
   *
   * @schema FunctionSpecInitProviderBuildConfigSourceRepoSource#commitSha
   */
  readonly commitSha?: string;

  /**
   * Directory, relative to the source root, in which to run the build.
   *
   * @schema FunctionSpecInitProviderBuildConfigSourceRepoSource#dir
   */
  readonly dir?: string;

  /**
   * Only trigger a build if the revision regex does NOT match the revision regex.
   *
   * @schema FunctionSpecInitProviderBuildConfigSourceRepoSource#invertRegex
   */
  readonly invertRegex?: boolean;

  /**
   * Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
   *
   * @schema FunctionSpecInitProviderBuildConfigSourceRepoSource#projectId
   */
  readonly projectId?: string;

  /**
   * Name of the Cloud Source Repository.
   *
   * @schema FunctionSpecInitProviderBuildConfigSourceRepoSource#repoName
   */
  readonly repoName?: string;

  /**
   * Regex matching tags to build.
   *
   * @schema FunctionSpecInitProviderBuildConfigSourceRepoSource#tagName
   */
  readonly tagName?: string;

}

/**
 * Converts an object of type 'FunctionSpecInitProviderBuildConfigSourceRepoSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProviderBuildConfigSourceRepoSource(obj: FunctionSpecInitProviderBuildConfigSourceRepoSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branchName': obj.branchName,
    'commitSha': obj.commitSha,
    'dir': obj.dir,
    'invertRegex': obj.invertRegex,
    'projectId': obj.projectId,
    'repoName': obj.repoName,
    'tagName': obj.tagName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecInitProviderBuildConfigSourceStorageSource
 */
export interface FunctionSpecInitProviderBuildConfigSourceStorageSource {
  /**
   * Google Cloud Storage generation for the object. If the generation is omitted, the latest generation will be used.
   *
   * @schema FunctionSpecInitProviderBuildConfigSourceStorageSource#generation
   */
  readonly generation?: number;

}

/**
 * Converts an object of type 'FunctionSpecInitProviderBuildConfigSourceStorageSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProviderBuildConfigSourceStorageSource(obj: FunctionSpecInitProviderBuildConfigSourceStorageSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generation': obj.generation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecInitProviderServiceConfigSecretVolumesVersions
 */
export interface FunctionSpecInitProviderServiceConfigSecretVolumesVersions {
  /**
   * Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mountPath as '/etc/secrets' and path as secret_foo would mount the secret value file at /etc/secrets/secret_foo.
   *
   * @schema FunctionSpecInitProviderServiceConfigSecretVolumesVersions#path
   */
  readonly path?: string;

  /**
   * Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
   *
   * @schema FunctionSpecInitProviderServiceConfigSecretVolumesVersions#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'FunctionSpecInitProviderServiceConfigSecretVolumesVersions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProviderServiceConfigSecretVolumesVersions(obj: FunctionSpecInitProviderServiceConfigSecretVolumesVersions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRef
 */
export interface FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRef#policy
   */
  readonly policy?: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRef(obj: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelector
 */
export interface FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelector#policy
   */
  readonly policy?: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelector(obj: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a BucketObject in storage to populate object.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRef
 */
export interface FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRef#policy
   */
  readonly policy?: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRef(obj: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a BucketObject in storage to populate object.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelector
 */
export interface FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelector#policy
   */
  readonly policy?: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelector(obj: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderBuildConfigWorkerPoolRefPolicyResolution
 */
export enum FunctionSpecForProviderBuildConfigWorkerPoolRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderBuildConfigWorkerPoolRefPolicyResolve
 */
export enum FunctionSpecForProviderBuildConfigWorkerPoolRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicyResolution
 */
export enum FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicyResolve
 */
export enum FunctionSpecForProviderBuildConfigWorkerPoolSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicy
 */
export interface FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicy(obj: FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicy
 */
export interface FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicy(obj: FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderEventTriggerPubsubTopicRefPolicyResolution
 */
export enum FunctionSpecForProviderEventTriggerPubsubTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderEventTriggerPubsubTopicRefPolicyResolve
 */
export enum FunctionSpecForProviderEventTriggerPubsubTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicyResolution
 */
export enum FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicyResolve
 */
export enum FunctionSpecForProviderEventTriggerPubsubTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicyResolution
 */
export enum FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicyResolve
 */
export enum FunctionSpecForProviderEventTriggerServiceAccountEmailRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicyResolution
 */
export enum FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicyResolve
 */
export enum FunctionSpecForProviderEventTriggerServiceAccountEmailSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy
 */
export interface FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy(obj: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy
 */
export interface FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy(obj: FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicy
 */
export interface FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicy(obj: FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicy
 */
export interface FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicy(obj: FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicyResolution
 */
export enum FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicyResolve
 */
export enum FunctionSpecForProviderServiceConfigServiceAccountEmailRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicyResolution
 */
export enum FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicyResolve
 */
export enum FunctionSpecForProviderServiceConfigServiceAccountEmailSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicy
 */
export interface FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicy(obj: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy
 */
export interface FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy(obj: FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicy
 */
export interface FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicy(obj: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy
 */
export interface FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy(obj: FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicyResolution
 */
export enum FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicyResolve
 */
export enum FunctionSpecForProviderEventTriggerEventFiltersValueRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicyResolution
 */
export enum FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicyResolve
 */
export enum FunctionSpecForProviderEventTriggerEventFiltersValueSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolution
 */
export enum FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolve
 */
export enum FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolution
 */
export enum FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolve
 */
export enum FunctionSpecForProviderServiceConfigSecretEnvironmentVariablesSecretSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicyResolution
 */
export enum FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicyResolve
 */
export enum FunctionSpecForProviderServiceConfigSecretVolumesSecretRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicyResolution
 */
export enum FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicyResolve
 */
export enum FunctionSpecForProviderServiceConfigSecretVolumesSecretSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicyResolution
 */
export enum FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicyResolve
 */
export enum FunctionSpecForProviderBuildConfigSourceStorageSourceBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolution
 */
export enum FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolve
 */
export enum FunctionSpecForProviderBuildConfigSourceStorageSourceBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicyResolution
 */
export enum FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicyResolve
 */
export enum FunctionSpecForProviderBuildConfigSourceStorageSourceObjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolution
 */
export enum FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolve
 */
export enum FunctionSpecForProviderBuildConfigSourceStorageSourceObjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

