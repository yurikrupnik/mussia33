// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Association is the Schema for the Associations API. Provides a License Manager association resource.
 *
 * @schema Association
 */
export class Association extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Association"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'licensemanager.aws.upbound.io/v1beta1',
    kind: 'Association',
  }

  /**
   * Renders a Kubernetes manifest for "Association".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AssociationProps): any {
    return {
      ...Association.GVK,
      ...toJson_AssociationProps(props),
    };
  }

  /**
   * Defines a "Association" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AssociationProps) {
    super(scope, id, {
      ...Association.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Association.GVK,
      ...toJson_AssociationProps(resolved),
    };
  }
}

/**
 * Association is the Schema for the Associations API. Provides a License Manager association resource.
 *
 * @schema Association
 */
export interface AssociationProps {
  /**
   * @schema Association#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AssociationSpec defines the desired state of Association
   *
   * @schema Association#spec
   */
  readonly spec: AssociationSpec;

}

/**
 * Converts an object of type 'AssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationProps(obj: AssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AssociationSpec defines the desired state of Association
 *
 * @schema AssociationSpec
 */
export interface AssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: AssociationSpecDeletionPolicy;

  /**
   * @schema AssociationSpec#forProvider
   */
  readonly forProvider: AssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AssociationSpec#managementPolicy
   */
  readonly managementPolicy?: AssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: AssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AssociationSpec#providerRef
   */
  readonly providerRef?: AssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpec(obj: AssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AssociationSpecDeletionPolicy
 */
export enum AssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AssociationSpecForProvider
 */
export interface AssociationSpecForProvider {
  /**
   * ARN of the license configuration.
   *
   * @schema AssociationSpecForProvider#licenseConfigurationArn
   */
  readonly licenseConfigurationArn?: string;

  /**
   * Reference to a LicenseConfiguration to populate licenseConfigurationArn.
   *
   * @schema AssociationSpecForProvider#licenseConfigurationArnRef
   */
  readonly licenseConfigurationArnRef?: AssociationSpecForProviderLicenseConfigurationArnRef;

  /**
   * Selector for a LicenseConfiguration to populate licenseConfigurationArn.
   *
   * @schema AssociationSpecForProvider#licenseConfigurationArnSelector
   */
  readonly licenseConfigurationArnSelector?: AssociationSpecForProviderLicenseConfigurationArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of the resource associated with the license configuration.
   *
   * @schema AssociationSpecForProvider#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a Instance in ec2 to populate resourceArn.
   *
   * @schema AssociationSpecForProvider#resourceArnRef
   */
  readonly resourceArnRef?: AssociationSpecForProviderResourceArnRef;

  /**
   * Selector for a Instance in ec2 to populate resourceArn.
   *
   * @schema AssociationSpecForProvider#resourceArnSelector
   */
  readonly resourceArnSelector?: AssociationSpecForProviderResourceArnSelector;

}

/**
 * Converts an object of type 'AssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProvider(obj: AssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'licenseConfigurationArn': obj.licenseConfigurationArn,
    'licenseConfigurationArnRef': toJson_AssociationSpecForProviderLicenseConfigurationArnRef(obj.licenseConfigurationArnRef),
    'licenseConfigurationArnSelector': toJson_AssociationSpecForProviderLicenseConfigurationArnSelector(obj.licenseConfigurationArnSelector),
    'region': obj.region,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_AssociationSpecForProviderResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_AssociationSpecForProviderResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AssociationSpecManagementPolicy
 */
export enum AssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AssociationSpecProviderConfigRef
 */
export interface AssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssociationSpecProviderConfigRef#policy
   */
  readonly policy?: AssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecProviderConfigRef(obj: AssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AssociationSpecProviderRef
 */
export interface AssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssociationSpecProviderRef#policy
   */
  readonly policy?: AssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecProviderRef(obj: AssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AssociationSpecPublishConnectionDetailsTo
 */
export interface AssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecPublishConnectionDetailsTo(obj: AssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AssociationSpecWriteConnectionSecretToRef
 */
export interface AssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecWriteConnectionSecretToRef(obj: AssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LicenseConfiguration to populate licenseConfigurationArn.
 *
 * @schema AssociationSpecForProviderLicenseConfigurationArnRef
 */
export interface AssociationSpecForProviderLicenseConfigurationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssociationSpecForProviderLicenseConfigurationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssociationSpecForProviderLicenseConfigurationArnRef#policy
   */
  readonly policy?: AssociationSpecForProviderLicenseConfigurationArnRefPolicy;

}

/**
 * Converts an object of type 'AssociationSpecForProviderLicenseConfigurationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderLicenseConfigurationArnRef(obj: AssociationSpecForProviderLicenseConfigurationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssociationSpecForProviderLicenseConfigurationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LicenseConfiguration to populate licenseConfigurationArn.
 *
 * @schema AssociationSpecForProviderLicenseConfigurationArnSelector
 */
export interface AssociationSpecForProviderLicenseConfigurationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AssociationSpecForProviderLicenseConfigurationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AssociationSpecForProviderLicenseConfigurationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AssociationSpecForProviderLicenseConfigurationArnSelector#policy
   */
  readonly policy?: AssociationSpecForProviderLicenseConfigurationArnSelectorPolicy;

}

/**
 * Converts an object of type 'AssociationSpecForProviderLicenseConfigurationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderLicenseConfigurationArnSelector(obj: AssociationSpecForProviderLicenseConfigurationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AssociationSpecForProviderLicenseConfigurationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in ec2 to populate resourceArn.
 *
 * @schema AssociationSpecForProviderResourceArnRef
 */
export interface AssociationSpecForProviderResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssociationSpecForProviderResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssociationSpecForProviderResourceArnRef#policy
   */
  readonly policy?: AssociationSpecForProviderResourceArnRefPolicy;

}

/**
 * Converts an object of type 'AssociationSpecForProviderResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderResourceArnRef(obj: AssociationSpecForProviderResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssociationSpecForProviderResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in ec2 to populate resourceArn.
 *
 * @schema AssociationSpecForProviderResourceArnSelector
 */
export interface AssociationSpecForProviderResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AssociationSpecForProviderResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AssociationSpecForProviderResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AssociationSpecForProviderResourceArnSelector#policy
   */
  readonly policy?: AssociationSpecForProviderResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'AssociationSpecForProviderResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderResourceArnSelector(obj: AssociationSpecForProviderResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AssociationSpecForProviderResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssociationSpecProviderConfigRefPolicy
 */
export interface AssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecProviderConfigRefPolicy(obj: AssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssociationSpecProviderRefPolicy
 */
export interface AssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecProviderRefPolicy(obj: AssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface AssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecPublishConnectionDetailsToConfigRef(obj: AssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AssociationSpecPublishConnectionDetailsToMetadata
 */
export interface AssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecPublishConnectionDetailsToMetadata(obj: AssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssociationSpecForProviderLicenseConfigurationArnRefPolicy
 */
export interface AssociationSpecForProviderLicenseConfigurationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecForProviderLicenseConfigurationArnRefPolicy#resolution
   */
  readonly resolution?: AssociationSpecForProviderLicenseConfigurationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecForProviderLicenseConfigurationArnRefPolicy#resolve
   */
  readonly resolve?: AssociationSpecForProviderLicenseConfigurationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecForProviderLicenseConfigurationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderLicenseConfigurationArnRefPolicy(obj: AssociationSpecForProviderLicenseConfigurationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AssociationSpecForProviderLicenseConfigurationArnSelectorPolicy
 */
export interface AssociationSpecForProviderLicenseConfigurationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecForProviderLicenseConfigurationArnSelectorPolicy#resolution
   */
  readonly resolution?: AssociationSpecForProviderLicenseConfigurationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecForProviderLicenseConfigurationArnSelectorPolicy#resolve
   */
  readonly resolve?: AssociationSpecForProviderLicenseConfigurationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecForProviderLicenseConfigurationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderLicenseConfigurationArnSelectorPolicy(obj: AssociationSpecForProviderLicenseConfigurationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssociationSpecForProviderResourceArnRefPolicy
 */
export interface AssociationSpecForProviderResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecForProviderResourceArnRefPolicy#resolution
   */
  readonly resolution?: AssociationSpecForProviderResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecForProviderResourceArnRefPolicy#resolve
   */
  readonly resolve?: AssociationSpecForProviderResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecForProviderResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderResourceArnRefPolicy(obj: AssociationSpecForProviderResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AssociationSpecForProviderResourceArnSelectorPolicy
 */
export interface AssociationSpecForProviderResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecForProviderResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: AssociationSpecForProviderResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecForProviderResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: AssociationSpecForProviderResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecForProviderResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderResourceArnSelectorPolicy(obj: AssociationSpecForProviderResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecProviderConfigRefPolicyResolution
 */
export enum AssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecProviderConfigRefPolicyResolve
 */
export enum AssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecProviderRefPolicyResolution
 */
export enum AssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecProviderRefPolicyResolve
 */
export enum AssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: AssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecForProviderLicenseConfigurationArnRefPolicyResolution
 */
export enum AssociationSpecForProviderLicenseConfigurationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecForProviderLicenseConfigurationArnRefPolicyResolve
 */
export enum AssociationSpecForProviderLicenseConfigurationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecForProviderLicenseConfigurationArnSelectorPolicyResolution
 */
export enum AssociationSpecForProviderLicenseConfigurationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecForProviderLicenseConfigurationArnSelectorPolicyResolve
 */
export enum AssociationSpecForProviderLicenseConfigurationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecForProviderResourceArnRefPolicyResolution
 */
export enum AssociationSpecForProviderResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecForProviderResourceArnRefPolicyResolve
 */
export enum AssociationSpecForProviderResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecForProviderResourceArnSelectorPolicyResolution
 */
export enum AssociationSpecForProviderResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecForProviderResourceArnSelectorPolicyResolve
 */
export enum AssociationSpecForProviderResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LicenseConfiguration is the Schema for the LicenseConfigurations API. Provides a License Manager license configuration resource.
 *
 * @schema LicenseConfiguration
 */
export class LicenseConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LicenseConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'licensemanager.aws.upbound.io/v1beta1',
    kind: 'LicenseConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "LicenseConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LicenseConfigurationProps): any {
    return {
      ...LicenseConfiguration.GVK,
      ...toJson_LicenseConfigurationProps(props),
    };
  }

  /**
   * Defines a "LicenseConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LicenseConfigurationProps) {
    super(scope, id, {
      ...LicenseConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LicenseConfiguration.GVK,
      ...toJson_LicenseConfigurationProps(resolved),
    };
  }
}

/**
 * LicenseConfiguration is the Schema for the LicenseConfigurations API. Provides a License Manager license configuration resource.
 *
 * @schema LicenseConfiguration
 */
export interface LicenseConfigurationProps {
  /**
   * @schema LicenseConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LicenseConfigurationSpec defines the desired state of LicenseConfiguration
   *
   * @schema LicenseConfiguration#spec
   */
  readonly spec: LicenseConfigurationSpec;

}

/**
 * Converts an object of type 'LicenseConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationProps(obj: LicenseConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LicenseConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LicenseConfigurationSpec defines the desired state of LicenseConfiguration
 *
 * @schema LicenseConfigurationSpec
 */
export interface LicenseConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LicenseConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: LicenseConfigurationSpecDeletionPolicy;

  /**
   * @schema LicenseConfigurationSpec#forProvider
   */
  readonly forProvider: LicenseConfigurationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LicenseConfigurationSpec#managementPolicy
   */
  readonly managementPolicy?: LicenseConfigurationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LicenseConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: LicenseConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LicenseConfigurationSpec#providerRef
   */
  readonly providerRef?: LicenseConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LicenseConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LicenseConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LicenseConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LicenseConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LicenseConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpec(obj: LicenseConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LicenseConfigurationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LicenseConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LicenseConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LicenseConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LicenseConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LicenseConfigurationSpecDeletionPolicy
 */
export enum LicenseConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LicenseConfigurationSpecForProvider
 */
export interface LicenseConfigurationSpecForProvider {
  /**
   * Description of the license configuration.
   *
   * @schema LicenseConfigurationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Number of licenses managed by the license configuration.
   *
   * @schema LicenseConfigurationSpecForProvider#licenseCount
   */
  readonly licenseCount?: number;

  /**
   * Sets the number of available licenses as a hard limit.
   *
   * @schema LicenseConfigurationSpecForProvider#licenseCountHardLimit
   */
  readonly licenseCountHardLimit?: boolean;

  /**
   * Dimension to use to track license inventory. Specify either vCPU, Instance, Core or Socket.
   *
   * @schema LicenseConfigurationSpecForProvider#licenseCountingType
   */
  readonly licenseCountingType?: string;

  /**
   * Array of configured License Manager rules.
   *
   * @schema LicenseConfigurationSpecForProvider#licenseRules
   */
  readonly licenseRules?: string[];

  /**
   * Name of the license configuration.
   *
   * @schema LicenseConfigurationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LicenseConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LicenseConfigurationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LicenseConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpecForProvider(obj: LicenseConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'licenseCount': obj.licenseCount,
    'licenseCountHardLimit': obj.licenseCountHardLimit,
    'licenseCountingType': obj.licenseCountingType,
    'licenseRules': obj.licenseRules?.map(y => y),
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LicenseConfigurationSpecManagementPolicy
 */
export enum LicenseConfigurationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LicenseConfigurationSpecProviderConfigRef
 */
export interface LicenseConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LicenseConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LicenseConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: LicenseConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LicenseConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpecProviderConfigRef(obj: LicenseConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LicenseConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LicenseConfigurationSpecProviderRef
 */
export interface LicenseConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LicenseConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LicenseConfigurationSpecProviderRef#policy
   */
  readonly policy?: LicenseConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LicenseConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpecProviderRef(obj: LicenseConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LicenseConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LicenseConfigurationSpecPublishConnectionDetailsTo
 */
export interface LicenseConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LicenseConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LicenseConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LicenseConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LicenseConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LicenseConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LicenseConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpecPublishConnectionDetailsTo(obj: LicenseConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LicenseConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LicenseConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LicenseConfigurationSpecWriteConnectionSecretToRef
 */
export interface LicenseConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LicenseConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LicenseConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LicenseConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpecWriteConnectionSecretToRef(obj: LicenseConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LicenseConfigurationSpecProviderConfigRefPolicy
 */
export interface LicenseConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LicenseConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LicenseConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LicenseConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LicenseConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LicenseConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpecProviderConfigRefPolicy(obj: LicenseConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LicenseConfigurationSpecProviderRefPolicy
 */
export interface LicenseConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LicenseConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LicenseConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LicenseConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LicenseConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LicenseConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpecProviderRefPolicy(obj: LicenseConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LicenseConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface LicenseConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LicenseConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LicenseConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LicenseConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpecPublishConnectionDetailsToConfigRef(obj: LicenseConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LicenseConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface LicenseConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LicenseConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LicenseConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LicenseConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LicenseConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpecPublishConnectionDetailsToMetadata(obj: LicenseConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LicenseConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum LicenseConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LicenseConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum LicenseConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LicenseConfigurationSpecProviderRefPolicyResolution
 */
export enum LicenseConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LicenseConfigurationSpecProviderRefPolicyResolve
 */
export enum LicenseConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LicenseConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

