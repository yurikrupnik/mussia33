// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * GatewayRoute is the Schema for the GatewayRoutes API. Provides an AWS App Mesh gateway route resource.
 *
 * @schema GatewayRoute
 */
export class GatewayRoute extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GatewayRoute"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appmesh.aws.upbound.io/v1beta1',
    kind: 'GatewayRoute',
  }

  /**
   * Renders a Kubernetes manifest for "GatewayRoute".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GatewayRouteProps): any {
    return {
      ...GatewayRoute.GVK,
      ...toJson_GatewayRouteProps(props),
    };
  }

  /**
   * Defines a "GatewayRoute" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GatewayRouteProps) {
    super(scope, id, {
      ...GatewayRoute.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GatewayRoute.GVK,
      ...toJson_GatewayRouteProps(resolved),
    };
  }
}

/**
 * GatewayRoute is the Schema for the GatewayRoutes API. Provides an AWS App Mesh gateway route resource.
 *
 * @schema GatewayRoute
 */
export interface GatewayRouteProps {
  /**
   * @schema GatewayRoute#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GatewayRouteSpec defines the desired state of GatewayRoute
   *
   * @schema GatewayRoute#spec
   */
  readonly spec: GatewayRouteSpec;

}

/**
 * Converts an object of type 'GatewayRouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteProps(obj: GatewayRouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GatewayRouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayRouteSpec defines the desired state of GatewayRoute
 *
 * @schema GatewayRouteSpec
 */
export interface GatewayRouteSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GatewayRouteSpec#deletionPolicy
   */
  readonly deletionPolicy?: GatewayRouteSpecDeletionPolicy;

  /**
   * @schema GatewayRouteSpec#forProvider
   */
  readonly forProvider: GatewayRouteSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema GatewayRouteSpec#initProvider
   */
  readonly initProvider?: GatewayRouteSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GatewayRouteSpec#managementPolicies
   */
  readonly managementPolicies?: GatewayRouteSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GatewayRouteSpec#providerConfigRef
   */
  readonly providerConfigRef?: GatewayRouteSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GatewayRouteSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GatewayRouteSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GatewayRouteSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GatewayRouteSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GatewayRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpec(obj: GatewayRouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GatewayRouteSpecForProvider(obj.forProvider),
    'initProvider': toJson_GatewayRouteSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GatewayRouteSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GatewayRouteSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GatewayRouteSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GatewayRouteSpecDeletionPolicy
 */
export enum GatewayRouteSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GatewayRouteSpecForProvider
 */
export interface GatewayRouteSpecForProvider {
  /**
   * Name of the service mesh in which to create the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecForProvider#meshName
   */
  readonly meshName?: string;

  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema GatewayRouteSpecForProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GatewayRouteSpecForProvider#region
   */
  readonly region: string;

  /**
   * Gateway route specification to apply.
   *
   * @schema GatewayRouteSpecForProvider#spec
   */
  readonly spec?: GatewayRouteSpecForProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema GatewayRouteSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Name of the virtual gateway to associate the gateway route with. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecForProvider#virtualGatewayName
   */
  readonly virtualGatewayName?: string;

  /**
   * Reference to a VirtualGateway in appmesh to populate virtualGatewayName.
   *
   * @schema GatewayRouteSpecForProvider#virtualGatewayNameRef
   */
  readonly virtualGatewayNameRef?: GatewayRouteSpecForProviderVirtualGatewayNameRef;

  /**
   * Selector for a VirtualGateway in appmesh to populate virtualGatewayName.
   *
   * @schema GatewayRouteSpecForProvider#virtualGatewayNameSelector
   */
  readonly virtualGatewayNameSelector?: GatewayRouteSpecForProviderVirtualGatewayNameSelector;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProvider(obj: GatewayRouteSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshName': obj.meshName,
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'region': obj.region,
    'spec': obj.spec?.map(y => toJson_GatewayRouteSpecForProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'virtualGatewayName': obj.virtualGatewayName,
    'virtualGatewayNameRef': toJson_GatewayRouteSpecForProviderVirtualGatewayNameRef(obj.virtualGatewayNameRef),
    'virtualGatewayNameSelector': toJson_GatewayRouteSpecForProviderVirtualGatewayNameSelector(obj.virtualGatewayNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema GatewayRouteSpecInitProvider
 */
export interface GatewayRouteSpecInitProvider {
  /**
   * Name of the service mesh in which to create the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecInitProvider#meshName
   */
  readonly meshName?: string;

  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema GatewayRouteSpecInitProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Gateway route specification to apply.
   *
   * @schema GatewayRouteSpecInitProvider#spec
   */
  readonly spec?: GatewayRouteSpecInitProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema GatewayRouteSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProvider(obj: GatewayRouteSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshName': obj.meshName,
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'spec': obj.spec?.map(y => toJson_GatewayRouteSpecInitProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GatewayRouteSpecManagementPolicies
 */
export enum GatewayRouteSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GatewayRouteSpecProviderConfigRef
 */
export interface GatewayRouteSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayRouteSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayRouteSpecProviderConfigRef#policy
   */
  readonly policy?: GatewayRouteSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewayRouteSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecProviderConfigRef(obj: GatewayRouteSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayRouteSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GatewayRouteSpecPublishConnectionDetailsTo
 */
export interface GatewayRouteSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GatewayRouteSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GatewayRouteSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GatewayRouteSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GatewayRouteSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GatewayRouteSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecPublishConnectionDetailsTo(obj: GatewayRouteSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GatewayRouteSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GatewayRouteSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GatewayRouteSpecWriteConnectionSecretToRef
 */
export interface GatewayRouteSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GatewayRouteSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GatewayRouteSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecWriteConnectionSecretToRef(obj: GatewayRouteSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpec
 */
export interface GatewayRouteSpecForProviderSpec {
  /**
   * Specification of a gRPC gateway route.
   *
   * @schema GatewayRouteSpecForProviderSpec#grpcRoute
   */
  readonly grpcRoute?: GatewayRouteSpecForProviderSpecGrpcRoute[];

  /**
   * Specification of an HTTP/2 gateway route.
   *
   * @schema GatewayRouteSpecForProviderSpec#http2Route
   */
  readonly http2Route?: GatewayRouteSpecForProviderSpecHttp2Route[];

  /**
   * Specification of an HTTP gateway route.
   *
   * @schema GatewayRouteSpecForProviderSpec#httpRoute
   */
  readonly httpRoute?: GatewayRouteSpecForProviderSpecHttpRoute[];

  /**
   * Priority for the gateway route, between 0 and 1000.
   *
   * @schema GatewayRouteSpecForProviderSpec#priority
   */
  readonly priority?: number;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpec(obj: GatewayRouteSpecForProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcRoute': obj.grpcRoute?.map(y => toJson_GatewayRouteSpecForProviderSpecGrpcRoute(y)),
    'http2Route': obj.http2Route?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2Route(y)),
    'httpRoute': obj.httpRoute?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRoute(y)),
    'priority': obj.priority,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VirtualGateway in appmesh to populate virtualGatewayName.
 *
 * @schema GatewayRouteSpecForProviderVirtualGatewayNameRef
 */
export interface GatewayRouteSpecForProviderVirtualGatewayNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayRouteSpecForProviderVirtualGatewayNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayRouteSpecForProviderVirtualGatewayNameRef#policy
   */
  readonly policy?: GatewayRouteSpecForProviderVirtualGatewayNameRefPolicy;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderVirtualGatewayNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderVirtualGatewayNameRef(obj: GatewayRouteSpecForProviderVirtualGatewayNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayRouteSpecForProviderVirtualGatewayNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VirtualGateway in appmesh to populate virtualGatewayName.
 *
 * @schema GatewayRouteSpecForProviderVirtualGatewayNameSelector
 */
export interface GatewayRouteSpecForProviderVirtualGatewayNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GatewayRouteSpecForProviderVirtualGatewayNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GatewayRouteSpecForProviderVirtualGatewayNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GatewayRouteSpecForProviderVirtualGatewayNameSelector#policy
   */
  readonly policy?: GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicy;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderVirtualGatewayNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderVirtualGatewayNameSelector(obj: GatewayRouteSpecForProviderVirtualGatewayNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpec
 */
export interface GatewayRouteSpecInitProviderSpec {
  /**
   * Specification of a gRPC gateway route.
   *
   * @schema GatewayRouteSpecInitProviderSpec#grpcRoute
   */
  readonly grpcRoute?: GatewayRouteSpecInitProviderSpecGrpcRoute[];

  /**
   * Specification of an HTTP/2 gateway route.
   *
   * @schema GatewayRouteSpecInitProviderSpec#http2Route
   */
  readonly http2Route?: GatewayRouteSpecInitProviderSpecHttp2Route[];

  /**
   * Specification of an HTTP gateway route.
   *
   * @schema GatewayRouteSpecInitProviderSpec#httpRoute
   */
  readonly httpRoute?: GatewayRouteSpecInitProviderSpecHttpRoute[];

  /**
   * Priority for the gateway route, between 0 and 1000.
   *
   * @schema GatewayRouteSpecInitProviderSpec#priority
   */
  readonly priority?: number;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpec(obj: GatewayRouteSpecInitProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcRoute': obj.grpcRoute?.map(y => toJson_GatewayRouteSpecInitProviderSpecGrpcRoute(y)),
    'http2Route': obj.http2Route?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2Route(y)),
    'httpRoute': obj.httpRoute?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRoute(y)),
    'priority': obj.priority,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayRouteSpecProviderConfigRefPolicy
 */
export interface GatewayRouteSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayRouteSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GatewayRouteSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayRouteSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GatewayRouteSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayRouteSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecProviderConfigRefPolicy(obj: GatewayRouteSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GatewayRouteSpecPublishConnectionDetailsToConfigRef
 */
export interface GatewayRouteSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayRouteSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayRouteSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewayRouteSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecPublishConnectionDetailsToConfigRef(obj: GatewayRouteSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GatewayRouteSpecPublishConnectionDetailsToMetadata
 */
export interface GatewayRouteSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewayRouteSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewayRouteSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GatewayRouteSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecPublishConnectionDetailsToMetadata(obj: GatewayRouteSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecGrpcRoute
 */
export interface GatewayRouteSpecForProviderSpecGrpcRoute {
  /**
   * Action to take if a match is determined.
   *
   * @schema GatewayRouteSpecForProviderSpecGrpcRoute#action
   */
  readonly action?: GatewayRouteSpecForProviderSpecGrpcRouteAction[];

  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecForProviderSpecGrpcRoute#match
   */
  readonly match?: GatewayRouteSpecForProviderSpecGrpcRouteMatch[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecGrpcRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecGrpcRoute(obj: GatewayRouteSpecForProviderSpecGrpcRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_GatewayRouteSpecForProviderSpecGrpcRouteAction(y)),
    'match': obj.match?.map(y => toJson_GatewayRouteSpecForProviderSpecGrpcRouteMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2Route
 */
export interface GatewayRouteSpecForProviderSpecHttp2Route {
  /**
   * Action to take if a match is determined.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2Route#action
   */
  readonly action?: GatewayRouteSpecForProviderSpecHttp2RouteAction[];

  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2Route#match
   */
  readonly match?: GatewayRouteSpecForProviderSpecHttp2RouteMatch[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2Route' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2Route(obj: GatewayRouteSpecForProviderSpecHttp2Route | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteAction(y)),
    'match': obj.match?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRoute
 */
export interface GatewayRouteSpecForProviderSpecHttpRoute {
  /**
   * Action to take if a match is determined.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRoute#action
   */
  readonly action?: GatewayRouteSpecForProviderSpecHttpRouteAction[];

  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRoute#match
   */
  readonly match?: GatewayRouteSpecForProviderSpecHttpRouteMatch[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRoute(obj: GatewayRouteSpecForProviderSpecHttpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteAction(y)),
    'match': obj.match?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayRouteSpecForProviderVirtualGatewayNameRefPolicy
 */
export interface GatewayRouteSpecForProviderVirtualGatewayNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayRouteSpecForProviderVirtualGatewayNameRefPolicy#resolution
   */
  readonly resolution?: GatewayRouteSpecForProviderVirtualGatewayNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayRouteSpecForProviderVirtualGatewayNameRefPolicy#resolve
   */
  readonly resolve?: GatewayRouteSpecForProviderVirtualGatewayNameRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderVirtualGatewayNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderVirtualGatewayNameRefPolicy(obj: GatewayRouteSpecForProviderVirtualGatewayNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicy
 */
export interface GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicy#resolution
   */
  readonly resolution?: GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicy#resolve
   */
  readonly resolve?: GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicy(obj: GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecGrpcRoute
 */
export interface GatewayRouteSpecInitProviderSpecGrpcRoute {
  /**
   * Action to take if a match is determined.
   *
   * @schema GatewayRouteSpecInitProviderSpecGrpcRoute#action
   */
  readonly action?: GatewayRouteSpecInitProviderSpecGrpcRouteAction[];

  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecInitProviderSpecGrpcRoute#match
   */
  readonly match?: GatewayRouteSpecInitProviderSpecGrpcRouteMatch[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecGrpcRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecGrpcRoute(obj: GatewayRouteSpecInitProviderSpecGrpcRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_GatewayRouteSpecInitProviderSpecGrpcRouteAction(y)),
    'match': obj.match?.map(y => toJson_GatewayRouteSpecInitProviderSpecGrpcRouteMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2Route
 */
export interface GatewayRouteSpecInitProviderSpecHttp2Route {
  /**
   * Action to take if a match is determined.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2Route#action
   */
  readonly action?: GatewayRouteSpecInitProviderSpecHttp2RouteAction[];

  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2Route#match
   */
  readonly match?: GatewayRouteSpecInitProviderSpecHttp2RouteMatch[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2Route' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2Route(obj: GatewayRouteSpecInitProviderSpecHttp2Route | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteAction(y)),
    'match': obj.match?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRoute
 */
export interface GatewayRouteSpecInitProviderSpecHttpRoute {
  /**
   * Action to take if a match is determined.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRoute#action
   */
  readonly action?: GatewayRouteSpecInitProviderSpecHttpRouteAction[];

  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRoute#match
   */
  readonly match?: GatewayRouteSpecInitProviderSpecHttpRouteMatch[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRoute(obj: GatewayRouteSpecInitProviderSpecHttpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteAction(y)),
    'match': obj.match?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayRouteSpecProviderConfigRefPolicyResolution
 */
export enum GatewayRouteSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayRouteSpecProviderConfigRefPolicyResolve
 */
export enum GatewayRouteSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy(obj: GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecGrpcRouteAction
 */
export interface GatewayRouteSpecForProviderSpecGrpcRouteAction {
  /**
   * Target that traffic is routed to when a request matches the gateway route.
   *
   * @schema GatewayRouteSpecForProviderSpecGrpcRouteAction#target
   */
  readonly target?: GatewayRouteSpecForProviderSpecGrpcRouteActionTarget[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecGrpcRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecGrpcRouteAction(obj: GatewayRouteSpecForProviderSpecGrpcRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'target': obj.target?.map(y => toJson_GatewayRouteSpecForProviderSpecGrpcRouteActionTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecGrpcRouteMatch
 */
export interface GatewayRouteSpecForProviderSpecGrpcRouteMatch {
  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecForProviderSpecGrpcRouteMatch#port
   */
  readonly port?: number;

  /**
   * Fully qualified domain name for the service to match from the request.
   *
   * @schema GatewayRouteSpecForProviderSpecGrpcRouteMatch#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecGrpcRouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecGrpcRouteMatch(obj: GatewayRouteSpecForProviderSpecGrpcRouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteAction
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteAction {
  /**
   * Gateway route action to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteAction#rewrite
   */
  readonly rewrite?: GatewayRouteSpecForProviderSpecHttp2RouteActionRewrite[];

  /**
   * Target that traffic is routed to when a request matches the gateway route.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteAction#target
   */
  readonly target?: GatewayRouteSpecForProviderSpecHttp2RouteActionTarget[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteAction(obj: GatewayRouteSpecForProviderSpecHttp2RouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rewrite': obj.rewrite?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteActionRewrite(y)),
    'target': obj.target?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteActionTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatch
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteMatch {
  /**
   * Client request headers to match on.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatch#header
   */
  readonly header?: GatewayRouteSpecForProviderSpecHttp2RouteMatchHeader[];

  /**
   * Host name to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatch#hostname
   */
  readonly hostname?: GatewayRouteSpecForProviderSpecHttp2RouteMatchHostname[];

  /**
   * Client request path to match on.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatch#path
   */
  readonly path?: GatewayRouteSpecForProviderSpecHttp2RouteMatchPath[];

  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatch#port
   */
  readonly port?: number;

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Client request query parameters to match on.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatch#queryParameter
   */
  readonly queryParameter?: GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameter[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatch(obj: GatewayRouteSpecForProviderSpecHttp2RouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchHeader(y)),
    'hostname': obj.hostname?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchHostname(y)),
    'path': obj.path?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchPath(y)),
    'port': obj.port,
    'prefix': obj.prefix,
    'queryParameter': obj.queryParameter?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteAction
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteAction {
  /**
   * Gateway route action to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteAction#rewrite
   */
  readonly rewrite?: GatewayRouteSpecForProviderSpecHttpRouteActionRewrite[];

  /**
   * Target that traffic is routed to when a request matches the gateway route.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteAction#target
   */
  readonly target?: GatewayRouteSpecForProviderSpecHttpRouteActionTarget[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteAction(obj: GatewayRouteSpecForProviderSpecHttpRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rewrite': obj.rewrite?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteActionRewrite(y)),
    'target': obj.target?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteMatch
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteMatch {
  /**
   * Client request headers to match on.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatch#header
   */
  readonly header?: GatewayRouteSpecForProviderSpecHttpRouteMatchHeader[];

  /**
   * Host name to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatch#hostname
   */
  readonly hostname?: GatewayRouteSpecForProviderSpecHttpRouteMatchHostname[];

  /**
   * Client request path to match on.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatch#path
   */
  readonly path?: GatewayRouteSpecForProviderSpecHttpRouteMatchPath[];

  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatch#port
   */
  readonly port?: number;

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Client request query parameters to match on.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatch#queryParameter
   */
  readonly queryParameter?: GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameter[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteMatch(obj: GatewayRouteSpecForProviderSpecHttpRouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchHeader(y)),
    'hostname': obj.hostname?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchHostname(y)),
    'path': obj.path?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchPath(y)),
    'port': obj.port,
    'prefix': obj.prefix,
    'queryParameter': obj.queryParameter?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayRouteSpecForProviderVirtualGatewayNameRefPolicyResolution
 */
export enum GatewayRouteSpecForProviderVirtualGatewayNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayRouteSpecForProviderVirtualGatewayNameRefPolicyResolve
 */
export enum GatewayRouteSpecForProviderVirtualGatewayNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicyResolution
 */
export enum GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicyResolve
 */
export enum GatewayRouteSpecForProviderVirtualGatewayNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema GatewayRouteSpecInitProviderSpecGrpcRouteAction
 */
export interface GatewayRouteSpecInitProviderSpecGrpcRouteAction {
  /**
   * Target that traffic is routed to when a request matches the gateway route.
   *
   * @schema GatewayRouteSpecInitProviderSpecGrpcRouteAction#target
   */
  readonly target?: GatewayRouteSpecInitProviderSpecGrpcRouteActionTarget[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecGrpcRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecGrpcRouteAction(obj: GatewayRouteSpecInitProviderSpecGrpcRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'target': obj.target?.map(y => toJson_GatewayRouteSpecInitProviderSpecGrpcRouteActionTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecGrpcRouteMatch
 */
export interface GatewayRouteSpecInitProviderSpecGrpcRouteMatch {
  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecInitProviderSpecGrpcRouteMatch#port
   */
  readonly port?: number;

  /**
   * Fully qualified domain name for the service to match from the request.
   *
   * @schema GatewayRouteSpecInitProviderSpecGrpcRouteMatch#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecGrpcRouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecGrpcRouteMatch(obj: GatewayRouteSpecInitProviderSpecGrpcRouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteAction
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteAction {
  /**
   * Gateway route action to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteAction#rewrite
   */
  readonly rewrite?: GatewayRouteSpecInitProviderSpecHttp2RouteActionRewrite[];

  /**
   * Target that traffic is routed to when a request matches the gateway route.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteAction#target
   */
  readonly target?: GatewayRouteSpecInitProviderSpecHttp2RouteActionTarget[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteAction(obj: GatewayRouteSpecInitProviderSpecHttp2RouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rewrite': obj.rewrite?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteActionRewrite(y)),
    'target': obj.target?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteActionTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatch
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteMatch {
  /**
   * Client request headers to match on.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatch#header
   */
  readonly header?: GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeader[];

  /**
   * Host name to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatch#hostname
   */
  readonly hostname?: GatewayRouteSpecInitProviderSpecHttp2RouteMatchHostname[];

  /**
   * Client request path to match on.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatch#path
   */
  readonly path?: GatewayRouteSpecInitProviderSpecHttp2RouteMatchPath[];

  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatch#port
   */
  readonly port?: number;

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Client request query parameters to match on.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatch#queryParameter
   */
  readonly queryParameter?: GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameter[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatch(obj: GatewayRouteSpecInitProviderSpecHttp2RouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeader(y)),
    'hostname': obj.hostname?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchHostname(y)),
    'path': obj.path?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchPath(y)),
    'port': obj.port,
    'prefix': obj.prefix,
    'queryParameter': obj.queryParameter?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteAction
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteAction {
  /**
   * Gateway route action to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteAction#rewrite
   */
  readonly rewrite?: GatewayRouteSpecInitProviderSpecHttpRouteActionRewrite[];

  /**
   * Target that traffic is routed to when a request matches the gateway route.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteAction#target
   */
  readonly target?: GatewayRouteSpecInitProviderSpecHttpRouteActionTarget[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteAction(obj: GatewayRouteSpecInitProviderSpecHttpRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rewrite': obj.rewrite?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteActionRewrite(y)),
    'target': obj.target?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteActionTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatch
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteMatch {
  /**
   * Client request headers to match on.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatch#header
   */
  readonly header?: GatewayRouteSpecInitProviderSpecHttpRouteMatchHeader[];

  /**
   * Host name to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatch#hostname
   */
  readonly hostname?: GatewayRouteSpecInitProviderSpecHttpRouteMatchHostname[];

  /**
   * Client request path to match on.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatch#path
   */
  readonly path?: GatewayRouteSpecInitProviderSpecHttpRouteMatchPath[];

  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatch#port
   */
  readonly port?: number;

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Client request query parameters to match on.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatch#queryParameter
   */
  readonly queryParameter?: GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameter[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatch(obj: GatewayRouteSpecInitProviderSpecHttpRouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchHeader(y)),
    'hostname': obj.hostname?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchHostname(y)),
    'path': obj.path?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchPath(y)),
    'port': obj.port,
    'prefix': obj.prefix,
    'queryParameter': obj.queryParameter?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GatewayRouteSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema GatewayRouteSpecForProviderSpecGrpcRouteActionTarget
 */
export interface GatewayRouteSpecForProviderSpecGrpcRouteActionTarget {
  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecForProviderSpecGrpcRouteActionTarget#port
   */
  readonly port?: number;

  /**
   * Virtual service gateway route target.
   *
   * @schema GatewayRouteSpecForProviderSpecGrpcRouteActionTarget#virtualService
   */
  readonly virtualService?: GatewayRouteSpecForProviderSpecGrpcRouteActionTargetVirtualService[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecGrpcRouteActionTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecGrpcRouteActionTarget(obj: GatewayRouteSpecForProviderSpecGrpcRouteActionTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualService': obj.virtualService?.map(y => toJson_GatewayRouteSpecForProviderSpecGrpcRouteActionTargetVirtualService(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionRewrite
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteActionRewrite {
  /**
   * Host name to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionRewrite#hostname
   */
  readonly hostname?: GatewayRouteSpecForProviderSpecHttp2RouteActionRewriteHostname[];

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionRewrite#prefix
   */
  readonly prefix?: GatewayRouteSpecForProviderSpecHttp2RouteActionRewritePrefix[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteActionRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteActionRewrite(obj: GatewayRouteSpecForProviderSpecHttp2RouteActionRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteActionRewriteHostname(y)),
    'prefix': obj.prefix?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteActionRewritePrefix(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionTarget
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteActionTarget {
  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionTarget#port
   */
  readonly port?: number;

  /**
   * Virtual service gateway route target.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionTarget#virtualService
   */
  readonly virtualService?: GatewayRouteSpecForProviderSpecHttp2RouteActionTargetVirtualService[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteActionTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteActionTarget(obj: GatewayRouteSpecForProviderSpecHttp2RouteActionTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualService': obj.virtualService?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteActionTargetVirtualService(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeader
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteMatchHeader {
  /**
   * If true, the match is on the opposite of the match method and value. Default is false.
   *
   * @default false.
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeader#invert
   */
  readonly invert?: boolean;

  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeader#match
   */
  readonly match?: GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch[];

  /**
   * Name to use for the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeader#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteMatchHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchHeader(obj: GatewayRouteSpecForProviderSpecHttp2RouteMatchHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'match': obj.match?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHostname
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteMatchHostname {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHostname#exact
   */
  readonly exact?: string;

  /**
   * Header value sent by the client must end with the specified characters.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHostname#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteMatchHostname' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchHostname(obj: GatewayRouteSpecForProviderSpecHttp2RouteMatchHostname | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchPath
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteMatchPath {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchPath#exact
   */
  readonly exact?: string;

  /**
   * Header value sent by the client must include the specified characters.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchPath#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteMatchPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchPath(obj: GatewayRouteSpecForProviderSpecHttp2RouteMatchPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameter
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameter {
  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameter#match
   */
  readonly match?: GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch[];

  /**
   * Name to use for the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameter(obj: GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionRewrite
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteActionRewrite {
  /**
   * Host name to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionRewrite#hostname
   */
  readonly hostname?: GatewayRouteSpecForProviderSpecHttpRouteActionRewriteHostname[];

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionRewrite#prefix
   */
  readonly prefix?: GatewayRouteSpecForProviderSpecHttpRouteActionRewritePrefix[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteActionRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteActionRewrite(obj: GatewayRouteSpecForProviderSpecHttpRouteActionRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteActionRewriteHostname(y)),
    'prefix': obj.prefix?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteActionRewritePrefix(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTarget
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteActionTarget {
  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTarget#port
   */
  readonly port?: number;

  /**
   * Virtual service gateway route target.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTarget#virtualService
   */
  readonly virtualService?: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualService[];

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteActionTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTarget(obj: GatewayRouteSpecForProviderSpecHttpRouteActionTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualService': obj.virtualService?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualService(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeader
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteMatchHeader {
  /**
   * If true, the match is on the opposite of the match method and value. Default is false.
   *
   * @default false.
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeader#invert
   */
  readonly invert?: boolean;

  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeader#match
   */
  readonly match?: GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch[];

  /**
   * Name to use for the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeader#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteMatchHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchHeader(obj: GatewayRouteSpecForProviderSpecHttpRouteMatchHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'match': obj.match?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHostname
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteMatchHostname {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHostname#exact
   */
  readonly exact?: string;

  /**
   * Header value sent by the client must end with the specified characters.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHostname#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteMatchHostname' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchHostname(obj: GatewayRouteSpecForProviderSpecHttpRouteMatchHostname | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchPath
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteMatchPath {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchPath#exact
   */
  readonly exact?: string;

  /**
   * Header value sent by the client must include the specified characters.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchPath#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteMatchPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchPath(obj: GatewayRouteSpecForProviderSpecHttpRouteMatchPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameter
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameter {
  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameter#match
   */
  readonly match?: GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch[];

  /**
   * Name to use for the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameter(obj: GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecGrpcRouteActionTarget
 */
export interface GatewayRouteSpecInitProviderSpecGrpcRouteActionTarget {
  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecInitProviderSpecGrpcRouteActionTarget#port
   */
  readonly port?: number;

  /**
   * Virtual service gateway route target.
   *
   * @schema GatewayRouteSpecInitProviderSpecGrpcRouteActionTarget#virtualService
   */
  readonly virtualService?: GatewayRouteSpecInitProviderSpecGrpcRouteActionTargetVirtualService[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecGrpcRouteActionTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecGrpcRouteActionTarget(obj: GatewayRouteSpecInitProviderSpecGrpcRouteActionTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualService': obj.virtualService?.map(y => toJson_GatewayRouteSpecInitProviderSpecGrpcRouteActionTargetVirtualService(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionRewrite
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteActionRewrite {
  /**
   * Host name to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionRewrite#hostname
   */
  readonly hostname?: GatewayRouteSpecInitProviderSpecHttp2RouteActionRewriteHostname[];

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionRewrite#prefix
   */
  readonly prefix?: GatewayRouteSpecInitProviderSpecHttp2RouteActionRewritePrefix[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteActionRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteActionRewrite(obj: GatewayRouteSpecInitProviderSpecHttp2RouteActionRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteActionRewriteHostname(y)),
    'prefix': obj.prefix?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteActionRewritePrefix(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionTarget
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteActionTarget {
  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionTarget#port
   */
  readonly port?: number;

  /**
   * Virtual service gateway route target.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionTarget#virtualService
   */
  readonly virtualService?: GatewayRouteSpecInitProviderSpecHttp2RouteActionTargetVirtualService[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteActionTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteActionTarget(obj: GatewayRouteSpecInitProviderSpecHttp2RouteActionTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualService': obj.virtualService?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteActionTargetVirtualService(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeader
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeader {
  /**
   * If true, the match is on the opposite of the match method and value. Default is false.
   *
   * @default false.
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeader#invert
   */
  readonly invert?: boolean;

  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeader#match
   */
  readonly match?: GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch[];

  /**
   * Name to use for the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeader#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeader(obj: GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'match': obj.match?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHostname
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteMatchHostname {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHostname#exact
   */
  readonly exact?: string;

  /**
   * Header value sent by the client must end with the specified characters.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHostname#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteMatchHostname' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchHostname(obj: GatewayRouteSpecInitProviderSpecHttp2RouteMatchHostname | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchPath
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteMatchPath {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchPath#exact
   */
  readonly exact?: string;

  /**
   * Header value sent by the client must include the specified characters.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchPath#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteMatchPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchPath(obj: GatewayRouteSpecInitProviderSpecHttp2RouteMatchPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameter
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameter {
  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameter#match
   */
  readonly match?: GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch[];

  /**
   * Name to use for the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameter(obj: GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionRewrite
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteActionRewrite {
  /**
   * Host name to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionRewrite#hostname
   */
  readonly hostname?: GatewayRouteSpecInitProviderSpecHttpRouteActionRewriteHostname[];

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionRewrite#prefix
   */
  readonly prefix?: GatewayRouteSpecInitProviderSpecHttpRouteActionRewritePrefix[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteActionRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteActionRewrite(obj: GatewayRouteSpecInitProviderSpecHttpRouteActionRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteActionRewriteHostname(y)),
    'prefix': obj.prefix?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteActionRewritePrefix(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionTarget
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteActionTarget {
  /**
   * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionTarget#port
   */
  readonly port?: number;

  /**
   * Virtual service gateway route target.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionTarget#virtualService
   */
  readonly virtualService?: any[];

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteActionTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteActionTarget(obj: GatewayRouteSpecInitProviderSpecHttpRouteActionTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualService': obj.virtualService?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeader
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteMatchHeader {
  /**
   * If true, the match is on the opposite of the match method and value. Default is false.
   *
   * @default false.
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeader#invert
   */
  readonly invert?: boolean;

  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeader#match
   */
  readonly match?: GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch[];

  /**
   * Name to use for the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeader#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteMatchHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchHeader(obj: GatewayRouteSpecInitProviderSpecHttpRouteMatchHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'match': obj.match?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHostname
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteMatchHostname {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHostname#exact
   */
  readonly exact?: string;

  /**
   * Header value sent by the client must end with the specified characters.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHostname#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteMatchHostname' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchHostname(obj: GatewayRouteSpecInitProviderSpecHttpRouteMatchHostname | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchPath
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteMatchPath {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchPath#exact
   */
  readonly exact?: string;

  /**
   * Header value sent by the client must include the specified characters.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchPath#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteMatchPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchPath(obj: GatewayRouteSpecInitProviderSpecHttpRouteMatchPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameter
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameter {
  /**
   * Criteria for determining a request match.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameter#match
   */
  readonly match?: GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch[];

  /**
   * Name to use for the gateway route. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameter(obj: GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecGrpcRouteActionTargetVirtualService
 */
export interface GatewayRouteSpecForProviderSpecGrpcRouteActionTargetVirtualService {
  /**
   * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecForProviderSpecGrpcRouteActionTargetVirtualService#virtualServiceName
   */
  readonly virtualServiceName?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecGrpcRouteActionTargetVirtualService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecGrpcRouteActionTargetVirtualService(obj: GatewayRouteSpecForProviderSpecGrpcRouteActionTargetVirtualService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualServiceName': obj.virtualServiceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionRewriteHostname
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteActionRewriteHostname {
  /**
   * Default target host name to write to. Valid values: ENABLED, DISABLED.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionRewriteHostname#defaultTargetHostname
   */
  readonly defaultTargetHostname?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteActionRewriteHostname' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteActionRewriteHostname(obj: GatewayRouteSpecForProviderSpecHttp2RouteActionRewriteHostname | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultTargetHostname': obj.defaultTargetHostname,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionRewritePrefix
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteActionRewritePrefix {
  /**
   * Default prefix used to replace the incoming route prefix when rewritten. Valid values: ENABLED, DISABLED.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionRewritePrefix#defaultPrefix
   */
  readonly defaultPrefix?: string;

  /**
   * Value used to replace the incoming route prefix when rewritten.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionRewritePrefix#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteActionRewritePrefix' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteActionRewritePrefix(obj: GatewayRouteSpecForProviderSpecHttp2RouteActionRewritePrefix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultPrefix': obj.defaultPrefix,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionTargetVirtualService
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteActionTargetVirtualService {
  /**
   * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteActionTargetVirtualService#virtualServiceName
   */
  readonly virtualServiceName?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteActionTargetVirtualService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteActionTargetVirtualService(obj: GatewayRouteSpecForProviderSpecHttp2RouteActionTargetVirtualService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualServiceName': obj.virtualServiceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch#exact
   */
  readonly exact?: string;

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Object that specifies the range of numbers that the header value sent by the client must be included in.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch#range
   */
  readonly range?: GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange[];

  /**
   * Header value sent by the client must include the specified characters.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch#regex
   */
  readonly regex?: string;

  /**
   * Header value sent by the client must end with the specified characters.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch(obj: GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'range': obj.range?.map(y => toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange(y)),
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch#exact
   */
  readonly exact?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch(obj: GatewayRouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionRewriteHostname
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteActionRewriteHostname {
  /**
   * Default target host name to write to. Valid values: ENABLED, DISABLED.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionRewriteHostname#defaultTargetHostname
   */
  readonly defaultTargetHostname?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteActionRewriteHostname' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteActionRewriteHostname(obj: GatewayRouteSpecForProviderSpecHttpRouteActionRewriteHostname | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultTargetHostname': obj.defaultTargetHostname,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionRewritePrefix
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteActionRewritePrefix {
  /**
   * Default prefix used to replace the incoming route prefix when rewritten. Valid values: ENABLED, DISABLED.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionRewritePrefix#defaultPrefix
   */
  readonly defaultPrefix?: string;

  /**
   * Value used to replace the incoming route prefix when rewritten.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionRewritePrefix#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteActionRewritePrefix' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteActionRewritePrefix(obj: GatewayRouteSpecForProviderSpecHttpRouteActionRewritePrefix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultPrefix': obj.defaultPrefix,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualService
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualService {
  /**
   * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualService#virtualServiceName
   */
  readonly virtualServiceName?: string;

  /**
   * Reference to a VirtualService in appmesh to populate virtualServiceName.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualService#virtualServiceNameRef
   */
  readonly virtualServiceNameRef?: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRef;

  /**
   * Selector for a VirtualService in appmesh to populate virtualServiceName.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualService#virtualServiceNameSelector
   */
  readonly virtualServiceNameSelector?: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelector;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualService(obj: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualServiceName': obj.virtualServiceName,
    'virtualServiceNameRef': toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRef(obj.virtualServiceNameRef),
    'virtualServiceNameSelector': toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelector(obj.virtualServiceNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch#exact
   */
  readonly exact?: string;

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Object that specifies the range of numbers that the header value sent by the client must be included in.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch#range
   */
  readonly range?: GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange[];

  /**
   * Header value sent by the client must include the specified characters.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch#regex
   */
  readonly regex?: string;

  /**
   * Header value sent by the client must end with the specified characters.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch(obj: GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'range': obj.range?.map(y => toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange(y)),
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch#exact
   */
  readonly exact?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch(obj: GatewayRouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecGrpcRouteActionTargetVirtualService
 */
export interface GatewayRouteSpecInitProviderSpecGrpcRouteActionTargetVirtualService {
  /**
   * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecInitProviderSpecGrpcRouteActionTargetVirtualService#virtualServiceName
   */
  readonly virtualServiceName?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecGrpcRouteActionTargetVirtualService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecGrpcRouteActionTargetVirtualService(obj: GatewayRouteSpecInitProviderSpecGrpcRouteActionTargetVirtualService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualServiceName': obj.virtualServiceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionRewriteHostname
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteActionRewriteHostname {
  /**
   * Default target host name to write to. Valid values: ENABLED, DISABLED.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionRewriteHostname#defaultTargetHostname
   */
  readonly defaultTargetHostname?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteActionRewriteHostname' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteActionRewriteHostname(obj: GatewayRouteSpecInitProviderSpecHttp2RouteActionRewriteHostname | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultTargetHostname': obj.defaultTargetHostname,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionRewritePrefix
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteActionRewritePrefix {
  /**
   * Default prefix used to replace the incoming route prefix when rewritten. Valid values: ENABLED, DISABLED.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionRewritePrefix#defaultPrefix
   */
  readonly defaultPrefix?: string;

  /**
   * Value used to replace the incoming route prefix when rewritten.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionRewritePrefix#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteActionRewritePrefix' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteActionRewritePrefix(obj: GatewayRouteSpecInitProviderSpecHttp2RouteActionRewritePrefix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultPrefix': obj.defaultPrefix,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionTargetVirtualService
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteActionTargetVirtualService {
  /**
   * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteActionTargetVirtualService#virtualServiceName
   */
  readonly virtualServiceName?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteActionTargetVirtualService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteActionTargetVirtualService(obj: GatewayRouteSpecInitProviderSpecHttp2RouteActionTargetVirtualService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualServiceName': obj.virtualServiceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch#exact
   */
  readonly exact?: string;

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Object that specifies the range of numbers that the header value sent by the client must be included in.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch#range
   */
  readonly range?: GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange[];

  /**
   * Header value sent by the client must include the specified characters.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch#regex
   */
  readonly regex?: string;

  /**
   * Header value sent by the client must end with the specified characters.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch(obj: GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'range': obj.range?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange(y)),
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch#exact
   */
  readonly exact?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch(obj: GatewayRouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionRewriteHostname
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteActionRewriteHostname {
  /**
   * Default target host name to write to. Valid values: ENABLED, DISABLED.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionRewriteHostname#defaultTargetHostname
   */
  readonly defaultTargetHostname?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteActionRewriteHostname' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteActionRewriteHostname(obj: GatewayRouteSpecInitProviderSpecHttpRouteActionRewriteHostname | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultTargetHostname': obj.defaultTargetHostname,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionRewritePrefix
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteActionRewritePrefix {
  /**
   * Default prefix used to replace the incoming route prefix when rewritten. Valid values: ENABLED, DISABLED.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionRewritePrefix#defaultPrefix
   */
  readonly defaultPrefix?: string;

  /**
   * Value used to replace the incoming route prefix when rewritten.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteActionRewritePrefix#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteActionRewritePrefix' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteActionRewritePrefix(obj: GatewayRouteSpecInitProviderSpecHttpRouteActionRewritePrefix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultPrefix': obj.defaultPrefix,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch#exact
   */
  readonly exact?: string;

  /**
   * Specified beginning characters to rewrite.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Object that specifies the range of numbers that the header value sent by the client must be included in.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch#range
   */
  readonly range?: GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange[];

  /**
   * Header value sent by the client must include the specified characters.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch#regex
   */
  readonly regex?: string;

  /**
   * Header value sent by the client must end with the specified characters.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch(obj: GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'range': obj.range?.map(y => toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange(y)),
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch {
  /**
   * Header value sent by the client must match the specified value exactly.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch#exact
   */
  readonly exact?: string;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch(obj: GatewayRouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange
 */
export interface GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange {
  /**
   * End of the range.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange#end
   */
  readonly end?: number;

  /**
   * (Requited) Start of the range.
   *
   * @schema GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange(obj: GatewayRouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VirtualService in appmesh to populate virtualServiceName.
 *
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRef
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRef#policy
   */
  readonly policy?: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicy;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRef(obj: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VirtualService in appmesh to populate virtualServiceName.
 *
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelector
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelector#policy
   */
  readonly policy?: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicy;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelector(obj: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange {
  /**
   * End of the range.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange#end
   */
  readonly end?: number;

  /**
   * (Requited) Start of the range.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange(obj: GatewayRouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange
 */
export interface GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange {
  /**
   * End of the range.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange#end
   */
  readonly end?: number;

  /**
   * (Requited) Start of the range.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange(obj: GatewayRouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange
 */
export interface GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange {
  /**
   * End of the range.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange#end
   */
  readonly end?: number;

  /**
   * (Requited) Start of the range.
   *
   * @schema GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange(obj: GatewayRouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicy
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicy#resolution
   */
  readonly resolution?: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicy#resolve
   */
  readonly resolve?: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicy(obj: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicy
 */
export interface GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicy#resolution
   */
  readonly resolution?: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicy#resolve
   */
  readonly resolve?: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicy(obj: GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicyResolution
 */
export enum GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicyResolve
 */
export enum GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicyResolution
 */
export enum GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicyResolve
 */
export enum GatewayRouteSpecForProviderSpecHttpRouteActionTargetVirtualServiceVirtualServiceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Mesh is the Schema for the Meshs API. Provides an AWS App Mesh service mesh resource.
 *
 * @schema Mesh
 */
export class Mesh extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Mesh"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appmesh.aws.upbound.io/v1beta1',
    kind: 'Mesh',
  }

  /**
   * Renders a Kubernetes manifest for "Mesh".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MeshProps): any {
    return {
      ...Mesh.GVK,
      ...toJson_MeshProps(props),
    };
  }

  /**
   * Defines a "Mesh" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MeshProps) {
    super(scope, id, {
      ...Mesh.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Mesh.GVK,
      ...toJson_MeshProps(resolved),
    };
  }
}

/**
 * Mesh is the Schema for the Meshs API. Provides an AWS App Mesh service mesh resource.
 *
 * @schema Mesh
 */
export interface MeshProps {
  /**
   * @schema Mesh#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MeshSpec defines the desired state of Mesh
   *
   * @schema Mesh#spec
   */
  readonly spec: MeshSpec;

}

/**
 * Converts an object of type 'MeshProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshProps(obj: MeshProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MeshSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MeshSpec defines the desired state of Mesh
 *
 * @schema MeshSpec
 */
export interface MeshSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MeshSpec#deletionPolicy
   */
  readonly deletionPolicy?: MeshSpecDeletionPolicy;

  /**
   * @schema MeshSpec#forProvider
   */
  readonly forProvider: MeshSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema MeshSpec#initProvider
   */
  readonly initProvider?: MeshSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema MeshSpec#managementPolicies
   */
  readonly managementPolicies?: MeshSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MeshSpec#providerConfigRef
   */
  readonly providerConfigRef?: MeshSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MeshSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MeshSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MeshSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MeshSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MeshSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpec(obj: MeshSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MeshSpecForProvider(obj.forProvider),
    'initProvider': toJson_MeshSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_MeshSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_MeshSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MeshSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MeshSpecDeletionPolicy
 */
export enum MeshSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MeshSpecForProvider
 */
export interface MeshSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MeshSpecForProvider#region
   */
  readonly region: string;

  /**
   * Service mesh specification to apply.
   *
   * @schema MeshSpecForProvider#spec
   */
  readonly spec?: MeshSpecForProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema MeshSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'MeshSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecForProvider(obj: MeshSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'spec': obj.spec?.map(y => toJson_MeshSpecForProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema MeshSpecInitProvider
 */
export interface MeshSpecInitProvider {
  /**
   * Service mesh specification to apply.
   *
   * @schema MeshSpecInitProvider#spec
   */
  readonly spec?: MeshSpecInitProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema MeshSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'MeshSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecInitProvider(obj: MeshSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'spec': obj.spec?.map(y => toJson_MeshSpecInitProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema MeshSpecManagementPolicies
 */
export enum MeshSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MeshSpecProviderConfigRef
 */
export interface MeshSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MeshSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MeshSpecProviderConfigRef#policy
   */
  readonly policy?: MeshSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MeshSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecProviderConfigRef(obj: MeshSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MeshSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MeshSpecPublishConnectionDetailsTo
 */
export interface MeshSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MeshSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MeshSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MeshSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MeshSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MeshSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MeshSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecPublishConnectionDetailsTo(obj: MeshSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MeshSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MeshSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MeshSpecWriteConnectionSecretToRef
 */
export interface MeshSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MeshSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MeshSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MeshSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecWriteConnectionSecretToRef(obj: MeshSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MeshSpecForProviderSpec
 */
export interface MeshSpecForProviderSpec {
  /**
   * Egress filter rules for the service mesh.
   *
   * @schema MeshSpecForProviderSpec#egressFilter
   */
  readonly egressFilter?: MeshSpecForProviderSpecEgressFilter[];

}

/**
 * Converts an object of type 'MeshSpecForProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecForProviderSpec(obj: MeshSpecForProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressFilter': obj.egressFilter?.map(y => toJson_MeshSpecForProviderSpecEgressFilter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MeshSpecInitProviderSpec
 */
export interface MeshSpecInitProviderSpec {
  /**
   * Egress filter rules for the service mesh.
   *
   * @schema MeshSpecInitProviderSpec#egressFilter
   */
  readonly egressFilter?: MeshSpecInitProviderSpecEgressFilter[];

}

/**
 * Converts an object of type 'MeshSpecInitProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecInitProviderSpec(obj: MeshSpecInitProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressFilter': obj.egressFilter?.map(y => toJson_MeshSpecInitProviderSpecEgressFilter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MeshSpecProviderConfigRefPolicy
 */
export interface MeshSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MeshSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MeshSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MeshSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MeshSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MeshSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecProviderConfigRefPolicy(obj: MeshSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MeshSpecPublishConnectionDetailsToConfigRef
 */
export interface MeshSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MeshSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MeshSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MeshSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MeshSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecPublishConnectionDetailsToConfigRef(obj: MeshSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MeshSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MeshSpecPublishConnectionDetailsToMetadata
 */
export interface MeshSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MeshSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MeshSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MeshSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MeshSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecPublishConnectionDetailsToMetadata(obj: MeshSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MeshSpecForProviderSpecEgressFilter
 */
export interface MeshSpecForProviderSpecEgressFilter {
  /**
   * Egress filter type. By default, the type is DROP_ALL. Valid values are ALLOW_ALL and DROP_ALL.
   *
   * @schema MeshSpecForProviderSpecEgressFilter#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MeshSpecForProviderSpecEgressFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecForProviderSpecEgressFilter(obj: MeshSpecForProviderSpecEgressFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MeshSpecInitProviderSpecEgressFilter
 */
export interface MeshSpecInitProviderSpecEgressFilter {
  /**
   * Egress filter type. By default, the type is DROP_ALL. Valid values are ALLOW_ALL and DROP_ALL.
   *
   * @schema MeshSpecInitProviderSpecEgressFilter#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MeshSpecInitProviderSpecEgressFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecInitProviderSpecEgressFilter(obj: MeshSpecInitProviderSpecEgressFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MeshSpecProviderConfigRefPolicyResolution
 */
export enum MeshSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MeshSpecProviderConfigRefPolicyResolve
 */
export enum MeshSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MeshSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MeshSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MeshSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MeshSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MeshSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MeshSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MeshSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MeshSpecPublishConnectionDetailsToConfigRefPolicy(obj: MeshSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MeshSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MeshSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MeshSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MeshSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Route is the Schema for the Routes API. Provides an AWS App Mesh route resource.
 *
 * @schema Route
 */
export class Route extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Route"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appmesh.aws.upbound.io/v1beta1',
    kind: 'Route',
  }

  /**
   * Renders a Kubernetes manifest for "Route".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RouteProps): any {
    return {
      ...Route.GVK,
      ...toJson_RouteProps(props),
    };
  }

  /**
   * Defines a "Route" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RouteProps) {
    super(scope, id, {
      ...Route.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route.GVK,
      ...toJson_RouteProps(resolved),
    };
  }
}

/**
 * Route is the Schema for the Routes API. Provides an AWS App Mesh route resource.
 *
 * @schema Route
 */
export interface RouteProps {
  /**
   * @schema Route#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RouteSpec defines the desired state of Route
   *
   * @schema Route#spec
   */
  readonly spec: RouteSpec;

}

/**
 * Converts an object of type 'RouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteProps(obj: RouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteSpec defines the desired state of Route
 *
 * @schema RouteSpec
 */
export interface RouteSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RouteSpec#deletionPolicy
   */
  readonly deletionPolicy?: RouteSpecDeletionPolicy;

  /**
   * @schema RouteSpec#forProvider
   */
  readonly forProvider: RouteSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RouteSpec#initProvider
   */
  readonly initProvider?: RouteSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RouteSpec#managementPolicies
   */
  readonly managementPolicies?: RouteSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RouteSpec#providerConfigRef
   */
  readonly providerConfigRef?: RouteSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RouteSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RouteSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RouteSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RouteSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpec(obj: RouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RouteSpecForProvider(obj.forProvider),
    'initProvider': toJson_RouteSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RouteSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RouteSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RouteSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RouteSpecDeletionPolicy
 */
export enum RouteSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RouteSpecForProvider
 */
export interface RouteSpecForProvider {
  /**
   * Name of the service mesh in which to create the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProvider#meshName
   */
  readonly meshName?: string;

  /**
   * Reference to a Mesh in appmesh to populate meshName.
   *
   * @schema RouteSpecForProvider#meshNameRef
   */
  readonly meshNameRef?: RouteSpecForProviderMeshNameRef;

  /**
   * Selector for a Mesh in appmesh to populate meshName.
   *
   * @schema RouteSpecForProvider#meshNameSelector
   */
  readonly meshNameSelector?: RouteSpecForProviderMeshNameSelector;

  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema RouteSpecForProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RouteSpecForProvider#region
   */
  readonly region: string;

  /**
   * Route specification to apply.
   *
   * @schema RouteSpecForProvider#spec
   */
  readonly spec?: RouteSpecForProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema RouteSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Name of the virtual router in which to create the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProvider#virtualRouterName
   */
  readonly virtualRouterName?: string;

  /**
   * Reference to a VirtualRouter in appmesh to populate virtualRouterName.
   *
   * @schema RouteSpecForProvider#virtualRouterNameRef
   */
  readonly virtualRouterNameRef?: RouteSpecForProviderVirtualRouterNameRef;

  /**
   * Selector for a VirtualRouter in appmesh to populate virtualRouterName.
   *
   * @schema RouteSpecForProvider#virtualRouterNameSelector
   */
  readonly virtualRouterNameSelector?: RouteSpecForProviderVirtualRouterNameSelector;

}

/**
 * Converts an object of type 'RouteSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProvider(obj: RouteSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshName': obj.meshName,
    'meshNameRef': toJson_RouteSpecForProviderMeshNameRef(obj.meshNameRef),
    'meshNameSelector': toJson_RouteSpecForProviderMeshNameSelector(obj.meshNameSelector),
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'region': obj.region,
    'spec': obj.spec?.map(y => toJson_RouteSpecForProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'virtualRouterName': obj.virtualRouterName,
    'virtualRouterNameRef': toJson_RouteSpecForProviderVirtualRouterNameRef(obj.virtualRouterNameRef),
    'virtualRouterNameSelector': toJson_RouteSpecForProviderVirtualRouterNameSelector(obj.virtualRouterNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RouteSpecInitProvider
 */
export interface RouteSpecInitProvider {
  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema RouteSpecInitProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Route specification to apply.
   *
   * @schema RouteSpecInitProvider#spec
   */
  readonly spec?: RouteSpecInitProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema RouteSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RouteSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProvider(obj: RouteSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'spec': obj.spec?.map(y => toJson_RouteSpecInitProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RouteSpecManagementPolicies
 */
export enum RouteSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RouteSpecProviderConfigRef
 */
export interface RouteSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecProviderConfigRef#policy
   */
  readonly policy?: RouteSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecProviderConfigRef(obj: RouteSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RouteSpecPublishConnectionDetailsTo
 */
export interface RouteSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RouteSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RouteSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsTo(obj: RouteSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RouteSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RouteSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RouteSpecWriteConnectionSecretToRef
 */
export interface RouteSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RouteSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RouteSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RouteSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecWriteConnectionSecretToRef(obj: RouteSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Mesh in appmesh to populate meshName.
 *
 * @schema RouteSpecForProviderMeshNameRef
 */
export interface RouteSpecForProviderMeshNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderMeshNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderMeshNameRef#policy
   */
  readonly policy?: RouteSpecForProviderMeshNameRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderMeshNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderMeshNameRef(obj: RouteSpecForProviderMeshNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderMeshNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Mesh in appmesh to populate meshName.
 *
 * @schema RouteSpecForProviderMeshNameSelector
 */
export interface RouteSpecForProviderMeshNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderMeshNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderMeshNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderMeshNameSelector#policy
   */
  readonly policy?: RouteSpecForProviderMeshNameSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderMeshNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderMeshNameSelector(obj: RouteSpecForProviderMeshNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderMeshNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpec
 */
export interface RouteSpecForProviderSpec {
  /**
   * GRPC routing information for the route.
   *
   * @schema RouteSpecForProviderSpec#grpcRoute
   */
  readonly grpcRoute?: RouteSpecForProviderSpecGrpcRoute[];

  /**
   * HTTP/2 routing information for the route.
   *
   * @schema RouteSpecForProviderSpec#http2Route
   */
  readonly http2Route?: RouteSpecForProviderSpecHttp2Route[];

  /**
   * HTTP routing information for the route.
   *
   * @schema RouteSpecForProviderSpec#httpRoute
   */
  readonly httpRoute?: RouteSpecForProviderSpecHttpRoute[];

  /**
   * Priority for the route, between 0 and 1000. Routes are matched based on the specified value, where 0 is the highest priority.
   *
   * @schema RouteSpecForProviderSpec#priority
   */
  readonly priority?: number;

  /**
   * TCP routing information for the route.
   *
   * @schema RouteSpecForProviderSpec#tcpRoute
   */
  readonly tcpRoute?: RouteSpecForProviderSpecTcpRoute[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpec(obj: RouteSpecForProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcRoute': obj.grpcRoute?.map(y => toJson_RouteSpecForProviderSpecGrpcRoute(y)),
    'http2Route': obj.http2Route?.map(y => toJson_RouteSpecForProviderSpecHttp2Route(y)),
    'httpRoute': obj.httpRoute?.map(y => toJson_RouteSpecForProviderSpecHttpRoute(y)),
    'priority': obj.priority,
    'tcpRoute': obj.tcpRoute?.map(y => toJson_RouteSpecForProviderSpecTcpRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VirtualRouter in appmesh to populate virtualRouterName.
 *
 * @schema RouteSpecForProviderVirtualRouterNameRef
 */
export interface RouteSpecForProviderVirtualRouterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderVirtualRouterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderVirtualRouterNameRef#policy
   */
  readonly policy?: RouteSpecForProviderVirtualRouterNameRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderVirtualRouterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderVirtualRouterNameRef(obj: RouteSpecForProviderVirtualRouterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderVirtualRouterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VirtualRouter in appmesh to populate virtualRouterName.
 *
 * @schema RouteSpecForProviderVirtualRouterNameSelector
 */
export interface RouteSpecForProviderVirtualRouterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderVirtualRouterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderVirtualRouterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderVirtualRouterNameSelector#policy
   */
  readonly policy?: RouteSpecForProviderVirtualRouterNameSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderVirtualRouterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderVirtualRouterNameSelector(obj: RouteSpecForProviderVirtualRouterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderVirtualRouterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpec
 */
export interface RouteSpecInitProviderSpec {
  /**
   * GRPC routing information for the route.
   *
   * @schema RouteSpecInitProviderSpec#grpcRoute
   */
  readonly grpcRoute?: RouteSpecInitProviderSpecGrpcRoute[];

  /**
   * HTTP/2 routing information for the route.
   *
   * @schema RouteSpecInitProviderSpec#http2Route
   */
  readonly http2Route?: RouteSpecInitProviderSpecHttp2Route[];

  /**
   * HTTP routing information for the route.
   *
   * @schema RouteSpecInitProviderSpec#httpRoute
   */
  readonly httpRoute?: RouteSpecInitProviderSpecHttpRoute[];

  /**
   * Priority for the route, between 0 and 1000. Routes are matched based on the specified value, where 0 is the highest priority.
   *
   * @schema RouteSpecInitProviderSpec#priority
   */
  readonly priority?: number;

  /**
   * TCP routing information for the route.
   *
   * @schema RouteSpecInitProviderSpec#tcpRoute
   */
  readonly tcpRoute?: RouteSpecInitProviderSpecTcpRoute[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpec(obj: RouteSpecInitProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcRoute': obj.grpcRoute?.map(y => toJson_RouteSpecInitProviderSpecGrpcRoute(y)),
    'http2Route': obj.http2Route?.map(y => toJson_RouteSpecInitProviderSpecHttp2Route(y)),
    'httpRoute': obj.httpRoute?.map(y => toJson_RouteSpecInitProviderSpecHttpRoute(y)),
    'priority': obj.priority,
    'tcpRoute': obj.tcpRoute?.map(y => toJson_RouteSpecInitProviderSpecTcpRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecProviderConfigRefPolicy
 */
export interface RouteSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RouteSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RouteSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecProviderConfigRefPolicy(obj: RouteSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRef
 */
export interface RouteSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RouteSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToConfigRef(obj: RouteSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RouteSpecPublishConnectionDetailsToMetadata
 */
export interface RouteSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToMetadata(obj: RouteSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderMeshNameRefPolicy
 */
export interface RouteSpecForProviderMeshNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderMeshNameRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderMeshNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderMeshNameRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderMeshNameRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderMeshNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderMeshNameRefPolicy(obj: RouteSpecForProviderMeshNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderMeshNameSelectorPolicy
 */
export interface RouteSpecForProviderMeshNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderMeshNameSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderMeshNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderMeshNameSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderMeshNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderMeshNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderMeshNameSelectorPolicy(obj: RouteSpecForProviderMeshNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecGrpcRoute
 */
export interface RouteSpecForProviderSpecGrpcRoute {
  /**
   * Action to take if a match is determined.
   *
   * @schema RouteSpecForProviderSpecGrpcRoute#action
   */
  readonly action?: RouteSpecForProviderSpecGrpcRouteAction[];

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecForProviderSpecGrpcRoute#match
   */
  readonly match?: RouteSpecForProviderSpecGrpcRouteMatch[];

  /**
   * Retry policy.
   *
   * @schema RouteSpecForProviderSpecGrpcRoute#retryPolicy
   */
  readonly retryPolicy?: RouteSpecForProviderSpecGrpcRouteRetryPolicy[];

  /**
   * Types of timeouts.
   *
   * @schema RouteSpecForProviderSpecGrpcRoute#timeout
   */
  readonly timeout?: RouteSpecForProviderSpecGrpcRouteTimeout[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRoute(obj: RouteSpecForProviderSpecGrpcRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteAction(y)),
    'match': obj.match?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteMatch(y)),
    'retryPolicy': obj.retryPolicy?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteRetryPolicy(y)),
    'timeout': obj.timeout?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteTimeout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2Route
 */
export interface RouteSpecForProviderSpecHttp2Route {
  /**
   * Action to take if a match is determined.
   *
   * @schema RouteSpecForProviderSpecHttp2Route#action
   */
  readonly action?: RouteSpecForProviderSpecHttp2RouteAction[];

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecForProviderSpecHttp2Route#match
   */
  readonly match?: RouteSpecForProviderSpecHttp2RouteMatch[];

  /**
   * Retry policy.
   *
   * @schema RouteSpecForProviderSpecHttp2Route#retryPolicy
   */
  readonly retryPolicy?: RouteSpecForProviderSpecHttp2RouteRetryPolicy[];

  /**
   * Types of timeouts.
   *
   * @schema RouteSpecForProviderSpecHttp2Route#timeout
   */
  readonly timeout?: RouteSpecForProviderSpecHttp2RouteTimeout[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2Route' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2Route(obj: RouteSpecForProviderSpecHttp2Route | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteAction(y)),
    'match': obj.match?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteMatch(y)),
    'retryPolicy': obj.retryPolicy?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteRetryPolicy(y)),
    'timeout': obj.timeout?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteTimeout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRoute
 */
export interface RouteSpecForProviderSpecHttpRoute {
  /**
   * Action to take if a match is determined.
   *
   * @schema RouteSpecForProviderSpecHttpRoute#action
   */
  readonly action?: RouteSpecForProviderSpecHttpRouteAction[];

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecForProviderSpecHttpRoute#match
   */
  readonly match?: RouteSpecForProviderSpecHttpRouteMatch[];

  /**
   * Retry policy.
   *
   * @schema RouteSpecForProviderSpecHttpRoute#retryPolicy
   */
  readonly retryPolicy?: RouteSpecForProviderSpecHttpRouteRetryPolicy[];

  /**
   * Types of timeouts.
   *
   * @schema RouteSpecForProviderSpecHttpRoute#timeout
   */
  readonly timeout?: RouteSpecForProviderSpecHttpRouteTimeout[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRoute(obj: RouteSpecForProviderSpecHttpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_RouteSpecForProviderSpecHttpRouteAction(y)),
    'match': obj.match?.map(y => toJson_RouteSpecForProviderSpecHttpRouteMatch(y)),
    'retryPolicy': obj.retryPolicy?.map(y => toJson_RouteSpecForProviderSpecHttpRouteRetryPolicy(y)),
    'timeout': obj.timeout?.map(y => toJson_RouteSpecForProviderSpecHttpRouteTimeout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecTcpRoute
 */
export interface RouteSpecForProviderSpecTcpRoute {
  /**
   * Action to take if a match is determined.
   *
   * @schema RouteSpecForProviderSpecTcpRoute#action
   */
  readonly action?: RouteSpecForProviderSpecTcpRouteAction[];

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecForProviderSpecTcpRoute#match
   */
  readonly match?: RouteSpecForProviderSpecTcpRouteMatch[];

  /**
   * Types of timeouts.
   *
   * @schema RouteSpecForProviderSpecTcpRoute#timeout
   */
  readonly timeout?: RouteSpecForProviderSpecTcpRouteTimeout[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecTcpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecTcpRoute(obj: RouteSpecForProviderSpecTcpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_RouteSpecForProviderSpecTcpRouteAction(y)),
    'match': obj.match?.map(y => toJson_RouteSpecForProviderSpecTcpRouteMatch(y)),
    'timeout': obj.timeout?.map(y => toJson_RouteSpecForProviderSpecTcpRouteTimeout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderVirtualRouterNameRefPolicy
 */
export interface RouteSpecForProviderVirtualRouterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderVirtualRouterNameRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderVirtualRouterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderVirtualRouterNameRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderVirtualRouterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderVirtualRouterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderVirtualRouterNameRefPolicy(obj: RouteSpecForProviderVirtualRouterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderVirtualRouterNameSelectorPolicy
 */
export interface RouteSpecForProviderVirtualRouterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderVirtualRouterNameSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderVirtualRouterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderVirtualRouterNameSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderVirtualRouterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderVirtualRouterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderVirtualRouterNameSelectorPolicy(obj: RouteSpecForProviderVirtualRouterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRoute
 */
export interface RouteSpecInitProviderSpecGrpcRoute {
  /**
   * Action to take if a match is determined.
   *
   * @schema RouteSpecInitProviderSpecGrpcRoute#action
   */
  readonly action?: RouteSpecInitProviderSpecGrpcRouteAction[];

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecInitProviderSpecGrpcRoute#match
   */
  readonly match?: RouteSpecInitProviderSpecGrpcRouteMatch[];

  /**
   * Retry policy.
   *
   * @schema RouteSpecInitProviderSpecGrpcRoute#retryPolicy
   */
  readonly retryPolicy?: RouteSpecInitProviderSpecGrpcRouteRetryPolicy[];

  /**
   * Types of timeouts.
   *
   * @schema RouteSpecInitProviderSpecGrpcRoute#timeout
   */
  readonly timeout?: RouteSpecInitProviderSpecGrpcRouteTimeout[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRoute(obj: RouteSpecInitProviderSpecGrpcRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteAction(y)),
    'match': obj.match?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteMatch(y)),
    'retryPolicy': obj.retryPolicy?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteRetryPolicy(y)),
    'timeout': obj.timeout?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteTimeout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2Route
 */
export interface RouteSpecInitProviderSpecHttp2Route {
  /**
   * Action to take if a match is determined.
   *
   * @schema RouteSpecInitProviderSpecHttp2Route#action
   */
  readonly action?: RouteSpecInitProviderSpecHttp2RouteAction[];

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecInitProviderSpecHttp2Route#match
   */
  readonly match?: RouteSpecInitProviderSpecHttp2RouteMatch[];

  /**
   * Retry policy.
   *
   * @schema RouteSpecInitProviderSpecHttp2Route#retryPolicy
   */
  readonly retryPolicy?: RouteSpecInitProviderSpecHttp2RouteRetryPolicy[];

  /**
   * Types of timeouts.
   *
   * @schema RouteSpecInitProviderSpecHttp2Route#timeout
   */
  readonly timeout?: RouteSpecInitProviderSpecHttp2RouteTimeout[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2Route' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2Route(obj: RouteSpecInitProviderSpecHttp2Route | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteAction(y)),
    'match': obj.match?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteMatch(y)),
    'retryPolicy': obj.retryPolicy?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteRetryPolicy(y)),
    'timeout': obj.timeout?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteTimeout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRoute
 */
export interface RouteSpecInitProviderSpecHttpRoute {
  /**
   * Action to take if a match is determined.
   *
   * @schema RouteSpecInitProviderSpecHttpRoute#action
   */
  readonly action?: RouteSpecInitProviderSpecHttpRouteAction[];

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecInitProviderSpecHttpRoute#match
   */
  readonly match?: RouteSpecInitProviderSpecHttpRouteMatch[];

  /**
   * Retry policy.
   *
   * @schema RouteSpecInitProviderSpecHttpRoute#retryPolicy
   */
  readonly retryPolicy?: RouteSpecInitProviderSpecHttpRouteRetryPolicy[];

  /**
   * Types of timeouts.
   *
   * @schema RouteSpecInitProviderSpecHttpRoute#timeout
   */
  readonly timeout?: RouteSpecInitProviderSpecHttpRouteTimeout[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRoute(obj: RouteSpecInitProviderSpecHttpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteAction(y)),
    'match': obj.match?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteMatch(y)),
    'retryPolicy': obj.retryPolicy?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteRetryPolicy(y)),
    'timeout': obj.timeout?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteTimeout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecTcpRoute
 */
export interface RouteSpecInitProviderSpecTcpRoute {
  /**
   * Action to take if a match is determined.
   *
   * @schema RouteSpecInitProviderSpecTcpRoute#action
   */
  readonly action?: RouteSpecInitProviderSpecTcpRouteAction[];

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecInitProviderSpecTcpRoute#match
   */
  readonly match?: RouteSpecInitProviderSpecTcpRouteMatch[];

  /**
   * Types of timeouts.
   *
   * @schema RouteSpecInitProviderSpecTcpRoute#timeout
   */
  readonly timeout?: RouteSpecInitProviderSpecTcpRouteTimeout[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecTcpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecTcpRoute(obj: RouteSpecInitProviderSpecTcpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_RouteSpecInitProviderSpecTcpRouteAction(y)),
    'match': obj.match?.map(y => toJson_RouteSpecInitProviderSpecTcpRouteMatch(y)),
    'timeout': obj.timeout?.map(y => toJson_RouteSpecInitProviderSpecTcpRouteTimeout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecProviderConfigRefPolicyResolution
 */
export enum RouteSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecProviderConfigRefPolicyResolve
 */
export enum RouteSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RouteSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToConfigRefPolicy(obj: RouteSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderMeshNameRefPolicyResolution
 */
export enum RouteSpecForProviderMeshNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderMeshNameRefPolicyResolve
 */
export enum RouteSpecForProviderMeshNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderMeshNameSelectorPolicyResolution
 */
export enum RouteSpecForProviderMeshNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderMeshNameSelectorPolicyResolve
 */
export enum RouteSpecForProviderMeshNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RouteSpecForProviderSpecGrpcRouteAction
 */
export interface RouteSpecForProviderSpecGrpcRouteAction {
  /**
   * Targets that traffic is routed to when a request matches the route. You can specify one or more targets and their relative weights with which to distribute traffic.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteAction#weightedTarget
   */
  readonly weightedTarget?: RouteSpecForProviderSpecGrpcRouteActionWeightedTarget[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteAction(obj: RouteSpecForProviderSpecGrpcRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weightedTarget': obj.weightedTarget?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteActionWeightedTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecGrpcRouteMatch
 */
export interface RouteSpecForProviderSpecGrpcRouteMatch {
  /**
   * Data to match from the gRPC request.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatch#metadata
   */
  readonly metadata?: RouteSpecForProviderSpecGrpcRouteMatchMetadata[];

  /**
   * Method name to match from the request. If you specify a name, you must also specify a service_name.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatch#methodName
   */
  readonly methodName?: string;

  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatch#port
   */
  readonly port?: number;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Fully qualified domain name for the service to match from the request.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatch#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteMatch(obj: RouteSpecForProviderSpecGrpcRouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteMatchMetadata(y)),
    'methodName': obj.methodName,
    'port': obj.port,
    'prefix': obj.prefix,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecGrpcRouteRetryPolicy
 */
export interface RouteSpecForProviderSpecGrpcRouteRetryPolicy {
  /**
   * List of gRPC retry events. Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteRetryPolicy#grpcRetryEvents
   */
  readonly grpcRetryEvents?: string[];

  /**
   * List of HTTP retry events. Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
   *
   * @schema RouteSpecForProviderSpecGrpcRouteRetryPolicy#httpRetryEvents
   */
  readonly httpRetryEvents?: string[];

  /**
   * Maximum number of retries.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteRetryPolicy#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * Per-retry timeout.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteRetryPolicy#perRetryTimeout
   */
  readonly perRetryTimeout?: RouteSpecForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout[];

  /**
   * List of TCP retry events. The only valid value is connection-error.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteRetryPolicy#tcpRetryEvents
   */
  readonly tcpRetryEvents?: string[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteRetryPolicy(obj: RouteSpecForProviderSpecGrpcRouteRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcRetryEvents': obj.grpcRetryEvents?.map(y => y),
    'httpRetryEvents': obj.httpRetryEvents?.map(y => y),
    'maxRetries': obj.maxRetries,
    'perRetryTimeout': obj.perRetryTimeout?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout(y)),
    'tcpRetryEvents': obj.tcpRetryEvents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecGrpcRouteTimeout
 */
export interface RouteSpecForProviderSpecGrpcRouteTimeout {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteTimeout#idle
   */
  readonly idle?: RouteSpecForProviderSpecGrpcRouteTimeoutIdle[];

  /**
   * Per request timeout.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteTimeout#perRequest
   */
  readonly perRequest?: RouteSpecForProviderSpecGrpcRouteTimeoutPerRequest[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteTimeout(obj: RouteSpecForProviderSpecGrpcRouteTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteTimeoutIdle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteTimeoutPerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteAction
 */
export interface RouteSpecForProviderSpecHttp2RouteAction {
  /**
   * Targets that traffic is routed to when a request matches the route. You can specify one or more targets and their relative weights with which to distribute traffic.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteAction#weightedTarget
   */
  readonly weightedTarget?: RouteSpecForProviderSpecHttp2RouteActionWeightedTarget[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteAction(obj: RouteSpecForProviderSpecHttp2RouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weightedTarget': obj.weightedTarget?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteActionWeightedTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteMatch
 */
export interface RouteSpecForProviderSpecHttp2RouteMatch {
  /**
   * Client request headers to match on.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatch#header
   */
  readonly header?: RouteSpecForProviderSpecHttp2RouteMatchHeader[];

  /**
   * Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatch#method
   */
  readonly method?: string;

  /**
   * Client request path to match on.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatch#path
   */
  readonly path?: RouteSpecForProviderSpecHttp2RouteMatchPath[];

  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatch#port
   */
  readonly port?: number;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Client request query parameters to match on.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatch#queryParameter
   */
  readonly queryParameter?: RouteSpecForProviderSpecHttp2RouteMatchQueryParameter[];

  /**
   * Client request header scheme to match on. Valid values: http, https.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatch#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteMatch(obj: RouteSpecForProviderSpecHttp2RouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteMatchHeader(y)),
    'method': obj.method,
    'path': obj.path?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteMatchPath(y)),
    'port': obj.port,
    'prefix': obj.prefix,
    'queryParameter': obj.queryParameter?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteMatchQueryParameter(y)),
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteRetryPolicy
 */
export interface RouteSpecForProviderSpecHttp2RouteRetryPolicy {
  /**
   * List of HTTP retry events. Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
   *
   * @schema RouteSpecForProviderSpecHttp2RouteRetryPolicy#httpRetryEvents
   */
  readonly httpRetryEvents?: string[];

  /**
   * Maximum number of retries.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteRetryPolicy#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * Per-retry timeout.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteRetryPolicy#perRetryTimeout
   */
  readonly perRetryTimeout?: RouteSpecForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout[];

  /**
   * List of TCP retry events. The only valid value is connection-error.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteRetryPolicy#tcpRetryEvents
   */
  readonly tcpRetryEvents?: string[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteRetryPolicy(obj: RouteSpecForProviderSpecHttp2RouteRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpRetryEvents': obj.httpRetryEvents?.map(y => y),
    'maxRetries': obj.maxRetries,
    'perRetryTimeout': obj.perRetryTimeout?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout(y)),
    'tcpRetryEvents': obj.tcpRetryEvents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteTimeout
 */
export interface RouteSpecForProviderSpecHttp2RouteTimeout {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteTimeout#idle
   */
  readonly idle?: RouteSpecForProviderSpecHttp2RouteTimeoutIdle[];

  /**
   * Per request timeout.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteTimeout#perRequest
   */
  readonly perRequest?: RouteSpecForProviderSpecHttp2RouteTimeoutPerRequest[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteTimeout(obj: RouteSpecForProviderSpecHttp2RouteTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteTimeoutIdle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteTimeoutPerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteAction
 */
export interface RouteSpecForProviderSpecHttpRouteAction {
  /**
   * Targets that traffic is routed to when a request matches the route. You can specify one or more targets and their relative weights with which to distribute traffic.
   *
   * @schema RouteSpecForProviderSpecHttpRouteAction#weightedTarget
   */
  readonly weightedTarget?: RouteSpecForProviderSpecHttpRouteActionWeightedTarget[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteAction(obj: RouteSpecForProviderSpecHttpRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weightedTarget': obj.weightedTarget?.map(y => toJson_RouteSpecForProviderSpecHttpRouteActionWeightedTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteMatch
 */
export interface RouteSpecForProviderSpecHttpRouteMatch {
  /**
   * Client request headers to match on.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatch#header
   */
  readonly header?: RouteSpecForProviderSpecHttpRouteMatchHeader[];

  /**
   * Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatch#method
   */
  readonly method?: string;

  /**
   * Client request path to match on.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatch#path
   */
  readonly path?: RouteSpecForProviderSpecHttpRouteMatchPath[];

  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatch#port
   */
  readonly port?: number;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Client request query parameters to match on.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatch#queryParameter
   */
  readonly queryParameter?: RouteSpecForProviderSpecHttpRouteMatchQueryParameter[];

  /**
   * Client request header scheme to match on. Valid values: http, https.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatch#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteMatch(obj: RouteSpecForProviderSpecHttpRouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header?.map(y => toJson_RouteSpecForProviderSpecHttpRouteMatchHeader(y)),
    'method': obj.method,
    'path': obj.path?.map(y => toJson_RouteSpecForProviderSpecHttpRouteMatchPath(y)),
    'port': obj.port,
    'prefix': obj.prefix,
    'queryParameter': obj.queryParameter?.map(y => toJson_RouteSpecForProviderSpecHttpRouteMatchQueryParameter(y)),
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteRetryPolicy
 */
export interface RouteSpecForProviderSpecHttpRouteRetryPolicy {
  /**
   * List of HTTP retry events. Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
   *
   * @schema RouteSpecForProviderSpecHttpRouteRetryPolicy#httpRetryEvents
   */
  readonly httpRetryEvents?: string[];

  /**
   * Maximum number of retries.
   *
   * @schema RouteSpecForProviderSpecHttpRouteRetryPolicy#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * Per-retry timeout.
   *
   * @schema RouteSpecForProviderSpecHttpRouteRetryPolicy#perRetryTimeout
   */
  readonly perRetryTimeout?: RouteSpecForProviderSpecHttpRouteRetryPolicyPerRetryTimeout[];

  /**
   * List of TCP retry events. The only valid value is connection-error.
   *
   * @schema RouteSpecForProviderSpecHttpRouteRetryPolicy#tcpRetryEvents
   */
  readonly tcpRetryEvents?: string[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteRetryPolicy(obj: RouteSpecForProviderSpecHttpRouteRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpRetryEvents': obj.httpRetryEvents?.map(y => y),
    'maxRetries': obj.maxRetries,
    'perRetryTimeout': obj.perRetryTimeout?.map(y => toJson_RouteSpecForProviderSpecHttpRouteRetryPolicyPerRetryTimeout(y)),
    'tcpRetryEvents': obj.tcpRetryEvents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteTimeout
 */
export interface RouteSpecForProviderSpecHttpRouteTimeout {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema RouteSpecForProviderSpecHttpRouteTimeout#idle
   */
  readonly idle?: RouteSpecForProviderSpecHttpRouteTimeoutIdle[];

  /**
   * Per request timeout.
   *
   * @schema RouteSpecForProviderSpecHttpRouteTimeout#perRequest
   */
  readonly perRequest?: RouteSpecForProviderSpecHttpRouteTimeoutPerRequest[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteTimeout(obj: RouteSpecForProviderSpecHttpRouteTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_RouteSpecForProviderSpecHttpRouteTimeoutIdle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_RouteSpecForProviderSpecHttpRouteTimeoutPerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecTcpRouteAction
 */
export interface RouteSpecForProviderSpecTcpRouteAction {
  /**
   * Targets that traffic is routed to when a request matches the route. You can specify one or more targets and their relative weights with which to distribute traffic.
   *
   * @schema RouteSpecForProviderSpecTcpRouteAction#weightedTarget
   */
  readonly weightedTarget?: RouteSpecForProviderSpecTcpRouteActionWeightedTarget[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecTcpRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecTcpRouteAction(obj: RouteSpecForProviderSpecTcpRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weightedTarget': obj.weightedTarget?.map(y => toJson_RouteSpecForProviderSpecTcpRouteActionWeightedTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecTcpRouteMatch
 */
export interface RouteSpecForProviderSpecTcpRouteMatch {
  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecForProviderSpecTcpRouteMatch#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecTcpRouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecTcpRouteMatch(obj: RouteSpecForProviderSpecTcpRouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecTcpRouteTimeout
 */
export interface RouteSpecForProviderSpecTcpRouteTimeout {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema RouteSpecForProviderSpecTcpRouteTimeout#idle
   */
  readonly idle?: RouteSpecForProviderSpecTcpRouteTimeoutIdle[];

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecTcpRouteTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecTcpRouteTimeout(obj: RouteSpecForProviderSpecTcpRouteTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_RouteSpecForProviderSpecTcpRouteTimeoutIdle(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderVirtualRouterNameRefPolicyResolution
 */
export enum RouteSpecForProviderVirtualRouterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderVirtualRouterNameRefPolicyResolve
 */
export enum RouteSpecForProviderVirtualRouterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderVirtualRouterNameSelectorPolicyResolution
 */
export enum RouteSpecForProviderVirtualRouterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderVirtualRouterNameSelectorPolicyResolve
 */
export enum RouteSpecForProviderVirtualRouterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteAction
 */
export interface RouteSpecInitProviderSpecGrpcRouteAction {
  /**
   * Targets that traffic is routed to when a request matches the route. You can specify one or more targets and their relative weights with which to distribute traffic.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteAction#weightedTarget
   */
  readonly weightedTarget?: RouteSpecInitProviderSpecGrpcRouteActionWeightedTarget[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteAction(obj: RouteSpecInitProviderSpecGrpcRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weightedTarget': obj.weightedTarget?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteActionWeightedTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteMatch
 */
export interface RouteSpecInitProviderSpecGrpcRouteMatch {
  /**
   * Data to match from the gRPC request.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatch#metadata
   */
  readonly metadata?: RouteSpecInitProviderSpecGrpcRouteMatchMetadata[];

  /**
   * Method name to match from the request. If you specify a name, you must also specify a service_name.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatch#methodName
   */
  readonly methodName?: string;

  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatch#port
   */
  readonly port?: number;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Fully qualified domain name for the service to match from the request.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatch#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteMatch(obj: RouteSpecInitProviderSpecGrpcRouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteMatchMetadata(y)),
    'methodName': obj.methodName,
    'port': obj.port,
    'prefix': obj.prefix,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteRetryPolicy
 */
export interface RouteSpecInitProviderSpecGrpcRouteRetryPolicy {
  /**
   * List of gRPC retry events. Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteRetryPolicy#grpcRetryEvents
   */
  readonly grpcRetryEvents?: string[];

  /**
   * List of HTTP retry events. Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteRetryPolicy#httpRetryEvents
   */
  readonly httpRetryEvents?: string[];

  /**
   * Maximum number of retries.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteRetryPolicy#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * Per-retry timeout.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteRetryPolicy#perRetryTimeout
   */
  readonly perRetryTimeout?: RouteSpecInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout[];

  /**
   * List of TCP retry events. The only valid value is connection-error.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteRetryPolicy#tcpRetryEvents
   */
  readonly tcpRetryEvents?: string[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteRetryPolicy(obj: RouteSpecInitProviderSpecGrpcRouteRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcRetryEvents': obj.grpcRetryEvents?.map(y => y),
    'httpRetryEvents': obj.httpRetryEvents?.map(y => y),
    'maxRetries': obj.maxRetries,
    'perRetryTimeout': obj.perRetryTimeout?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout(y)),
    'tcpRetryEvents': obj.tcpRetryEvents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteTimeout
 */
export interface RouteSpecInitProviderSpecGrpcRouteTimeout {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteTimeout#idle
   */
  readonly idle?: RouteSpecInitProviderSpecGrpcRouteTimeoutIdle[];

  /**
   * Per request timeout.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteTimeout#perRequest
   */
  readonly perRequest?: RouteSpecInitProviderSpecGrpcRouteTimeoutPerRequest[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteTimeout(obj: RouteSpecInitProviderSpecGrpcRouteTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteTimeoutIdle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteTimeoutPerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteAction
 */
export interface RouteSpecInitProviderSpecHttp2RouteAction {
  /**
   * Targets that traffic is routed to when a request matches the route. You can specify one or more targets and their relative weights with which to distribute traffic.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteAction#weightedTarget
   */
  readonly weightedTarget?: RouteSpecInitProviderSpecHttp2RouteActionWeightedTarget[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteAction(obj: RouteSpecInitProviderSpecHttp2RouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weightedTarget': obj.weightedTarget?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteActionWeightedTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteMatch
 */
export interface RouteSpecInitProviderSpecHttp2RouteMatch {
  /**
   * Client request headers to match on.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatch#header
   */
  readonly header?: RouteSpecInitProviderSpecHttp2RouteMatchHeader[];

  /**
   * Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatch#method
   */
  readonly method?: string;

  /**
   * Client request path to match on.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatch#path
   */
  readonly path?: RouteSpecInitProviderSpecHttp2RouteMatchPath[];

  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatch#port
   */
  readonly port?: number;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Client request query parameters to match on.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatch#queryParameter
   */
  readonly queryParameter?: RouteSpecInitProviderSpecHttp2RouteMatchQueryParameter[];

  /**
   * Client request header scheme to match on. Valid values: http, https.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatch#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteMatch(obj: RouteSpecInitProviderSpecHttp2RouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteMatchHeader(y)),
    'method': obj.method,
    'path': obj.path?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteMatchPath(y)),
    'port': obj.port,
    'prefix': obj.prefix,
    'queryParameter': obj.queryParameter?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteMatchQueryParameter(y)),
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteRetryPolicy
 */
export interface RouteSpecInitProviderSpecHttp2RouteRetryPolicy {
  /**
   * List of HTTP retry events. Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteRetryPolicy#httpRetryEvents
   */
  readonly httpRetryEvents?: string[];

  /**
   * Maximum number of retries.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteRetryPolicy#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * Per-retry timeout.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteRetryPolicy#perRetryTimeout
   */
  readonly perRetryTimeout?: RouteSpecInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout[];

  /**
   * List of TCP retry events. The only valid value is connection-error.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteRetryPolicy#tcpRetryEvents
   */
  readonly tcpRetryEvents?: string[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteRetryPolicy(obj: RouteSpecInitProviderSpecHttp2RouteRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpRetryEvents': obj.httpRetryEvents?.map(y => y),
    'maxRetries': obj.maxRetries,
    'perRetryTimeout': obj.perRetryTimeout?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout(y)),
    'tcpRetryEvents': obj.tcpRetryEvents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteTimeout
 */
export interface RouteSpecInitProviderSpecHttp2RouteTimeout {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteTimeout#idle
   */
  readonly idle?: RouteSpecInitProviderSpecHttp2RouteTimeoutIdle[];

  /**
   * Per request timeout.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteTimeout#perRequest
   */
  readonly perRequest?: RouteSpecInitProviderSpecHttp2RouteTimeoutPerRequest[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteTimeout(obj: RouteSpecInitProviderSpecHttp2RouteTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteTimeoutIdle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteTimeoutPerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteAction
 */
export interface RouteSpecInitProviderSpecHttpRouteAction {
  /**
   * Targets that traffic is routed to when a request matches the route. You can specify one or more targets and their relative weights with which to distribute traffic.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteAction#weightedTarget
   */
  readonly weightedTarget?: RouteSpecInitProviderSpecHttpRouteActionWeightedTarget[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteAction(obj: RouteSpecInitProviderSpecHttpRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weightedTarget': obj.weightedTarget?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteActionWeightedTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteMatch
 */
export interface RouteSpecInitProviderSpecHttpRouteMatch {
  /**
   * Client request headers to match on.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatch#header
   */
  readonly header?: RouteSpecInitProviderSpecHttpRouteMatchHeader[];

  /**
   * Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatch#method
   */
  readonly method?: string;

  /**
   * Client request path to match on.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatch#path
   */
  readonly path?: RouteSpecInitProviderSpecHttpRouteMatchPath[];

  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatch#port
   */
  readonly port?: number;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Client request query parameters to match on.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatch#queryParameter
   */
  readonly queryParameter?: RouteSpecInitProviderSpecHttpRouteMatchQueryParameter[];

  /**
   * Client request header scheme to match on. Valid values: http, https.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatch#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteMatch(obj: RouteSpecInitProviderSpecHttpRouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteMatchHeader(y)),
    'method': obj.method,
    'path': obj.path?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteMatchPath(y)),
    'port': obj.port,
    'prefix': obj.prefix,
    'queryParameter': obj.queryParameter?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteMatchQueryParameter(y)),
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteRetryPolicy
 */
export interface RouteSpecInitProviderSpecHttpRouteRetryPolicy {
  /**
   * List of HTTP retry events. Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
   *
   * @schema RouteSpecInitProviderSpecHttpRouteRetryPolicy#httpRetryEvents
   */
  readonly httpRetryEvents?: string[];

  /**
   * Maximum number of retries.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteRetryPolicy#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * Per-retry timeout.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteRetryPolicy#perRetryTimeout
   */
  readonly perRetryTimeout?: RouteSpecInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout[];

  /**
   * List of TCP retry events. The only valid value is connection-error.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteRetryPolicy#tcpRetryEvents
   */
  readonly tcpRetryEvents?: string[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteRetryPolicy(obj: RouteSpecInitProviderSpecHttpRouteRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpRetryEvents': obj.httpRetryEvents?.map(y => y),
    'maxRetries': obj.maxRetries,
    'perRetryTimeout': obj.perRetryTimeout?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout(y)),
    'tcpRetryEvents': obj.tcpRetryEvents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteTimeout
 */
export interface RouteSpecInitProviderSpecHttpRouteTimeout {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteTimeout#idle
   */
  readonly idle?: RouteSpecInitProviderSpecHttpRouteTimeoutIdle[];

  /**
   * Per request timeout.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteTimeout#perRequest
   */
  readonly perRequest?: RouteSpecInitProviderSpecHttpRouteTimeoutPerRequest[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteTimeout(obj: RouteSpecInitProviderSpecHttpRouteTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteTimeoutIdle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteTimeoutPerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecTcpRouteAction
 */
export interface RouteSpecInitProviderSpecTcpRouteAction {
  /**
   * Targets that traffic is routed to when a request matches the route. You can specify one or more targets and their relative weights with which to distribute traffic.
   *
   * @schema RouteSpecInitProviderSpecTcpRouteAction#weightedTarget
   */
  readonly weightedTarget?: RouteSpecInitProviderSpecTcpRouteActionWeightedTarget[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecTcpRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecTcpRouteAction(obj: RouteSpecInitProviderSpecTcpRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weightedTarget': obj.weightedTarget?.map(y => toJson_RouteSpecInitProviderSpecTcpRouteActionWeightedTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecTcpRouteMatch
 */
export interface RouteSpecInitProviderSpecTcpRouteMatch {
  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecInitProviderSpecTcpRouteMatch#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecTcpRouteMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecTcpRouteMatch(obj: RouteSpecInitProviderSpecTcpRouteMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecTcpRouteTimeout
 */
export interface RouteSpecInitProviderSpecTcpRouteTimeout {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema RouteSpecInitProviderSpecTcpRouteTimeout#idle
   */
  readonly idle?: RouteSpecInitProviderSpecTcpRouteTimeoutIdle[];

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecTcpRouteTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecTcpRouteTimeout(obj: RouteSpecInitProviderSpecTcpRouteTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_RouteSpecInitProviderSpecTcpRouteTimeoutIdle(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RouteSpecForProviderSpecGrpcRouteActionWeightedTarget
 */
export interface RouteSpecForProviderSpecGrpcRouteActionWeightedTarget {
  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteActionWeightedTarget#port
   */
  readonly port?: number;

  /**
   * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteActionWeightedTarget#virtualNode
   */
  readonly virtualNode?: string;

  /**
   * Relative weight of the weighted target. An integer between 0 and 100.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteActionWeightedTarget#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteActionWeightedTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteActionWeightedTarget(obj: RouteSpecForProviderSpecGrpcRouteActionWeightedTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualNode': obj.virtualNode,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadata
 */
export interface RouteSpecForProviderSpecGrpcRouteMatchMetadata {
  /**
   * If true, the match is on the opposite of the match criteria. Default is false.
   *
   * @default false.
   * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadata#invert
   */
  readonly invert?: boolean;

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadata#match
   */
  readonly match?: RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch[];

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteMatchMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteMatchMetadata(obj: RouteSpecForProviderSpecGrpcRouteMatchMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'match': obj.match?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout
 */
export interface RouteSpecForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout(obj: RouteSpecForProviderSpecGrpcRouteRetryPolicyPerRetryTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecGrpcRouteTimeoutIdle
 */
export interface RouteSpecForProviderSpecGrpcRouteTimeoutIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteTimeoutIdle#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteTimeoutIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteTimeoutIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteTimeoutIdle(obj: RouteSpecForProviderSpecGrpcRouteTimeoutIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecGrpcRouteTimeoutPerRequest
 */
export interface RouteSpecForProviderSpecGrpcRouteTimeoutPerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteTimeoutPerRequest#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteTimeoutPerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteTimeoutPerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteTimeoutPerRequest(obj: RouteSpecForProviderSpecGrpcRouteTimeoutPerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteActionWeightedTarget
 */
export interface RouteSpecForProviderSpecHttp2RouteActionWeightedTarget {
  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteActionWeightedTarget#port
   */
  readonly port?: number;

  /**
   * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteActionWeightedTarget#virtualNode
   */
  readonly virtualNode?: string;

  /**
   * Relative weight of the weighted target. An integer between 0 and 100.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteActionWeightedTarget#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteActionWeightedTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteActionWeightedTarget(obj: RouteSpecForProviderSpecHttp2RouteActionWeightedTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualNode': obj.virtualNode,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteMatchHeader
 */
export interface RouteSpecForProviderSpecHttp2RouteMatchHeader {
  /**
   * If true, the match is on the opposite of the match criteria. Default is false.
   *
   * @default false.
   * @schema RouteSpecForProviderSpecHttp2RouteMatchHeader#invert
   */
  readonly invert?: boolean;

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchHeader#match
   */
  readonly match?: RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch[];

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchHeader#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteMatchHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteMatchHeader(obj: RouteSpecForProviderSpecHttp2RouteMatchHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'match': obj.match?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteMatchPath
 */
export interface RouteSpecForProviderSpecHttp2RouteMatchPath {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchPath#exact
   */
  readonly exact?: string;

  /**
   * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchPath#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteMatchPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteMatchPath(obj: RouteSpecForProviderSpecHttp2RouteMatchPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteMatchQueryParameter
 */
export interface RouteSpecForProviderSpecHttp2RouteMatchQueryParameter {
  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchQueryParameter#match
   */
  readonly match?: RouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch[];

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchQueryParameter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteMatchQueryParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteMatchQueryParameter(obj: RouteSpecForProviderSpecHttp2RouteMatchQueryParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout
 */
export interface RouteSpecForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout(obj: RouteSpecForProviderSpecHttp2RouteRetryPolicyPerRetryTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteTimeoutIdle
 */
export interface RouteSpecForProviderSpecHttp2RouteTimeoutIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteTimeoutIdle#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteTimeoutIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteTimeoutIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteTimeoutIdle(obj: RouteSpecForProviderSpecHttp2RouteTimeoutIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteTimeoutPerRequest
 */
export interface RouteSpecForProviderSpecHttp2RouteTimeoutPerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteTimeoutPerRequest#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteTimeoutPerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteTimeoutPerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteTimeoutPerRequest(obj: RouteSpecForProviderSpecHttp2RouteTimeoutPerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTarget
 */
export interface RouteSpecForProviderSpecHttpRouteActionWeightedTarget {
  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTarget#port
   */
  readonly port?: number;

  /**
   * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTarget#virtualNode
   */
  readonly virtualNode?: string;

  /**
   * Reference to a VirtualNode in appmesh to populate virtualNode.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTarget#virtualNodeRef
   */
  readonly virtualNodeRef?: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef;

  /**
   * Selector for a VirtualNode in appmesh to populate virtualNode.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTarget#virtualNodeSelector
   */
  readonly virtualNodeSelector?: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector;

  /**
   * Relative weight of the weighted target. An integer between 0 and 100.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTarget#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteActionWeightedTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteActionWeightedTarget(obj: RouteSpecForProviderSpecHttpRouteActionWeightedTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualNode': obj.virtualNode,
    'virtualNodeRef': toJson_RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef(obj.virtualNodeRef),
    'virtualNodeSelector': toJson_RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector(obj.virtualNodeSelector),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteMatchHeader
 */
export interface RouteSpecForProviderSpecHttpRouteMatchHeader {
  /**
   * If true, the match is on the opposite of the match criteria. Default is false.
   *
   * @default false.
   * @schema RouteSpecForProviderSpecHttpRouteMatchHeader#invert
   */
  readonly invert?: boolean;

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchHeader#match
   */
  readonly match?: RouteSpecForProviderSpecHttpRouteMatchHeaderMatch[];

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchHeader#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteMatchHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteMatchHeader(obj: RouteSpecForProviderSpecHttpRouteMatchHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'match': obj.match?.map(y => toJson_RouteSpecForProviderSpecHttpRouteMatchHeaderMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteMatchPath
 */
export interface RouteSpecForProviderSpecHttpRouteMatchPath {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchPath#exact
   */
  readonly exact?: string;

  /**
   * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchPath#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteMatchPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteMatchPath(obj: RouteSpecForProviderSpecHttpRouteMatchPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteMatchQueryParameter
 */
export interface RouteSpecForProviderSpecHttpRouteMatchQueryParameter {
  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchQueryParameter#match
   */
  readonly match?: RouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch[];

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchQueryParameter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteMatchQueryParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteMatchQueryParameter(obj: RouteSpecForProviderSpecHttpRouteMatchQueryParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_RouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteRetryPolicyPerRetryTimeout
 */
export interface RouteSpecForProviderSpecHttpRouteRetryPolicyPerRetryTimeout {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecForProviderSpecHttpRouteRetryPolicyPerRetryTimeout#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecForProviderSpecHttpRouteRetryPolicyPerRetryTimeout#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteRetryPolicyPerRetryTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteRetryPolicyPerRetryTimeout(obj: RouteSpecForProviderSpecHttpRouteRetryPolicyPerRetryTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteTimeoutIdle
 */
export interface RouteSpecForProviderSpecHttpRouteTimeoutIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecForProviderSpecHttpRouteTimeoutIdle#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecForProviderSpecHttpRouteTimeoutIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteTimeoutIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteTimeoutIdle(obj: RouteSpecForProviderSpecHttpRouteTimeoutIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteTimeoutPerRequest
 */
export interface RouteSpecForProviderSpecHttpRouteTimeoutPerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecForProviderSpecHttpRouteTimeoutPerRequest#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecForProviderSpecHttpRouteTimeoutPerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteTimeoutPerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteTimeoutPerRequest(obj: RouteSpecForProviderSpecHttpRouteTimeoutPerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTarget
 */
export interface RouteSpecForProviderSpecTcpRouteActionWeightedTarget {
  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTarget#port
   */
  readonly port?: number;

  /**
   * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTarget#virtualNode
   */
  readonly virtualNode?: string;

  /**
   * Reference to a VirtualNode in appmesh to populate virtualNode.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTarget#virtualNodeRef
   */
  readonly virtualNodeRef?: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef;

  /**
   * Selector for a VirtualNode in appmesh to populate virtualNode.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTarget#virtualNodeSelector
   */
  readonly virtualNodeSelector?: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector;

  /**
   * Relative weight of the weighted target. An integer between 0 and 100.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTarget#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecTcpRouteActionWeightedTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecTcpRouteActionWeightedTarget(obj: RouteSpecForProviderSpecTcpRouteActionWeightedTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualNode': obj.virtualNode,
    'virtualNodeRef': toJson_RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef(obj.virtualNodeRef),
    'virtualNodeSelector': toJson_RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector(obj.virtualNodeSelector),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecTcpRouteTimeoutIdle
 */
export interface RouteSpecForProviderSpecTcpRouteTimeoutIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecForProviderSpecTcpRouteTimeoutIdle#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecForProviderSpecTcpRouteTimeoutIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecTcpRouteTimeoutIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecTcpRouteTimeoutIdle(obj: RouteSpecForProviderSpecTcpRouteTimeoutIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteActionWeightedTarget
 */
export interface RouteSpecInitProviderSpecGrpcRouteActionWeightedTarget {
  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteActionWeightedTarget#port
   */
  readonly port?: number;

  /**
   * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteActionWeightedTarget#virtualNode
   */
  readonly virtualNode?: string;

  /**
   * Relative weight of the weighted target. An integer between 0 and 100.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteActionWeightedTarget#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteActionWeightedTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteActionWeightedTarget(obj: RouteSpecInitProviderSpecGrpcRouteActionWeightedTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualNode': obj.virtualNode,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadata
 */
export interface RouteSpecInitProviderSpecGrpcRouteMatchMetadata {
  /**
   * If true, the match is on the opposite of the match criteria. Default is false.
   *
   * @default false.
   * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadata#invert
   */
  readonly invert?: boolean;

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadata#match
   */
  readonly match?: RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch[];

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteMatchMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteMatchMetadata(obj: RouteSpecInitProviderSpecGrpcRouteMatchMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'match': obj.match?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout
 */
export interface RouteSpecInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout(obj: RouteSpecInitProviderSpecGrpcRouteRetryPolicyPerRetryTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteTimeoutIdle
 */
export interface RouteSpecInitProviderSpecGrpcRouteTimeoutIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteTimeoutIdle#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteTimeoutIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteTimeoutIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteTimeoutIdle(obj: RouteSpecInitProviderSpecGrpcRouteTimeoutIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteTimeoutPerRequest
 */
export interface RouteSpecInitProviderSpecGrpcRouteTimeoutPerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteTimeoutPerRequest#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteTimeoutPerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteTimeoutPerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteTimeoutPerRequest(obj: RouteSpecInitProviderSpecGrpcRouteTimeoutPerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteActionWeightedTarget
 */
export interface RouteSpecInitProviderSpecHttp2RouteActionWeightedTarget {
  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteActionWeightedTarget#port
   */
  readonly port?: number;

  /**
   * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteActionWeightedTarget#virtualNode
   */
  readonly virtualNode?: string;

  /**
   * Relative weight of the weighted target. An integer between 0 and 100.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteActionWeightedTarget#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteActionWeightedTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteActionWeightedTarget(obj: RouteSpecInitProviderSpecHttp2RouteActionWeightedTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'virtualNode': obj.virtualNode,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeader
 */
export interface RouteSpecInitProviderSpecHttp2RouteMatchHeader {
  /**
   * If true, the match is on the opposite of the match criteria. Default is false.
   *
   * @default false.
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeader#invert
   */
  readonly invert?: boolean;

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeader#match
   */
  readonly match?: RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch[];

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeader#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteMatchHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteMatchHeader(obj: RouteSpecInitProviderSpecHttp2RouteMatchHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'match': obj.match?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteMatchPath
 */
export interface RouteSpecInitProviderSpecHttp2RouteMatchPath {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchPath#exact
   */
  readonly exact?: string;

  /**
   * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchPath#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteMatchPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteMatchPath(obj: RouteSpecInitProviderSpecHttp2RouteMatchPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteMatchQueryParameter
 */
export interface RouteSpecInitProviderSpecHttp2RouteMatchQueryParameter {
  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchQueryParameter#match
   */
  readonly match?: RouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch[];

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchQueryParameter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteMatchQueryParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteMatchQueryParameter(obj: RouteSpecInitProviderSpecHttp2RouteMatchQueryParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout
 */
export interface RouteSpecInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout(obj: RouteSpecInitProviderSpecHttp2RouteRetryPolicyPerRetryTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteTimeoutIdle
 */
export interface RouteSpecInitProviderSpecHttp2RouteTimeoutIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteTimeoutIdle#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteTimeoutIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteTimeoutIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteTimeoutIdle(obj: RouteSpecInitProviderSpecHttp2RouteTimeoutIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteTimeoutPerRequest
 */
export interface RouteSpecInitProviderSpecHttp2RouteTimeoutPerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteTimeoutPerRequest#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteTimeoutPerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteTimeoutPerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteTimeoutPerRequest(obj: RouteSpecInitProviderSpecHttp2RouteTimeoutPerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteActionWeightedTarget
 */
export interface RouteSpecInitProviderSpecHttpRouteActionWeightedTarget {
  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteActionWeightedTarget#port
   */
  readonly port?: number;

  /**
   * Relative weight of the weighted target. An integer between 0 and 100.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteActionWeightedTarget#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteActionWeightedTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteActionWeightedTarget(obj: RouteSpecInitProviderSpecHttpRouteActionWeightedTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteMatchHeader
 */
export interface RouteSpecInitProviderSpecHttpRouteMatchHeader {
  /**
   * If true, the match is on the opposite of the match criteria. Default is false.
   *
   * @default false.
   * @schema RouteSpecInitProviderSpecHttpRouteMatchHeader#invert
   */
  readonly invert?: boolean;

  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchHeader#match
   */
  readonly match?: RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch[];

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchHeader#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteMatchHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteMatchHeader(obj: RouteSpecInitProviderSpecHttpRouteMatchHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'match': obj.match?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteMatchPath
 */
export interface RouteSpecInitProviderSpecHttpRouteMatchPath {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchPath#exact
   */
  readonly exact?: string;

  /**
   * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchPath#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteMatchPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteMatchPath(obj: RouteSpecInitProviderSpecHttpRouteMatchPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteMatchQueryParameter
 */
export interface RouteSpecInitProviderSpecHttpRouteMatchQueryParameter {
  /**
   * Criteria for determining an gRPC request match.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchQueryParameter#match
   */
  readonly match?: RouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch[];

  /**
   * Name to use for the route. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchQueryParameter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteMatchQueryParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteMatchQueryParameter(obj: RouteSpecInitProviderSpecHttpRouteMatchQueryParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout
 */
export interface RouteSpecInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout(obj: RouteSpecInitProviderSpecHttpRouteRetryPolicyPerRetryTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteTimeoutIdle
 */
export interface RouteSpecInitProviderSpecHttpRouteTimeoutIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteTimeoutIdle#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteTimeoutIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteTimeoutIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteTimeoutIdle(obj: RouteSpecInitProviderSpecHttpRouteTimeoutIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteTimeoutPerRequest
 */
export interface RouteSpecInitProviderSpecHttpRouteTimeoutPerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteTimeoutPerRequest#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteTimeoutPerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteTimeoutPerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteTimeoutPerRequest(obj: RouteSpecInitProviderSpecHttpRouteTimeoutPerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecTcpRouteActionWeightedTarget
 */
export interface RouteSpecInitProviderSpecTcpRouteActionWeightedTarget {
  /**
   * The port number to match from the request.
   *
   * @schema RouteSpecInitProviderSpecTcpRouteActionWeightedTarget#port
   */
  readonly port?: number;

  /**
   * Relative weight of the weighted target. An integer between 0 and 100.
   *
   * @schema RouteSpecInitProviderSpecTcpRouteActionWeightedTarget#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecTcpRouteActionWeightedTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecTcpRouteActionWeightedTarget(obj: RouteSpecInitProviderSpecTcpRouteActionWeightedTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecTcpRouteTimeoutIdle
 */
export interface RouteSpecInitProviderSpecTcpRouteTimeoutIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema RouteSpecInitProviderSpecTcpRouteTimeoutIdle#unit
   */
  readonly unit?: string;

  /**
   * Number of time units. Minimum value of 0.
   *
   * @schema RouteSpecInitProviderSpecTcpRouteTimeoutIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecTcpRouteTimeoutIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecTcpRouteTimeoutIdle(obj: RouteSpecInitProviderSpecTcpRouteTimeoutIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch
 */
export interface RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch#exact
   */
  readonly exact?: string;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Object that specifies the range of numbers that the value sent by the client must be included in.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch#range
   */
  readonly range?: RouteSpecForProviderSpecGrpcRouteMatchMetadataMatchRange[];

  /**
   * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch#regex
   */
  readonly regex?: string;

  /**
   * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch(obj: RouteSpecForProviderSpecGrpcRouteMatchMetadataMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'range': obj.range?.map(y => toJson_RouteSpecForProviderSpecGrpcRouteMatchMetadataMatchRange(y)),
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch
 */
export interface RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch#exact
   */
  readonly exact?: string;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Object that specifies the range of numbers that the value sent by the client must be included in.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch#range
   */
  readonly range?: RouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange[];

  /**
   * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch#regex
   */
  readonly regex?: string;

  /**
   * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch(obj: RouteSpecForProviderSpecHttp2RouteMatchHeaderMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'range': obj.range?.map(y => toJson_RouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange(y)),
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch
 */
export interface RouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch#exact
   */
  readonly exact?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch(obj: RouteSpecForProviderSpecHttp2RouteMatchQueryParameterMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VirtualNode in appmesh to populate virtualNode.
 *
 * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef
 */
export interface RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef#policy
   */
  readonly policy?: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef(obj: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VirtualNode in appmesh to populate virtualNode.
 *
 * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector
 */
export interface RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector#policy
   */
  readonly policy?: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector(obj: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteMatchHeaderMatch
 */
export interface RouteSpecForProviderSpecHttpRouteMatchHeaderMatch {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchHeaderMatch#exact
   */
  readonly exact?: string;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchHeaderMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Object that specifies the range of numbers that the value sent by the client must be included in.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchHeaderMatch#range
   */
  readonly range?: RouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange[];

  /**
   * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchHeaderMatch#regex
   */
  readonly regex?: string;

  /**
   * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchHeaderMatch#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteMatchHeaderMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteMatchHeaderMatch(obj: RouteSpecForProviderSpecHttpRouteMatchHeaderMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'range': obj.range?.map(y => toJson_RouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange(y)),
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch
 */
export interface RouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch#exact
   */
  readonly exact?: string;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch(obj: RouteSpecForProviderSpecHttpRouteMatchQueryParameterMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VirtualNode in appmesh to populate virtualNode.
 *
 * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef
 */
export interface RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef#policy
   */
  readonly policy?: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef(obj: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VirtualNode in appmesh to populate virtualNode.
 *
 * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector
 */
export interface RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector#policy
   */
  readonly policy?: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector(obj: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch
 */
export interface RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch#exact
   */
  readonly exact?: string;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Object that specifies the range of numbers that the value sent by the client must be included in.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch#range
   */
  readonly range?: RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatchRange[];

  /**
   * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch#regex
   */
  readonly regex?: string;

  /**
   * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch(obj: RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'range': obj.range?.map(y => toJson_RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatchRange(y)),
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch
 */
export interface RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch#exact
   */
  readonly exact?: string;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Object that specifies the range of numbers that the value sent by the client must be included in.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch#range
   */
  readonly range?: RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange[];

  /**
   * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch#regex
   */
  readonly regex?: string;

  /**
   * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch(obj: RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'range': obj.range?.map(y => toJson_RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange(y)),
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch
 */
export interface RouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch#exact
   */
  readonly exact?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch(obj: RouteSpecInitProviderSpecHttp2RouteMatchQueryParameterMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch
 */
export interface RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch#exact
   */
  readonly exact?: string;

  /**
   * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch#prefix
   */
  readonly prefix?: string;

  /**
   * Object that specifies the range of numbers that the value sent by the client must be included in.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch#range
   */
  readonly range?: RouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange[];

  /**
   * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch#regex
   */
  readonly regex?: string;

  /**
   * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch(obj: RouteSpecInitProviderSpecHttpRouteMatchHeaderMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'range': obj.range?.map(y => toJson_RouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange(y)),
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch
 */
export interface RouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch {
  /**
   * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch#exact
   */
  readonly exact?: string;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch(obj: RouteSpecInitProviderSpecHttpRouteMatchQueryParameterMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadataMatchRange
 */
export interface RouteSpecForProviderSpecGrpcRouteMatchMetadataMatchRange {
  /**
   * End of the range.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadataMatchRange#end
   */
  readonly end?: number;

  /**
   * (Requited) Start of the range.
   *
   * @schema RouteSpecForProviderSpecGrpcRouteMatchMetadataMatchRange#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecGrpcRouteMatchMetadataMatchRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecGrpcRouteMatchMetadataMatchRange(obj: RouteSpecForProviderSpecGrpcRouteMatchMetadataMatchRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange
 */
export interface RouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange {
  /**
   * End of the range.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange#end
   */
  readonly end?: number;

  /**
   * (Requited) Start of the range.
   *
   * @schema RouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange(obj: RouteSpecForProviderSpecHttp2RouteMatchHeaderMatchRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy
 */
export interface RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy(obj: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy
 */
export interface RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy(obj: RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange
 */
export interface RouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange {
  /**
   * End of the range.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange#end
   */
  readonly end?: number;

  /**
   * (Requited) Start of the range.
   *
   * @schema RouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange(obj: RouteSpecForProviderSpecHttpRouteMatchHeaderMatchRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy
 */
export interface RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy(obj: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy
 */
export interface RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy(obj: RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatchRange
 */
export interface RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatchRange {
  /**
   * End of the range.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatchRange#end
   */
  readonly end?: number;

  /**
   * (Requited) Start of the range.
   *
   * @schema RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatchRange#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatchRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatchRange(obj: RouteSpecInitProviderSpecGrpcRouteMatchMetadataMatchRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange
 */
export interface RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange {
  /**
   * End of the range.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange#end
   */
  readonly end?: number;

  /**
   * (Requited) Start of the range.
   *
   * @schema RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange(obj: RouteSpecInitProviderSpecHttp2RouteMatchHeaderMatchRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange
 */
export interface RouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange {
  /**
   * End of the range.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange#end
   */
  readonly end?: number;

  /**
   * (Requited) Start of the range.
   *
   * @schema RouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'RouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange(obj: RouteSpecInitProviderSpecHttpRouteMatchHeaderMatchRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolution
 */
export enum RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolve
 */
export enum RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution
 */
export enum RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve
 */
export enum RouteSpecForProviderSpecHttpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolution
 */
export enum RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolve
 */
export enum RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution
 */
export enum RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve
 */
export enum RouteSpecForProviderSpecTcpRouteActionWeightedTargetVirtualNodeSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VirtualGateway is the Schema for the VirtualGateways API. Provides an AWS App Mesh virtual gateway resource.
 *
 * @schema VirtualGateway
 */
export class VirtualGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appmesh.aws.upbound.io/v1beta1',
    kind: 'VirtualGateway',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualGatewayProps): any {
    return {
      ...VirtualGateway.GVK,
      ...toJson_VirtualGatewayProps(props),
    };
  }

  /**
   * Defines a "VirtualGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualGatewayProps) {
    super(scope, id, {
      ...VirtualGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualGateway.GVK,
      ...toJson_VirtualGatewayProps(resolved),
    };
  }
}

/**
 * VirtualGateway is the Schema for the VirtualGateways API. Provides an AWS App Mesh virtual gateway resource.
 *
 * @schema VirtualGateway
 */
export interface VirtualGatewayProps {
  /**
   * @schema VirtualGateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VirtualGatewaySpec defines the desired state of VirtualGateway
   *
   * @schema VirtualGateway#spec
   */
  readonly spec: VirtualGatewaySpec;

}

/**
 * Converts an object of type 'VirtualGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewayProps(obj: VirtualGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VirtualGatewaySpec defines the desired state of VirtualGateway
 *
 * @schema VirtualGatewaySpec
 */
export interface VirtualGatewaySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VirtualGatewaySpec#deletionPolicy
   */
  readonly deletionPolicy?: VirtualGatewaySpecDeletionPolicy;

  /**
   * @schema VirtualGatewaySpec#forProvider
   */
  readonly forProvider: VirtualGatewaySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VirtualGatewaySpec#initProvider
   */
  readonly initProvider?: VirtualGatewaySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VirtualGatewaySpec#managementPolicies
   */
  readonly managementPolicies?: VirtualGatewaySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VirtualGatewaySpec#providerConfigRef
   */
  readonly providerConfigRef?: VirtualGatewaySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VirtualGatewaySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VirtualGatewaySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VirtualGatewaySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VirtualGatewaySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VirtualGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpec(obj: VirtualGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VirtualGatewaySpecForProvider(obj.forProvider),
    'initProvider': toJson_VirtualGatewaySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VirtualGatewaySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VirtualGatewaySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VirtualGatewaySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VirtualGatewaySpecDeletionPolicy
 */
export enum VirtualGatewaySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VirtualGatewaySpecForProvider
 */
export interface VirtualGatewaySpecForProvider {
  /**
   * Name of the service mesh in which to create the virtual gateway. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualGatewaySpecForProvider#meshName
   */
  readonly meshName?: string;

  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema VirtualGatewaySpecForProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the virtual gateway. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualGatewaySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VirtualGatewaySpecForProvider#region
   */
  readonly region: string;

  /**
   * Virtual gateway specification to apply.
   *
   * @schema VirtualGatewaySpecForProvider#spec
   */
  readonly spec?: VirtualGatewaySpecForProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VirtualGatewaySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProvider(obj: VirtualGatewaySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshName': obj.meshName,
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'region': obj.region,
    'spec': obj.spec?.map(y => toJson_VirtualGatewaySpecForProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VirtualGatewaySpecInitProvider
 */
export interface VirtualGatewaySpecInitProvider {
  /**
   * Name of the service mesh in which to create the virtual gateway. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualGatewaySpecInitProvider#meshName
   */
  readonly meshName?: string;

  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema VirtualGatewaySpecInitProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the virtual gateway. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualGatewaySpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Virtual gateway specification to apply.
   *
   * @schema VirtualGatewaySpecInitProvider#spec
   */
  readonly spec?: VirtualGatewaySpecInitProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VirtualGatewaySpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProvider(obj: VirtualGatewaySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshName': obj.meshName,
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'spec': obj.spec?.map(y => toJson_VirtualGatewaySpecInitProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VirtualGatewaySpecManagementPolicies
 */
export enum VirtualGatewaySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VirtualGatewaySpecProviderConfigRef
 */
export interface VirtualGatewaySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualGatewaySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualGatewaySpecProviderConfigRef#policy
   */
  readonly policy?: VirtualGatewaySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VirtualGatewaySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecProviderConfigRef(obj: VirtualGatewaySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualGatewaySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VirtualGatewaySpecPublishConnectionDetailsTo
 */
export interface VirtualGatewaySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VirtualGatewaySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VirtualGatewaySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VirtualGatewaySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VirtualGatewaySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VirtualGatewaySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecPublishConnectionDetailsTo(obj: VirtualGatewaySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VirtualGatewaySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VirtualGatewaySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VirtualGatewaySpecWriteConnectionSecretToRef
 */
export interface VirtualGatewaySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VirtualGatewaySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VirtualGatewaySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecWriteConnectionSecretToRef(obj: VirtualGatewaySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpec
 */
export interface VirtualGatewaySpecForProviderSpec {
  /**
   * Defaults for backends.
   *
   * @schema VirtualGatewaySpecForProviderSpec#backendDefaults
   */
  readonly backendDefaults?: VirtualGatewaySpecForProviderSpecBackendDefaults[];

  /**
   * Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
   *
   * @schema VirtualGatewaySpecForProviderSpec#listener
   */
  readonly listener?: VirtualGatewaySpecForProviderSpecListener[];

  /**
   * Inbound and outbound access logging information for the virtual gateway.
   *
   * @schema VirtualGatewaySpecForProviderSpec#logging
   */
  readonly logging?: VirtualGatewaySpecForProviderSpecLogging[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpec(obj: VirtualGatewaySpecForProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendDefaults': obj.backendDefaults?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaults(y)),
    'listener': obj.listener?.map(y => toJson_VirtualGatewaySpecForProviderSpecListener(y)),
    'logging': obj.logging?.map(y => toJson_VirtualGatewaySpecForProviderSpecLogging(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpec
 */
export interface VirtualGatewaySpecInitProviderSpec {
  /**
   * Defaults for backends.
   *
   * @schema VirtualGatewaySpecInitProviderSpec#backendDefaults
   */
  readonly backendDefaults?: VirtualGatewaySpecInitProviderSpecBackendDefaults[];

  /**
   * Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
   *
   * @schema VirtualGatewaySpecInitProviderSpec#listener
   */
  readonly listener?: VirtualGatewaySpecInitProviderSpecListener[];

  /**
   * Inbound and outbound access logging information for the virtual gateway.
   *
   * @schema VirtualGatewaySpecInitProviderSpec#logging
   */
  readonly logging?: VirtualGatewaySpecInitProviderSpecLogging[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpec(obj: VirtualGatewaySpecInitProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendDefaults': obj.backendDefaults?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaults(y)),
    'listener': obj.listener?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListener(y)),
    'logging': obj.logging?.map(y => toJson_VirtualGatewaySpecInitProviderSpecLogging(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualGatewaySpecProviderConfigRefPolicy
 */
export interface VirtualGatewaySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualGatewaySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VirtualGatewaySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualGatewaySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VirtualGatewaySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualGatewaySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecProviderConfigRefPolicy(obj: VirtualGatewaySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VirtualGatewaySpecPublishConnectionDetailsToConfigRef
 */
export interface VirtualGatewaySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualGatewaySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualGatewaySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VirtualGatewaySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecPublishConnectionDetailsToConfigRef(obj: VirtualGatewaySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VirtualGatewaySpecPublishConnectionDetailsToMetadata
 */
export interface VirtualGatewaySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VirtualGatewaySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VirtualGatewaySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VirtualGatewaySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecPublishConnectionDetailsToMetadata(obj: VirtualGatewaySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaults
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaults {
  /**
   * Default client policy for virtual gateway backends.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaults#clientPolicy
   */
  readonly clientPolicy?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicy[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaults' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaults(obj: VirtualGatewaySpecForProviderSpecBackendDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientPolicy': obj.clientPolicy?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListener
 */
export interface VirtualGatewaySpecForProviderSpecListener {
  /**
   * Connection pool information for the listener.
   *
   * @schema VirtualGatewaySpecForProviderSpecListener#connectionPool
   */
  readonly connectionPool?: VirtualGatewaySpecForProviderSpecListenerConnectionPool[];

  /**
   * Health check information for the listener.
   *
   * @schema VirtualGatewaySpecForProviderSpecListener#healthCheck
   */
  readonly healthCheck?: VirtualGatewaySpecForProviderSpecListenerHealthCheck[];

  /**
   * Port mapping information for the listener.
   *
   * @schema VirtualGatewaySpecForProviderSpecListener#portMapping
   */
  readonly portMapping?: VirtualGatewaySpecForProviderSpecListenerPortMapping[];

  /**
   * Transport Layer Security (TLS) client policy.
   *
   * @schema VirtualGatewaySpecForProviderSpecListener#tls
   */
  readonly tls?: VirtualGatewaySpecForProviderSpecListenerTls[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListener(obj: VirtualGatewaySpecForProviderSpecListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': obj.connectionPool?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerConnectionPool(y)),
    'healthCheck': obj.healthCheck?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerHealthCheck(y)),
    'portMapping': obj.portMapping?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerPortMapping(y)),
    'tls': obj.tls?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecLogging
 */
export interface VirtualGatewaySpecForProviderSpecLogging {
  /**
   * Access log configuration for a virtual gateway.
   *
   * @schema VirtualGatewaySpecForProviderSpecLogging#accessLog
   */
  readonly accessLog?: VirtualGatewaySpecForProviderSpecLoggingAccessLog[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecLogging(obj: VirtualGatewaySpecForProviderSpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog?.map(y => toJson_VirtualGatewaySpecForProviderSpecLoggingAccessLog(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaults
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaults {
  /**
   * Default client policy for virtual gateway backends.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaults#clientPolicy
   */
  readonly clientPolicy?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicy[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaults' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaults(obj: VirtualGatewaySpecInitProviderSpecBackendDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientPolicy': obj.clientPolicy?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListener
 */
export interface VirtualGatewaySpecInitProviderSpecListener {
  /**
   * Connection pool information for the listener.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListener#connectionPool
   */
  readonly connectionPool?: VirtualGatewaySpecInitProviderSpecListenerConnectionPool[];

  /**
   * Health check information for the listener.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListener#healthCheck
   */
  readonly healthCheck?: VirtualGatewaySpecInitProviderSpecListenerHealthCheck[];

  /**
   * Port mapping information for the listener.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListener#portMapping
   */
  readonly portMapping?: VirtualGatewaySpecInitProviderSpecListenerPortMapping[];

  /**
   * Transport Layer Security (TLS) client policy.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListener#tls
   */
  readonly tls?: VirtualGatewaySpecInitProviderSpecListenerTls[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListener(obj: VirtualGatewaySpecInitProviderSpecListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': obj.connectionPool?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerConnectionPool(y)),
    'healthCheck': obj.healthCheck?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerHealthCheck(y)),
    'portMapping': obj.portMapping?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerPortMapping(y)),
    'tls': obj.tls?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecLogging
 */
export interface VirtualGatewaySpecInitProviderSpecLogging {
  /**
   * Access log configuration for a virtual gateway.
   *
   * @schema VirtualGatewaySpecInitProviderSpecLogging#accessLog
   */
  readonly accessLog?: VirtualGatewaySpecInitProviderSpecLoggingAccessLog[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecLogging(obj: VirtualGatewaySpecInitProviderSpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog?.map(y => toJson_VirtualGatewaySpecInitProviderSpecLoggingAccessLog(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualGatewaySpecProviderConfigRefPolicyResolution
 */
export enum VirtualGatewaySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualGatewaySpecProviderConfigRefPolicyResolve
 */
export enum VirtualGatewaySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj: VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicy
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicy {
  /**
   * Transport Layer Security (TLS) client policy.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicy#tls
   */
  readonly tls?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicy(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tls': obj.tls?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPool
 */
export interface VirtualGatewaySpecForProviderSpecListenerConnectionPool {
  /**
   * Connection pool information for gRPC listeners.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPool#grpc
   */
  readonly grpc?: VirtualGatewaySpecForProviderSpecListenerConnectionPoolGrpc[];

  /**
   * Connection pool information for HTTP listeners.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPool#http
   */
  readonly http?: VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp[];

  /**
   * Connection pool information for HTTP2 listeners.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPool#http2
   */
  readonly http2?: VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp2[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerConnectionPool(obj: VirtualGatewaySpecForProviderSpecListenerConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': obj.grpc?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerConnectionPoolGrpc(y)),
    'http': obj.http?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp(y)),
    'http2': obj.http2?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp2(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerHealthCheck
 */
export interface VirtualGatewaySpecForProviderSpecListenerHealthCheck {
  /**
   * Number of consecutive successful health checks that must occur before declaring listener healthy.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerHealthCheck#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * Time period in milliseconds between each health check execution.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerHealthCheck#intervalMillis
   */
  readonly intervalMillis?: number;

  /**
   * File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerHealthCheck#path
   */
  readonly path?: string;

  /**
   * Port used for the port mapping.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerHealthCheck#port
   */
  readonly port?: number;

  /**
   * Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerHealthCheck#protocol
   */
  readonly protocol?: string;

  /**
   * Amount of time to wait when receiving a response from the health check, in milliseconds.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerHealthCheck#timeoutMillis
   */
  readonly timeoutMillis?: number;

  /**
   * Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerHealthCheck#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerHealthCheck(obj: VirtualGatewaySpecForProviderSpecListenerHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThreshold': obj.healthyThreshold,
    'intervalMillis': obj.intervalMillis,
    'path': obj.path,
    'port': obj.port,
    'protocol': obj.protocol,
    'timeoutMillis': obj.timeoutMillis,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerPortMapping
 */
export interface VirtualGatewaySpecForProviderSpecListenerPortMapping {
  /**
   * Port used for the port mapping.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerPortMapping#port
   */
  readonly port?: number;

  /**
   * Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerPortMapping#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerPortMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerPortMapping(obj: VirtualGatewaySpecForProviderSpecListenerPortMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTls
 */
export interface VirtualGatewaySpecForProviderSpecListenerTls {
  /**
   * Virtual gateway's client's Transport Layer Security (TLS) certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTls#certificate
   */
  readonly certificate?: VirtualGatewaySpecForProviderSpecListenerTlsCertificate[];

  /**
   * Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTls#mode
   */
  readonly mode?: string;

  /**
   * TLS validation context.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTls#validation
   */
  readonly validation?: VirtualGatewaySpecForProviderSpecListenerTlsValidation[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTls(obj: VirtualGatewaySpecForProviderSpecListenerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificate(y)),
    'mode': obj.mode,
    'validation': obj.validation?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLog
 */
export interface VirtualGatewaySpecForProviderSpecLoggingAccessLog {
  /**
   * Local file certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLog#file
   */
  readonly file?: VirtualGatewaySpecForProviderSpecLoggingAccessLogFile[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecLoggingAccessLog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecLoggingAccessLog(obj: VirtualGatewaySpecForProviderSpecLoggingAccessLog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualGatewaySpecForProviderSpecLoggingAccessLogFile(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicy
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicy {
  /**
   * Transport Layer Security (TLS) client policy.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicy#tls
   */
  readonly tls?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicy(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tls': obj.tls?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPool
 */
export interface VirtualGatewaySpecInitProviderSpecListenerConnectionPool {
  /**
   * Connection pool information for gRPC listeners.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPool#grpc
   */
  readonly grpc?: VirtualGatewaySpecInitProviderSpecListenerConnectionPoolGrpc[];

  /**
   * Connection pool information for HTTP listeners.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPool#http
   */
  readonly http?: VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp[];

  /**
   * Connection pool information for HTTP2 listeners.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPool#http2
   */
  readonly http2?: VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp2[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerConnectionPool(obj: VirtualGatewaySpecInitProviderSpecListenerConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': obj.grpc?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerConnectionPoolGrpc(y)),
    'http': obj.http?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp(y)),
    'http2': obj.http2?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp2(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerHealthCheck
 */
export interface VirtualGatewaySpecInitProviderSpecListenerHealthCheck {
  /**
   * Number of consecutive successful health checks that must occur before declaring listener healthy.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerHealthCheck#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * Time period in milliseconds between each health check execution.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerHealthCheck#intervalMillis
   */
  readonly intervalMillis?: number;

  /**
   * File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerHealthCheck#path
   */
  readonly path?: string;

  /**
   * Port used for the port mapping.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerHealthCheck#port
   */
  readonly port?: number;

  /**
   * Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerHealthCheck#protocol
   */
  readonly protocol?: string;

  /**
   * Amount of time to wait when receiving a response from the health check, in milliseconds.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerHealthCheck#timeoutMillis
   */
  readonly timeoutMillis?: number;

  /**
   * Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerHealthCheck#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerHealthCheck(obj: VirtualGatewaySpecInitProviderSpecListenerHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThreshold': obj.healthyThreshold,
    'intervalMillis': obj.intervalMillis,
    'path': obj.path,
    'port': obj.port,
    'protocol': obj.protocol,
    'timeoutMillis': obj.timeoutMillis,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerPortMapping
 */
export interface VirtualGatewaySpecInitProviderSpecListenerPortMapping {
  /**
   * Port used for the port mapping.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerPortMapping#port
   */
  readonly port?: number;

  /**
   * Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerPortMapping#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerPortMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerPortMapping(obj: VirtualGatewaySpecInitProviderSpecListenerPortMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerTls
 */
export interface VirtualGatewaySpecInitProviderSpecListenerTls {
  /**
   * Virtual gateway's client's Transport Layer Security (TLS) certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTls#certificate
   */
  readonly certificate?: VirtualGatewaySpecInitProviderSpecListenerTlsCertificate[];

  /**
   * Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTls#mode
   */
  readonly mode?: string;

  /**
   * TLS validation context.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTls#validation
   */
  readonly validation?: VirtualGatewaySpecInitProviderSpecListenerTlsValidation[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerTls(obj: VirtualGatewaySpecInitProviderSpecListenerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerTlsCertificate(y)),
    'mode': obj.mode,
    'validation': obj.validation?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLog
 */
export interface VirtualGatewaySpecInitProviderSpecLoggingAccessLog {
  /**
   * Local file certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLog#file
   */
  readonly file?: VirtualGatewaySpecInitProviderSpecLoggingAccessLogFile[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecLoggingAccessLog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecLoggingAccessLog(obj: VirtualGatewaySpecInitProviderSpecLoggingAccessLog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualGatewaySpecInitProviderSpecLoggingAccessLogFile(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VirtualGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls {
  /**
   * Virtual gateway's client's Transport Layer Security (TLS) certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls#certificate
   */
  readonly certificate?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate[];

  /**
   * Whether the policy is enforced. Default is true.
   *
   * @default true.
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls#enforce
   */
  readonly enforce?: boolean;

  /**
   * One or more ports that the policy is enforced for.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls#ports
   */
  readonly ports?: number[];

  /**
   * TLS validation context.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls#validation
   */
  readonly validation?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidation[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate(y)),
    'enforce': obj.enforce,
    'ports': obj.ports?.map(y => y),
    'validation': obj.validation?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPoolGrpc
 */
export interface VirtualGatewaySpecForProviderSpecListenerConnectionPoolGrpc {
  /**
   * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPoolGrpc#maxRequests
   */
  readonly maxRequests?: number;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerConnectionPoolGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerConnectionPoolGrpc(obj: VirtualGatewaySpecForProviderSpecListenerConnectionPoolGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRequests': obj.maxRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp
 */
export interface VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp {
  /**
   * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp(obj: VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxPendingRequests': obj.maxPendingRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp2
 */
export interface VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp2 {
  /**
   * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp2#maxRequests
   */
  readonly maxRequests?: number;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp2(obj: VirtualGatewaySpecForProviderSpecListenerConnectionPoolHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRequests': obj.maxRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificate
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsCertificate {
  /**
   * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificate#acm
   */
  readonly acm?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcm[];

  /**
   * Local file certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificate#file
   */
  readonly file?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificate#sds
   */
  readonly sds?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateSds[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificate(obj: VirtualGatewaySpecForProviderSpecListenerTlsCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acm': obj.acm?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcm(y)),
    'file': obj.file?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidation
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsValidation {
  /**
   * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidation#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNames[];

  /**
   * TLS validation context trust.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidation#trust
   */
  readonly trust?: VirtualGatewaySpecForProviderSpecListenerTlsValidationTrust[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidation(obj: VirtualGatewaySpecForProviderSpecListenerTlsValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNames(y)),
    'trust': obj.trust?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidationTrust(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLogFile
 */
export interface VirtualGatewaySpecForProviderSpecLoggingAccessLogFile {
  /**
   * The specified format for the logs.
   *
   * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLogFile#format
   */
  readonly format?: VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormat[];

  /**
   * File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLogFile#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecLoggingAccessLogFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecLoggingAccessLogFile(obj: VirtualGatewaySpecForProviderSpecLoggingAccessLogFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format?.map(y => toJson_VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormat(y)),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls {
  /**
   * Virtual gateway's client's Transport Layer Security (TLS) certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls#certificate
   */
  readonly certificate?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate[];

  /**
   * Whether the policy is enforced. Default is true.
   *
   * @default true.
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls#enforce
   */
  readonly enforce?: boolean;

  /**
   * One or more ports that the policy is enforced for.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls#ports
   */
  readonly ports?: number[];

  /**
   * TLS validation context.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls#validation
   */
  readonly validation?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate(y)),
    'enforce': obj.enforce,
    'ports': obj.ports?.map(y => y),
    'validation': obj.validation?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPoolGrpc
 */
export interface VirtualGatewaySpecInitProviderSpecListenerConnectionPoolGrpc {
  /**
   * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPoolGrpc#maxRequests
   */
  readonly maxRequests?: number;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerConnectionPoolGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerConnectionPoolGrpc(obj: VirtualGatewaySpecInitProviderSpecListenerConnectionPoolGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRequests': obj.maxRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp
 */
export interface VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp {
  /**
   * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp(obj: VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxPendingRequests': obj.maxPendingRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp2
 */
export interface VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp2 {
  /**
   * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp2#maxRequests
   */
  readonly maxRequests?: number;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp2(obj: VirtualGatewaySpecInitProviderSpecListenerConnectionPoolHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRequests': obj.maxRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerTlsCertificate
 */
export interface VirtualGatewaySpecInitProviderSpecListenerTlsCertificate {
  /**
   * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsCertificate#acm
   */
  readonly acm?: any[];

  /**
   * Local file certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsCertificate#file
   */
  readonly file?: VirtualGatewaySpecInitProviderSpecListenerTlsCertificateFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsCertificate#sds
   */
  readonly sds?: VirtualGatewaySpecInitProviderSpecListenerTlsCertificateSds[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerTlsCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerTlsCertificate(obj: VirtualGatewaySpecInitProviderSpecListenerTlsCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acm': obj.acm?.map(y => y),
    'file': obj.file?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerTlsCertificateFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerTlsCertificateSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidation
 */
export interface VirtualGatewaySpecInitProviderSpecListenerTlsValidation {
  /**
   * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidation#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames[];

  /**
   * TLS validation context trust.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidation#trust
   */
  readonly trust?: VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrust[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerTlsValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidation(obj: VirtualGatewaySpecInitProviderSpecListenerTlsValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames(y)),
    'trust': obj.trust?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrust(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLogFile
 */
export interface VirtualGatewaySpecInitProviderSpecLoggingAccessLogFile {
  /**
   * The specified format for the logs.
   *
   * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLogFile#format
   */
  readonly format?: VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormat[];

  /**
   * File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLogFile#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecLoggingAccessLogFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecLoggingAccessLogFile(obj: VirtualGatewaySpecInitProviderSpecLoggingAccessLogFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format?.map(y => toJson_VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormat(y)),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate {
  /**
   * Local file certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate#file
   */
  readonly file?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate#sds
   */
  readonly sds?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidation
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidation {
  /**
   * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidation#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames[];

  /**
   * TLS validation context trust.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidation#trust
   */
  readonly trust?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidation(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames(y)),
    'trust': obj.trust?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcm
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcm {
  /**
   * ARN for the certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcm#certificateArn
   */
  readonly certificateArn?: string;

  /**
   * Reference to a Certificate in acm to populate certificateArn.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcm#certificateArnRef
   */
  readonly certificateArnRef?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRef;

  /**
   * Selector for a Certificate in acm to populate certificateArn.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcm#certificateArnSelector
   */
  readonly certificateArnSelector?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelector;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcm(obj: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateArn': obj.certificateArn,
    'certificateArnRef': toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRef(obj.certificateArnRef),
    'certificateArnSelector': toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelector(obj.certificateArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateFile
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsCertificateFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateFile#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateFile#privateKey
   */
  readonly privateKey?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsCertificateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateFile(obj: VirtualGatewaySpecForProviderSpecListenerTlsCertificateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
    'privateKey': obj.privateKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateSds
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsCertificateSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsCertificateSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateSds(obj: VirtualGatewaySpecForProviderSpecListenerTlsCertificateSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNames
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNames {
  /**
   * Criteria for determining a SAN's match.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNames#match
   */
  readonly match?: VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNames(obj: VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationTrust
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsValidationTrust {
  /**
   * Local file certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationTrust#file
   */
  readonly file?: VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationTrust#sds
   */
  readonly sds?: VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustSds[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsValidationTrust' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidationTrust(obj: VirtualGatewaySpecForProviderSpecListenerTlsValidationTrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormat
 */
export interface VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormat {
  /**
   * The logging format for JSON.
   *
   * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormat#json
   */
  readonly json?: VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormatJson[];

  /**
   * The logging format for text. Must be between 1 and 1000 characters in length.
   *
   * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormat#text
   */
  readonly text?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormat(obj: VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'json': obj.json?.map(y => toJson_VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormatJson(y)),
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate {
  /**
   * Local file certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate#file
   */
  readonly file?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate#sds
   */
  readonly sds?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation {
  /**
   * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames[];

  /**
   * TLS validation context trust.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation#trust
   */
  readonly trust?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames(y)),
    'trust': obj.trust?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerTlsCertificateFile
 */
export interface VirtualGatewaySpecInitProviderSpecListenerTlsCertificateFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsCertificateFile#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsCertificateFile#privateKey
   */
  readonly privateKey?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerTlsCertificateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerTlsCertificateFile(obj: VirtualGatewaySpecInitProviderSpecListenerTlsCertificateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
    'privateKey': obj.privateKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerTlsCertificateSds
 */
export interface VirtualGatewaySpecInitProviderSpecListenerTlsCertificateSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsCertificateSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerTlsCertificateSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerTlsCertificateSds(obj: VirtualGatewaySpecInitProviderSpecListenerTlsCertificateSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames
 */
export interface VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames {
  /**
   * Criteria for determining a SAN's match.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames#match
   */
  readonly match?: VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames(obj: VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrust
 */
export interface VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrust {
  /**
   * Local file certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrust#file
   */
  readonly file?: VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrust#sds
   */
  readonly sds?: VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustSds[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrust' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrust(obj: VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormat
 */
export interface VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormat {
  /**
   * The logging format for JSON.
   *
   * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormat#json
   */
  readonly json?: VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormatJson[];

  /**
   * The logging format for text. Must be between 1 and 1000 characters in length.
   *
   * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormat#text
   */
  readonly text?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormat(obj: VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'json': obj.json?.map(y => toJson_VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormatJson(y)),
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile#privateKey
   */
  readonly privateKey?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
    'privateKey': obj.privateKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
  /**
   * Criteria for determining a SAN's match.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames#match
   */
  readonly match?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust {
  /**
   * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#acm
   */
  readonly acm?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm[];

  /**
   * Local file certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#file
   */
  readonly file?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#sds
   */
  readonly sds?: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acm': obj.acm?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(y)),
    'file': obj.file?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Certificate in acm to populate certificateArn.
 *
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRef
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRef#policy
   */
  readonly policy?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicy;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRef(obj: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Certificate in acm to populate certificateArn.
 *
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelector
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelector#policy
   */
  readonly policy?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicy;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelector(obj: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch {
  /**
   * Values sent must match the specified values exactly.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch#exact
   */
  readonly exact?: string[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch(obj: VirtualGatewaySpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustFile
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustFile#certificateChain
   */
  readonly certificateChain?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustFile(obj: VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustSds
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustSds(obj: VirtualGatewaySpecForProviderSpecListenerTlsValidationTrustSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormatJson
 */
export interface VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormatJson {
  /**
   * The specified key for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormatJson#key
   */
  readonly key?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormatJson#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormatJson' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormatJson(obj: VirtualGatewaySpecForProviderSpecLoggingAccessLogFileFormatJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile#privateKey
   */
  readonly privateKey?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
    'privateKey': obj.privateKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
  /**
   * Criteria for determining a SAN's match.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames#match
   */
  readonly match?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust {
  /**
   * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#acm
   */
  readonly acm?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm[];

  /**
   * Local file certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#file
   */
  readonly file?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#sds
   */
  readonly sds?: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acm': obj.acm?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(y)),
    'file': obj.file?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch
 */
export interface VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch {
  /**
   * Values sent must match the specified values exactly.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch#exact
   */
  readonly exact?: string[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch(obj: VirtualGatewaySpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustFile
 */
export interface VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustFile#certificateChain
   */
  readonly certificateChain?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustFile(obj: VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustSds
 */
export interface VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustSds(obj: VirtualGatewaySpecInitProviderSpecListenerTlsValidationTrustSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormatJson
 */
export interface VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormatJson {
  /**
   * The specified key for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormatJson#key
   */
  readonly key?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormatJson#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormatJson' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormatJson(obj: VirtualGatewaySpecInitProviderSpecLoggingAccessLogFileFormatJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
  /**
   * Values sent must match the specified values exactly.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch#exact
   */
  readonly exact?: string[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
  /**
   * One or more ACM ARNs.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm#certificateAuthorityArns
   */
  readonly certificateAuthorityArns?: string[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityArns': obj.certificateAuthorityArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile#certificateChain
   */
  readonly certificateChain?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds
 */
export interface VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds(obj: VirtualGatewaySpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicy
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicy#resolution
   */
  readonly resolution?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicy#resolve
   */
  readonly resolve?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicy(obj: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicy
 */
export interface VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicy#resolution
   */
  readonly resolution?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicy#resolve
   */
  readonly resolve?: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicy(obj: VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
  /**
   * Values sent must match the specified values exactly.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch#exact
   */
  readonly exact?: string[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
  /**
   * One or more ACM ARNs.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm#certificateAuthorityArns
   */
  readonly certificateAuthorityArns?: string[];

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityArns': obj.certificateAuthorityArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile#certificateChain
   */
  readonly certificateChain?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds
 */
export interface VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds(obj: VirtualGatewaySpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicyResolution
 */
export enum VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicyResolve
 */
export enum VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicyResolution
 */
export enum VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicyResolve
 */
export enum VirtualGatewaySpecForProviderSpecListenerTlsCertificateAcmCertificateArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VirtualNode is the Schema for the VirtualNodes API. Provides an AWS App Mesh virtual node resource.
 *
 * @schema VirtualNode
 */
export class VirtualNode extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualNode"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appmesh.aws.upbound.io/v1beta1',
    kind: 'VirtualNode',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualNode".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualNodeProps): any {
    return {
      ...VirtualNode.GVK,
      ...toJson_VirtualNodeProps(props),
    };
  }

  /**
   * Defines a "VirtualNode" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualNodeProps) {
    super(scope, id, {
      ...VirtualNode.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualNode.GVK,
      ...toJson_VirtualNodeProps(resolved),
    };
  }
}

/**
 * VirtualNode is the Schema for the VirtualNodes API. Provides an AWS App Mesh virtual node resource.
 *
 * @schema VirtualNode
 */
export interface VirtualNodeProps {
  /**
   * @schema VirtualNode#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VirtualNodeSpec defines the desired state of VirtualNode
   *
   * @schema VirtualNode#spec
   */
  readonly spec: VirtualNodeSpec;

}

/**
 * Converts an object of type 'VirtualNodeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeProps(obj: VirtualNodeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualNodeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VirtualNodeSpec defines the desired state of VirtualNode
 *
 * @schema VirtualNodeSpec
 */
export interface VirtualNodeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VirtualNodeSpec#deletionPolicy
   */
  readonly deletionPolicy?: VirtualNodeSpecDeletionPolicy;

  /**
   * @schema VirtualNodeSpec#forProvider
   */
  readonly forProvider: VirtualNodeSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VirtualNodeSpec#initProvider
   */
  readonly initProvider?: VirtualNodeSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VirtualNodeSpec#managementPolicies
   */
  readonly managementPolicies?: VirtualNodeSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VirtualNodeSpec#providerConfigRef
   */
  readonly providerConfigRef?: VirtualNodeSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VirtualNodeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VirtualNodeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VirtualNodeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VirtualNodeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VirtualNodeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpec(obj: VirtualNodeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VirtualNodeSpecForProvider(obj.forProvider),
    'initProvider': toJson_VirtualNodeSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VirtualNodeSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VirtualNodeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VirtualNodeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VirtualNodeSpecDeletionPolicy
 */
export enum VirtualNodeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VirtualNodeSpecForProvider
 */
export interface VirtualNodeSpecForProvider {
  /**
   * Name of the service mesh in which to create the virtual node. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualNodeSpecForProvider#meshName
   */
  readonly meshName?: string;

  /**
   * Reference to a Mesh in appmesh to populate meshName.
   *
   * @schema VirtualNodeSpecForProvider#meshNameRef
   */
  readonly meshNameRef?: VirtualNodeSpecForProviderMeshNameRef;

  /**
   * Selector for a Mesh in appmesh to populate meshName.
   *
   * @schema VirtualNodeSpecForProvider#meshNameSelector
   */
  readonly meshNameSelector?: VirtualNodeSpecForProviderMeshNameSelector;

  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema VirtualNodeSpecForProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the virtual node. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualNodeSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VirtualNodeSpecForProvider#region
   */
  readonly region: string;

  /**
   * Virtual node specification to apply.
   *
   * @schema VirtualNodeSpecForProvider#spec
   */
  readonly spec?: VirtualNodeSpecForProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VirtualNodeSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualNodeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProvider(obj: VirtualNodeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshName': obj.meshName,
    'meshNameRef': toJson_VirtualNodeSpecForProviderMeshNameRef(obj.meshNameRef),
    'meshNameSelector': toJson_VirtualNodeSpecForProviderMeshNameSelector(obj.meshNameSelector),
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'region': obj.region,
    'spec': obj.spec?.map(y => toJson_VirtualNodeSpecForProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VirtualNodeSpecInitProvider
 */
export interface VirtualNodeSpecInitProvider {
  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema VirtualNodeSpecInitProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the virtual node. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualNodeSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Virtual node specification to apply.
   *
   * @schema VirtualNodeSpecInitProvider#spec
   */
  readonly spec?: VirtualNodeSpecInitProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VirtualNodeSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProvider(obj: VirtualNodeSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'spec': obj.spec?.map(y => toJson_VirtualNodeSpecInitProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VirtualNodeSpecManagementPolicies
 */
export enum VirtualNodeSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VirtualNodeSpecProviderConfigRef
 */
export interface VirtualNodeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualNodeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualNodeSpecProviderConfigRef#policy
   */
  readonly policy?: VirtualNodeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VirtualNodeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecProviderConfigRef(obj: VirtualNodeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualNodeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VirtualNodeSpecPublishConnectionDetailsTo
 */
export interface VirtualNodeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VirtualNodeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VirtualNodeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VirtualNodeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VirtualNodeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VirtualNodeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecPublishConnectionDetailsTo(obj: VirtualNodeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VirtualNodeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VirtualNodeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VirtualNodeSpecWriteConnectionSecretToRef
 */
export interface VirtualNodeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VirtualNodeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VirtualNodeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecWriteConnectionSecretToRef(obj: VirtualNodeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Mesh in appmesh to populate meshName.
 *
 * @schema VirtualNodeSpecForProviderMeshNameRef
 */
export interface VirtualNodeSpecForProviderMeshNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualNodeSpecForProviderMeshNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualNodeSpecForProviderMeshNameRef#policy
   */
  readonly policy?: VirtualNodeSpecForProviderMeshNameRefPolicy;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderMeshNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderMeshNameRef(obj: VirtualNodeSpecForProviderMeshNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualNodeSpecForProviderMeshNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Mesh in appmesh to populate meshName.
 *
 * @schema VirtualNodeSpecForProviderMeshNameSelector
 */
export interface VirtualNodeSpecForProviderMeshNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VirtualNodeSpecForProviderMeshNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VirtualNodeSpecForProviderMeshNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VirtualNodeSpecForProviderMeshNameSelector#policy
   */
  readonly policy?: VirtualNodeSpecForProviderMeshNameSelectorPolicy;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderMeshNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderMeshNameSelector(obj: VirtualNodeSpecForProviderMeshNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VirtualNodeSpecForProviderMeshNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpec
 */
export interface VirtualNodeSpecForProviderSpec {
  /**
   * Backends to which the virtual node is expected to send outbound traffic.
   *
   * @schema VirtualNodeSpecForProviderSpec#backend
   */
  readonly backend?: VirtualNodeSpecForProviderSpecBackend[];

  /**
   * Defaults for backends.
   *
   * @schema VirtualNodeSpecForProviderSpec#backendDefaults
   */
  readonly backendDefaults?: VirtualNodeSpecForProviderSpecBackendDefaults[];

  /**
   * Listeners from which the virtual node is expected to receive inbound traffic.
   *
   * @schema VirtualNodeSpecForProviderSpec#listener
   */
  readonly listener?: VirtualNodeSpecForProviderSpecListener[];

  /**
   * Inbound and outbound access logging information for the virtual node.
   *
   * @schema VirtualNodeSpecForProviderSpec#logging
   */
  readonly logging?: VirtualNodeSpecForProviderSpecLogging[];

  /**
   * Service discovery information for the virtual node.
   *
   * @schema VirtualNodeSpecForProviderSpec#serviceDiscovery
   */
  readonly serviceDiscovery?: VirtualNodeSpecForProviderSpecServiceDiscovery[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpec(obj: VirtualNodeSpecForProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backend': obj.backend?.map(y => toJson_VirtualNodeSpecForProviderSpecBackend(y)),
    'backendDefaults': obj.backendDefaults?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaults(y)),
    'listener': obj.listener?.map(y => toJson_VirtualNodeSpecForProviderSpecListener(y)),
    'logging': obj.logging?.map(y => toJson_VirtualNodeSpecForProviderSpecLogging(y)),
    'serviceDiscovery': obj.serviceDiscovery?.map(y => toJson_VirtualNodeSpecForProviderSpecServiceDiscovery(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpec
 */
export interface VirtualNodeSpecInitProviderSpec {
  /**
   * Backends to which the virtual node is expected to send outbound traffic.
   *
   * @schema VirtualNodeSpecInitProviderSpec#backend
   */
  readonly backend?: VirtualNodeSpecInitProviderSpecBackend[];

  /**
   * Defaults for backends.
   *
   * @schema VirtualNodeSpecInitProviderSpec#backendDefaults
   */
  readonly backendDefaults?: VirtualNodeSpecInitProviderSpecBackendDefaults[];

  /**
   * Listeners from which the virtual node is expected to receive inbound traffic.
   *
   * @schema VirtualNodeSpecInitProviderSpec#listener
   */
  readonly listener?: VirtualNodeSpecInitProviderSpecListener[];

  /**
   * Inbound and outbound access logging information for the virtual node.
   *
   * @schema VirtualNodeSpecInitProviderSpec#logging
   */
  readonly logging?: VirtualNodeSpecInitProviderSpecLogging[];

  /**
   * Service discovery information for the virtual node.
   *
   * @schema VirtualNodeSpecInitProviderSpec#serviceDiscovery
   */
  readonly serviceDiscovery?: VirtualNodeSpecInitProviderSpecServiceDiscovery[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpec(obj: VirtualNodeSpecInitProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backend': obj.backend?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackend(y)),
    'backendDefaults': obj.backendDefaults?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaults(y)),
    'listener': obj.listener?.map(y => toJson_VirtualNodeSpecInitProviderSpecListener(y)),
    'logging': obj.logging?.map(y => toJson_VirtualNodeSpecInitProviderSpecLogging(y)),
    'serviceDiscovery': obj.serviceDiscovery?.map(y => toJson_VirtualNodeSpecInitProviderSpecServiceDiscovery(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualNodeSpecProviderConfigRefPolicy
 */
export interface VirtualNodeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualNodeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VirtualNodeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualNodeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VirtualNodeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualNodeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecProviderConfigRefPolicy(obj: VirtualNodeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VirtualNodeSpecPublishConnectionDetailsToConfigRef
 */
export interface VirtualNodeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualNodeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualNodeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VirtualNodeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecPublishConnectionDetailsToConfigRef(obj: VirtualNodeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VirtualNodeSpecPublishConnectionDetailsToMetadata
 */
export interface VirtualNodeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VirtualNodeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VirtualNodeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VirtualNodeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecPublishConnectionDetailsToMetadata(obj: VirtualNodeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualNodeSpecForProviderMeshNameRefPolicy
 */
export interface VirtualNodeSpecForProviderMeshNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualNodeSpecForProviderMeshNameRefPolicy#resolution
   */
  readonly resolution?: VirtualNodeSpecForProviderMeshNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualNodeSpecForProviderMeshNameRefPolicy#resolve
   */
  readonly resolve?: VirtualNodeSpecForProviderMeshNameRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderMeshNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderMeshNameRefPolicy(obj: VirtualNodeSpecForProviderMeshNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VirtualNodeSpecForProviderMeshNameSelectorPolicy
 */
export interface VirtualNodeSpecForProviderMeshNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualNodeSpecForProviderMeshNameSelectorPolicy#resolution
   */
  readonly resolution?: VirtualNodeSpecForProviderMeshNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualNodeSpecForProviderMeshNameSelectorPolicy#resolve
   */
  readonly resolve?: VirtualNodeSpecForProviderMeshNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderMeshNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderMeshNameSelectorPolicy(obj: VirtualNodeSpecForProviderMeshNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackend
 */
export interface VirtualNodeSpecForProviderSpecBackend {
  /**
   * Virtual service to use as a backend for a virtual node.
   *
   * @schema VirtualNodeSpecForProviderSpecBackend#virtualService
   */
  readonly virtualService?: VirtualNodeSpecForProviderSpecBackendVirtualService[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackend(obj: VirtualNodeSpecForProviderSpecBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualService': obj.virtualService?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualService(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaults
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaults {
  /**
   * Client policy for the backend.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaults#clientPolicy
   */
  readonly clientPolicy?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicy[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaults' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaults(obj: VirtualNodeSpecForProviderSpecBackendDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientPolicy': obj.clientPolicy?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListener
 */
export interface VirtualNodeSpecForProviderSpecListener {
  /**
   * Connection pool information for the listener.
   *
   * @schema VirtualNodeSpecForProviderSpecListener#connectionPool
   */
  readonly connectionPool?: VirtualNodeSpecForProviderSpecListenerConnectionPool[];

  /**
   * Health check information for the listener.
   *
   * @schema VirtualNodeSpecForProviderSpecListener#healthCheck
   */
  readonly healthCheck?: VirtualNodeSpecForProviderSpecListenerHealthCheck[];

  /**
   * Outlier detection information for the listener.
   *
   * @schema VirtualNodeSpecForProviderSpecListener#outlierDetection
   */
  readonly outlierDetection?: VirtualNodeSpecForProviderSpecListenerOutlierDetection[];

  /**
   * Port mapping information for the listener.
   *
   * @schema VirtualNodeSpecForProviderSpecListener#portMapping
   */
  readonly portMapping?: VirtualNodeSpecForProviderSpecListenerPortMapping[];

  /**
   * Timeouts for different protocols.
   *
   * @schema VirtualNodeSpecForProviderSpecListener#timeout
   */
  readonly timeout?: VirtualNodeSpecForProviderSpecListenerTimeout[];

  /**
   * Transport Layer Security (TLS) client policy.
   *
   * @schema VirtualNodeSpecForProviderSpecListener#tls
   */
  readonly tls?: VirtualNodeSpecForProviderSpecListenerTls[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListener(obj: VirtualNodeSpecForProviderSpecListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': obj.connectionPool?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerConnectionPool(y)),
    'healthCheck': obj.healthCheck?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerHealthCheck(y)),
    'outlierDetection': obj.outlierDetection?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerOutlierDetection(y)),
    'portMapping': obj.portMapping?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerPortMapping(y)),
    'timeout': obj.timeout?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeout(y)),
    'tls': obj.tls?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecLogging
 */
export interface VirtualNodeSpecForProviderSpecLogging {
  /**
   * Access log configuration for a virtual node.
   *
   * @schema VirtualNodeSpecForProviderSpecLogging#accessLog
   */
  readonly accessLog?: VirtualNodeSpecForProviderSpecLoggingAccessLog[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecLogging(obj: VirtualNodeSpecForProviderSpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog?.map(y => toJson_VirtualNodeSpecForProviderSpecLoggingAccessLog(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecServiceDiscovery
 */
export interface VirtualNodeSpecForProviderSpecServiceDiscovery {
  /**
   * Any AWS Cloud Map information for the virtual node.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscovery#awsCloudMap
   */
  readonly awsCloudMap?: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap[];

  /**
   * DNS service name for the virtual node.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscovery#dns
   */
  readonly dns?: VirtualNodeSpecForProviderSpecServiceDiscoveryDns[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecServiceDiscovery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecServiceDiscovery(obj: VirtualNodeSpecForProviderSpecServiceDiscovery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsCloudMap': obj.awsCloudMap?.map(y => toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap(y)),
    'dns': obj.dns?.map(y => toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryDns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackend
 */
export interface VirtualNodeSpecInitProviderSpecBackend {
  /**
   * Virtual service to use as a backend for a virtual node.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackend#virtualService
   */
  readonly virtualService?: VirtualNodeSpecInitProviderSpecBackendVirtualService[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackend(obj: VirtualNodeSpecInitProviderSpecBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualService': obj.virtualService?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualService(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaults
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaults {
  /**
   * Client policy for the backend.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaults#clientPolicy
   */
  readonly clientPolicy?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicy[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaults' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaults(obj: VirtualNodeSpecInitProviderSpecBackendDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientPolicy': obj.clientPolicy?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListener
 */
export interface VirtualNodeSpecInitProviderSpecListener {
  /**
   * Connection pool information for the listener.
   *
   * @schema VirtualNodeSpecInitProviderSpecListener#connectionPool
   */
  readonly connectionPool?: VirtualNodeSpecInitProviderSpecListenerConnectionPool[];

  /**
   * Health check information for the listener.
   *
   * @schema VirtualNodeSpecInitProviderSpecListener#healthCheck
   */
  readonly healthCheck?: VirtualNodeSpecInitProviderSpecListenerHealthCheck[];

  /**
   * Outlier detection information for the listener.
   *
   * @schema VirtualNodeSpecInitProviderSpecListener#outlierDetection
   */
  readonly outlierDetection?: VirtualNodeSpecInitProviderSpecListenerOutlierDetection[];

  /**
   * Port mapping information for the listener.
   *
   * @schema VirtualNodeSpecInitProviderSpecListener#portMapping
   */
  readonly portMapping?: VirtualNodeSpecInitProviderSpecListenerPortMapping[];

  /**
   * Timeouts for different protocols.
   *
   * @schema VirtualNodeSpecInitProviderSpecListener#timeout
   */
  readonly timeout?: VirtualNodeSpecInitProviderSpecListenerTimeout[];

  /**
   * Transport Layer Security (TLS) client policy.
   *
   * @schema VirtualNodeSpecInitProviderSpecListener#tls
   */
  readonly tls?: VirtualNodeSpecInitProviderSpecListenerTls[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListener(obj: VirtualNodeSpecInitProviderSpecListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': obj.connectionPool?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerConnectionPool(y)),
    'healthCheck': obj.healthCheck?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerHealthCheck(y)),
    'outlierDetection': obj.outlierDetection?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerOutlierDetection(y)),
    'portMapping': obj.portMapping?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerPortMapping(y)),
    'timeout': obj.timeout?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeout(y)),
    'tls': obj.tls?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecLogging
 */
export interface VirtualNodeSpecInitProviderSpecLogging {
  /**
   * Access log configuration for a virtual node.
   *
   * @schema VirtualNodeSpecInitProviderSpecLogging#accessLog
   */
  readonly accessLog?: VirtualNodeSpecInitProviderSpecLoggingAccessLog[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecLogging(obj: VirtualNodeSpecInitProviderSpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog?.map(y => toJson_VirtualNodeSpecInitProviderSpecLoggingAccessLog(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecServiceDiscovery
 */
export interface VirtualNodeSpecInitProviderSpecServiceDiscovery {
  /**
   * Any AWS Cloud Map information for the virtual node.
   *
   * @schema VirtualNodeSpecInitProviderSpecServiceDiscovery#awsCloudMap
   */
  readonly awsCloudMap?: VirtualNodeSpecInitProviderSpecServiceDiscoveryAwsCloudMap[];

  /**
   * DNS service name for the virtual node.
   *
   * @schema VirtualNodeSpecInitProviderSpecServiceDiscovery#dns
   */
  readonly dns?: VirtualNodeSpecInitProviderSpecServiceDiscoveryDns[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecServiceDiscovery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecServiceDiscovery(obj: VirtualNodeSpecInitProviderSpecServiceDiscovery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsCloudMap': obj.awsCloudMap?.map(y => toJson_VirtualNodeSpecInitProviderSpecServiceDiscoveryAwsCloudMap(y)),
    'dns': obj.dns?.map(y => toJson_VirtualNodeSpecInitProviderSpecServiceDiscoveryDns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualNodeSpecProviderConfigRefPolicyResolution
 */
export enum VirtualNodeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualNodeSpecProviderConfigRefPolicyResolve
 */
export enum VirtualNodeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicy(obj: VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualNodeSpecForProviderMeshNameRefPolicyResolution
 */
export enum VirtualNodeSpecForProviderMeshNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualNodeSpecForProviderMeshNameRefPolicyResolve
 */
export enum VirtualNodeSpecForProviderMeshNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualNodeSpecForProviderMeshNameSelectorPolicyResolution
 */
export enum VirtualNodeSpecForProviderMeshNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualNodeSpecForProviderMeshNameSelectorPolicyResolve
 */
export enum VirtualNodeSpecForProviderMeshNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualService
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualService {
  /**
   * Client policy for the backend.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualService#clientPolicy
   */
  readonly clientPolicy?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicy[];

  /**
   * Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualService#virtualServiceName
   */
  readonly virtualServiceName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualService(obj: VirtualNodeSpecForProviderSpecBackendVirtualService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientPolicy': obj.clientPolicy?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicy(y)),
    'virtualServiceName': obj.virtualServiceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicy
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicy {
  /**
   * Transport Layer Security (TLS) client policy.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicy#tls
   */
  readonly tls?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicy(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tls': obj.tls?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerConnectionPool
 */
export interface VirtualNodeSpecForProviderSpecListenerConnectionPool {
  /**
   * Connection pool information for gRPC listeners.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerConnectionPool#grpc
   */
  readonly grpc?: VirtualNodeSpecForProviderSpecListenerConnectionPoolGrpc[];

  /**
   * Connection pool information for HTTP listeners.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerConnectionPool#http
   */
  readonly http?: VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp[];

  /**
   * Connection pool information for HTTP2 listeners.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerConnectionPool#http2
   */
  readonly http2?: VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp2[];

  /**
   * Connection pool information for TCP listeners.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerConnectionPool#tcp
   */
  readonly tcp?: VirtualNodeSpecForProviderSpecListenerConnectionPoolTcp[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerConnectionPool(obj: VirtualNodeSpecForProviderSpecListenerConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': obj.grpc?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerConnectionPoolGrpc(y)),
    'http': obj.http?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp(y)),
    'http2': obj.http2?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp2(y)),
    'tcp': obj.tcp?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerConnectionPoolTcp(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerHealthCheck
 */
export interface VirtualNodeSpecForProviderSpecListenerHealthCheck {
  /**
   * Number of consecutive successful health checks that must occur before declaring listener healthy.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerHealthCheck#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * Time period in milliseconds between each health check execution.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerHealthCheck#intervalMillis
   */
  readonly intervalMillis?: number;

  /**
   * File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerHealthCheck#path
   */
  readonly path?: string;

  /**
   * Port used for the port mapping.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerHealthCheck#port
   */
  readonly port?: number;

  /**
   * Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerHealthCheck#protocol
   */
  readonly protocol?: string;

  /**
   * Amount of time to wait when receiving a response from the health check, in milliseconds.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerHealthCheck#timeoutMillis
   */
  readonly timeoutMillis?: number;

  /**
   * Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerHealthCheck#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerHealthCheck(obj: VirtualNodeSpecForProviderSpecListenerHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThreshold': obj.healthyThreshold,
    'intervalMillis': obj.intervalMillis,
    'path': obj.path,
    'port': obj.port,
    'protocol': obj.protocol,
    'timeoutMillis': obj.timeoutMillis,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetection
 */
export interface VirtualNodeSpecForProviderSpecListenerOutlierDetection {
  /**
   * Base amount of time for which a host is ejected.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetection#baseEjectionDuration
   */
  readonly baseEjectionDuration?: VirtualNodeSpecForProviderSpecListenerOutlierDetectionBaseEjectionDuration[];

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetection#interval
   */
  readonly interval?: VirtualNodeSpecForProviderSpecListenerOutlierDetectionInterval[];

  /**
   * Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value. Minimum value of 0. Maximum value of 100.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Number of consecutive 5xx errors required for ejection. Minimum value of 1.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetection#maxServerErrors
   */
  readonly maxServerErrors?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerOutlierDetection(obj: VirtualNodeSpecForProviderSpecListenerOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionDuration': obj.baseEjectionDuration?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerOutlierDetectionBaseEjectionDuration(y)),
    'interval': obj.interval?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerOutlierDetectionInterval(y)),
    'maxEjectionPercent': obj.maxEjectionPercent,
    'maxServerErrors': obj.maxServerErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerPortMapping
 */
export interface VirtualNodeSpecForProviderSpecListenerPortMapping {
  /**
   * Port used for the port mapping.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerPortMapping#port
   */
  readonly port?: number;

  /**
   * Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerPortMapping#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerPortMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerPortMapping(obj: VirtualNodeSpecForProviderSpecListenerPortMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeout
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeout {
  /**
   * Connection pool information for gRPC listeners.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeout#grpc
   */
  readonly grpc?: VirtualNodeSpecForProviderSpecListenerTimeoutGrpc[];

  /**
   * Connection pool information for HTTP listeners.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeout#http
   */
  readonly http?: VirtualNodeSpecForProviderSpecListenerTimeoutHttp[];

  /**
   * Connection pool information for HTTP2 listeners.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeout#http2
   */
  readonly http2?: VirtualNodeSpecForProviderSpecListenerTimeoutHttp2[];

  /**
   * Connection pool information for TCP listeners.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeout#tcp
   */
  readonly tcp?: VirtualNodeSpecForProviderSpecListenerTimeoutTcp[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeout(obj: VirtualNodeSpecForProviderSpecListenerTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': obj.grpc?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutGrpc(y)),
    'http': obj.http?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttp(y)),
    'http2': obj.http2?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttp2(y)),
    'tcp': obj.tcp?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutTcp(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTls
 */
export interface VirtualNodeSpecForProviderSpecListenerTls {
  /**
   * Virtual node's client's Transport Layer Security (TLS) certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTls#certificate
   */
  readonly certificate?: VirtualNodeSpecForProviderSpecListenerTlsCertificate[];

  /**
   * Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTls#mode
   */
  readonly mode?: string;

  /**
   * TLS validation context.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTls#validation
   */
  readonly validation?: VirtualNodeSpecForProviderSpecListenerTlsValidation[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTls(obj: VirtualNodeSpecForProviderSpecListenerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTlsCertificate(y)),
    'mode': obj.mode,
    'validation': obj.validation?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTlsValidation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecLoggingAccessLog
 */
export interface VirtualNodeSpecForProviderSpecLoggingAccessLog {
  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecLoggingAccessLog#file
   */
  readonly file?: VirtualNodeSpecForProviderSpecLoggingAccessLogFile[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecLoggingAccessLog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecLoggingAccessLog(obj: VirtualNodeSpecForProviderSpecLoggingAccessLog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualNodeSpecForProviderSpecLoggingAccessLogFile(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap
 */
export interface VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap {
  /**
   * String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the AWS Cloud Map namespace to use. Use the aws_service_discovery_http_namespace resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap#namespaceName
   */
  readonly namespaceName?: string;

  /**
   * Reference to a HTTPNamespace in servicediscovery to populate namespaceName.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap#namespaceNameRef
   */
  readonly namespaceNameRef?: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef;

  /**
   * Selector for a HTTPNamespace in servicediscovery to populate namespaceName.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap#namespaceNameSelector
   */
  readonly namespaceNameSelector?: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector;

  /**
   * attribute of the dns object to hostname.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap(obj: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespaceName': obj.namespaceName,
    'namespaceNameRef': toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef(obj.namespaceNameRef),
    'namespaceNameSelector': toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector(obj.namespaceNameSelector),
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryDns
 */
export interface VirtualNodeSpecForProviderSpecServiceDiscoveryDns {
  /**
   * DNS host name for your virtual node.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryDns#hostname
   */
  readonly hostname?: string;

  /**
   * The preferred IP version that this virtual node uses. Valid values: IPv6_PREFERRED, IPv4_PREFERRED, IPv4_ONLY, IPv6_ONLY.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryDns#ipPreference
   */
  readonly ipPreference?: string;

  /**
   * The DNS response type for the virtual node. Valid values: LOADBALANCER, ENDPOINTS.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryDns#responseType
   */
  readonly responseType?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecServiceDiscoveryDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryDns(obj: VirtualNodeSpecForProviderSpecServiceDiscoveryDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname,
    'ipPreference': obj.ipPreference,
    'responseType': obj.responseType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualService
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualService {
  /**
   * Client policy for the backend.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualService#clientPolicy
   */
  readonly clientPolicy?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicy[];

  /**
   * Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualService#virtualServiceName
   */
  readonly virtualServiceName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualService(obj: VirtualNodeSpecInitProviderSpecBackendVirtualService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientPolicy': obj.clientPolicy?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicy(y)),
    'virtualServiceName': obj.virtualServiceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicy
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicy {
  /**
   * Transport Layer Security (TLS) client policy.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicy#tls
   */
  readonly tls?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicy(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tls': obj.tls?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPool
 */
export interface VirtualNodeSpecInitProviderSpecListenerConnectionPool {
  /**
   * Connection pool information for gRPC listeners.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPool#grpc
   */
  readonly grpc?: VirtualNodeSpecInitProviderSpecListenerConnectionPoolGrpc[];

  /**
   * Connection pool information for HTTP listeners.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPool#http
   */
  readonly http?: VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp[];

  /**
   * Connection pool information for HTTP2 listeners.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPool#http2
   */
  readonly http2?: VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp2[];

  /**
   * Connection pool information for TCP listeners.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPool#tcp
   */
  readonly tcp?: VirtualNodeSpecInitProviderSpecListenerConnectionPoolTcp[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerConnectionPool(obj: VirtualNodeSpecInitProviderSpecListenerConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': obj.grpc?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerConnectionPoolGrpc(y)),
    'http': obj.http?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp(y)),
    'http2': obj.http2?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp2(y)),
    'tcp': obj.tcp?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerConnectionPoolTcp(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerHealthCheck
 */
export interface VirtualNodeSpecInitProviderSpecListenerHealthCheck {
  /**
   * Number of consecutive successful health checks that must occur before declaring listener healthy.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerHealthCheck#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * Time period in milliseconds between each health check execution.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerHealthCheck#intervalMillis
   */
  readonly intervalMillis?: number;

  /**
   * File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerHealthCheck#path
   */
  readonly path?: string;

  /**
   * Port used for the port mapping.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerHealthCheck#port
   */
  readonly port?: number;

  /**
   * Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerHealthCheck#protocol
   */
  readonly protocol?: string;

  /**
   * Amount of time to wait when receiving a response from the health check, in milliseconds.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerHealthCheck#timeoutMillis
   */
  readonly timeoutMillis?: number;

  /**
   * Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerHealthCheck#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerHealthCheck(obj: VirtualNodeSpecInitProviderSpecListenerHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThreshold': obj.healthyThreshold,
    'intervalMillis': obj.intervalMillis,
    'path': obj.path,
    'port': obj.port,
    'protocol': obj.protocol,
    'timeoutMillis': obj.timeoutMillis,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetection
 */
export interface VirtualNodeSpecInitProviderSpecListenerOutlierDetection {
  /**
   * Base amount of time for which a host is ejected.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetection#baseEjectionDuration
   */
  readonly baseEjectionDuration?: VirtualNodeSpecInitProviderSpecListenerOutlierDetectionBaseEjectionDuration[];

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetection#interval
   */
  readonly interval?: VirtualNodeSpecInitProviderSpecListenerOutlierDetectionInterval[];

  /**
   * Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value. Minimum value of 0. Maximum value of 100.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Number of consecutive 5xx errors required for ejection. Minimum value of 1.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetection#maxServerErrors
   */
  readonly maxServerErrors?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerOutlierDetection(obj: VirtualNodeSpecInitProviderSpecListenerOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionDuration': obj.baseEjectionDuration?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerOutlierDetectionBaseEjectionDuration(y)),
    'interval': obj.interval?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerOutlierDetectionInterval(y)),
    'maxEjectionPercent': obj.maxEjectionPercent,
    'maxServerErrors': obj.maxServerErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerPortMapping
 */
export interface VirtualNodeSpecInitProviderSpecListenerPortMapping {
  /**
   * Port used for the port mapping.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerPortMapping#port
   */
  readonly port?: number;

  /**
   * Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerPortMapping#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerPortMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerPortMapping(obj: VirtualNodeSpecInitProviderSpecListenerPortMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeout
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeout {
  /**
   * Connection pool information for gRPC listeners.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeout#grpc
   */
  readonly grpc?: VirtualNodeSpecInitProviderSpecListenerTimeoutGrpc[];

  /**
   * Connection pool information for HTTP listeners.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeout#http
   */
  readonly http?: VirtualNodeSpecInitProviderSpecListenerTimeoutHttp[];

  /**
   * Connection pool information for HTTP2 listeners.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeout#http2
   */
  readonly http2?: VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2[];

  /**
   * Connection pool information for TCP listeners.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeout#tcp
   */
  readonly tcp?: VirtualNodeSpecInitProviderSpecListenerTimeoutTcp[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeout(obj: VirtualNodeSpecInitProviderSpecListenerTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': obj.grpc?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutGrpc(y)),
    'http': obj.http?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttp(y)),
    'http2': obj.http2?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2(y)),
    'tcp': obj.tcp?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutTcp(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTls
 */
export interface VirtualNodeSpecInitProviderSpecListenerTls {
  /**
   * Virtual node's client's Transport Layer Security (TLS) certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTls#certificate
   */
  readonly certificate?: VirtualNodeSpecInitProviderSpecListenerTlsCertificate[];

  /**
   * Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTls#mode
   */
  readonly mode?: string;

  /**
   * TLS validation context.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTls#validation
   */
  readonly validation?: VirtualNodeSpecInitProviderSpecListenerTlsValidation[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTls(obj: VirtualNodeSpecInitProviderSpecListenerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTlsCertificate(y)),
    'mode': obj.mode,
    'validation': obj.validation?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLog
 */
export interface VirtualNodeSpecInitProviderSpecLoggingAccessLog {
  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLog#file
   */
  readonly file?: VirtualNodeSpecInitProviderSpecLoggingAccessLogFile[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecLoggingAccessLog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecLoggingAccessLog(obj: VirtualNodeSpecInitProviderSpecLoggingAccessLog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualNodeSpecInitProviderSpecLoggingAccessLogFile(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecServiceDiscoveryAwsCloudMap
 */
export interface VirtualNodeSpecInitProviderSpecServiceDiscoveryAwsCloudMap {
  /**
   * String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
   *
   * @schema VirtualNodeSpecInitProviderSpecServiceDiscoveryAwsCloudMap#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * attribute of the dns object to hostname.
   *
   * @schema VirtualNodeSpecInitProviderSpecServiceDiscoveryAwsCloudMap#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecServiceDiscoveryAwsCloudMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecServiceDiscoveryAwsCloudMap(obj: VirtualNodeSpecInitProviderSpecServiceDiscoveryAwsCloudMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecServiceDiscoveryDns
 */
export interface VirtualNodeSpecInitProviderSpecServiceDiscoveryDns {
  /**
   * DNS host name for your virtual node.
   *
   * @schema VirtualNodeSpecInitProviderSpecServiceDiscoveryDns#hostname
   */
  readonly hostname?: string;

  /**
   * The preferred IP version that this virtual node uses. Valid values: IPv6_PREFERRED, IPv4_PREFERRED, IPv4_ONLY, IPv6_ONLY.
   *
   * @schema VirtualNodeSpecInitProviderSpecServiceDiscoveryDns#ipPreference
   */
  readonly ipPreference?: string;

  /**
   * The DNS response type for the virtual node. Valid values: LOADBALANCER, ENDPOINTS.
   *
   * @schema VirtualNodeSpecInitProviderSpecServiceDiscoveryDns#responseType
   */
  readonly responseType?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecServiceDiscoveryDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecServiceDiscoveryDns(obj: VirtualNodeSpecInitProviderSpecServiceDiscoveryDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname,
    'ipPreference': obj.ipPreference,
    'responseType': obj.responseType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VirtualNodeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicy
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicy {
  /**
   * Transport Layer Security (TLS) client policy.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicy#tls
   */
  readonly tls?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicy(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tls': obj.tls?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls {
  /**
   * Virtual node's client's Transport Layer Security (TLS) certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls#certificate
   */
  readonly certificate?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate[];

  /**
   * Whether the policy is enforced. Default is true.
   *
   * @default true.
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls#enforce
   */
  readonly enforce?: boolean;

  /**
   * One or more ports that the policy is enforced for.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls#ports
   */
  readonly ports?: number[];

  /**
   * TLS validation context.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls#validation
   */
  readonly validation?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidation[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate(y)),
    'enforce': obj.enforce,
    'ports': obj.ports?.map(y => y),
    'validation': obj.validation?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerConnectionPoolGrpc
 */
export interface VirtualNodeSpecForProviderSpecListenerConnectionPoolGrpc {
  /**
   * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerConnectionPoolGrpc#maxRequests
   */
  readonly maxRequests?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerConnectionPoolGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerConnectionPoolGrpc(obj: VirtualNodeSpecForProviderSpecListenerConnectionPoolGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRequests': obj.maxRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp
 */
export interface VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp {
  /**
   * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp(obj: VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxPendingRequests': obj.maxPendingRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp2
 */
export interface VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp2 {
  /**
   * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp2#maxRequests
   */
  readonly maxRequests?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp2(obj: VirtualNodeSpecForProviderSpecListenerConnectionPoolHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRequests': obj.maxRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerConnectionPoolTcp
 */
export interface VirtualNodeSpecForProviderSpecListenerConnectionPoolTcp {
  /**
   * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerConnectionPoolTcp(obj: VirtualNodeSpecForProviderSpecListenerConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetectionBaseEjectionDuration
 */
export interface VirtualNodeSpecForProviderSpecListenerOutlierDetectionBaseEjectionDuration {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetectionBaseEjectionDuration#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetectionBaseEjectionDuration#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerOutlierDetectionBaseEjectionDuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerOutlierDetectionBaseEjectionDuration(obj: VirtualNodeSpecForProviderSpecListenerOutlierDetectionBaseEjectionDuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetectionInterval
 */
export interface VirtualNodeSpecForProviderSpecListenerOutlierDetectionInterval {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetectionInterval#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerOutlierDetectionInterval#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerOutlierDetectionInterval' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerOutlierDetectionInterval(obj: VirtualNodeSpecForProviderSpecListenerOutlierDetectionInterval | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutGrpc
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutGrpc {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutGrpc#idle
   */
  readonly idle?: VirtualNodeSpecForProviderSpecListenerTimeoutGrpcIdle[];

  /**
   * Per request timeout.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutGrpc#perRequest
   */
  readonly perRequest?: VirtualNodeSpecForProviderSpecListenerTimeoutGrpcPerRequest[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutGrpc(obj: VirtualNodeSpecForProviderSpecListenerTimeoutGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutGrpcIdle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutGrpcPerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutHttp {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp#idle
   */
  readonly idle?: VirtualNodeSpecForProviderSpecListenerTimeoutHttpIdle[];

  /**
   * Per request timeout.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp#perRequest
   */
  readonly perRequest?: VirtualNodeSpecForProviderSpecListenerTimeoutHttpPerRequest[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttp(obj: VirtualNodeSpecForProviderSpecListenerTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttpIdle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttpPerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp2
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutHttp2 {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp2#idle
   */
  readonly idle?: VirtualNodeSpecForProviderSpecListenerTimeoutHttp2Idle[];

  /**
   * Per request timeout.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp2#perRequest
   */
  readonly perRequest?: VirtualNodeSpecForProviderSpecListenerTimeoutHttp2PerRequest[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutHttp2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttp2(obj: VirtualNodeSpecForProviderSpecListenerTimeoutHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttp2Idle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttp2PerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutTcp
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutTcp {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutTcp#idle
   */
  readonly idle?: VirtualNodeSpecForProviderSpecListenerTimeoutTcpIdle[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutTcp(obj: VirtualNodeSpecForProviderSpecListenerTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTimeoutTcpIdle(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificate
 */
export interface VirtualNodeSpecForProviderSpecListenerTlsCertificate {
  /**
   * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificate#acm
   */
  readonly acm?: VirtualNodeSpecForProviderSpecListenerTlsCertificateAcm[];

  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificate#file
   */
  readonly file?: VirtualNodeSpecForProviderSpecListenerTlsCertificateFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificate#sds
   */
  readonly sds?: VirtualNodeSpecForProviderSpecListenerTlsCertificateSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTlsCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTlsCertificate(obj: VirtualNodeSpecForProviderSpecListenerTlsCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acm': obj.acm?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTlsCertificateAcm(y)),
    'file': obj.file?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTlsCertificateFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTlsCertificateSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTlsValidation
 */
export interface VirtualNodeSpecForProviderSpecListenerTlsValidation {
  /**
   * SANs for a TLS validation context.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsValidation#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNames[];

  /**
   * TLS validation context trust.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsValidation#trust
   */
  readonly trust?: VirtualNodeSpecForProviderSpecListenerTlsValidationTrust[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTlsValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTlsValidation(obj: VirtualNodeSpecForProviderSpecListenerTlsValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNames(y)),
    'trust': obj.trust?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTlsValidationTrust(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecLoggingAccessLogFile
 */
export interface VirtualNodeSpecForProviderSpecLoggingAccessLogFile {
  /**
   * The specified format for the logs.
   *
   * @schema VirtualNodeSpecForProviderSpecLoggingAccessLogFile#format
   */
  readonly format?: VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormat[];

  /**
   * File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecLoggingAccessLogFile#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecLoggingAccessLogFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecLoggingAccessLogFile(obj: VirtualNodeSpecForProviderSpecLoggingAccessLogFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format?.map(y => toJson_VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormat(y)),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HTTPNamespace in servicediscovery to populate namespaceName.
 *
 * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef
 */
export interface VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef#policy
   */
  readonly policy?: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef(obj: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HTTPNamespace in servicediscovery to populate namespaceName.
 *
 * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector
 */
export interface VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector#policy
   */
  readonly policy?: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector(obj: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicy
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicy {
  /**
   * Transport Layer Security (TLS) client policy.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicy#tls
   */
  readonly tls?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicy(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tls': obj.tls?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls {
  /**
   * Virtual node's client's Transport Layer Security (TLS) certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls#certificate
   */
  readonly certificate?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate[];

  /**
   * Whether the policy is enforced. Default is true.
   *
   * @default true.
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls#enforce
   */
  readonly enforce?: boolean;

  /**
   * One or more ports that the policy is enforced for.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls#ports
   */
  readonly ports?: number[];

  /**
   * TLS validation context.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls#validation
   */
  readonly validation?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate(y)),
    'enforce': obj.enforce,
    'ports': obj.ports?.map(y => y),
    'validation': obj.validation?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPoolGrpc
 */
export interface VirtualNodeSpecInitProviderSpecListenerConnectionPoolGrpc {
  /**
   * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPoolGrpc#maxRequests
   */
  readonly maxRequests?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerConnectionPoolGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerConnectionPoolGrpc(obj: VirtualNodeSpecInitProviderSpecListenerConnectionPoolGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRequests': obj.maxRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp
 */
export interface VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp {
  /**
   * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp(obj: VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxPendingRequests': obj.maxPendingRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp2
 */
export interface VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp2 {
  /**
   * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp2#maxRequests
   */
  readonly maxRequests?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp2(obj: VirtualNodeSpecInitProviderSpecListenerConnectionPoolHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRequests': obj.maxRequests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPoolTcp
 */
export interface VirtualNodeSpecInitProviderSpecListenerConnectionPoolTcp {
  /**
   * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerConnectionPoolTcp(obj: VirtualNodeSpecInitProviderSpecListenerConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetectionBaseEjectionDuration
 */
export interface VirtualNodeSpecInitProviderSpecListenerOutlierDetectionBaseEjectionDuration {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetectionBaseEjectionDuration#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetectionBaseEjectionDuration#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerOutlierDetectionBaseEjectionDuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerOutlierDetectionBaseEjectionDuration(obj: VirtualNodeSpecInitProviderSpecListenerOutlierDetectionBaseEjectionDuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetectionInterval
 */
export interface VirtualNodeSpecInitProviderSpecListenerOutlierDetectionInterval {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetectionInterval#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerOutlierDetectionInterval#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerOutlierDetectionInterval' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerOutlierDetectionInterval(obj: VirtualNodeSpecInitProviderSpecListenerOutlierDetectionInterval | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutGrpc
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutGrpc {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutGrpc#idle
   */
  readonly idle?: VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcIdle[];

  /**
   * Per request timeout.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutGrpc#perRequest
   */
  readonly perRequest?: VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcPerRequest[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutGrpc(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcIdle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcPerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutHttp {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp#idle
   */
  readonly idle?: VirtualNodeSpecInitProviderSpecListenerTimeoutHttpIdle[];

  /**
   * Per request timeout.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp#perRequest
   */
  readonly perRequest?: VirtualNodeSpecInitProviderSpecListenerTimeoutHttpPerRequest[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttp(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttpIdle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttpPerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2 {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2#idle
   */
  readonly idle?: VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2Idle[];

  /**
   * Per request timeout.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2#perRequest
   */
  readonly perRequest?: VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2PerRequest[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2Idle(y)),
    'perRequest': obj.perRequest?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2PerRequest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutTcp
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutTcp {
  /**
   * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutTcp#idle
   */
  readonly idle?: VirtualNodeSpecInitProviderSpecListenerTimeoutTcpIdle[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutTcp(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutTcpIdle(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificate
 */
export interface VirtualNodeSpecInitProviderSpecListenerTlsCertificate {
  /**
   * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificate#acm
   */
  readonly acm?: VirtualNodeSpecInitProviderSpecListenerTlsCertificateAcm[];

  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificate#file
   */
  readonly file?: VirtualNodeSpecInitProviderSpecListenerTlsCertificateFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificate#sds
   */
  readonly sds?: VirtualNodeSpecInitProviderSpecListenerTlsCertificateSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTlsCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTlsCertificate(obj: VirtualNodeSpecInitProviderSpecListenerTlsCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acm': obj.acm?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTlsCertificateAcm(y)),
    'file': obj.file?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTlsCertificateFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTlsCertificateSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidation
 */
export interface VirtualNodeSpecInitProviderSpecListenerTlsValidation {
  /**
   * SANs for a TLS validation context.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidation#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames[];

  /**
   * TLS validation context trust.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidation#trust
   */
  readonly trust?: VirtualNodeSpecInitProviderSpecListenerTlsValidationTrust[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTlsValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidation(obj: VirtualNodeSpecInitProviderSpecListenerTlsValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames(y)),
    'trust': obj.trust?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidationTrust(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLogFile
 */
export interface VirtualNodeSpecInitProviderSpecLoggingAccessLogFile {
  /**
   * The specified format for the logs.
   *
   * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLogFile#format
   */
  readonly format?: VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormat[];

  /**
   * File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLogFile#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecLoggingAccessLogFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecLoggingAccessLogFile(obj: VirtualNodeSpecInitProviderSpecLoggingAccessLogFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format?.map(y => toJson_VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormat(y)),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls {
  /**
   * Virtual node's client's Transport Layer Security (TLS) certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls#certificate
   */
  readonly certificate?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate[];

  /**
   * Whether the policy is enforced. Default is true.
   *
   * @default true.
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls#enforce
   */
  readonly enforce?: boolean;

  /**
   * One or more ports that the policy is enforced for.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls#ports
   */
  readonly ports?: number[];

  /**
   * TLS validation context.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls#validation
   */
  readonly validation?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidation[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate(y)),
    'enforce': obj.enforce,
    'ports': obj.ports?.map(y => y),
    'validation': obj.validation?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate {
  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate#file
   */
  readonly file?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate#sds
   */
  readonly sds?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidation
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidation {
  /**
   * SANs for a TLS validation context.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidation#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames[];

  /**
   * TLS validation context trust.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidation#trust
   */
  readonly trust?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidation(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames(y)),
    'trust': obj.trust?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutGrpcIdle
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutGrpcIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutGrpcIdle#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutGrpcIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutGrpcIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutGrpcIdle(obj: VirtualNodeSpecForProviderSpecListenerTimeoutGrpcIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutGrpcPerRequest
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutGrpcPerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutGrpcPerRequest#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutGrpcPerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutGrpcPerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutGrpcPerRequest(obj: VirtualNodeSpecForProviderSpecListenerTimeoutGrpcPerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttpIdle
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutHttpIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttpIdle#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttpIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutHttpIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttpIdle(obj: VirtualNodeSpecForProviderSpecListenerTimeoutHttpIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttpPerRequest
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutHttpPerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttpPerRequest#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttpPerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutHttpPerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttpPerRequest(obj: VirtualNodeSpecForProviderSpecListenerTimeoutHttpPerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp2Idle
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutHttp2Idle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp2Idle#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp2Idle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutHttp2Idle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttp2Idle(obj: VirtualNodeSpecForProviderSpecListenerTimeoutHttp2Idle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp2PerRequest
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutHttp2PerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp2PerRequest#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutHttp2PerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutHttp2PerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutHttp2PerRequest(obj: VirtualNodeSpecForProviderSpecListenerTimeoutHttp2PerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTimeoutTcpIdle
 */
export interface VirtualNodeSpecForProviderSpecListenerTimeoutTcpIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutTcpIdle#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTimeoutTcpIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTimeoutTcpIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTimeoutTcpIdle(obj: VirtualNodeSpecForProviderSpecListenerTimeoutTcpIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificateAcm
 */
export interface VirtualNodeSpecForProviderSpecListenerTlsCertificateAcm {
  /**
   * ARN for the certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificateAcm#certificateArn
   */
  readonly certificateArn?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTlsCertificateAcm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTlsCertificateAcm(obj: VirtualNodeSpecForProviderSpecListenerTlsCertificateAcm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateArn': obj.certificateArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificateFile
 */
export interface VirtualNodeSpecForProviderSpecListenerTlsCertificateFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificateFile#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificateFile#privateKey
   */
  readonly privateKey?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTlsCertificateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTlsCertificateFile(obj: VirtualNodeSpecForProviderSpecListenerTlsCertificateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
    'privateKey': obj.privateKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificateSds
 */
export interface VirtualNodeSpecForProviderSpecListenerTlsCertificateSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsCertificateSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTlsCertificateSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTlsCertificateSds(obj: VirtualNodeSpecForProviderSpecListenerTlsCertificateSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNames
 */
export interface VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNames {
  /**
   * Criteria for determining a SAN's match.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNames#match
   */
  readonly match?: VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNames(obj: VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationTrust
 */
export interface VirtualNodeSpecForProviderSpecListenerTlsValidationTrust {
  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationTrust#file
   */
  readonly file?: VirtualNodeSpecForProviderSpecListenerTlsValidationTrustFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationTrust#sds
   */
  readonly sds?: VirtualNodeSpecForProviderSpecListenerTlsValidationTrustSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTlsValidationTrust' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTlsValidationTrust(obj: VirtualNodeSpecForProviderSpecListenerTlsValidationTrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTlsValidationTrustFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecForProviderSpecListenerTlsValidationTrustSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormat
 */
export interface VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormat {
  /**
   * The logging format for JSON.
   *
   * @schema VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormat#json
   */
  readonly json?: VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormatJson[];

  /**
   * The logging format for text. Must be between 1 and 1000 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormat#text
   */
  readonly text?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormat(obj: VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'json': obj.json?.map(y => toJson_VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormatJson(y)),
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy
 */
export interface VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy#resolution
   */
  readonly resolution?: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy#resolve
   */
  readonly resolve?: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy(obj: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy
 */
export interface VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy#resolution
   */
  readonly resolution?: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy#resolve
   */
  readonly resolve?: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy(obj: VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls {
  /**
   * Virtual node's client's Transport Layer Security (TLS) certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls#certificate
   */
  readonly certificate?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate[];

  /**
   * Whether the policy is enforced. Default is true.
   *
   * @default true.
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls#enforce
   */
  readonly enforce?: boolean;

  /**
   * One or more ports that the policy is enforced for.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls#ports
   */
  readonly ports?: number[];

  /**
   * TLS validation context.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls#validation
   */
  readonly validation?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate(y)),
    'enforce': obj.enforce,
    'ports': obj.ports?.map(y => y),
    'validation': obj.validation?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate {
  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate#file
   */
  readonly file?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate#sds
   */
  readonly sds?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation {
  /**
   * SANs for a TLS validation context.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames[];

  /**
   * TLS validation context trust.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation#trust
   */
  readonly trust?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames(y)),
    'trust': obj.trust?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcIdle
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcIdle#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcIdle(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcPerRequest
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcPerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcPerRequest#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcPerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcPerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcPerRequest(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutGrpcPerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttpIdle
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutHttpIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttpIdle#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttpIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutHttpIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttpIdle(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutHttpIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttpPerRequest
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutHttpPerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttpPerRequest#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttpPerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutHttpPerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttpPerRequest(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutHttpPerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2Idle
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2Idle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2Idle#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2Idle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2Idle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2Idle(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2Idle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2PerRequest
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2PerRequest {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2PerRequest#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2PerRequest#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2PerRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2PerRequest(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutHttp2PerRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutTcpIdle
 */
export interface VirtualNodeSpecInitProviderSpecListenerTimeoutTcpIdle {
  /**
   * Unit of time. Valid values: ms, s.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutTcpIdle#unit
   */
  readonly unit?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTimeoutTcpIdle#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTimeoutTcpIdle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTimeoutTcpIdle(obj: VirtualNodeSpecInitProviderSpecListenerTimeoutTcpIdle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificateAcm
 */
export interface VirtualNodeSpecInitProviderSpecListenerTlsCertificateAcm {
  /**
   * ARN for the certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificateAcm#certificateArn
   */
  readonly certificateArn?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTlsCertificateAcm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTlsCertificateAcm(obj: VirtualNodeSpecInitProviderSpecListenerTlsCertificateAcm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateArn': obj.certificateArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificateFile
 */
export interface VirtualNodeSpecInitProviderSpecListenerTlsCertificateFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificateFile#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificateFile#privateKey
   */
  readonly privateKey?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTlsCertificateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTlsCertificateFile(obj: VirtualNodeSpecInitProviderSpecListenerTlsCertificateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
    'privateKey': obj.privateKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificateSds
 */
export interface VirtualNodeSpecInitProviderSpecListenerTlsCertificateSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsCertificateSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTlsCertificateSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTlsCertificateSds(obj: VirtualNodeSpecInitProviderSpecListenerTlsCertificateSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames
 */
export interface VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames {
  /**
   * Criteria for determining a SAN's match.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames#match
   */
  readonly match?: VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames(obj: VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationTrust
 */
export interface VirtualNodeSpecInitProviderSpecListenerTlsValidationTrust {
  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationTrust#file
   */
  readonly file?: VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationTrust#sds
   */
  readonly sds?: VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTlsValidationTrust' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidationTrust(obj: VirtualNodeSpecInitProviderSpecListenerTlsValidationTrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormat
 */
export interface VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormat {
  /**
   * The logging format for JSON.
   *
   * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormat#json
   */
  readonly json?: VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormatJson[];

  /**
   * The logging format for text. Must be between 1 and 1000 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormat#text
   */
  readonly text?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormat(obj: VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'json': obj.json?.map(y => toJson_VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormatJson(y)),
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate {
  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate#file
   */
  readonly file?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate#sds
   */
  readonly sds?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidation
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidation {
  /**
   * SANs for a TLS validation context.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidation#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames[];

  /**
   * TLS validation context trust.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidation#trust
   */
  readonly trust?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidation(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames(y)),
    'trust': obj.trust?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile#privateKey
   */
  readonly privateKey?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
    'privateKey': obj.privateKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsCertificateSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
  /**
   * Criteria for determining a SAN's match.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames#match
   */
  readonly match?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust {
  /**
   * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#acm
   */
  readonly acm?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm[];

  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#file
   */
  readonly file?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#sds
   */
  readonly sds?: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acm': obj.acm?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(y)),
    'file': obj.file?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch
 */
export interface VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch {
  /**
   * Values sent must match the specified values exactly.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch#exact
   */
  readonly exact?: string[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch(obj: VirtualNodeSpecForProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationTrustFile
 */
export interface VirtualNodeSpecForProviderSpecListenerTlsValidationTrustFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationTrustFile#certificateChain
   */
  readonly certificateChain?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTlsValidationTrustFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTlsValidationTrustFile(obj: VirtualNodeSpecForProviderSpecListenerTlsValidationTrustFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationTrustSds
 */
export interface VirtualNodeSpecForProviderSpecListenerTlsValidationTrustSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecForProviderSpecListenerTlsValidationTrustSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecListenerTlsValidationTrustSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecListenerTlsValidationTrustSds(obj: VirtualNodeSpecForProviderSpecListenerTlsValidationTrustSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormatJson
 */
export interface VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormatJson {
  /**
   * The specified key for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormatJson#key
   */
  readonly key?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormatJson#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormatJson' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormatJson(obj: VirtualNodeSpecForProviderSpecLoggingAccessLogFileFormatJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolution
 */
export enum VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolve
 */
export enum VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolution
 */
export enum VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolve
 */
export enum VirtualNodeSpecForProviderSpecServiceDiscoveryAwsCloudMapNamespaceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate {
  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate#file
   */
  readonly file?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate#sds
   */
  readonly sds?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'file': obj.file?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation {
  /**
   * SANs for a TLS validation context.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation#subjectAlternativeNames
   */
  readonly subjectAlternativeNames?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames[];

  /**
   * TLS validation context trust.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation#trust
   */
  readonly trust?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subjectAlternativeNames': obj.subjectAlternativeNames?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames(y)),
    'trust': obj.trust?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile#privateKey
   */
  readonly privateKey?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
    'privateKey': obj.privateKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsCertificateSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
  /**
   * Criteria for determining a SAN's match.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames#match
   */
  readonly match?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust {
  /**
   * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#acm
   */
  readonly acm?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm[];

  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#file
   */
  readonly file?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust#sds
   */
  readonly sds?: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acm': obj.acm?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(y)),
    'file': obj.file?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch
 */
export interface VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch {
  /**
   * Values sent must match the specified values exactly.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch#exact
   */
  readonly exact?: string[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch(obj: VirtualNodeSpecInitProviderSpecListenerTlsValidationSubjectAlternativeNamesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustFile
 */
export interface VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustFile#certificateChain
   */
  readonly certificateChain?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustFile(obj: VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustSds
 */
export interface VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustSds(obj: VirtualNodeSpecInitProviderSpecListenerTlsValidationTrustSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormatJson
 */
export interface VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormatJson {
  /**
   * The specified key for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormatJson#key
   */
  readonly key?: string;

  /**
   * The specified value for the JSON. Must be between 1 and 100 characters in length.
   *
   * @schema VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormatJson#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormatJson' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormatJson(obj: VirtualNodeSpecInitProviderSpecLoggingAccessLogFileFormatJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile#privateKey
   */
  readonly privateKey?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
    'privateKey': obj.privateKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames {
  /**
   * Criteria for determining a SAN's match.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames#match
   */
  readonly match?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust {
  /**
   * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust#acm
   */
  readonly acm?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm[];

  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust#file
   */
  readonly file?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust#sds
   */
  readonly sds?: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acm': obj.acm?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm(y)),
    'file': obj.file?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
  /**
   * Values sent must match the specified values exactly.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch#exact
   */
  readonly exact?: string[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
  /**
   * One or more ACM ARNs.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm#certificateAuthorityArns
   */
  readonly certificateAuthorityArns?: string[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityArns': obj.certificateAuthorityArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile#certificateChain
   */
  readonly certificateChain?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds
 */
export interface VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds(obj: VirtualNodeSpecForProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile#privateKey
   */
  readonly privateKey?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
    'privateKey': obj.privateKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsCertificateSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames {
  /**
   * Criteria for determining a SAN's match.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames#match
   */
  readonly match?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust {
  /**
   * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust#acm
   */
  readonly acm?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm[];

  /**
   * Local file certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust#file
   */
  readonly file?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile[];

  /**
   * A Secret Discovery Service certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust#sds
   */
  readonly sds?: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acm': obj.acm?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm(y)),
    'file': obj.file?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile(y)),
    'sds': obj.sds?.map(y => toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
  /**
   * Values sent must match the specified values exactly.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch#exact
   */
  readonly exact?: string[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
  /**
   * One or more ACM ARNs.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm#certificateAuthorityArns
   */
  readonly certificateAuthorityArns?: string[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustAcm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityArns': obj.certificateAuthorityArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile#certificateChain
   */
  readonly certificateChain?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds
 */
export interface VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds(obj: VirtualNodeSpecInitProviderSpecBackendDefaultsClientPolicyTlsValidationTrustSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch {
  /**
   * Values sent must match the specified values exactly.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch#exact
   */
  readonly exact?: string[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm {
  /**
   * One or more ACM ARNs.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm#certificateAuthorityArns
   */
  readonly certificateAuthorityArns?: string[];

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityArns': obj.certificateAuthorityArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile#certificateChain
   */
  readonly certificateChain?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds
 */
export interface VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds(obj: VirtualNodeSpecForProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch {
  /**
   * Values sent must match the specified values exactly.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch#exact
   */
  readonly exact?: string[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm {
  /**
   * One or more ACM ARNs.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm#certificateAuthorityArns
   */
  readonly certificateAuthorityArns?: string[];

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityArns': obj.certificateAuthorityArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile {
  /**
   * Certificate chain for the certificate.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile#certificateChain
   */
  readonly certificateChain?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChain': obj.certificateChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds
 */
export interface VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds {
  /**
   * Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
   *
   * @schema VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds(obj: VirtualNodeSpecInitProviderSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * VirtualRouter is the Schema for the VirtualRouters API. Provides an AWS App Mesh virtual router resource.
 *
 * @schema VirtualRouter
 */
export class VirtualRouter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualRouter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appmesh.aws.upbound.io/v1beta1',
    kind: 'VirtualRouter',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualRouter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualRouterProps): any {
    return {
      ...VirtualRouter.GVK,
      ...toJson_VirtualRouterProps(props),
    };
  }

  /**
   * Defines a "VirtualRouter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualRouterProps) {
    super(scope, id, {
      ...VirtualRouter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualRouter.GVK,
      ...toJson_VirtualRouterProps(resolved),
    };
  }
}

/**
 * VirtualRouter is the Schema for the VirtualRouters API. Provides an AWS App Mesh virtual router resource.
 *
 * @schema VirtualRouter
 */
export interface VirtualRouterProps {
  /**
   * @schema VirtualRouter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VirtualRouterSpec defines the desired state of VirtualRouter
   *
   * @schema VirtualRouter#spec
   */
  readonly spec: VirtualRouterSpec;

}

/**
 * Converts an object of type 'VirtualRouterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterProps(obj: VirtualRouterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualRouterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VirtualRouterSpec defines the desired state of VirtualRouter
 *
 * @schema VirtualRouterSpec
 */
export interface VirtualRouterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VirtualRouterSpec#deletionPolicy
   */
  readonly deletionPolicy?: VirtualRouterSpecDeletionPolicy;

  /**
   * @schema VirtualRouterSpec#forProvider
   */
  readonly forProvider: VirtualRouterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VirtualRouterSpec#initProvider
   */
  readonly initProvider?: VirtualRouterSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VirtualRouterSpec#managementPolicies
   */
  readonly managementPolicies?: VirtualRouterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VirtualRouterSpec#providerConfigRef
   */
  readonly providerConfigRef?: VirtualRouterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VirtualRouterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VirtualRouterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VirtualRouterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VirtualRouterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VirtualRouterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpec(obj: VirtualRouterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VirtualRouterSpecForProvider(obj.forProvider),
    'initProvider': toJson_VirtualRouterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VirtualRouterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VirtualRouterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VirtualRouterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VirtualRouterSpecDeletionPolicy
 */
export enum VirtualRouterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VirtualRouterSpecForProvider
 */
export interface VirtualRouterSpecForProvider {
  /**
   * Name of the service mesh in which to create the virtual router. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualRouterSpecForProvider#meshName
   */
  readonly meshName?: string;

  /**
   * Reference to a Mesh in appmesh to populate meshName.
   *
   * @schema VirtualRouterSpecForProvider#meshNameRef
   */
  readonly meshNameRef?: VirtualRouterSpecForProviderMeshNameRef;

  /**
   * Selector for a Mesh in appmesh to populate meshName.
   *
   * @schema VirtualRouterSpecForProvider#meshNameSelector
   */
  readonly meshNameSelector?: VirtualRouterSpecForProviderMeshNameSelector;

  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema VirtualRouterSpecForProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the virtual router. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualRouterSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VirtualRouterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Virtual router specification to apply.
   *
   * @schema VirtualRouterSpecForProvider#spec
   */
  readonly spec?: VirtualRouterSpecForProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VirtualRouterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualRouterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecForProvider(obj: VirtualRouterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshName': obj.meshName,
    'meshNameRef': toJson_VirtualRouterSpecForProviderMeshNameRef(obj.meshNameRef),
    'meshNameSelector': toJson_VirtualRouterSpecForProviderMeshNameSelector(obj.meshNameSelector),
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'region': obj.region,
    'spec': obj.spec?.map(y => toJson_VirtualRouterSpecForProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VirtualRouterSpecInitProvider
 */
export interface VirtualRouterSpecInitProvider {
  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema VirtualRouterSpecInitProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the virtual router. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualRouterSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Virtual router specification to apply.
   *
   * @schema VirtualRouterSpecInitProvider#spec
   */
  readonly spec?: VirtualRouterSpecInitProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VirtualRouterSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualRouterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecInitProvider(obj: VirtualRouterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'spec': obj.spec?.map(y => toJson_VirtualRouterSpecInitProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VirtualRouterSpecManagementPolicies
 */
export enum VirtualRouterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VirtualRouterSpecProviderConfigRef
 */
export interface VirtualRouterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualRouterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualRouterSpecProviderConfigRef#policy
   */
  readonly policy?: VirtualRouterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VirtualRouterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecProviderConfigRef(obj: VirtualRouterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualRouterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VirtualRouterSpecPublishConnectionDetailsTo
 */
export interface VirtualRouterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VirtualRouterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VirtualRouterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VirtualRouterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VirtualRouterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VirtualRouterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VirtualRouterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecPublishConnectionDetailsTo(obj: VirtualRouterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VirtualRouterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VirtualRouterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VirtualRouterSpecWriteConnectionSecretToRef
 */
export interface VirtualRouterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VirtualRouterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VirtualRouterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VirtualRouterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecWriteConnectionSecretToRef(obj: VirtualRouterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Mesh in appmesh to populate meshName.
 *
 * @schema VirtualRouterSpecForProviderMeshNameRef
 */
export interface VirtualRouterSpecForProviderMeshNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualRouterSpecForProviderMeshNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualRouterSpecForProviderMeshNameRef#policy
   */
  readonly policy?: VirtualRouterSpecForProviderMeshNameRefPolicy;

}

/**
 * Converts an object of type 'VirtualRouterSpecForProviderMeshNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecForProviderMeshNameRef(obj: VirtualRouterSpecForProviderMeshNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualRouterSpecForProviderMeshNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Mesh in appmesh to populate meshName.
 *
 * @schema VirtualRouterSpecForProviderMeshNameSelector
 */
export interface VirtualRouterSpecForProviderMeshNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VirtualRouterSpecForProviderMeshNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VirtualRouterSpecForProviderMeshNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VirtualRouterSpecForProviderMeshNameSelector#policy
   */
  readonly policy?: VirtualRouterSpecForProviderMeshNameSelectorPolicy;

}

/**
 * Converts an object of type 'VirtualRouterSpecForProviderMeshNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecForProviderMeshNameSelector(obj: VirtualRouterSpecForProviderMeshNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VirtualRouterSpecForProviderMeshNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualRouterSpecForProviderSpec
 */
export interface VirtualRouterSpecForProviderSpec {
  /**
   * configuration block to the spec argument.
   *
   * @schema VirtualRouterSpecForProviderSpec#listener
   */
  readonly listener?: VirtualRouterSpecForProviderSpecListener[];

}

/**
 * Converts an object of type 'VirtualRouterSpecForProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecForProviderSpec(obj: VirtualRouterSpecForProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': obj.listener?.map(y => toJson_VirtualRouterSpecForProviderSpecListener(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualRouterSpecInitProviderSpec
 */
export interface VirtualRouterSpecInitProviderSpec {
  /**
   * configuration block to the spec argument.
   *
   * @schema VirtualRouterSpecInitProviderSpec#listener
   */
  readonly listener?: VirtualRouterSpecInitProviderSpecListener[];

}

/**
 * Converts an object of type 'VirtualRouterSpecInitProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecInitProviderSpec(obj: VirtualRouterSpecInitProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': obj.listener?.map(y => toJson_VirtualRouterSpecInitProviderSpecListener(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualRouterSpecProviderConfigRefPolicy
 */
export interface VirtualRouterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualRouterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VirtualRouterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualRouterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VirtualRouterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualRouterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecProviderConfigRefPolicy(obj: VirtualRouterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VirtualRouterSpecPublishConnectionDetailsToConfigRef
 */
export interface VirtualRouterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualRouterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualRouterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VirtualRouterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecPublishConnectionDetailsToConfigRef(obj: VirtualRouterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VirtualRouterSpecPublishConnectionDetailsToMetadata
 */
export interface VirtualRouterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VirtualRouterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VirtualRouterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VirtualRouterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualRouterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecPublishConnectionDetailsToMetadata(obj: VirtualRouterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualRouterSpecForProviderMeshNameRefPolicy
 */
export interface VirtualRouterSpecForProviderMeshNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualRouterSpecForProviderMeshNameRefPolicy#resolution
   */
  readonly resolution?: VirtualRouterSpecForProviderMeshNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualRouterSpecForProviderMeshNameRefPolicy#resolve
   */
  readonly resolve?: VirtualRouterSpecForProviderMeshNameRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualRouterSpecForProviderMeshNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecForProviderMeshNameRefPolicy(obj: VirtualRouterSpecForProviderMeshNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VirtualRouterSpecForProviderMeshNameSelectorPolicy
 */
export interface VirtualRouterSpecForProviderMeshNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualRouterSpecForProviderMeshNameSelectorPolicy#resolution
   */
  readonly resolution?: VirtualRouterSpecForProviderMeshNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualRouterSpecForProviderMeshNameSelectorPolicy#resolve
   */
  readonly resolve?: VirtualRouterSpecForProviderMeshNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VirtualRouterSpecForProviderMeshNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecForProviderMeshNameSelectorPolicy(obj: VirtualRouterSpecForProviderMeshNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualRouterSpecForProviderSpecListener
 */
export interface VirtualRouterSpecForProviderSpecListener {
  /**
   * Port mapping information for the listener.
   *
   * @schema VirtualRouterSpecForProviderSpecListener#portMapping
   */
  readonly portMapping?: VirtualRouterSpecForProviderSpecListenerPortMapping[];

}

/**
 * Converts an object of type 'VirtualRouterSpecForProviderSpecListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecForProviderSpecListener(obj: VirtualRouterSpecForProviderSpecListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'portMapping': obj.portMapping?.map(y => toJson_VirtualRouterSpecForProviderSpecListenerPortMapping(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualRouterSpecInitProviderSpecListener
 */
export interface VirtualRouterSpecInitProviderSpecListener {
  /**
   * Port mapping information for the listener.
   *
   * @schema VirtualRouterSpecInitProviderSpecListener#portMapping
   */
  readonly portMapping?: VirtualRouterSpecInitProviderSpecListenerPortMapping[];

}

/**
 * Converts an object of type 'VirtualRouterSpecInitProviderSpecListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecInitProviderSpecListener(obj: VirtualRouterSpecInitProviderSpecListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'portMapping': obj.portMapping?.map(y => toJson_VirtualRouterSpecInitProviderSpecListenerPortMapping(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualRouterSpecProviderConfigRefPolicyResolution
 */
export enum VirtualRouterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualRouterSpecProviderConfigRefPolicyResolve
 */
export enum VirtualRouterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicy(obj: VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualRouterSpecForProviderMeshNameRefPolicyResolution
 */
export enum VirtualRouterSpecForProviderMeshNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualRouterSpecForProviderMeshNameRefPolicyResolve
 */
export enum VirtualRouterSpecForProviderMeshNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualRouterSpecForProviderMeshNameSelectorPolicyResolution
 */
export enum VirtualRouterSpecForProviderMeshNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualRouterSpecForProviderMeshNameSelectorPolicyResolve
 */
export enum VirtualRouterSpecForProviderMeshNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema VirtualRouterSpecForProviderSpecListenerPortMapping
 */
export interface VirtualRouterSpecForProviderSpecListenerPortMapping {
  /**
   * Port used for the port mapping.
   *
   * @schema VirtualRouterSpecForProviderSpecListenerPortMapping#port
   */
  readonly port?: number;

  /**
   * Protocol used for the port mapping. Valid values are http,http2, tcp and grpc.
   *
   * @schema VirtualRouterSpecForProviderSpecListenerPortMapping#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'VirtualRouterSpecForProviderSpecListenerPortMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecForProviderSpecListenerPortMapping(obj: VirtualRouterSpecForProviderSpecListenerPortMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualRouterSpecInitProviderSpecListenerPortMapping
 */
export interface VirtualRouterSpecInitProviderSpecListenerPortMapping {
  /**
   * Port used for the port mapping.
   *
   * @schema VirtualRouterSpecInitProviderSpecListenerPortMapping#port
   */
  readonly port?: number;

  /**
   * Protocol used for the port mapping. Valid values are http,http2, tcp and grpc.
   *
   * @schema VirtualRouterSpecInitProviderSpecListenerPortMapping#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'VirtualRouterSpecInitProviderSpecListenerPortMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualRouterSpecInitProviderSpecListenerPortMapping(obj: VirtualRouterSpecInitProviderSpecListenerPortMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VirtualRouterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VirtualService is the Schema for the VirtualServices API. Provides an AWS App Mesh virtual service resource.
 *
 * @schema VirtualService
 */
export class VirtualService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appmesh.aws.upbound.io/v1beta1',
    kind: 'VirtualService',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualServiceProps): any {
    return {
      ...VirtualService.GVK,
      ...toJson_VirtualServiceProps(props),
    };
  }

  /**
   * Defines a "VirtualService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualServiceProps) {
    super(scope, id, {
      ...VirtualService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualService.GVK,
      ...toJson_VirtualServiceProps(resolved),
    };
  }
}

/**
 * VirtualService is the Schema for the VirtualServices API. Provides an AWS App Mesh virtual service resource.
 *
 * @schema VirtualService
 */
export interface VirtualServiceProps {
  /**
   * @schema VirtualService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VirtualServiceSpec defines the desired state of VirtualService
   *
   * @schema VirtualService#spec
   */
  readonly spec: VirtualServiceSpec;

}

/**
 * Converts an object of type 'VirtualServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceProps(obj: VirtualServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VirtualServiceSpec defines the desired state of VirtualService
 *
 * @schema VirtualServiceSpec
 */
export interface VirtualServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VirtualServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: VirtualServiceSpecDeletionPolicy;

  /**
   * @schema VirtualServiceSpec#forProvider
   */
  readonly forProvider: VirtualServiceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VirtualServiceSpec#initProvider
   */
  readonly initProvider?: VirtualServiceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VirtualServiceSpec#managementPolicies
   */
  readonly managementPolicies?: VirtualServiceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VirtualServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: VirtualServiceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VirtualServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VirtualServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VirtualServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VirtualServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VirtualServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpec(obj: VirtualServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VirtualServiceSpecForProvider(obj.forProvider),
    'initProvider': toJson_VirtualServiceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VirtualServiceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VirtualServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VirtualServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VirtualServiceSpecDeletionPolicy
 */
export enum VirtualServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VirtualServiceSpecForProvider
 */
export interface VirtualServiceSpecForProvider {
  /**
   * Name of the service mesh in which to create the virtual service. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualServiceSpecForProvider#meshName
   */
  readonly meshName?: string;

  /**
   * Reference to a Mesh in appmesh to populate meshName.
   *
   * @schema VirtualServiceSpecForProvider#meshNameRef
   */
  readonly meshNameRef?: VirtualServiceSpecForProviderMeshNameRef;

  /**
   * Selector for a Mesh in appmesh to populate meshName.
   *
   * @schema VirtualServiceSpecForProvider#meshNameSelector
   */
  readonly meshNameSelector?: VirtualServiceSpecForProviderMeshNameSelector;

  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema VirtualServiceSpecForProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the virtual service. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualServiceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VirtualServiceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Virtual service specification to apply.
   *
   * @schema VirtualServiceSpecForProvider#spec
   */
  readonly spec?: VirtualServiceSpecForProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VirtualServiceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProvider(obj: VirtualServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshName': obj.meshName,
    'meshNameRef': toJson_VirtualServiceSpecForProviderMeshNameRef(obj.meshNameRef),
    'meshNameSelector': toJson_VirtualServiceSpecForProviderMeshNameSelector(obj.meshNameSelector),
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'region': obj.region,
    'spec': obj.spec?.map(y => toJson_VirtualServiceSpecForProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VirtualServiceSpecInitProvider
 */
export interface VirtualServiceSpecInitProvider {
  /**
   * AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
   *
   * @default the account ID the AWS provider is currently connected to.
   * @schema VirtualServiceSpecInitProvider#meshOwner
   */
  readonly meshOwner?: string;

  /**
   * Name to use for the virtual service. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualServiceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Virtual service specification to apply.
   *
   * @schema VirtualServiceSpecInitProvider#spec
   */
  readonly spec?: VirtualServiceSpecInitProviderSpec[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VirtualServiceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecInitProvider(obj: VirtualServiceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'meshOwner': obj.meshOwner,
    'name': obj.name,
    'spec': obj.spec?.map(y => toJson_VirtualServiceSpecInitProviderSpec(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VirtualServiceSpecManagementPolicies
 */
export enum VirtualServiceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VirtualServiceSpecProviderConfigRef
 */
export interface VirtualServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualServiceSpecProviderConfigRef#policy
   */
  readonly policy?: VirtualServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VirtualServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecProviderConfigRef(obj: VirtualServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VirtualServiceSpecPublishConnectionDetailsTo
 */
export interface VirtualServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VirtualServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VirtualServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VirtualServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VirtualServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VirtualServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecPublishConnectionDetailsTo(obj: VirtualServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VirtualServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VirtualServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VirtualServiceSpecWriteConnectionSecretToRef
 */
export interface VirtualServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VirtualServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VirtualServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecWriteConnectionSecretToRef(obj: VirtualServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Mesh in appmesh to populate meshName.
 *
 * @schema VirtualServiceSpecForProviderMeshNameRef
 */
export interface VirtualServiceSpecForProviderMeshNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualServiceSpecForProviderMeshNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualServiceSpecForProviderMeshNameRef#policy
   */
  readonly policy?: VirtualServiceSpecForProviderMeshNameRefPolicy;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderMeshNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderMeshNameRef(obj: VirtualServiceSpecForProviderMeshNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualServiceSpecForProviderMeshNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Mesh in appmesh to populate meshName.
 *
 * @schema VirtualServiceSpecForProviderMeshNameSelector
 */
export interface VirtualServiceSpecForProviderMeshNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VirtualServiceSpecForProviderMeshNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VirtualServiceSpecForProviderMeshNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VirtualServiceSpecForProviderMeshNameSelector#policy
   */
  readonly policy?: VirtualServiceSpecForProviderMeshNameSelectorPolicy;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderMeshNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderMeshNameSelector(obj: VirtualServiceSpecForProviderMeshNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VirtualServiceSpecForProviderMeshNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecForProviderSpec
 */
export interface VirtualServiceSpecForProviderSpec {
  /**
   * App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
   *
   * @schema VirtualServiceSpecForProviderSpec#provider
   */
  readonly provider?: VirtualServiceSpecForProviderSpecProvider[];

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpec(obj: VirtualServiceSpecForProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'provider': obj.provider?.map(y => toJson_VirtualServiceSpecForProviderSpecProvider(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecInitProviderSpec
 */
export interface VirtualServiceSpecInitProviderSpec {
  /**
   * App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
   *
   * @schema VirtualServiceSpecInitProviderSpec#provider
   */
  readonly provider?: VirtualServiceSpecInitProviderSpecProvider[];

}

/**
 * Converts an object of type 'VirtualServiceSpecInitProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecInitProviderSpec(obj: VirtualServiceSpecInitProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'provider': obj.provider?.map(y => toJson_VirtualServiceSpecInitProviderSpecProvider(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualServiceSpecProviderConfigRefPolicy
 */
export interface VirtualServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VirtualServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VirtualServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecProviderConfigRefPolicy(obj: VirtualServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VirtualServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface VirtualServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VirtualServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecPublishConnectionDetailsToConfigRef(obj: VirtualServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VirtualServiceSpecPublishConnectionDetailsToMetadata
 */
export interface VirtualServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VirtualServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VirtualServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VirtualServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecPublishConnectionDetailsToMetadata(obj: VirtualServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualServiceSpecForProviderMeshNameRefPolicy
 */
export interface VirtualServiceSpecForProviderMeshNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualServiceSpecForProviderMeshNameRefPolicy#resolution
   */
  readonly resolution?: VirtualServiceSpecForProviderMeshNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualServiceSpecForProviderMeshNameRefPolicy#resolve
   */
  readonly resolve?: VirtualServiceSpecForProviderMeshNameRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderMeshNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderMeshNameRefPolicy(obj: VirtualServiceSpecForProviderMeshNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VirtualServiceSpecForProviderMeshNameSelectorPolicy
 */
export interface VirtualServiceSpecForProviderMeshNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualServiceSpecForProviderMeshNameSelectorPolicy#resolution
   */
  readonly resolution?: VirtualServiceSpecForProviderMeshNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualServiceSpecForProviderMeshNameSelectorPolicy#resolve
   */
  readonly resolve?: VirtualServiceSpecForProviderMeshNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderMeshNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderMeshNameSelectorPolicy(obj: VirtualServiceSpecForProviderMeshNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecForProviderSpecProvider
 */
export interface VirtualServiceSpecForProviderSpecProvider {
  /**
   * Virtual node associated with a virtual service.
   *
   * @schema VirtualServiceSpecForProviderSpecProvider#virtualNode
   */
  readonly virtualNode?: VirtualServiceSpecForProviderSpecProviderVirtualNode[];

  /**
   * Virtual router associated with a virtual service.
   *
   * @schema VirtualServiceSpecForProviderSpecProvider#virtualRouter
   */
  readonly virtualRouter?: VirtualServiceSpecForProviderSpecProviderVirtualRouter[];

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProvider(obj: VirtualServiceSpecForProviderSpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualNode': obj.virtualNode?.map(y => toJson_VirtualServiceSpecForProviderSpecProviderVirtualNode(y)),
    'virtualRouter': obj.virtualRouter?.map(y => toJson_VirtualServiceSpecForProviderSpecProviderVirtualRouter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecInitProviderSpecProvider
 */
export interface VirtualServiceSpecInitProviderSpecProvider {
  /**
   * Virtual node associated with a virtual service.
   *
   * @schema VirtualServiceSpecInitProviderSpecProvider#virtualNode
   */
  readonly virtualNode?: any[];

  /**
   * Virtual router associated with a virtual service.
   *
   * @schema VirtualServiceSpecInitProviderSpecProvider#virtualRouter
   */
  readonly virtualRouter?: any[];

}

/**
 * Converts an object of type 'VirtualServiceSpecInitProviderSpecProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecInitProviderSpecProvider(obj: VirtualServiceSpecInitProviderSpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualNode': obj.virtualNode?.map(y => y),
    'virtualRouter': obj.virtualRouter?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualServiceSpecProviderConfigRefPolicyResolution
 */
export enum VirtualServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualServiceSpecProviderConfigRefPolicyResolve
 */
export enum VirtualServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualServiceSpecForProviderMeshNameRefPolicyResolution
 */
export enum VirtualServiceSpecForProviderMeshNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualServiceSpecForProviderMeshNameRefPolicyResolve
 */
export enum VirtualServiceSpecForProviderMeshNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualServiceSpecForProviderMeshNameSelectorPolicyResolution
 */
export enum VirtualServiceSpecForProviderMeshNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualServiceSpecForProviderMeshNameSelectorPolicyResolve
 */
export enum VirtualServiceSpecForProviderMeshNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualNode
 */
export interface VirtualServiceSpecForProviderSpecProviderVirtualNode {
  /**
   * Name of the virtual node that is acting as a service provider. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNode#virtualNodeName
   */
  readonly virtualNodeName?: string;

  /**
   * Reference to a VirtualNode in appmesh to populate virtualNodeName.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNode#virtualNodeNameRef
   */
  readonly virtualNodeNameRef?: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRef;

  /**
   * Selector for a VirtualNode in appmesh to populate virtualNodeName.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNode#virtualNodeNameSelector
   */
  readonly virtualNodeNameSelector?: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelector;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProviderVirtualNode' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProviderVirtualNode(obj: VirtualServiceSpecForProviderSpecProviderVirtualNode | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualNodeName': obj.virtualNodeName,
    'virtualNodeNameRef': toJson_VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRef(obj.virtualNodeNameRef),
    'virtualNodeNameSelector': toJson_VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelector(obj.virtualNodeNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouter
 */
export interface VirtualServiceSpecForProviderSpecProviderVirtualRouter {
  /**
   * Name of the virtual router that is acting as a service provider. Must be between 1 and 255 characters in length.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouter#virtualRouterName
   */
  readonly virtualRouterName?: string;

  /**
   * Reference to a VirtualRouter in appmesh to populate virtualRouterName.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouter#virtualRouterNameRef
   */
  readonly virtualRouterNameRef?: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRef;

  /**
   * Selector for a VirtualRouter in appmesh to populate virtualRouterName.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouter#virtualRouterNameSelector
   */
  readonly virtualRouterNameSelector?: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelector;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProviderVirtualRouter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProviderVirtualRouter(obj: VirtualServiceSpecForProviderSpecProviderVirtualRouter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualRouterName': obj.virtualRouterName,
    'virtualRouterNameRef': toJson_VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRef(obj.virtualRouterNameRef),
    'virtualRouterNameSelector': toJson_VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelector(obj.virtualRouterNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VirtualServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a VirtualNode in appmesh to populate virtualNodeName.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRef
 */
export interface VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRef#policy
   */
  readonly policy?: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicy;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRef(obj: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VirtualNode in appmesh to populate virtualNodeName.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelector
 */
export interface VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelector#policy
   */
  readonly policy?: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicy;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelector(obj: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VirtualRouter in appmesh to populate virtualRouterName.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRef
 */
export interface VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRef#policy
   */
  readonly policy?: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicy;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRef(obj: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VirtualRouter in appmesh to populate virtualRouterName.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelector
 */
export interface VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelector#policy
   */
  readonly policy?: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicy;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelector(obj: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicy
 */
export interface VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicy#resolution
   */
  readonly resolution?: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicy#resolve
   */
  readonly resolve?: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicy(obj: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicy
 */
export interface VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicy#resolution
   */
  readonly resolution?: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicy#resolve
   */
  readonly resolve?: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicy(obj: VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicy
 */
export interface VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicy#resolution
   */
  readonly resolution?: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicy#resolve
   */
  readonly resolve?: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicy(obj: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicy
 */
export interface VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicy#resolution
   */
  readonly resolution?: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicy#resolve
   */
  readonly resolve?: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicy(obj: VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicyResolution
 */
export enum VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicyResolve
 */
export enum VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicyResolution
 */
export enum VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicyResolve
 */
export enum VirtualServiceSpecForProviderSpecProviderVirtualNodeVirtualNodeNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicyResolution
 */
export enum VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicyResolve
 */
export enum VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicyResolution
 */
export enum VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicyResolve
 */
export enum VirtualServiceSpecForProviderSpecProviderVirtualRouterVirtualRouterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

