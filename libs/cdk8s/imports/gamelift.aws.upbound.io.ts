// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Alias is the Schema for the Aliass API. Provides a GameLift Alias resource.
 *
 * @schema Alias
 */
export class Alias extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Alias"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gamelift.aws.upbound.io/v1beta1',
    kind: 'Alias',
  }

  /**
   * Renders a Kubernetes manifest for "Alias".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AliasProps): any {
    return {
      ...Alias.GVK,
      ...toJson_AliasProps(props),
    };
  }

  /**
   * Defines a "Alias" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AliasProps) {
    super(scope, id, {
      ...Alias.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Alias.GVK,
      ...toJson_AliasProps(resolved),
    };
  }
}

/**
 * Alias is the Schema for the Aliass API. Provides a GameLift Alias resource.
 *
 * @schema Alias
 */
export interface AliasProps {
  /**
   * @schema Alias#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AliasSpec defines the desired state of Alias
   *
   * @schema Alias#spec
   */
  readonly spec: AliasSpec;

}

/**
 * Converts an object of type 'AliasProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasProps(obj: AliasProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AliasSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AliasSpec defines the desired state of Alias
 *
 * @schema AliasSpec
 */
export interface AliasSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AliasSpec#deletionPolicy
   */
  readonly deletionPolicy?: AliasSpecDeletionPolicy;

  /**
   * @schema AliasSpec#forProvider
   */
  readonly forProvider: AliasSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AliasSpec#initProvider
   */
  readonly initProvider?: AliasSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AliasSpec#managementPolicies
   */
  readonly managementPolicies?: AliasSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AliasSpec#providerConfigRef
   */
  readonly providerConfigRef?: AliasSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AliasSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AliasSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AliasSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AliasSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AliasSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpec(obj: AliasSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AliasSpecForProvider(obj.forProvider),
    'initProvider': toJson_AliasSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AliasSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AliasSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AliasSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AliasSpecDeletionPolicy
 */
export enum AliasSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AliasSpecForProvider
 */
export interface AliasSpecForProvider {
  /**
   * Description of the alias.
   *
   * @schema AliasSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Name of the alias.
   *
   * @schema AliasSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AliasSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the fleet and/or routing type to use for the alias.
   *
   * @schema AliasSpecForProvider#routingStrategy
   */
  readonly routingStrategy?: AliasSpecForProviderRoutingStrategy[];

  /**
   * Key-value map of resource tags.
   *
   * @schema AliasSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AliasSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProvider(obj: AliasSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'routingStrategy': obj.routingStrategy?.map(y => toJson_AliasSpecForProviderRoutingStrategy(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AliasSpecInitProvider
 */
export interface AliasSpecInitProvider {
  /**
   * Description of the alias.
   *
   * @schema AliasSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Name of the alias.
   *
   * @schema AliasSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Specifies the fleet and/or routing type to use for the alias.
   *
   * @schema AliasSpecInitProvider#routingStrategy
   */
  readonly routingStrategy?: AliasSpecInitProviderRoutingStrategy[];

  /**
   * Key-value map of resource tags.
   *
   * @schema AliasSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AliasSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecInitProvider(obj: AliasSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'routingStrategy': obj.routingStrategy?.map(y => toJson_AliasSpecInitProviderRoutingStrategy(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AliasSpecManagementPolicies
 */
export enum AliasSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AliasSpecProviderConfigRef
 */
export interface AliasSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecProviderConfigRef#policy
   */
  readonly policy?: AliasSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderConfigRef(obj: AliasSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AliasSpecPublishConnectionDetailsTo
 */
export interface AliasSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AliasSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AliasSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsTo(obj: AliasSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AliasSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AliasSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AliasSpecWriteConnectionSecretToRef
 */
export interface AliasSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AliasSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AliasSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AliasSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecWriteConnectionSecretToRef(obj: AliasSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AliasSpecForProviderRoutingStrategy
 */
export interface AliasSpecForProviderRoutingStrategy {
  /**
   * ID of the GameLift Fleet to point the alias to.
   *
   * @schema AliasSpecForProviderRoutingStrategy#fleetId
   */
  readonly fleetId?: string;

  /**
   * Message text to be used with the TERMINAL routing strategy.
   *
   * @schema AliasSpecForProviderRoutingStrategy#message
   */
  readonly message?: string;

  /**
   * Type of routing strategyE.g., SIMPLE or TERMINAL
   *
   * @schema AliasSpecForProviderRoutingStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AliasSpecForProviderRoutingStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderRoutingStrategy(obj: AliasSpecForProviderRoutingStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fleetId': obj.fleetId,
    'message': obj.message,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AliasSpecInitProviderRoutingStrategy
 */
export interface AliasSpecInitProviderRoutingStrategy {
  /**
   * ID of the GameLift Fleet to point the alias to.
   *
   * @schema AliasSpecInitProviderRoutingStrategy#fleetId
   */
  readonly fleetId?: string;

  /**
   * Message text to be used with the TERMINAL routing strategy.
   *
   * @schema AliasSpecInitProviderRoutingStrategy#message
   */
  readonly message?: string;

  /**
   * Type of routing strategyE.g., SIMPLE or TERMINAL
   *
   * @schema AliasSpecInitProviderRoutingStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AliasSpecInitProviderRoutingStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecInitProviderRoutingStrategy(obj: AliasSpecInitProviderRoutingStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fleetId': obj.fleetId,
    'message': obj.message,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AliasSpecProviderConfigRefPolicy
 */
export interface AliasSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AliasSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AliasSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderConfigRefPolicy(obj: AliasSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRef
 */
export interface AliasSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AliasSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToConfigRef(obj: AliasSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AliasSpecPublishConnectionDetailsToMetadata
 */
export interface AliasSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToMetadata(obj: AliasSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecProviderConfigRefPolicyResolution
 */
export enum AliasSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecProviderConfigRefPolicyResolve
 */
export enum AliasSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AliasSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToConfigRefPolicy(obj: AliasSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Build is the Schema for the Builds API. Provides a GameLift Build resource.
 *
 * @schema Build
 */
export class Build extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Build"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gamelift.aws.upbound.io/v1beta1',
    kind: 'Build',
  }

  /**
   * Renders a Kubernetes manifest for "Build".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BuildProps): any {
    return {
      ...Build.GVK,
      ...toJson_BuildProps(props),
    };
  }

  /**
   * Defines a "Build" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BuildProps) {
    super(scope, id, {
      ...Build.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Build.GVK,
      ...toJson_BuildProps(resolved),
    };
  }
}

/**
 * Build is the Schema for the Builds API. Provides a GameLift Build resource.
 *
 * @schema Build
 */
export interface BuildProps {
  /**
   * @schema Build#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BuildSpec defines the desired state of Build
   *
   * @schema Build#spec
   */
  readonly spec: BuildSpec;

}

/**
 * Converts an object of type 'BuildProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildProps(obj: BuildProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BuildSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BuildSpec defines the desired state of Build
 *
 * @schema BuildSpec
 */
export interface BuildSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BuildSpec#deletionPolicy
   */
  readonly deletionPolicy?: BuildSpecDeletionPolicy;

  /**
   * @schema BuildSpec#forProvider
   */
  readonly forProvider: BuildSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema BuildSpec#initProvider
   */
  readonly initProvider?: BuildSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BuildSpec#managementPolicies
   */
  readonly managementPolicies?: BuildSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BuildSpec#providerConfigRef
   */
  readonly providerConfigRef?: BuildSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BuildSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BuildSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BuildSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BuildSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BuildSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpec(obj: BuildSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BuildSpecForProvider(obj.forProvider),
    'initProvider': toJson_BuildSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BuildSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BuildSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BuildSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BuildSpecDeletionPolicy
 */
export enum BuildSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BuildSpecForProvider
 */
export interface BuildSpecForProvider {
  /**
   * Name of the build
   *
   * @schema BuildSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Operating system that the game server binaries are built to run onE.g., WINDOWS_2012, AMAZON_LINUX or AMAZON_LINUX_2.
   *
   * @schema BuildSpecForProvider#operatingSystem
   */
  readonly operatingSystem?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BuildSpecForProvider#region
   */
  readonly region: string;

  /**
   * Information indicating where your game build files are stored. See below.
   *
   * @schema BuildSpecForProvider#storageLocation
   */
  readonly storageLocation?: BuildSpecForProviderStorageLocation[];

  /**
   * Key-value map of resource tags.
   *
   * @schema BuildSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Version that is associated with this build.
   *
   * @schema BuildSpecForProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'BuildSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProvider(obj: BuildSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'operatingSystem': obj.operatingSystem,
    'region': obj.region,
    'storageLocation': obj.storageLocation?.map(y => toJson_BuildSpecForProviderStorageLocation(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema BuildSpecInitProvider
 */
export interface BuildSpecInitProvider {
  /**
   * Name of the build
   *
   * @schema BuildSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Operating system that the game server binaries are built to run onE.g., WINDOWS_2012, AMAZON_LINUX or AMAZON_LINUX_2.
   *
   * @schema BuildSpecInitProvider#operatingSystem
   */
  readonly operatingSystem?: string;

  /**
   * Information indicating where your game build files are stored. See below.
   *
   * @schema BuildSpecInitProvider#storageLocation
   */
  readonly storageLocation?: BuildSpecInitProviderStorageLocation[];

  /**
   * Key-value map of resource tags.
   *
   * @schema BuildSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Version that is associated with this build.
   *
   * @schema BuildSpecInitProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'BuildSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecInitProvider(obj: BuildSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'operatingSystem': obj.operatingSystem,
    'storageLocation': obj.storageLocation?.map(y => toJson_BuildSpecInitProviderStorageLocation(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BuildSpecManagementPolicies
 */
export enum BuildSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BuildSpecProviderConfigRef
 */
export interface BuildSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BuildSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BuildSpecProviderConfigRef#policy
   */
  readonly policy?: BuildSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BuildSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecProviderConfigRef(obj: BuildSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BuildSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BuildSpecPublishConnectionDetailsTo
 */
export interface BuildSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BuildSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BuildSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BuildSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BuildSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BuildSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BuildSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecPublishConnectionDetailsTo(obj: BuildSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BuildSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BuildSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BuildSpecWriteConnectionSecretToRef
 */
export interface BuildSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BuildSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BuildSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BuildSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecWriteConnectionSecretToRef(obj: BuildSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BuildSpecForProviderStorageLocation
 */
export interface BuildSpecForProviderStorageLocation {
  /**
   * Name of your S3 bucket.
   *
   * @schema BuildSpecForProviderStorageLocation#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BuildSpecForProviderStorageLocation#bucketRef
   */
  readonly bucketRef?: BuildSpecForProviderStorageLocationBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BuildSpecForProviderStorageLocation#bucketSelector
   */
  readonly bucketSelector?: BuildSpecForProviderStorageLocationBucketSelector;

  /**
   * Name of the zip file containing your build files.
   *
   * @schema BuildSpecForProviderStorageLocation#key
   */
  readonly key?: string;

  /**
   * Reference to a Object in s3 to populate key.
   *
   * @schema BuildSpecForProviderStorageLocation#keyRef
   */
  readonly keyRef?: BuildSpecForProviderStorageLocationKeyRef;

  /**
   * Selector for a Object in s3 to populate key.
   *
   * @schema BuildSpecForProviderStorageLocation#keySelector
   */
  readonly keySelector?: BuildSpecForProviderStorageLocationKeySelector;

  /**
   * A specific version of the file. If not set, the latest version of the file is retrieved.
   *
   * @schema BuildSpecForProviderStorageLocation#objectVersion
   */
  readonly objectVersion?: string;

  /**
   * ARN of the access role that allows Amazon GameLift to access your S3 bucket.
   *
   * @schema BuildSpecForProviderStorageLocation#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema BuildSpecForProviderStorageLocation#roleArnRef
   */
  readonly roleArnRef?: BuildSpecForProviderStorageLocationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema BuildSpecForProviderStorageLocation#roleArnSelector
   */
  readonly roleArnSelector?: BuildSpecForProviderStorageLocationRoleArnSelector;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocation(obj: BuildSpecForProviderStorageLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BuildSpecForProviderStorageLocationBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BuildSpecForProviderStorageLocationBucketSelector(obj.bucketSelector),
    'key': obj.key,
    'keyRef': toJson_BuildSpecForProviderStorageLocationKeyRef(obj.keyRef),
    'keySelector': toJson_BuildSpecForProviderStorageLocationKeySelector(obj.keySelector),
    'objectVersion': obj.objectVersion,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_BuildSpecForProviderStorageLocationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_BuildSpecForProviderStorageLocationRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BuildSpecInitProviderStorageLocation
 */
export interface BuildSpecInitProviderStorageLocation {
  /**
   * A specific version of the file. If not set, the latest version of the file is retrieved.
   *
   * @schema BuildSpecInitProviderStorageLocation#objectVersion
   */
  readonly objectVersion?: string;

}

/**
 * Converts an object of type 'BuildSpecInitProviderStorageLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecInitProviderStorageLocation(obj: BuildSpecInitProviderStorageLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectVersion': obj.objectVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BuildSpecProviderConfigRefPolicy
 */
export interface BuildSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BuildSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BuildSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BuildSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BuildSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BuildSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecProviderConfigRefPolicy(obj: BuildSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BuildSpecPublishConnectionDetailsToConfigRef
 */
export interface BuildSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BuildSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BuildSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BuildSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BuildSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecPublishConnectionDetailsToConfigRef(obj: BuildSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BuildSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BuildSpecPublishConnectionDetailsToMetadata
 */
export interface BuildSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BuildSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BuildSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BuildSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BuildSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecPublishConnectionDetailsToMetadata(obj: BuildSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BuildSpecForProviderStorageLocationBucketRef
 */
export interface BuildSpecForProviderStorageLocationBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BuildSpecForProviderStorageLocationBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BuildSpecForProviderStorageLocationBucketRef#policy
   */
  readonly policy?: BuildSpecForProviderStorageLocationBucketRefPolicy;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationBucketRef(obj: BuildSpecForProviderStorageLocationBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BuildSpecForProviderStorageLocationBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BuildSpecForProviderStorageLocationBucketSelector
 */
export interface BuildSpecForProviderStorageLocationBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BuildSpecForProviderStorageLocationBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BuildSpecForProviderStorageLocationBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BuildSpecForProviderStorageLocationBucketSelector#policy
   */
  readonly policy?: BuildSpecForProviderStorageLocationBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationBucketSelector(obj: BuildSpecForProviderStorageLocationBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BuildSpecForProviderStorageLocationBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Object in s3 to populate key.
 *
 * @schema BuildSpecForProviderStorageLocationKeyRef
 */
export interface BuildSpecForProviderStorageLocationKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema BuildSpecForProviderStorageLocationKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BuildSpecForProviderStorageLocationKeyRef#policy
   */
  readonly policy?: BuildSpecForProviderStorageLocationKeyRefPolicy;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationKeyRef(obj: BuildSpecForProviderStorageLocationKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BuildSpecForProviderStorageLocationKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Object in s3 to populate key.
 *
 * @schema BuildSpecForProviderStorageLocationKeySelector
 */
export interface BuildSpecForProviderStorageLocationKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BuildSpecForProviderStorageLocationKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BuildSpecForProviderStorageLocationKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BuildSpecForProviderStorageLocationKeySelector#policy
   */
  readonly policy?: BuildSpecForProviderStorageLocationKeySelectorPolicy;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationKeySelector(obj: BuildSpecForProviderStorageLocationKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BuildSpecForProviderStorageLocationKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema BuildSpecForProviderStorageLocationRoleArnRef
 */
export interface BuildSpecForProviderStorageLocationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BuildSpecForProviderStorageLocationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BuildSpecForProviderStorageLocationRoleArnRef#policy
   */
  readonly policy?: BuildSpecForProviderStorageLocationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationRoleArnRef(obj: BuildSpecForProviderStorageLocationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BuildSpecForProviderStorageLocationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema BuildSpecForProviderStorageLocationRoleArnSelector
 */
export interface BuildSpecForProviderStorageLocationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BuildSpecForProviderStorageLocationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BuildSpecForProviderStorageLocationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BuildSpecForProviderStorageLocationRoleArnSelector#policy
   */
  readonly policy?: BuildSpecForProviderStorageLocationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationRoleArnSelector(obj: BuildSpecForProviderStorageLocationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BuildSpecForProviderStorageLocationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BuildSpecProviderConfigRefPolicyResolution
 */
export enum BuildSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BuildSpecProviderConfigRefPolicyResolve
 */
export enum BuildSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BuildSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BuildSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BuildSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BuildSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BuildSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BuildSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BuildSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecPublishConnectionDetailsToConfigRefPolicy(obj: BuildSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BuildSpecForProviderStorageLocationBucketRefPolicy
 */
export interface BuildSpecForProviderStorageLocationBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BuildSpecForProviderStorageLocationBucketRefPolicy#resolution
   */
  readonly resolution?: BuildSpecForProviderStorageLocationBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BuildSpecForProviderStorageLocationBucketRefPolicy#resolve
   */
  readonly resolve?: BuildSpecForProviderStorageLocationBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationBucketRefPolicy(obj: BuildSpecForProviderStorageLocationBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BuildSpecForProviderStorageLocationBucketSelectorPolicy
 */
export interface BuildSpecForProviderStorageLocationBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BuildSpecForProviderStorageLocationBucketSelectorPolicy#resolution
   */
  readonly resolution?: BuildSpecForProviderStorageLocationBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BuildSpecForProviderStorageLocationBucketSelectorPolicy#resolve
   */
  readonly resolve?: BuildSpecForProviderStorageLocationBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationBucketSelectorPolicy(obj: BuildSpecForProviderStorageLocationBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BuildSpecForProviderStorageLocationKeyRefPolicy
 */
export interface BuildSpecForProviderStorageLocationKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BuildSpecForProviderStorageLocationKeyRefPolicy#resolution
   */
  readonly resolution?: BuildSpecForProviderStorageLocationKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BuildSpecForProviderStorageLocationKeyRefPolicy#resolve
   */
  readonly resolve?: BuildSpecForProviderStorageLocationKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationKeyRefPolicy(obj: BuildSpecForProviderStorageLocationKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BuildSpecForProviderStorageLocationKeySelectorPolicy
 */
export interface BuildSpecForProviderStorageLocationKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BuildSpecForProviderStorageLocationKeySelectorPolicy#resolution
   */
  readonly resolution?: BuildSpecForProviderStorageLocationKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BuildSpecForProviderStorageLocationKeySelectorPolicy#resolve
   */
  readonly resolve?: BuildSpecForProviderStorageLocationKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationKeySelectorPolicy(obj: BuildSpecForProviderStorageLocationKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BuildSpecForProviderStorageLocationRoleArnRefPolicy
 */
export interface BuildSpecForProviderStorageLocationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BuildSpecForProviderStorageLocationRoleArnRefPolicy#resolution
   */
  readonly resolution?: BuildSpecForProviderStorageLocationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BuildSpecForProviderStorageLocationRoleArnRefPolicy#resolve
   */
  readonly resolve?: BuildSpecForProviderStorageLocationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationRoleArnRefPolicy(obj: BuildSpecForProviderStorageLocationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BuildSpecForProviderStorageLocationRoleArnSelectorPolicy
 */
export interface BuildSpecForProviderStorageLocationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BuildSpecForProviderStorageLocationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: BuildSpecForProviderStorageLocationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BuildSpecForProviderStorageLocationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: BuildSpecForProviderStorageLocationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BuildSpecForProviderStorageLocationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BuildSpecForProviderStorageLocationRoleArnSelectorPolicy(obj: BuildSpecForProviderStorageLocationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BuildSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BuildSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BuildSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BuildSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BuildSpecForProviderStorageLocationBucketRefPolicyResolution
 */
export enum BuildSpecForProviderStorageLocationBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BuildSpecForProviderStorageLocationBucketRefPolicyResolve
 */
export enum BuildSpecForProviderStorageLocationBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BuildSpecForProviderStorageLocationBucketSelectorPolicyResolution
 */
export enum BuildSpecForProviderStorageLocationBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BuildSpecForProviderStorageLocationBucketSelectorPolicyResolve
 */
export enum BuildSpecForProviderStorageLocationBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BuildSpecForProviderStorageLocationKeyRefPolicyResolution
 */
export enum BuildSpecForProviderStorageLocationKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BuildSpecForProviderStorageLocationKeyRefPolicyResolve
 */
export enum BuildSpecForProviderStorageLocationKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BuildSpecForProviderStorageLocationKeySelectorPolicyResolution
 */
export enum BuildSpecForProviderStorageLocationKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BuildSpecForProviderStorageLocationKeySelectorPolicyResolve
 */
export enum BuildSpecForProviderStorageLocationKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BuildSpecForProviderStorageLocationRoleArnRefPolicyResolution
 */
export enum BuildSpecForProviderStorageLocationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BuildSpecForProviderStorageLocationRoleArnRefPolicyResolve
 */
export enum BuildSpecForProviderStorageLocationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BuildSpecForProviderStorageLocationRoleArnSelectorPolicyResolution
 */
export enum BuildSpecForProviderStorageLocationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BuildSpecForProviderStorageLocationRoleArnSelectorPolicyResolve
 */
export enum BuildSpecForProviderStorageLocationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Fleet is the Schema for the Fleets API. Provides a GameLift Fleet resource.
 *
 * @schema Fleet
 */
export class Fleet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Fleet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gamelift.aws.upbound.io/v1beta1',
    kind: 'Fleet',
  }

  /**
   * Renders a Kubernetes manifest for "Fleet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FleetProps): any {
    return {
      ...Fleet.GVK,
      ...toJson_FleetProps(props),
    };
  }

  /**
   * Defines a "Fleet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FleetProps) {
    super(scope, id, {
      ...Fleet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Fleet.GVK,
      ...toJson_FleetProps(resolved),
    };
  }
}

/**
 * Fleet is the Schema for the Fleets API. Provides a GameLift Fleet resource.
 *
 * @schema Fleet
 */
export interface FleetProps {
  /**
   * @schema Fleet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FleetSpec defines the desired state of Fleet
   *
   * @schema Fleet#spec
   */
  readonly spec: FleetSpec;

}

/**
 * Converts an object of type 'FleetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetProps(obj: FleetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FleetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FleetSpec defines the desired state of Fleet
 *
 * @schema FleetSpec
 */
export interface FleetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FleetSpec#deletionPolicy
   */
  readonly deletionPolicy?: FleetSpecDeletionPolicy;

  /**
   * @schema FleetSpec#forProvider
   */
  readonly forProvider: FleetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FleetSpec#initProvider
   */
  readonly initProvider?: FleetSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FleetSpec#managementPolicies
   */
  readonly managementPolicies?: FleetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FleetSpec#providerConfigRef
   */
  readonly providerConfigRef?: FleetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FleetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FleetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FleetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FleetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FleetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpec(obj: FleetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FleetSpecForProvider(obj.forProvider),
    'initProvider': toJson_FleetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FleetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FleetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FleetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FleetSpecDeletionPolicy
 */
export enum FleetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FleetSpecForProvider
 */
export interface FleetSpecForProvider {
  /**
   * ID of the GameLift Build to be deployed on the fleet.
   *
   * @schema FleetSpecForProvider#buildId
   */
  readonly buildId?: string;

  /**
   * Reference to a Build to populate buildId.
   *
   * @schema FleetSpecForProvider#buildIdRef
   */
  readonly buildIdRef?: FleetSpecForProviderBuildIdRef;

  /**
   * Selector for a Build to populate buildId.
   *
   * @schema FleetSpecForProvider#buildIdSelector
   */
  readonly buildIdSelector?: FleetSpecForProviderBuildIdSelector;

  /**
   * Prompts GameLift to generate a TLS/SSL certificate for the fleet. See certificate_configuration.
   *
   * @schema FleetSpecForProvider#certificateConfiguration
   */
  readonly certificateConfiguration?: FleetSpecForProviderCertificateConfiguration[];

  /**
   * Human-readable description of the fleet.
   *
   * @schema FleetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Range of IP addresses and port settings that permit inbound traffic to access server processes running on the fleet. See below.
   *
   * @schema FleetSpecForProvider#ec2InboundPermission
   */
  readonly ec2InboundPermission?: FleetSpecForProviderEc2InboundPermission[];

  /**
   * Name of an EC2 instance typeE.g., t2.micro
   *
   * @schema FleetSpecForProvider#ec2InstanceType
   */
  readonly ec2InstanceType?: string;

  /**
   * Type of fleet. This value must be ON_DEMAND or SPOT. Defaults to ON_DEMAND.
   *
   * @default ON_DEMAND.
   * @schema FleetSpecForProvider#fleetType
   */
  readonly fleetType?: string;

  /**
   * ARN of an IAM role that instances in the fleet can assume.
   *
   * @schema FleetSpecForProvider#instanceRoleArn
   */
  readonly instanceRoleArn?: string;

  /**
   * Reference to a Role in iam to populate instanceRoleArn.
   *
   * @schema FleetSpecForProvider#instanceRoleArnRef
   */
  readonly instanceRoleArnRef?: FleetSpecForProviderInstanceRoleArnRef;

  /**
   * Selector for a Role in iam to populate instanceRoleArn.
   *
   * @schema FleetSpecForProvider#instanceRoleArnSelector
   */
  readonly instanceRoleArnSelector?: FleetSpecForProviderInstanceRoleArnSelector;

  /**
   * List of names of metric groups to add this fleet to. A metric group tracks metrics across all fleets in the group. Defaults to default.
   *
   * @default default.
   * @schema FleetSpecForProvider#metricGroups
   */
  readonly metricGroups?: string[];

  /**
   * The name of the fleet.
   *
   * @schema FleetSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Game session protection policy to apply to all instances in this fleetE.g., FullProtection. Defaults to NoProtection.
   *
   * @default NoProtection.
   * @schema FleetSpecForProvider#newGameSessionProtectionPolicy
   */
  readonly newGameSessionProtectionPolicy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FleetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Policy that limits the number of game sessions an individual player can create over a span of time for this fleet. See below.
   *
   * @schema FleetSpecForProvider#resourceCreationLimitPolicy
   */
  readonly resourceCreationLimitPolicy?: FleetSpecForProviderResourceCreationLimitPolicy[];

  /**
   * Instructions for launching server processes on each instance in the fleet. See below.
   *
   * @schema FleetSpecForProvider#runtimeConfiguration
   */
  readonly runtimeConfiguration?: FleetSpecForProviderRuntimeConfiguration[];

  /**
   * ID of the GameLift Script to be deployed on the fleet.
   *
   * @schema FleetSpecForProvider#scriptId
   */
  readonly scriptId?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FleetSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FleetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProvider(obj: FleetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buildId': obj.buildId,
    'buildIdRef': toJson_FleetSpecForProviderBuildIdRef(obj.buildIdRef),
    'buildIdSelector': toJson_FleetSpecForProviderBuildIdSelector(obj.buildIdSelector),
    'certificateConfiguration': obj.certificateConfiguration?.map(y => toJson_FleetSpecForProviderCertificateConfiguration(y)),
    'description': obj.description,
    'ec2InboundPermission': obj.ec2InboundPermission?.map(y => toJson_FleetSpecForProviderEc2InboundPermission(y)),
    'ec2InstanceType': obj.ec2InstanceType,
    'fleetType': obj.fleetType,
    'instanceRoleArn': obj.instanceRoleArn,
    'instanceRoleArnRef': toJson_FleetSpecForProviderInstanceRoleArnRef(obj.instanceRoleArnRef),
    'instanceRoleArnSelector': toJson_FleetSpecForProviderInstanceRoleArnSelector(obj.instanceRoleArnSelector),
    'metricGroups': obj.metricGroups?.map(y => y),
    'name': obj.name,
    'newGameSessionProtectionPolicy': obj.newGameSessionProtectionPolicy,
    'region': obj.region,
    'resourceCreationLimitPolicy': obj.resourceCreationLimitPolicy?.map(y => toJson_FleetSpecForProviderResourceCreationLimitPolicy(y)),
    'runtimeConfiguration': obj.runtimeConfiguration?.map(y => toJson_FleetSpecForProviderRuntimeConfiguration(y)),
    'scriptId': obj.scriptId,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FleetSpecInitProvider
 */
export interface FleetSpecInitProvider {
  /**
   * Prompts GameLift to generate a TLS/SSL certificate for the fleet. See certificate_configuration.
   *
   * @schema FleetSpecInitProvider#certificateConfiguration
   */
  readonly certificateConfiguration?: FleetSpecInitProviderCertificateConfiguration[];

  /**
   * Human-readable description of the fleet.
   *
   * @schema FleetSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Range of IP addresses and port settings that permit inbound traffic to access server processes running on the fleet. See below.
   *
   * @schema FleetSpecInitProvider#ec2InboundPermission
   */
  readonly ec2InboundPermission?: FleetSpecInitProviderEc2InboundPermission[];

  /**
   * Name of an EC2 instance typeE.g., t2.micro
   *
   * @schema FleetSpecInitProvider#ec2InstanceType
   */
  readonly ec2InstanceType?: string;

  /**
   * Type of fleet. This value must be ON_DEMAND or SPOT. Defaults to ON_DEMAND.
   *
   * @default ON_DEMAND.
   * @schema FleetSpecInitProvider#fleetType
   */
  readonly fleetType?: string;

  /**
   * List of names of metric groups to add this fleet to. A metric group tracks metrics across all fleets in the group. Defaults to default.
   *
   * @default default.
   * @schema FleetSpecInitProvider#metricGroups
   */
  readonly metricGroups?: string[];

  /**
   * The name of the fleet.
   *
   * @schema FleetSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Game session protection policy to apply to all instances in this fleetE.g., FullProtection. Defaults to NoProtection.
   *
   * @default NoProtection.
   * @schema FleetSpecInitProvider#newGameSessionProtectionPolicy
   */
  readonly newGameSessionProtectionPolicy?: string;

  /**
   * Policy that limits the number of game sessions an individual player can create over a span of time for this fleet. See below.
   *
   * @schema FleetSpecInitProvider#resourceCreationLimitPolicy
   */
  readonly resourceCreationLimitPolicy?: FleetSpecInitProviderResourceCreationLimitPolicy[];

  /**
   * Instructions for launching server processes on each instance in the fleet. See below.
   *
   * @schema FleetSpecInitProvider#runtimeConfiguration
   */
  readonly runtimeConfiguration?: FleetSpecInitProviderRuntimeConfiguration[];

  /**
   * ID of the GameLift Script to be deployed on the fleet.
   *
   * @schema FleetSpecInitProvider#scriptId
   */
  readonly scriptId?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FleetSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FleetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecInitProvider(obj: FleetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateConfiguration': obj.certificateConfiguration?.map(y => toJson_FleetSpecInitProviderCertificateConfiguration(y)),
    'description': obj.description,
    'ec2InboundPermission': obj.ec2InboundPermission?.map(y => toJson_FleetSpecInitProviderEc2InboundPermission(y)),
    'ec2InstanceType': obj.ec2InstanceType,
    'fleetType': obj.fleetType,
    'metricGroups': obj.metricGroups?.map(y => y),
    'name': obj.name,
    'newGameSessionProtectionPolicy': obj.newGameSessionProtectionPolicy,
    'resourceCreationLimitPolicy': obj.resourceCreationLimitPolicy?.map(y => toJson_FleetSpecInitProviderResourceCreationLimitPolicy(y)),
    'runtimeConfiguration': obj.runtimeConfiguration?.map(y => toJson_FleetSpecInitProviderRuntimeConfiguration(y)),
    'scriptId': obj.scriptId,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FleetSpecManagementPolicies
 */
export enum FleetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FleetSpecProviderConfigRef
 */
export interface FleetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetSpecProviderConfigRef#policy
   */
  readonly policy?: FleetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FleetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecProviderConfigRef(obj: FleetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FleetSpecPublishConnectionDetailsTo
 */
export interface FleetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FleetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FleetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FleetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FleetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FleetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FleetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecPublishConnectionDetailsTo(obj: FleetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FleetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FleetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FleetSpecWriteConnectionSecretToRef
 */
export interface FleetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FleetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FleetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FleetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecWriteConnectionSecretToRef(obj: FleetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Build to populate buildId.
 *
 * @schema FleetSpecForProviderBuildIdRef
 */
export interface FleetSpecForProviderBuildIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetSpecForProviderBuildIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetSpecForProviderBuildIdRef#policy
   */
  readonly policy?: FleetSpecForProviderBuildIdRefPolicy;

}

/**
 * Converts an object of type 'FleetSpecForProviderBuildIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderBuildIdRef(obj: FleetSpecForProviderBuildIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetSpecForProviderBuildIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Build to populate buildId.
 *
 * @schema FleetSpecForProviderBuildIdSelector
 */
export interface FleetSpecForProviderBuildIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FleetSpecForProviderBuildIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FleetSpecForProviderBuildIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FleetSpecForProviderBuildIdSelector#policy
   */
  readonly policy?: FleetSpecForProviderBuildIdSelectorPolicy;

}

/**
 * Converts an object of type 'FleetSpecForProviderBuildIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderBuildIdSelector(obj: FleetSpecForProviderBuildIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FleetSpecForProviderBuildIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecForProviderCertificateConfiguration
 */
export interface FleetSpecForProviderCertificateConfiguration {
  /**
   * Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are DISABLED and GENERATED. Default value is DISABLED.
   *
   * @schema FleetSpecForProviderCertificateConfiguration#certificateType
   */
  readonly certificateType?: string;

}

/**
 * Converts an object of type 'FleetSpecForProviderCertificateConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderCertificateConfiguration(obj: FleetSpecForProviderCertificateConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateType': obj.certificateType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecForProviderEc2InboundPermission
 */
export interface FleetSpecForProviderEc2InboundPermission {
  /**
   * Starting value for a range of allowed port numbers.
   *
   * @schema FleetSpecForProviderEc2InboundPermission#fromPort
   */
  readonly fromPort?: number;

  /**
   * Range of allowed IP addresses expressed in CIDR notationE.g., 000.000.000.000/[subnet mask] or 0.0.0.0/[subnet mask].
   *
   * @schema FleetSpecForProviderEc2InboundPermission#ipRange
   */
  readonly ipRange?: string;

  /**
   * Network communication protocol used by the fleetE.g., TCP or UDP
   *
   * @schema FleetSpecForProviderEc2InboundPermission#protocol
   */
  readonly protocol?: string;

  /**
   * Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than from_port.
   *
   * @schema FleetSpecForProviderEc2InboundPermission#toPort
   */
  readonly toPort?: number;

}

/**
 * Converts an object of type 'FleetSpecForProviderEc2InboundPermission' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderEc2InboundPermission(obj: FleetSpecForProviderEc2InboundPermission | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'ipRange': obj.ipRange,
    'protocol': obj.protocol,
    'toPort': obj.toPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate instanceRoleArn.
 *
 * @schema FleetSpecForProviderInstanceRoleArnRef
 */
export interface FleetSpecForProviderInstanceRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetSpecForProviderInstanceRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetSpecForProviderInstanceRoleArnRef#policy
   */
  readonly policy?: FleetSpecForProviderInstanceRoleArnRefPolicy;

}

/**
 * Converts an object of type 'FleetSpecForProviderInstanceRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderInstanceRoleArnRef(obj: FleetSpecForProviderInstanceRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetSpecForProviderInstanceRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate instanceRoleArn.
 *
 * @schema FleetSpecForProviderInstanceRoleArnSelector
 */
export interface FleetSpecForProviderInstanceRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FleetSpecForProviderInstanceRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FleetSpecForProviderInstanceRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FleetSpecForProviderInstanceRoleArnSelector#policy
   */
  readonly policy?: FleetSpecForProviderInstanceRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'FleetSpecForProviderInstanceRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderInstanceRoleArnSelector(obj: FleetSpecForProviderInstanceRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FleetSpecForProviderInstanceRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecForProviderResourceCreationLimitPolicy
 */
export interface FleetSpecForProviderResourceCreationLimitPolicy {
  /**
   * Maximum number of game sessions that an individual can create during the policy period.
   *
   * @schema FleetSpecForProviderResourceCreationLimitPolicy#newGameSessionsPerCreator
   */
  readonly newGameSessionsPerCreator?: number;

  /**
   * Time span used in evaluating the resource creation limit policy.
   *
   * @schema FleetSpecForProviderResourceCreationLimitPolicy#policyPeriodInMinutes
   */
  readonly policyPeriodInMinutes?: number;

}

/**
 * Converts an object of type 'FleetSpecForProviderResourceCreationLimitPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderResourceCreationLimitPolicy(obj: FleetSpecForProviderResourceCreationLimitPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newGameSessionsPerCreator': obj.newGameSessionsPerCreator,
    'policyPeriodInMinutes': obj.policyPeriodInMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecForProviderRuntimeConfiguration
 */
export interface FleetSpecForProviderRuntimeConfiguration {
  /**
   * Maximum amount of time (in seconds) that a game session can remain in status ACTIVATING.
   *
   * @schema FleetSpecForProviderRuntimeConfiguration#gameSessionActivationTimeoutSeconds
   */
  readonly gameSessionActivationTimeoutSeconds?: number;

  /**
   * Maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously.
   *
   * @schema FleetSpecForProviderRuntimeConfiguration#maxConcurrentGameSessionActivations
   */
  readonly maxConcurrentGameSessionActivations?: number;

  /**
   * Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
   *
   * @schema FleetSpecForProviderRuntimeConfiguration#serverProcess
   */
  readonly serverProcess?: FleetSpecForProviderRuntimeConfigurationServerProcess[];

}

/**
 * Converts an object of type 'FleetSpecForProviderRuntimeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderRuntimeConfiguration(obj: FleetSpecForProviderRuntimeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gameSessionActivationTimeoutSeconds': obj.gameSessionActivationTimeoutSeconds,
    'maxConcurrentGameSessionActivations': obj.maxConcurrentGameSessionActivations,
    'serverProcess': obj.serverProcess?.map(y => toJson_FleetSpecForProviderRuntimeConfigurationServerProcess(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecInitProviderCertificateConfiguration
 */
export interface FleetSpecInitProviderCertificateConfiguration {
  /**
   * Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are DISABLED and GENERATED. Default value is DISABLED.
   *
   * @schema FleetSpecInitProviderCertificateConfiguration#certificateType
   */
  readonly certificateType?: string;

}

/**
 * Converts an object of type 'FleetSpecInitProviderCertificateConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecInitProviderCertificateConfiguration(obj: FleetSpecInitProviderCertificateConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateType': obj.certificateType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecInitProviderEc2InboundPermission
 */
export interface FleetSpecInitProviderEc2InboundPermission {
  /**
   * Starting value for a range of allowed port numbers.
   *
   * @schema FleetSpecInitProviderEc2InboundPermission#fromPort
   */
  readonly fromPort?: number;

  /**
   * Range of allowed IP addresses expressed in CIDR notationE.g., 000.000.000.000/[subnet mask] or 0.0.0.0/[subnet mask].
   *
   * @schema FleetSpecInitProviderEc2InboundPermission#ipRange
   */
  readonly ipRange?: string;

  /**
   * Network communication protocol used by the fleetE.g., TCP or UDP
   *
   * @schema FleetSpecInitProviderEc2InboundPermission#protocol
   */
  readonly protocol?: string;

  /**
   * Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than from_port.
   *
   * @schema FleetSpecInitProviderEc2InboundPermission#toPort
   */
  readonly toPort?: number;

}

/**
 * Converts an object of type 'FleetSpecInitProviderEc2InboundPermission' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecInitProviderEc2InboundPermission(obj: FleetSpecInitProviderEc2InboundPermission | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'ipRange': obj.ipRange,
    'protocol': obj.protocol,
    'toPort': obj.toPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecInitProviderResourceCreationLimitPolicy
 */
export interface FleetSpecInitProviderResourceCreationLimitPolicy {
  /**
   * Maximum number of game sessions that an individual can create during the policy period.
   *
   * @schema FleetSpecInitProviderResourceCreationLimitPolicy#newGameSessionsPerCreator
   */
  readonly newGameSessionsPerCreator?: number;

  /**
   * Time span used in evaluating the resource creation limit policy.
   *
   * @schema FleetSpecInitProviderResourceCreationLimitPolicy#policyPeriodInMinutes
   */
  readonly policyPeriodInMinutes?: number;

}

/**
 * Converts an object of type 'FleetSpecInitProviderResourceCreationLimitPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecInitProviderResourceCreationLimitPolicy(obj: FleetSpecInitProviderResourceCreationLimitPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newGameSessionsPerCreator': obj.newGameSessionsPerCreator,
    'policyPeriodInMinutes': obj.policyPeriodInMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecInitProviderRuntimeConfiguration
 */
export interface FleetSpecInitProviderRuntimeConfiguration {
  /**
   * Maximum amount of time (in seconds) that a game session can remain in status ACTIVATING.
   *
   * @schema FleetSpecInitProviderRuntimeConfiguration#gameSessionActivationTimeoutSeconds
   */
  readonly gameSessionActivationTimeoutSeconds?: number;

  /**
   * Maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously.
   *
   * @schema FleetSpecInitProviderRuntimeConfiguration#maxConcurrentGameSessionActivations
   */
  readonly maxConcurrentGameSessionActivations?: number;

  /**
   * Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
   *
   * @schema FleetSpecInitProviderRuntimeConfiguration#serverProcess
   */
  readonly serverProcess?: FleetSpecInitProviderRuntimeConfigurationServerProcess[];

}

/**
 * Converts an object of type 'FleetSpecInitProviderRuntimeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecInitProviderRuntimeConfiguration(obj: FleetSpecInitProviderRuntimeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gameSessionActivationTimeoutSeconds': obj.gameSessionActivationTimeoutSeconds,
    'maxConcurrentGameSessionActivations': obj.maxConcurrentGameSessionActivations,
    'serverProcess': obj.serverProcess?.map(y => toJson_FleetSpecInitProviderRuntimeConfigurationServerProcess(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FleetSpecProviderConfigRefPolicy
 */
export interface FleetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FleetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FleetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecProviderConfigRefPolicy(obj: FleetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FleetSpecPublishConnectionDetailsToConfigRef
 */
export interface FleetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FleetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FleetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecPublishConnectionDetailsToConfigRef(obj: FleetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FleetSpecPublishConnectionDetailsToMetadata
 */
export interface FleetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FleetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FleetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FleetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FleetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecPublishConnectionDetailsToMetadata(obj: FleetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FleetSpecForProviderBuildIdRefPolicy
 */
export interface FleetSpecForProviderBuildIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecForProviderBuildIdRefPolicy#resolution
   */
  readonly resolution?: FleetSpecForProviderBuildIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecForProviderBuildIdRefPolicy#resolve
   */
  readonly resolve?: FleetSpecForProviderBuildIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecForProviderBuildIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderBuildIdRefPolicy(obj: FleetSpecForProviderBuildIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FleetSpecForProviderBuildIdSelectorPolicy
 */
export interface FleetSpecForProviderBuildIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecForProviderBuildIdSelectorPolicy#resolution
   */
  readonly resolution?: FleetSpecForProviderBuildIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecForProviderBuildIdSelectorPolicy#resolve
   */
  readonly resolve?: FleetSpecForProviderBuildIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecForProviderBuildIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderBuildIdSelectorPolicy(obj: FleetSpecForProviderBuildIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FleetSpecForProviderInstanceRoleArnRefPolicy
 */
export interface FleetSpecForProviderInstanceRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecForProviderInstanceRoleArnRefPolicy#resolution
   */
  readonly resolution?: FleetSpecForProviderInstanceRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecForProviderInstanceRoleArnRefPolicy#resolve
   */
  readonly resolve?: FleetSpecForProviderInstanceRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecForProviderInstanceRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderInstanceRoleArnRefPolicy(obj: FleetSpecForProviderInstanceRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FleetSpecForProviderInstanceRoleArnSelectorPolicy
 */
export interface FleetSpecForProviderInstanceRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecForProviderInstanceRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: FleetSpecForProviderInstanceRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecForProviderInstanceRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: FleetSpecForProviderInstanceRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecForProviderInstanceRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderInstanceRoleArnSelectorPolicy(obj: FleetSpecForProviderInstanceRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecForProviderRuntimeConfigurationServerProcess
 */
export interface FleetSpecForProviderRuntimeConfigurationServerProcess {
  /**
   * Number of server processes using this configuration to run concurrently on an instance.
   *
   * @schema FleetSpecForProviderRuntimeConfigurationServerProcess#concurrentExecutions
   */
  readonly concurrentExecutions?: number;

  /**
   * Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances C:\game, and for Linux instances /local/game.
   *
   * @schema FleetSpecForProviderRuntimeConfigurationServerProcess#launchPath
   */
  readonly launchPath?: string;

  /**
   * Optional list of parameters to pass to the server executable on launch.
   *
   * @schema FleetSpecForProviderRuntimeConfigurationServerProcess#parameters
   */
  readonly parameters?: string;

}

/**
 * Converts an object of type 'FleetSpecForProviderRuntimeConfigurationServerProcess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderRuntimeConfigurationServerProcess(obj: FleetSpecForProviderRuntimeConfigurationServerProcess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'concurrentExecutions': obj.concurrentExecutions,
    'launchPath': obj.launchPath,
    'parameters': obj.parameters,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecInitProviderRuntimeConfigurationServerProcess
 */
export interface FleetSpecInitProviderRuntimeConfigurationServerProcess {
  /**
   * Number of server processes using this configuration to run concurrently on an instance.
   *
   * @schema FleetSpecInitProviderRuntimeConfigurationServerProcess#concurrentExecutions
   */
  readonly concurrentExecutions?: number;

  /**
   * Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances C:\game, and for Linux instances /local/game.
   *
   * @schema FleetSpecInitProviderRuntimeConfigurationServerProcess#launchPath
   */
  readonly launchPath?: string;

  /**
   * Optional list of parameters to pass to the server executable on launch.
   *
   * @schema FleetSpecInitProviderRuntimeConfigurationServerProcess#parameters
   */
  readonly parameters?: string;

}

/**
 * Converts an object of type 'FleetSpecInitProviderRuntimeConfigurationServerProcess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecInitProviderRuntimeConfigurationServerProcess(obj: FleetSpecInitProviderRuntimeConfigurationServerProcess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'concurrentExecutions': obj.concurrentExecutions,
    'launchPath': obj.launchPath,
    'parameters': obj.parameters,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecProviderConfigRefPolicyResolution
 */
export enum FleetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecProviderConfigRefPolicyResolve
 */
export enum FleetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FleetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FleetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FleetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FleetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecPublishConnectionDetailsToConfigRefPolicy(obj: FleetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecForProviderBuildIdRefPolicyResolution
 */
export enum FleetSpecForProviderBuildIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecForProviderBuildIdRefPolicyResolve
 */
export enum FleetSpecForProviderBuildIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecForProviderBuildIdSelectorPolicyResolution
 */
export enum FleetSpecForProviderBuildIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecForProviderBuildIdSelectorPolicyResolve
 */
export enum FleetSpecForProviderBuildIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecForProviderInstanceRoleArnRefPolicyResolution
 */
export enum FleetSpecForProviderInstanceRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecForProviderInstanceRoleArnRefPolicyResolve
 */
export enum FleetSpecForProviderInstanceRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecForProviderInstanceRoleArnSelectorPolicyResolution
 */
export enum FleetSpecForProviderInstanceRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecForProviderInstanceRoleArnSelectorPolicyResolve
 */
export enum FleetSpecForProviderInstanceRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FleetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FleetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GameSessionQueue is the Schema for the GameSessionQueues API. Provides a GameLift Game Session Queue resource.
 *
 * @schema GameSessionQueue
 */
export class GameSessionQueue extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GameSessionQueue"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gamelift.aws.upbound.io/v1beta1',
    kind: 'GameSessionQueue',
  }

  /**
   * Renders a Kubernetes manifest for "GameSessionQueue".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GameSessionQueueProps): any {
    return {
      ...GameSessionQueue.GVK,
      ...toJson_GameSessionQueueProps(props),
    };
  }

  /**
   * Defines a "GameSessionQueue" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GameSessionQueueProps) {
    super(scope, id, {
      ...GameSessionQueue.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GameSessionQueue.GVK,
      ...toJson_GameSessionQueueProps(resolved),
    };
  }
}

/**
 * GameSessionQueue is the Schema for the GameSessionQueues API. Provides a GameLift Game Session Queue resource.
 *
 * @schema GameSessionQueue
 */
export interface GameSessionQueueProps {
  /**
   * @schema GameSessionQueue#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GameSessionQueueSpec defines the desired state of GameSessionQueue
   *
   * @schema GameSessionQueue#spec
   */
  readonly spec: GameSessionQueueSpec;

}

/**
 * Converts an object of type 'GameSessionQueueProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueProps(obj: GameSessionQueueProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GameSessionQueueSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GameSessionQueueSpec defines the desired state of GameSessionQueue
 *
 * @schema GameSessionQueueSpec
 */
export interface GameSessionQueueSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GameSessionQueueSpec#deletionPolicy
   */
  readonly deletionPolicy?: GameSessionQueueSpecDeletionPolicy;

  /**
   * @schema GameSessionQueueSpec#forProvider
   */
  readonly forProvider: GameSessionQueueSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema GameSessionQueueSpec#initProvider
   */
  readonly initProvider?: GameSessionQueueSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GameSessionQueueSpec#managementPolicies
   */
  readonly managementPolicies?: GameSessionQueueSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GameSessionQueueSpec#providerConfigRef
   */
  readonly providerConfigRef?: GameSessionQueueSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GameSessionQueueSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GameSessionQueueSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GameSessionQueueSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GameSessionQueueSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GameSessionQueueSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpec(obj: GameSessionQueueSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GameSessionQueueSpecForProvider(obj.forProvider),
    'initProvider': toJson_GameSessionQueueSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GameSessionQueueSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GameSessionQueueSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GameSessionQueueSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GameSessionQueueSpecDeletionPolicy
 */
export enum GameSessionQueueSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GameSessionQueueSpecForProvider
 */
export interface GameSessionQueueSpecForProvider {
  /**
   * Information to be added to all events that are related to this game session queue.
   *
   * @schema GameSessionQueueSpecForProvider#customEventData
   */
  readonly customEventData?: string;

  /**
   * List of fleet/alias ARNs used by session queue for placing game sessions.
   *
   * @schema GameSessionQueueSpecForProvider#destinations
   */
  readonly destinations?: string[];

  /**
   * An SNS topic ARN that is set up to receive game session placement notifications.
   *
   * @schema GameSessionQueueSpecForProvider#notificationTarget
   */
  readonly notificationTarget?: string;

  /**
   * Reference to a Topic in sns to populate notificationTarget.
   *
   * @schema GameSessionQueueSpecForProvider#notificationTargetRef
   */
  readonly notificationTargetRef?: GameSessionQueueSpecForProviderNotificationTargetRef;

  /**
   * Selector for a Topic in sns to populate notificationTarget.
   *
   * @schema GameSessionQueueSpecForProvider#notificationTargetSelector
   */
  readonly notificationTargetSelector?: GameSessionQueueSpecForProviderNotificationTargetSelector;

  /**
   * One or more policies used to choose fleet based on player latency. See below.
   *
   * @schema GameSessionQueueSpecForProvider#playerLatencyPolicy
   */
  readonly playerLatencyPolicy?: GameSessionQueueSpecForProviderPlayerLatencyPolicy[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GameSessionQueueSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema GameSessionQueueSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Maximum time a game session request can remain in the queue.
   *
   * @schema GameSessionQueueSpecForProvider#timeoutInSeconds
   */
  readonly timeoutInSeconds?: number;

}

/**
 * Converts an object of type 'GameSessionQueueSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecForProvider(obj: GameSessionQueueSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customEventData': obj.customEventData,
    'destinations': obj.destinations?.map(y => y),
    'notificationTarget': obj.notificationTarget,
    'notificationTargetRef': toJson_GameSessionQueueSpecForProviderNotificationTargetRef(obj.notificationTargetRef),
    'notificationTargetSelector': toJson_GameSessionQueueSpecForProviderNotificationTargetSelector(obj.notificationTargetSelector),
    'playerLatencyPolicy': obj.playerLatencyPolicy?.map(y => toJson_GameSessionQueueSpecForProviderPlayerLatencyPolicy(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timeoutInSeconds': obj.timeoutInSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema GameSessionQueueSpecInitProvider
 */
export interface GameSessionQueueSpecInitProvider {
  /**
   * Information to be added to all events that are related to this game session queue.
   *
   * @schema GameSessionQueueSpecInitProvider#customEventData
   */
  readonly customEventData?: string;

  /**
   * List of fleet/alias ARNs used by session queue for placing game sessions.
   *
   * @schema GameSessionQueueSpecInitProvider#destinations
   */
  readonly destinations?: string[];

  /**
   * One or more policies used to choose fleet based on player latency. See below.
   *
   * @schema GameSessionQueueSpecInitProvider#playerLatencyPolicy
   */
  readonly playerLatencyPolicy?: GameSessionQueueSpecInitProviderPlayerLatencyPolicy[];

  /**
   * Key-value map of resource tags.
   *
   * @schema GameSessionQueueSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Maximum time a game session request can remain in the queue.
   *
   * @schema GameSessionQueueSpecInitProvider#timeoutInSeconds
   */
  readonly timeoutInSeconds?: number;

}

/**
 * Converts an object of type 'GameSessionQueueSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecInitProvider(obj: GameSessionQueueSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customEventData': obj.customEventData,
    'destinations': obj.destinations?.map(y => y),
    'playerLatencyPolicy': obj.playerLatencyPolicy?.map(y => toJson_GameSessionQueueSpecInitProviderPlayerLatencyPolicy(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timeoutInSeconds': obj.timeoutInSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GameSessionQueueSpecManagementPolicies
 */
export enum GameSessionQueueSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GameSessionQueueSpecProviderConfigRef
 */
export interface GameSessionQueueSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GameSessionQueueSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GameSessionQueueSpecProviderConfigRef#policy
   */
  readonly policy?: GameSessionQueueSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GameSessionQueueSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecProviderConfigRef(obj: GameSessionQueueSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GameSessionQueueSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GameSessionQueueSpecPublishConnectionDetailsTo
 */
export interface GameSessionQueueSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GameSessionQueueSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GameSessionQueueSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GameSessionQueueSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GameSessionQueueSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GameSessionQueueSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GameSessionQueueSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecPublishConnectionDetailsTo(obj: GameSessionQueueSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GameSessionQueueSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GameSessionQueueSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GameSessionQueueSpecWriteConnectionSecretToRef
 */
export interface GameSessionQueueSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GameSessionQueueSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GameSessionQueueSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GameSessionQueueSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecWriteConnectionSecretToRef(obj: GameSessionQueueSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate notificationTarget.
 *
 * @schema GameSessionQueueSpecForProviderNotificationTargetRef
 */
export interface GameSessionQueueSpecForProviderNotificationTargetRef {
  /**
   * Name of the referenced object.
   *
   * @schema GameSessionQueueSpecForProviderNotificationTargetRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GameSessionQueueSpecForProviderNotificationTargetRef#policy
   */
  readonly policy?: GameSessionQueueSpecForProviderNotificationTargetRefPolicy;

}

/**
 * Converts an object of type 'GameSessionQueueSpecForProviderNotificationTargetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecForProviderNotificationTargetRef(obj: GameSessionQueueSpecForProviderNotificationTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GameSessionQueueSpecForProviderNotificationTargetRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate notificationTarget.
 *
 * @schema GameSessionQueueSpecForProviderNotificationTargetSelector
 */
export interface GameSessionQueueSpecForProviderNotificationTargetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GameSessionQueueSpecForProviderNotificationTargetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GameSessionQueueSpecForProviderNotificationTargetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GameSessionQueueSpecForProviderNotificationTargetSelector#policy
   */
  readonly policy?: GameSessionQueueSpecForProviderNotificationTargetSelectorPolicy;

}

/**
 * Converts an object of type 'GameSessionQueueSpecForProviderNotificationTargetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecForProviderNotificationTargetSelector(obj: GameSessionQueueSpecForProviderNotificationTargetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GameSessionQueueSpecForProviderNotificationTargetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GameSessionQueueSpecForProviderPlayerLatencyPolicy
 */
export interface GameSessionQueueSpecForProviderPlayerLatencyPolicy {
  /**
   * Maximum latency value that is allowed for any player.
   *
   * @schema GameSessionQueueSpecForProviderPlayerLatencyPolicy#maximumIndividualPlayerLatencyMilliseconds
   */
  readonly maximumIndividualPlayerLatencyMilliseconds?: number;

  /**
   * Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
   *
   * @schema GameSessionQueueSpecForProviderPlayerLatencyPolicy#policyDurationSeconds
   */
  readonly policyDurationSeconds?: number;

}

/**
 * Converts an object of type 'GameSessionQueueSpecForProviderPlayerLatencyPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecForProviderPlayerLatencyPolicy(obj: GameSessionQueueSpecForProviderPlayerLatencyPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumIndividualPlayerLatencyMilliseconds': obj.maximumIndividualPlayerLatencyMilliseconds,
    'policyDurationSeconds': obj.policyDurationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GameSessionQueueSpecInitProviderPlayerLatencyPolicy
 */
export interface GameSessionQueueSpecInitProviderPlayerLatencyPolicy {
  /**
   * Maximum latency value that is allowed for any player.
   *
   * @schema GameSessionQueueSpecInitProviderPlayerLatencyPolicy#maximumIndividualPlayerLatencyMilliseconds
   */
  readonly maximumIndividualPlayerLatencyMilliseconds?: number;

  /**
   * Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
   *
   * @schema GameSessionQueueSpecInitProviderPlayerLatencyPolicy#policyDurationSeconds
   */
  readonly policyDurationSeconds?: number;

}

/**
 * Converts an object of type 'GameSessionQueueSpecInitProviderPlayerLatencyPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecInitProviderPlayerLatencyPolicy(obj: GameSessionQueueSpecInitProviderPlayerLatencyPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumIndividualPlayerLatencyMilliseconds': obj.maximumIndividualPlayerLatencyMilliseconds,
    'policyDurationSeconds': obj.policyDurationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GameSessionQueueSpecProviderConfigRefPolicy
 */
export interface GameSessionQueueSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GameSessionQueueSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GameSessionQueueSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GameSessionQueueSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GameSessionQueueSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GameSessionQueueSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecProviderConfigRefPolicy(obj: GameSessionQueueSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GameSessionQueueSpecPublishConnectionDetailsToConfigRef
 */
export interface GameSessionQueueSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GameSessionQueueSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GameSessionQueueSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GameSessionQueueSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecPublishConnectionDetailsToConfigRef(obj: GameSessionQueueSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GameSessionQueueSpecPublishConnectionDetailsToMetadata
 */
export interface GameSessionQueueSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GameSessionQueueSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GameSessionQueueSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GameSessionQueueSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GameSessionQueueSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecPublishConnectionDetailsToMetadata(obj: GameSessionQueueSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GameSessionQueueSpecForProviderNotificationTargetRefPolicy
 */
export interface GameSessionQueueSpecForProviderNotificationTargetRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GameSessionQueueSpecForProviderNotificationTargetRefPolicy#resolution
   */
  readonly resolution?: GameSessionQueueSpecForProviderNotificationTargetRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GameSessionQueueSpecForProviderNotificationTargetRefPolicy#resolve
   */
  readonly resolve?: GameSessionQueueSpecForProviderNotificationTargetRefPolicyResolve;

}

/**
 * Converts an object of type 'GameSessionQueueSpecForProviderNotificationTargetRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecForProviderNotificationTargetRefPolicy(obj: GameSessionQueueSpecForProviderNotificationTargetRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GameSessionQueueSpecForProviderNotificationTargetSelectorPolicy
 */
export interface GameSessionQueueSpecForProviderNotificationTargetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GameSessionQueueSpecForProviderNotificationTargetSelectorPolicy#resolution
   */
  readonly resolution?: GameSessionQueueSpecForProviderNotificationTargetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GameSessionQueueSpecForProviderNotificationTargetSelectorPolicy#resolve
   */
  readonly resolve?: GameSessionQueueSpecForProviderNotificationTargetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GameSessionQueueSpecForProviderNotificationTargetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecForProviderNotificationTargetSelectorPolicy(obj: GameSessionQueueSpecForProviderNotificationTargetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GameSessionQueueSpecProviderConfigRefPolicyResolution
 */
export enum GameSessionQueueSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GameSessionQueueSpecProviderConfigRefPolicyResolve
 */
export enum GameSessionQueueSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicy(obj: GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GameSessionQueueSpecForProviderNotificationTargetRefPolicyResolution
 */
export enum GameSessionQueueSpecForProviderNotificationTargetRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GameSessionQueueSpecForProviderNotificationTargetRefPolicyResolve
 */
export enum GameSessionQueueSpecForProviderNotificationTargetRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GameSessionQueueSpecForProviderNotificationTargetSelectorPolicyResolution
 */
export enum GameSessionQueueSpecForProviderNotificationTargetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GameSessionQueueSpecForProviderNotificationTargetSelectorPolicyResolve
 */
export enum GameSessionQueueSpecForProviderNotificationTargetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GameSessionQueueSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Script is the Schema for the Scripts API. Provides a GameLift Script resource.
 *
 * @schema Script
 */
export class Script extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Script"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gamelift.aws.upbound.io/v1beta1',
    kind: 'Script',
  }

  /**
   * Renders a Kubernetes manifest for "Script".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScriptProps): any {
    return {
      ...Script.GVK,
      ...toJson_ScriptProps(props),
    };
  }

  /**
   * Defines a "Script" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScriptProps) {
    super(scope, id, {
      ...Script.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Script.GVK,
      ...toJson_ScriptProps(resolved),
    };
  }
}

/**
 * Script is the Schema for the Scripts API. Provides a GameLift Script resource.
 *
 * @schema Script
 */
export interface ScriptProps {
  /**
   * @schema Script#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScriptSpec defines the desired state of Script
   *
   * @schema Script#spec
   */
  readonly spec: ScriptSpec;

}

/**
 * Converts an object of type 'ScriptProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptProps(obj: ScriptProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScriptSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScriptSpec defines the desired state of Script
 *
 * @schema ScriptSpec
 */
export interface ScriptSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScriptSpec#deletionPolicy
   */
  readonly deletionPolicy?: ScriptSpecDeletionPolicy;

  /**
   * @schema ScriptSpec#forProvider
   */
  readonly forProvider: ScriptSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ScriptSpec#initProvider
   */
  readonly initProvider?: ScriptSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ScriptSpec#managementPolicies
   */
  readonly managementPolicies?: ScriptSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ScriptSpec#providerConfigRef
   */
  readonly providerConfigRef?: ScriptSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ScriptSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ScriptSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ScriptSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ScriptSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ScriptSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpec(obj: ScriptSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ScriptSpecForProvider(obj.forProvider),
    'initProvider': toJson_ScriptSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ScriptSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ScriptSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ScriptSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScriptSpecDeletionPolicy
 */
export enum ScriptSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ScriptSpecForProvider
 */
export interface ScriptSpecForProvider {
  /**
   * Name of the script
   *
   * @schema ScriptSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ScriptSpecForProvider#region
   */
  readonly region: string;

  /**
   * Information indicating where your game script files are stored. See below.
   *
   * @schema ScriptSpecForProvider#storageLocation
   */
  readonly storageLocation?: ScriptSpecForProviderStorageLocation[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ScriptSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Version that is associated with this script.
   *
   * @schema ScriptSpecForProvider#version
   */
  readonly version?: string;

  /**
   * A data object containing your Realtime scripts and dependencies as a zip  file. The zip file can have one or multiple files. Maximum size of a zip file is 5 MB.
   *
   * @schema ScriptSpecForProvider#zipFile
   */
  readonly zipFile?: string;

}

/**
 * Converts an object of type 'ScriptSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProvider(obj: ScriptSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'storageLocation': obj.storageLocation?.map(y => toJson_ScriptSpecForProviderStorageLocation(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
    'zipFile': obj.zipFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ScriptSpecInitProvider
 */
export interface ScriptSpecInitProvider {
  /**
   * Name of the script
   *
   * @schema ScriptSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Information indicating where your game script files are stored. See below.
   *
   * @schema ScriptSpecInitProvider#storageLocation
   */
  readonly storageLocation?: ScriptSpecInitProviderStorageLocation[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ScriptSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Version that is associated with this script.
   *
   * @schema ScriptSpecInitProvider#version
   */
  readonly version?: string;

  /**
   * A data object containing your Realtime scripts and dependencies as a zip  file. The zip file can have one or multiple files. Maximum size of a zip file is 5 MB.
   *
   * @schema ScriptSpecInitProvider#zipFile
   */
  readonly zipFile?: string;

}

/**
 * Converts an object of type 'ScriptSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecInitProvider(obj: ScriptSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'storageLocation': obj.storageLocation?.map(y => toJson_ScriptSpecInitProviderStorageLocation(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
    'zipFile': obj.zipFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ScriptSpecManagementPolicies
 */
export enum ScriptSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ScriptSpecProviderConfigRef
 */
export interface ScriptSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScriptSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScriptSpecProviderConfigRef#policy
   */
  readonly policy?: ScriptSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ScriptSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecProviderConfigRef(obj: ScriptSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScriptSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ScriptSpecPublishConnectionDetailsTo
 */
export interface ScriptSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ScriptSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ScriptSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ScriptSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ScriptSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ScriptSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ScriptSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecPublishConnectionDetailsTo(obj: ScriptSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ScriptSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ScriptSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ScriptSpecWriteConnectionSecretToRef
 */
export interface ScriptSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ScriptSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ScriptSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ScriptSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecWriteConnectionSecretToRef(obj: ScriptSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScriptSpecForProviderStorageLocation
 */
export interface ScriptSpecForProviderStorageLocation {
  /**
   * Name of your S3 bucket.
   *
   * @schema ScriptSpecForProviderStorageLocation#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema ScriptSpecForProviderStorageLocation#bucketRef
   */
  readonly bucketRef?: ScriptSpecForProviderStorageLocationBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema ScriptSpecForProviderStorageLocation#bucketSelector
   */
  readonly bucketSelector?: ScriptSpecForProviderStorageLocationBucketSelector;

  /**
   * Name of the zip file containing your script files.
   *
   * @schema ScriptSpecForProviderStorageLocation#key
   */
  readonly key?: string;

  /**
   * Reference to a Object in s3 to populate key.
   *
   * @schema ScriptSpecForProviderStorageLocation#keyRef
   */
  readonly keyRef?: ScriptSpecForProviderStorageLocationKeyRef;

  /**
   * Selector for a Object in s3 to populate key.
   *
   * @schema ScriptSpecForProviderStorageLocation#keySelector
   */
  readonly keySelector?: ScriptSpecForProviderStorageLocationKeySelector;

  /**
   * A specific version of the file. If not set, the latest version of the file is retrieved.
   *
   * @schema ScriptSpecForProviderStorageLocation#objectVersion
   */
  readonly objectVersion?: string;

  /**
   * ARN of the access role that allows Amazon GameLift to access your S3 bucket.
   *
   * @schema ScriptSpecForProviderStorageLocation#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ScriptSpecForProviderStorageLocation#roleArnRef
   */
  readonly roleArnRef?: ScriptSpecForProviderStorageLocationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ScriptSpecForProviderStorageLocation#roleArnSelector
   */
  readonly roleArnSelector?: ScriptSpecForProviderStorageLocationRoleArnSelector;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocation(obj: ScriptSpecForProviderStorageLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_ScriptSpecForProviderStorageLocationBucketRef(obj.bucketRef),
    'bucketSelector': toJson_ScriptSpecForProviderStorageLocationBucketSelector(obj.bucketSelector),
    'key': obj.key,
    'keyRef': toJson_ScriptSpecForProviderStorageLocationKeyRef(obj.keyRef),
    'keySelector': toJson_ScriptSpecForProviderStorageLocationKeySelector(obj.keySelector),
    'objectVersion': obj.objectVersion,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ScriptSpecForProviderStorageLocationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ScriptSpecForProviderStorageLocationRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScriptSpecInitProviderStorageLocation
 */
export interface ScriptSpecInitProviderStorageLocation {
  /**
   * A specific version of the file. If not set, the latest version of the file is retrieved.
   *
   * @schema ScriptSpecInitProviderStorageLocation#objectVersion
   */
  readonly objectVersion?: string;

}

/**
 * Converts an object of type 'ScriptSpecInitProviderStorageLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecInitProviderStorageLocation(obj: ScriptSpecInitProviderStorageLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectVersion': obj.objectVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScriptSpecProviderConfigRefPolicy
 */
export interface ScriptSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScriptSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ScriptSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScriptSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ScriptSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScriptSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecProviderConfigRefPolicy(obj: ScriptSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ScriptSpecPublishConnectionDetailsToConfigRef
 */
export interface ScriptSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScriptSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScriptSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ScriptSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ScriptSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecPublishConnectionDetailsToConfigRef(obj: ScriptSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScriptSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ScriptSpecPublishConnectionDetailsToMetadata
 */
export interface ScriptSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScriptSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScriptSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ScriptSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScriptSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecPublishConnectionDetailsToMetadata(obj: ScriptSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema ScriptSpecForProviderStorageLocationBucketRef
 */
export interface ScriptSpecForProviderStorageLocationBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScriptSpecForProviderStorageLocationBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScriptSpecForProviderStorageLocationBucketRef#policy
   */
  readonly policy?: ScriptSpecForProviderStorageLocationBucketRefPolicy;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationBucketRef(obj: ScriptSpecForProviderStorageLocationBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScriptSpecForProviderStorageLocationBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema ScriptSpecForProviderStorageLocationBucketSelector
 */
export interface ScriptSpecForProviderStorageLocationBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScriptSpecForProviderStorageLocationBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScriptSpecForProviderStorageLocationBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScriptSpecForProviderStorageLocationBucketSelector#policy
   */
  readonly policy?: ScriptSpecForProviderStorageLocationBucketSelectorPolicy;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationBucketSelector(obj: ScriptSpecForProviderStorageLocationBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScriptSpecForProviderStorageLocationBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Object in s3 to populate key.
 *
 * @schema ScriptSpecForProviderStorageLocationKeyRef
 */
export interface ScriptSpecForProviderStorageLocationKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScriptSpecForProviderStorageLocationKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScriptSpecForProviderStorageLocationKeyRef#policy
   */
  readonly policy?: ScriptSpecForProviderStorageLocationKeyRefPolicy;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationKeyRef(obj: ScriptSpecForProviderStorageLocationKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScriptSpecForProviderStorageLocationKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Object in s3 to populate key.
 *
 * @schema ScriptSpecForProviderStorageLocationKeySelector
 */
export interface ScriptSpecForProviderStorageLocationKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScriptSpecForProviderStorageLocationKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScriptSpecForProviderStorageLocationKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScriptSpecForProviderStorageLocationKeySelector#policy
   */
  readonly policy?: ScriptSpecForProviderStorageLocationKeySelectorPolicy;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationKeySelector(obj: ScriptSpecForProviderStorageLocationKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScriptSpecForProviderStorageLocationKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ScriptSpecForProviderStorageLocationRoleArnRef
 */
export interface ScriptSpecForProviderStorageLocationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScriptSpecForProviderStorageLocationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScriptSpecForProviderStorageLocationRoleArnRef#policy
   */
  readonly policy?: ScriptSpecForProviderStorageLocationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationRoleArnRef(obj: ScriptSpecForProviderStorageLocationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScriptSpecForProviderStorageLocationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ScriptSpecForProviderStorageLocationRoleArnSelector
 */
export interface ScriptSpecForProviderStorageLocationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScriptSpecForProviderStorageLocationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScriptSpecForProviderStorageLocationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScriptSpecForProviderStorageLocationRoleArnSelector#policy
   */
  readonly policy?: ScriptSpecForProviderStorageLocationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationRoleArnSelector(obj: ScriptSpecForProviderStorageLocationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScriptSpecForProviderStorageLocationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScriptSpecProviderConfigRefPolicyResolution
 */
export enum ScriptSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScriptSpecProviderConfigRefPolicyResolve
 */
export enum ScriptSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ScriptSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ScriptSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScriptSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ScriptSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScriptSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ScriptSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScriptSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecPublishConnectionDetailsToConfigRefPolicy(obj: ScriptSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScriptSpecForProviderStorageLocationBucketRefPolicy
 */
export interface ScriptSpecForProviderStorageLocationBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScriptSpecForProviderStorageLocationBucketRefPolicy#resolution
   */
  readonly resolution?: ScriptSpecForProviderStorageLocationBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScriptSpecForProviderStorageLocationBucketRefPolicy#resolve
   */
  readonly resolve?: ScriptSpecForProviderStorageLocationBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationBucketRefPolicy(obj: ScriptSpecForProviderStorageLocationBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScriptSpecForProviderStorageLocationBucketSelectorPolicy
 */
export interface ScriptSpecForProviderStorageLocationBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScriptSpecForProviderStorageLocationBucketSelectorPolicy#resolution
   */
  readonly resolution?: ScriptSpecForProviderStorageLocationBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScriptSpecForProviderStorageLocationBucketSelectorPolicy#resolve
   */
  readonly resolve?: ScriptSpecForProviderStorageLocationBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationBucketSelectorPolicy(obj: ScriptSpecForProviderStorageLocationBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScriptSpecForProviderStorageLocationKeyRefPolicy
 */
export interface ScriptSpecForProviderStorageLocationKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScriptSpecForProviderStorageLocationKeyRefPolicy#resolution
   */
  readonly resolution?: ScriptSpecForProviderStorageLocationKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScriptSpecForProviderStorageLocationKeyRefPolicy#resolve
   */
  readonly resolve?: ScriptSpecForProviderStorageLocationKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationKeyRefPolicy(obj: ScriptSpecForProviderStorageLocationKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScriptSpecForProviderStorageLocationKeySelectorPolicy
 */
export interface ScriptSpecForProviderStorageLocationKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScriptSpecForProviderStorageLocationKeySelectorPolicy#resolution
   */
  readonly resolution?: ScriptSpecForProviderStorageLocationKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScriptSpecForProviderStorageLocationKeySelectorPolicy#resolve
   */
  readonly resolve?: ScriptSpecForProviderStorageLocationKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationKeySelectorPolicy(obj: ScriptSpecForProviderStorageLocationKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScriptSpecForProviderStorageLocationRoleArnRefPolicy
 */
export interface ScriptSpecForProviderStorageLocationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScriptSpecForProviderStorageLocationRoleArnRefPolicy#resolution
   */
  readonly resolution?: ScriptSpecForProviderStorageLocationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScriptSpecForProviderStorageLocationRoleArnRefPolicy#resolve
   */
  readonly resolve?: ScriptSpecForProviderStorageLocationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationRoleArnRefPolicy(obj: ScriptSpecForProviderStorageLocationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScriptSpecForProviderStorageLocationRoleArnSelectorPolicy
 */
export interface ScriptSpecForProviderStorageLocationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScriptSpecForProviderStorageLocationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ScriptSpecForProviderStorageLocationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScriptSpecForProviderStorageLocationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ScriptSpecForProviderStorageLocationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScriptSpecForProviderStorageLocationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScriptSpecForProviderStorageLocationRoleArnSelectorPolicy(obj: ScriptSpecForProviderStorageLocationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScriptSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ScriptSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScriptSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ScriptSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScriptSpecForProviderStorageLocationBucketRefPolicyResolution
 */
export enum ScriptSpecForProviderStorageLocationBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScriptSpecForProviderStorageLocationBucketRefPolicyResolve
 */
export enum ScriptSpecForProviderStorageLocationBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScriptSpecForProviderStorageLocationBucketSelectorPolicyResolution
 */
export enum ScriptSpecForProviderStorageLocationBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScriptSpecForProviderStorageLocationBucketSelectorPolicyResolve
 */
export enum ScriptSpecForProviderStorageLocationBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScriptSpecForProviderStorageLocationKeyRefPolicyResolution
 */
export enum ScriptSpecForProviderStorageLocationKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScriptSpecForProviderStorageLocationKeyRefPolicyResolve
 */
export enum ScriptSpecForProviderStorageLocationKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScriptSpecForProviderStorageLocationKeySelectorPolicyResolution
 */
export enum ScriptSpecForProviderStorageLocationKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScriptSpecForProviderStorageLocationKeySelectorPolicyResolve
 */
export enum ScriptSpecForProviderStorageLocationKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScriptSpecForProviderStorageLocationRoleArnRefPolicyResolution
 */
export enum ScriptSpecForProviderStorageLocationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScriptSpecForProviderStorageLocationRoleArnRefPolicyResolve
 */
export enum ScriptSpecForProviderStorageLocationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScriptSpecForProviderStorageLocationRoleArnSelectorPolicyResolution
 */
export enum ScriptSpecForProviderStorageLocationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScriptSpecForProviderStorageLocationRoleArnSelectorPolicyResolve
 */
export enum ScriptSpecForProviderStorageLocationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

