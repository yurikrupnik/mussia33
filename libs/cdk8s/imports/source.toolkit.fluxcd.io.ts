// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Bucket is the Schema for the buckets API
 *
 * @schema Bucket
 */
export class Bucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "Bucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketProps = {}): any {
    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(props),
    };
  }

  /**
   * Defines a "Bucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketProps = {}) {
    super(scope, id, {
      ...Bucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the buckets API
 *
 * @schema Bucket
 */
export interface BucketProps {
  /**
   * @schema Bucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec defines the desired state of an S3 compatible bucket
   *
   * @schema Bucket#spec
   */
  readonly spec?: BucketSpec;

}

/**
 * Converts an object of type 'BucketProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketProps(obj: BucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketSpec defines the desired state of an S3 compatible bucket
 *
 * @schema BucketSpec
 */
export interface BucketSpec {
  /**
   * The bucket name.
   *
   * @schema BucketSpec#bucketName
   */
  readonly bucketName: string;

  /**
   * The bucket endpoint address.
   *
   * @schema BucketSpec#endpoint
   */
  readonly endpoint: string;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
   *
   * @schema BucketSpec#ignore
   */
  readonly ignore?: string;

  /**
   * Insecure allows connecting to a non-TLS S3 HTTP endpoint.
   *
   * @schema BucketSpec#insecure
   */
  readonly insecure?: boolean;

  /**
   * The interval at which to check for bucket updates.
   *
   * @schema BucketSpec#interval
   */
  readonly interval: string;

  /**
   * The S3 compatible storage provider name, default ('generic').
   *
   * @schema BucketSpec#provider
   */
  readonly provider?: BucketSpecProvider;

  /**
   * The bucket region.
   *
   * @schema BucketSpec#region
   */
  readonly region?: string;

  /**
   * The name of the secret containing authentication credentials for the Bucket.
   *
   * @schema BucketSpec#secretRef
   */
  readonly secretRef?: BucketSpecSecretRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema BucketSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout for download operations, defaults to 20s.
   *
   * @schema BucketSpec#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'BucketSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpec(obj: BucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'endpoint': obj.endpoint,
    'ignore': obj.ignore,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'provider': obj.provider,
    'region': obj.region,
    'secretRef': toJson_BucketSpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The S3 compatible storage provider name, default ('generic').
 *
 * @schema BucketSpecProvider
 */
export enum BucketSpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
}

/**
 * The name of the secret containing authentication credentials for the Bucket.
 *
 * @schema BucketSpecSecretRef
 */
export interface BucketSpecSecretRef {
  /**
   * Name of the referent
   *
   * @schema BucketSpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecSecretRef(obj: BucketSpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * GitRepository is the Schema for the gitrepositories API
 *
 * @schema GitRepository
 */
export class GitRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GitRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'GitRepository',
  }

  /**
   * Renders a Kubernetes manifest for "GitRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GitRepositoryProps = {}): any {
    return {
      ...GitRepository.GVK,
      ...toJson_GitRepositoryProps(props),
    };
  }

  /**
   * Defines a "GitRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GitRepositoryProps = {}) {
    super(scope, id, {
      ...GitRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GitRepository.GVK,
      ...toJson_GitRepositoryProps(resolved),
    };
  }
}

/**
 * GitRepository is the Schema for the gitrepositories API
 *
 * @schema GitRepository
 */
export interface GitRepositoryProps {
  /**
   * @schema GitRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GitRepositorySpec defines the desired state of a Git repository.
   *
   * @schema GitRepository#spec
   */
  readonly spec?: GitRepositorySpec;

}

/**
 * Converts an object of type 'GitRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryProps(obj: GitRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GitRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepositorySpec defines the desired state of a Git repository.
 *
 * @schema GitRepositorySpec
 */
export interface GitRepositorySpec {
  /**
   * Determines which git client library to use. Defaults to go-git, valid values are ('go-git', 'libgit2').
   *
   * @default go-git, valid values are ('go-git', 'libgit2').
   * @schema GitRepositorySpec#gitImplementation
   */
  readonly gitImplementation?: GitRepositorySpecGitImplementation;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
   *
   * @schema GitRepositorySpec#ignore
   */
  readonly ignore?: string;

  /**
   * Extra git repositories to map into the repository
   *
   * @schema GitRepositorySpec#include
   */
  readonly include?: GitRepositorySpecInclude[];

  /**
   * The interval at which to check for repository updates.
   *
   * @schema GitRepositorySpec#interval
   */
  readonly interval: string;

  /**
   * When enabled, after the clone is created, initializes all submodules within, using their default settings. This option is available only when using the 'go-git' GitImplementation.
   *
   * @schema GitRepositorySpec#recurseSubmodules
   */
  readonly recurseSubmodules?: boolean;

  /**
   * The Git reference to checkout and monitor for changes, defaults to master branch.
   *
   * @schema GitRepositorySpec#ref
   */
  readonly ref?: GitRepositorySpecRef;

  /**
   * The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity, identity.pub and known_hosts fields.
   *
   * @schema GitRepositorySpec#secretRef
   */
  readonly secretRef?: GitRepositorySpecSecretRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema GitRepositorySpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout for remote Git operations like cloning, defaults to 20s.
   *
   * @schema GitRepositorySpec#timeout
   */
  readonly timeout?: string;

  /**
   * The repository URL, can be a HTTP/S or SSH address.
   *
   * @schema GitRepositorySpec#url
   */
  readonly url: string;

  /**
   * Verify OpenPGP signature for the Git commit HEAD points to.
   *
   * @schema GitRepositorySpec#verify
   */
  readonly verify?: GitRepositorySpecVerify;

}

/**
 * Converts an object of type 'GitRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpec(obj: GitRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gitImplementation': obj.gitImplementation,
    'ignore': obj.ignore,
    'include': obj.include?.map(y => toJson_GitRepositorySpecInclude(y)),
    'interval': obj.interval,
    'recurseSubmodules': obj.recurseSubmodules,
    'ref': toJson_GitRepositorySpecRef(obj.ref),
    'secretRef': toJson_GitRepositorySpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
    'verify': toJson_GitRepositorySpecVerify(obj.verify),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Determines which git client library to use. Defaults to go-git, valid values are ('go-git', 'libgit2').
 *
 * @default go-git, valid values are ('go-git', 'libgit2').
 * @schema GitRepositorySpecGitImplementation
 */
export enum GitRepositorySpecGitImplementation {
  /** go-git */
  GO_GIT = "go-git",
  /** libgit2 */
  LIBGIT2 = "libgit2",
}

/**
 * GitRepositoryInclude defines a source with a from and to path.
 *
 * @schema GitRepositorySpecInclude
 */
export interface GitRepositorySpecInclude {
  /**
   * The path to copy contents from, defaults to the root directory.
   *
   * @schema GitRepositorySpecInclude#fromPath
   */
  readonly fromPath?: string;

  /**
   * Reference to a GitRepository to include.
   *
   * @schema GitRepositorySpecInclude#repository
   */
  readonly repository: GitRepositorySpecIncludeRepository;

  /**
   * The path to copy contents to, defaults to the name of the source ref.
   *
   * @schema GitRepositorySpecInclude#toPath
   */
  readonly toPath?: string;

}

/**
 * Converts an object of type 'GitRepositorySpecInclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecInclude(obj: GitRepositorySpecInclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPath': obj.fromPath,
    'repository': toJson_GitRepositorySpecIncludeRepository(obj.repository),
    'toPath': obj.toPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Git reference to checkout and monitor for changes, defaults to master branch.
 *
 * @schema GitRepositorySpecRef
 */
export interface GitRepositorySpecRef {
  /**
   * The Git branch to checkout, defaults to master.
   *
   * @schema GitRepositorySpecRef#branch
   */
  readonly branch?: string;

  /**
   * The Git commit SHA to checkout, if specified Tag filters will be ignored.
   *
   * @schema GitRepositorySpecRef#commit
   */
  readonly commit?: string;

  /**
   * The Git tag semver expression, takes precedence over Tag.
   *
   * @schema GitRepositorySpecRef#semver
   */
  readonly semver?: string;

  /**
   * The Git tag to checkout, takes precedence over Branch.
   *
   * @schema GitRepositorySpecRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'GitRepositorySpecRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecRef(obj: GitRepositorySpecRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commit': obj.commit,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity, identity.pub and known_hosts fields.
 *
 * @schema GitRepositorySpecSecretRef
 */
export interface GitRepositorySpecSecretRef {
  /**
   * Name of the referent
   *
   * @schema GitRepositorySpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecSecretRef(obj: GitRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Verify OpenPGP signature for the Git commit HEAD points to.
 *
 * @schema GitRepositorySpecVerify
 */
export interface GitRepositorySpecVerify {
  /**
   * Mode describes what git object should be verified, currently ('head').
   *
   * @schema GitRepositorySpecVerify#mode
   */
  readonly mode: GitRepositorySpecVerifyMode;

  /**
   * The secret name containing the public keys of all trusted Git authors.
   *
   * @schema GitRepositorySpecVerify#secretRef
   */
  readonly secretRef?: GitRepositorySpecVerifySecretRef;

}

/**
 * Converts an object of type 'GitRepositorySpecVerify' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecVerify(obj: GitRepositorySpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'secretRef': toJson_GitRepositorySpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GitRepository to include.
 *
 * @schema GitRepositorySpecIncludeRepository
 */
export interface GitRepositorySpecIncludeRepository {
  /**
   * Name of the referent
   *
   * @schema GitRepositorySpecIncludeRepository#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecIncludeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecIncludeRepository(obj: GitRepositorySpecIncludeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode describes what git object should be verified, currently ('head').
 *
 * @schema GitRepositorySpecVerifyMode
 */
export enum GitRepositorySpecVerifyMode {
  /** head */
  HEAD = "head",
}

/**
 * The secret name containing the public keys of all trusted Git authors.
 *
 * @schema GitRepositorySpecVerifySecretRef
 */
export interface GitRepositorySpecVerifySecretRef {
  /**
   * Name of the referent
   *
   * @schema GitRepositorySpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecVerifySecretRef(obj: GitRepositorySpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * HelmChart is the Schema for the helmcharts API
 *
 * @schema HelmChart
 */
export class HelmChart extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmChart"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'HelmChart',
  }

  /**
   * Renders a Kubernetes manifest for "HelmChart".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmChartProps = {}): any {
    return {
      ...HelmChart.GVK,
      ...toJson_HelmChartProps(props),
    };
  }

  /**
   * Defines a "HelmChart" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmChartProps = {}) {
    super(scope, id, {
      ...HelmChart.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmChart.GVK,
      ...toJson_HelmChartProps(resolved),
    };
  }
}

/**
 * HelmChart is the Schema for the helmcharts API
 *
 * @schema HelmChart
 */
export interface HelmChartProps {
  /**
   * @schema HelmChart#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmChartSpec defines the desired state of a Helm chart.
   *
   * @schema HelmChart#spec
   */
  readonly spec?: HelmChartSpec;

}

/**
 * Converts an object of type 'HelmChartProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartProps(obj: HelmChartProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmChartSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HelmChartSpec defines the desired state of a Helm chart.
 *
 * @schema HelmChartSpec
 */
export interface HelmChartSpec {
  /**
   * The name or path the Helm chart is available at in the SourceRef.
   *
   * @schema HelmChartSpec#chart
   */
  readonly chart: string;

  /**
   * The interval at which to check the Source for updates.
   *
   * @schema HelmChartSpec#interval
   */
  readonly interval: string;

  /**
   * The reference to the Source the chart is available at.
   *
   * @schema HelmChartSpec#sourceRef
   */
  readonly sourceRef: HelmChartSpecSourceRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema HelmChartSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Deprecated in favor of ValuesFiles, for backwards compatibility the file defined here is merged before the ValuesFiles items. Ignored when omitted.
   *
   * @schema HelmChartSpec#valuesFile
   */
  readonly valuesFile?: string;

  /**
   * Alternative list of values files to use as the chart values (values.yaml is not included by default), expected to be a relative path in the SourceRef. Values files are merged in the order of this list with the last file overriding the first. Ignored when omitted.
   *
   * @schema HelmChartSpec#valuesFiles
   */
  readonly valuesFiles?: string[];

  /**
   * The chart version semver expression, ignored for charts from GitRepository and Bucket sources. Defaults to latest when omitted.
   *
   * @default latest when omitted.
   * @schema HelmChartSpec#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'HelmChartSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartSpec(obj: HelmChartSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chart': obj.chart,
    'interval': obj.interval,
    'sourceRef': toJson_HelmChartSpecSourceRef(obj.sourceRef),
    'suspend': obj.suspend,
    'valuesFile': obj.valuesFile,
    'valuesFiles': obj.valuesFiles?.map(y => y),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to the Source the chart is available at.
 *
 * @schema HelmChartSpecSourceRef
 */
export interface HelmChartSpecSourceRef {
  /**
   * APIVersion of the referent.
   *
   * @schema HelmChartSpecSourceRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent, valid values are ('HelmRepository', 'GitRepository', 'Bucket').
   *
   * @schema HelmChartSpecSourceRef#kind
   */
  readonly kind: HelmChartSpecSourceRefKind;

  /**
   * Name of the referent.
   *
   * @schema HelmChartSpecSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmChartSpecSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartSpecSourceRef(obj: HelmChartSpecSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind of the referent, valid values are ('HelmRepository', 'GitRepository', 'Bucket').
 *
 * @schema HelmChartSpecSourceRefKind
 */
export enum HelmChartSpecSourceRefKind {
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Bucket */
  BUCKET = "Bucket",
}


/**
 * HelmRepository is the Schema for the helmrepositories API
 *
 * @schema HelmRepository
 */
export class HelmRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'HelmRepository',
  }

  /**
   * Renders a Kubernetes manifest for "HelmRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmRepositoryProps = {}): any {
    return {
      ...HelmRepository.GVK,
      ...toJson_HelmRepositoryProps(props),
    };
  }

  /**
   * Defines a "HelmRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmRepositoryProps = {}) {
    super(scope, id, {
      ...HelmRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmRepository.GVK,
      ...toJson_HelmRepositoryProps(resolved),
    };
  }
}

/**
 * HelmRepository is the Schema for the helmrepositories API
 *
 * @schema HelmRepository
 */
export interface HelmRepositoryProps {
  /**
   * @schema HelmRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmRepositorySpec defines the reference to a Helm repository.
   *
   * @schema HelmRepository#spec
   */
  readonly spec?: HelmRepositorySpec;

}

/**
 * Converts an object of type 'HelmRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositoryProps(obj: HelmRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HelmRepositorySpec defines the reference to a Helm repository.
 *
 * @schema HelmRepositorySpec
 */
export interface HelmRepositorySpec {
  /**
   * The interval at which to check the upstream for updates.
   *
   * @schema HelmRepositorySpec#interval
   */
  readonly interval: string;

  /**
   * PassCredentials allows the credentials from the SecretRef to be passed on to a host that does not match the host as defined in URL. This may be required if the host of the advertised chart URLs in the index differ from the defined URL. Enabling this should be done with caution, as it can potentially result in credentials getting stolen in a MITM-attack.
   *
   * @schema HelmRepositorySpec#passCredentials
   */
  readonly passCredentials?: boolean;

  /**
   * The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain a certFile and keyFile, and/or caCert fields.
   *
   * @schema HelmRepositorySpec#secretRef
   */
  readonly secretRef?: HelmRepositorySpecSecretRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema HelmRepositorySpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout of index downloading, defaults to 60s.
   *
   * @schema HelmRepositorySpec#timeout
   */
  readonly timeout?: string;

  /**
   * The Helm repository URL, a valid URL contains at least a protocol and host.
   *
   * @schema HelmRepositorySpec#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'HelmRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositorySpec(obj: HelmRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'passCredentials': obj.passCredentials,
    'secretRef': toJson_HelmRepositorySpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain a certFile and keyFile, and/or caCert fields.
 *
 * @schema HelmRepositorySpecSecretRef
 */
export interface HelmRepositorySpecSecretRef {
  /**
   * Name of the referent
   *
   * @schema HelmRepositorySpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositorySpecSecretRef(obj: HelmRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

