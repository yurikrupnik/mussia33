// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * App is the Schema for the Apps API. Provides a SageMaker App resource.
 *
 * @schema App
 */
export class App extends ApiObject {
  /**
   * Returns the apiVersion and kind for "App"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'App',
  }

  /**
   * Renders a Kubernetes manifest for "App".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppProps): any {
    return {
      ...App.GVK,
      ...toJson_AppProps(props),
    };
  }

  /**
   * Defines a "App" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppProps) {
    super(scope, id, {
      ...App.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...App.GVK,
      ...toJson_AppProps(resolved),
    };
  }
}

/**
 * App is the Schema for the Apps API. Provides a SageMaker App resource.
 *
 * @schema App
 */
export interface AppProps {
  /**
   * @schema App#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppSpec defines the desired state of App
   *
   * @schema App#spec
   */
  readonly spec: AppSpec;

}

/**
 * Converts an object of type 'AppProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppProps(obj: AppProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppSpec defines the desired state of App
 *
 * @schema AppSpec
 */
export interface AppSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppSpecDeletionPolicy;

  /**
   * @schema AppSpec#forProvider
   */
  readonly forProvider: AppSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AppSpec#initProvider
   */
  readonly initProvider?: AppSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AppSpec#managementPolicies
   */
  readonly managementPolicies?: AppSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpec(obj: AppSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppSpecForProvider(obj.forProvider),
    'initProvider': toJson_AppSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AppSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AppSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppSpecDeletionPolicy
 */
export enum AppSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppSpecForProvider
 */
export interface AppSpecForProvider {
  /**
   * The name of the app.
   *
   * @schema AppSpecForProvider#appName
   */
  readonly appName?: string;

  /**
   * The type of app. Valid values are JupyterServer, KernelGateway, RStudioServerPro, RSessionGateway and TensorBoard.
   *
   * @schema AppSpecForProvider#appType
   */
  readonly appType?: string;

  /**
   * The domain ID.
   *
   * @schema AppSpecForProvider#domainId
   */
  readonly domainId?: string;

  /**
   * Reference to a Domain in sagemaker to populate domainId.
   *
   * @schema AppSpecForProvider#domainIdRef
   */
  readonly domainIdRef?: AppSpecForProviderDomainIdRef;

  /**
   * Selector for a Domain in sagemaker to populate domainId.
   *
   * @schema AppSpecForProvider#domainIdSelector
   */
  readonly domainIdSelector?: AppSpecForProviderDomainIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AppSpecForProvider#region
   */
  readonly region: string;

  /**
   * The instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.See Resource Spec below.
   *
   * @schema AppSpecForProvider#resourceSpec
   */
  readonly resourceSpec?: AppSpecForProviderResourceSpec[];

  /**
   * The name of the space. At least one of user_profile_name or space_name required.
   *
   * @schema AppSpecForProvider#spaceName
   */
  readonly spaceName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AppSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The user profile name. At least one of user_profile_name or space_name required.
   *
   * @schema AppSpecForProvider#userProfileName
   */
  readonly userProfileName?: string;

  /**
   * Reference to a UserProfile in sagemaker to populate userProfileName.
   *
   * @schema AppSpecForProvider#userProfileNameRef
   */
  readonly userProfileNameRef?: AppSpecForProviderUserProfileNameRef;

  /**
   * Selector for a UserProfile in sagemaker to populate userProfileName.
   *
   * @schema AppSpecForProvider#userProfileNameSelector
   */
  readonly userProfileNameSelector?: AppSpecForProviderUserProfileNameSelector;

}

/**
 * Converts an object of type 'AppSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProvider(obj: AppSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appName': obj.appName,
    'appType': obj.appType,
    'domainId': obj.domainId,
    'domainIdRef': toJson_AppSpecForProviderDomainIdRef(obj.domainIdRef),
    'domainIdSelector': toJson_AppSpecForProviderDomainIdSelector(obj.domainIdSelector),
    'region': obj.region,
    'resourceSpec': obj.resourceSpec?.map(y => toJson_AppSpecForProviderResourceSpec(y)),
    'spaceName': obj.spaceName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'userProfileName': obj.userProfileName,
    'userProfileNameRef': toJson_AppSpecForProviderUserProfileNameRef(obj.userProfileNameRef),
    'userProfileNameSelector': toJson_AppSpecForProviderUserProfileNameSelector(obj.userProfileNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AppSpecInitProvider
 */
export interface AppSpecInitProvider {
  /**
   * The name of the app.
   *
   * @schema AppSpecInitProvider#appName
   */
  readonly appName?: string;

  /**
   * The type of app. Valid values are JupyterServer, KernelGateway, RStudioServerPro, RSessionGateway and TensorBoard.
   *
   * @schema AppSpecInitProvider#appType
   */
  readonly appType?: string;

  /**
   * The instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.See Resource Spec below.
   *
   * @schema AppSpecInitProvider#resourceSpec
   */
  readonly resourceSpec?: AppSpecInitProviderResourceSpec[];

  /**
   * The name of the space. At least one of user_profile_name or space_name required.
   *
   * @schema AppSpecInitProvider#spaceName
   */
  readonly spaceName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AppSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AppSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecInitProvider(obj: AppSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appName': obj.appName,
    'appType': obj.appType,
    'resourceSpec': obj.resourceSpec?.map(y => toJson_AppSpecInitProviderResourceSpec(y)),
    'spaceName': obj.spaceName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AppSpecManagementPolicies
 */
export enum AppSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppSpecProviderConfigRef
 */
export interface AppSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecProviderConfigRef#policy
   */
  readonly policy?: AppSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderConfigRef(obj: AppSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppSpecPublishConnectionDetailsTo
 */
export interface AppSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsTo(obj: AppSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppSpecWriteConnectionSecretToRef
 */
export interface AppSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecWriteConnectionSecretToRef(obj: AppSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Domain in sagemaker to populate domainId.
 *
 * @schema AppSpecForProviderDomainIdRef
 */
export interface AppSpecForProviderDomainIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecForProviderDomainIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecForProviderDomainIdRef#policy
   */
  readonly policy?: AppSpecForProviderDomainIdRefPolicy;

}

/**
 * Converts an object of type 'AppSpecForProviderDomainIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderDomainIdRef(obj: AppSpecForProviderDomainIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecForProviderDomainIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Domain in sagemaker to populate domainId.
 *
 * @schema AppSpecForProviderDomainIdSelector
 */
export interface AppSpecForProviderDomainIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AppSpecForProviderDomainIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AppSpecForProviderDomainIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AppSpecForProviderDomainIdSelector#policy
   */
  readonly policy?: AppSpecForProviderDomainIdSelectorPolicy;

}

/**
 * Converts an object of type 'AppSpecForProviderDomainIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderDomainIdSelector(obj: AppSpecForProviderDomainIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AppSpecForProviderDomainIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecForProviderResourceSpec
 */
export interface AppSpecForProviderResourceSpec {
  /**
   * The instance type that the image version runs on. For valid values see SageMaker Instance Types.
   *
   * @schema AppSpecForProviderResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema AppSpecForProviderResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema AppSpecForProviderResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema AppSpecForProviderResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'AppSpecForProviderResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderResourceSpec(obj: AppSpecForProviderResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserProfile in sagemaker to populate userProfileName.
 *
 * @schema AppSpecForProviderUserProfileNameRef
 */
export interface AppSpecForProviderUserProfileNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecForProviderUserProfileNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecForProviderUserProfileNameRef#policy
   */
  readonly policy?: AppSpecForProviderUserProfileNameRefPolicy;

}

/**
 * Converts an object of type 'AppSpecForProviderUserProfileNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderUserProfileNameRef(obj: AppSpecForProviderUserProfileNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecForProviderUserProfileNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserProfile in sagemaker to populate userProfileName.
 *
 * @schema AppSpecForProviderUserProfileNameSelector
 */
export interface AppSpecForProviderUserProfileNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AppSpecForProviderUserProfileNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AppSpecForProviderUserProfileNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AppSpecForProviderUserProfileNameSelector#policy
   */
  readonly policy?: AppSpecForProviderUserProfileNameSelectorPolicy;

}

/**
 * Converts an object of type 'AppSpecForProviderUserProfileNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderUserProfileNameSelector(obj: AppSpecForProviderUserProfileNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AppSpecForProviderUserProfileNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecInitProviderResourceSpec
 */
export interface AppSpecInitProviderResourceSpec {
  /**
   * The instance type that the image version runs on. For valid values see SageMaker Instance Types.
   *
   * @schema AppSpecInitProviderResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema AppSpecInitProviderResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema AppSpecInitProviderResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema AppSpecInitProviderResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'AppSpecInitProviderResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecInitProviderResourceSpec(obj: AppSpecInitProviderResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecProviderConfigRefPolicy
 */
export interface AppSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderConfigRefPolicy(obj: AppSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRef
 */
export interface AppSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToConfigRef(obj: AppSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppSpecPublishConnectionDetailsToMetadata
 */
export interface AppSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToMetadata(obj: AppSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecForProviderDomainIdRefPolicy
 */
export interface AppSpecForProviderDomainIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecForProviderDomainIdRefPolicy#resolution
   */
  readonly resolution?: AppSpecForProviderDomainIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecForProviderDomainIdRefPolicy#resolve
   */
  readonly resolve?: AppSpecForProviderDomainIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecForProviderDomainIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderDomainIdRefPolicy(obj: AppSpecForProviderDomainIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AppSpecForProviderDomainIdSelectorPolicy
 */
export interface AppSpecForProviderDomainIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecForProviderDomainIdSelectorPolicy#resolution
   */
  readonly resolution?: AppSpecForProviderDomainIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecForProviderDomainIdSelectorPolicy#resolve
   */
  readonly resolve?: AppSpecForProviderDomainIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecForProviderDomainIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderDomainIdSelectorPolicy(obj: AppSpecForProviderDomainIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecForProviderUserProfileNameRefPolicy
 */
export interface AppSpecForProviderUserProfileNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecForProviderUserProfileNameRefPolicy#resolution
   */
  readonly resolution?: AppSpecForProviderUserProfileNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecForProviderUserProfileNameRefPolicy#resolve
   */
  readonly resolve?: AppSpecForProviderUserProfileNameRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecForProviderUserProfileNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderUserProfileNameRefPolicy(obj: AppSpecForProviderUserProfileNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AppSpecForProviderUserProfileNameSelectorPolicy
 */
export interface AppSpecForProviderUserProfileNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecForProviderUserProfileNameSelectorPolicy#resolution
   */
  readonly resolution?: AppSpecForProviderUserProfileNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecForProviderUserProfileNameSelectorPolicy#resolve
   */
  readonly resolve?: AppSpecForProviderUserProfileNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecForProviderUserProfileNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderUserProfileNameSelectorPolicy(obj: AppSpecForProviderUserProfileNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecProviderConfigRefPolicyResolution
 */
export enum AppSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecProviderConfigRefPolicyResolve
 */
export enum AppSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecForProviderDomainIdRefPolicyResolution
 */
export enum AppSpecForProviderDomainIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecForProviderDomainIdRefPolicyResolve
 */
export enum AppSpecForProviderDomainIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecForProviderDomainIdSelectorPolicyResolution
 */
export enum AppSpecForProviderDomainIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecForProviderDomainIdSelectorPolicyResolve
 */
export enum AppSpecForProviderDomainIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecForProviderUserProfileNameRefPolicyResolution
 */
export enum AppSpecForProviderUserProfileNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecForProviderUserProfileNameRefPolicyResolve
 */
export enum AppSpecForProviderUserProfileNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecForProviderUserProfileNameSelectorPolicyResolution
 */
export enum AppSpecForProviderUserProfileNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecForProviderUserProfileNameSelectorPolicyResolve
 */
export enum AppSpecForProviderUserProfileNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AppImageConfig is the Schema for the AppImageConfigs API. Provides a SageMaker App Image Config resource.
 *
 * @schema AppImageConfig
 */
export class AppImageConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AppImageConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'AppImageConfig',
  }

  /**
   * Renders a Kubernetes manifest for "AppImageConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppImageConfigProps): any {
    return {
      ...AppImageConfig.GVK,
      ...toJson_AppImageConfigProps(props),
    };
  }

  /**
   * Defines a "AppImageConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppImageConfigProps) {
    super(scope, id, {
      ...AppImageConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AppImageConfig.GVK,
      ...toJson_AppImageConfigProps(resolved),
    };
  }
}

/**
 * AppImageConfig is the Schema for the AppImageConfigs API. Provides a SageMaker App Image Config resource.
 *
 * @schema AppImageConfig
 */
export interface AppImageConfigProps {
  /**
   * @schema AppImageConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppImageConfigSpec defines the desired state of AppImageConfig
   *
   * @schema AppImageConfig#spec
   */
  readonly spec: AppImageConfigSpec;

}

/**
 * Converts an object of type 'AppImageConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigProps(obj: AppImageConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppImageConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppImageConfigSpec defines the desired state of AppImageConfig
 *
 * @schema AppImageConfigSpec
 */
export interface AppImageConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppImageConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppImageConfigSpecDeletionPolicy;

  /**
   * @schema AppImageConfigSpec#forProvider
   */
  readonly forProvider: AppImageConfigSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AppImageConfigSpec#initProvider
   */
  readonly initProvider?: AppImageConfigSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AppImageConfigSpec#managementPolicies
   */
  readonly managementPolicies?: AppImageConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppImageConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppImageConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppImageConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppImageConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppImageConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppImageConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppImageConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpec(obj: AppImageConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppImageConfigSpecForProvider(obj.forProvider),
    'initProvider': toJson_AppImageConfigSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AppImageConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AppImageConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppImageConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppImageConfigSpecDeletionPolicy
 */
export enum AppImageConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppImageConfigSpecForProvider
 */
export interface AppImageConfigSpecForProvider {
  /**
   * The configuration for the file system and kernels in a SageMaker image running as a KernelGateway app. See Kernel Gateway Image Config details below.
   *
   * @schema AppImageConfigSpecForProvider#kernelGatewayImageConfig
   */
  readonly kernelGatewayImageConfig?: AppImageConfigSpecForProviderKernelGatewayImageConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AppImageConfigSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AppImageConfigSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AppImageConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecForProvider(obj: AppImageConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kernelGatewayImageConfig': obj.kernelGatewayImageConfig?.map(y => toJson_AppImageConfigSpecForProviderKernelGatewayImageConfig(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AppImageConfigSpecInitProvider
 */
export interface AppImageConfigSpecInitProvider {
  /**
   * The configuration for the file system and kernels in a SageMaker image running as a KernelGateway app. See Kernel Gateway Image Config details below.
   *
   * @schema AppImageConfigSpecInitProvider#kernelGatewayImageConfig
   */
  readonly kernelGatewayImageConfig?: AppImageConfigSpecInitProviderKernelGatewayImageConfig[];

  /**
   * Key-value map of resource tags.
   *
   * @schema AppImageConfigSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AppImageConfigSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecInitProvider(obj: AppImageConfigSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kernelGatewayImageConfig': obj.kernelGatewayImageConfig?.map(y => toJson_AppImageConfigSpecInitProviderKernelGatewayImageConfig(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AppImageConfigSpecManagementPolicies
 */
export enum AppImageConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppImageConfigSpecProviderConfigRef
 */
export interface AppImageConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppImageConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppImageConfigSpecProviderConfigRef#policy
   */
  readonly policy?: AppImageConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppImageConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecProviderConfigRef(obj: AppImageConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppImageConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppImageConfigSpecPublishConnectionDetailsTo
 */
export interface AppImageConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppImageConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppImageConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppImageConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppImageConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppImageConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppImageConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecPublishConnectionDetailsTo(obj: AppImageConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppImageConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppImageConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppImageConfigSpecWriteConnectionSecretToRef
 */
export interface AppImageConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppImageConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppImageConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppImageConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecWriteConnectionSecretToRef(obj: AppImageConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppImageConfigSpecForProviderKernelGatewayImageConfig
 */
export interface AppImageConfigSpecForProviderKernelGatewayImageConfig {
  /**
   * The URL where the Git repository is located. See File System Config details below.
   *
   * @schema AppImageConfigSpecForProviderKernelGatewayImageConfig#fileSystemConfig
   */
  readonly fileSystemConfig?: AppImageConfigSpecForProviderKernelGatewayImageConfigFileSystemConfig[];

  /**
   * The default branch for the Git repository. See Kernel Spec details below.
   *
   * @schema AppImageConfigSpecForProviderKernelGatewayImageConfig#kernelSpec
   */
  readonly kernelSpec?: AppImageConfigSpecForProviderKernelGatewayImageConfigKernelSpec[];

}

/**
 * Converts an object of type 'AppImageConfigSpecForProviderKernelGatewayImageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecForProviderKernelGatewayImageConfig(obj: AppImageConfigSpecForProviderKernelGatewayImageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemConfig': obj.fileSystemConfig?.map(y => toJson_AppImageConfigSpecForProviderKernelGatewayImageConfigFileSystemConfig(y)),
    'kernelSpec': obj.kernelSpec?.map(y => toJson_AppImageConfigSpecForProviderKernelGatewayImageConfigKernelSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppImageConfigSpecInitProviderKernelGatewayImageConfig
 */
export interface AppImageConfigSpecInitProviderKernelGatewayImageConfig {
  /**
   * The URL where the Git repository is located. See File System Config details below.
   *
   * @schema AppImageConfigSpecInitProviderKernelGatewayImageConfig#fileSystemConfig
   */
  readonly fileSystemConfig?: AppImageConfigSpecInitProviderKernelGatewayImageConfigFileSystemConfig[];

  /**
   * The default branch for the Git repository. See Kernel Spec details below.
   *
   * @schema AppImageConfigSpecInitProviderKernelGatewayImageConfig#kernelSpec
   */
  readonly kernelSpec?: AppImageConfigSpecInitProviderKernelGatewayImageConfigKernelSpec[];

}

/**
 * Converts an object of type 'AppImageConfigSpecInitProviderKernelGatewayImageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecInitProviderKernelGatewayImageConfig(obj: AppImageConfigSpecInitProviderKernelGatewayImageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemConfig': obj.fileSystemConfig?.map(y => toJson_AppImageConfigSpecInitProviderKernelGatewayImageConfigFileSystemConfig(y)),
    'kernelSpec': obj.kernelSpec?.map(y => toJson_AppImageConfigSpecInitProviderKernelGatewayImageConfigKernelSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppImageConfigSpecProviderConfigRefPolicy
 */
export interface AppImageConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppImageConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppImageConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppImageConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppImageConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppImageConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecProviderConfigRefPolicy(obj: AppImageConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppImageConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface AppImageConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppImageConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppImageConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppImageConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecPublishConnectionDetailsToConfigRef(obj: AppImageConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppImageConfigSpecPublishConnectionDetailsToMetadata
 */
export interface AppImageConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppImageConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppImageConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppImageConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppImageConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecPublishConnectionDetailsToMetadata(obj: AppImageConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppImageConfigSpecForProviderKernelGatewayImageConfigFileSystemConfig
 */
export interface AppImageConfigSpecForProviderKernelGatewayImageConfigFileSystemConfig {
  /**
   * The default POSIX group ID (GID). If not specified, defaults to 100. Valid values are 0 and 100.
   *
   * @schema AppImageConfigSpecForProviderKernelGatewayImageConfigFileSystemConfig#defaultGid
   */
  readonly defaultGid?: number;

  /**
   * The default POSIX user ID (UID). If not specified, defaults to 1000. Valid values are 0 and 1000.
   *
   * @schema AppImageConfigSpecForProviderKernelGatewayImageConfigFileSystemConfig#defaultUid
   */
  readonly defaultUid?: number;

  /**
   * The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to /home/sagemaker-user.
   *
   * @schema AppImageConfigSpecForProviderKernelGatewayImageConfigFileSystemConfig#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'AppImageConfigSpecForProviderKernelGatewayImageConfigFileSystemConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecForProviderKernelGatewayImageConfigFileSystemConfig(obj: AppImageConfigSpecForProviderKernelGatewayImageConfigFileSystemConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultGid': obj.defaultGid,
    'defaultUid': obj.defaultUid,
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppImageConfigSpecForProviderKernelGatewayImageConfigKernelSpec
 */
export interface AppImageConfigSpecForProviderKernelGatewayImageConfigKernelSpec {
  /**
   * The display name of the kernel.
   *
   * @schema AppImageConfigSpecForProviderKernelGatewayImageConfigKernelSpec#displayName
   */
  readonly displayName?: string;

  /**
   * The name of the kernel.
   *
   * @schema AppImageConfigSpecForProviderKernelGatewayImageConfigKernelSpec#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'AppImageConfigSpecForProviderKernelGatewayImageConfigKernelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecForProviderKernelGatewayImageConfigKernelSpec(obj: AppImageConfigSpecForProviderKernelGatewayImageConfigKernelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppImageConfigSpecInitProviderKernelGatewayImageConfigFileSystemConfig
 */
export interface AppImageConfigSpecInitProviderKernelGatewayImageConfigFileSystemConfig {
  /**
   * The default POSIX group ID (GID). If not specified, defaults to 100. Valid values are 0 and 100.
   *
   * @schema AppImageConfigSpecInitProviderKernelGatewayImageConfigFileSystemConfig#defaultGid
   */
  readonly defaultGid?: number;

  /**
   * The default POSIX user ID (UID). If not specified, defaults to 1000. Valid values are 0 and 1000.
   *
   * @schema AppImageConfigSpecInitProviderKernelGatewayImageConfigFileSystemConfig#defaultUid
   */
  readonly defaultUid?: number;

  /**
   * The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to /home/sagemaker-user.
   *
   * @schema AppImageConfigSpecInitProviderKernelGatewayImageConfigFileSystemConfig#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'AppImageConfigSpecInitProviderKernelGatewayImageConfigFileSystemConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecInitProviderKernelGatewayImageConfigFileSystemConfig(obj: AppImageConfigSpecInitProviderKernelGatewayImageConfigFileSystemConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultGid': obj.defaultGid,
    'defaultUid': obj.defaultUid,
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppImageConfigSpecInitProviderKernelGatewayImageConfigKernelSpec
 */
export interface AppImageConfigSpecInitProviderKernelGatewayImageConfigKernelSpec {
  /**
   * The display name of the kernel.
   *
   * @schema AppImageConfigSpecInitProviderKernelGatewayImageConfigKernelSpec#displayName
   */
  readonly displayName?: string;

  /**
   * The name of the kernel.
   *
   * @schema AppImageConfigSpecInitProviderKernelGatewayImageConfigKernelSpec#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'AppImageConfigSpecInitProviderKernelGatewayImageConfigKernelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecInitProviderKernelGatewayImageConfigKernelSpec(obj: AppImageConfigSpecInitProviderKernelGatewayImageConfigKernelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppImageConfigSpecProviderConfigRefPolicyResolution
 */
export enum AppImageConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppImageConfigSpecProviderConfigRefPolicyResolve
 */
export enum AppImageConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppImageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CodeRepository is the Schema for the CodeRepositorys API. Provides a SageMaker Code Repository resource.
 *
 * @schema CodeRepository
 */
export class CodeRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CodeRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'CodeRepository',
  }

  /**
   * Renders a Kubernetes manifest for "CodeRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CodeRepositoryProps): any {
    return {
      ...CodeRepository.GVK,
      ...toJson_CodeRepositoryProps(props),
    };
  }

  /**
   * Defines a "CodeRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CodeRepositoryProps) {
    super(scope, id, {
      ...CodeRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CodeRepository.GVK,
      ...toJson_CodeRepositoryProps(resolved),
    };
  }
}

/**
 * CodeRepository is the Schema for the CodeRepositorys API. Provides a SageMaker Code Repository resource.
 *
 * @schema CodeRepository
 */
export interface CodeRepositoryProps {
  /**
   * @schema CodeRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CodeRepositorySpec defines the desired state of CodeRepository
   *
   * @schema CodeRepository#spec
   */
  readonly spec: CodeRepositorySpec;

}

/**
 * Converts an object of type 'CodeRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositoryProps(obj: CodeRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CodeRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CodeRepositorySpec defines the desired state of CodeRepository
 *
 * @schema CodeRepositorySpec
 */
export interface CodeRepositorySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CodeRepositorySpec#deletionPolicy
   */
  readonly deletionPolicy?: CodeRepositorySpecDeletionPolicy;

  /**
   * @schema CodeRepositorySpec#forProvider
   */
  readonly forProvider: CodeRepositorySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CodeRepositorySpec#initProvider
   */
  readonly initProvider?: CodeRepositorySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CodeRepositorySpec#managementPolicies
   */
  readonly managementPolicies?: CodeRepositorySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CodeRepositorySpec#providerConfigRef
   */
  readonly providerConfigRef?: CodeRepositorySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CodeRepositorySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CodeRepositorySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CodeRepositorySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CodeRepositorySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CodeRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpec(obj: CodeRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CodeRepositorySpecForProvider(obj.forProvider),
    'initProvider': toJson_CodeRepositorySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CodeRepositorySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CodeRepositorySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CodeRepositorySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CodeRepositorySpecDeletionPolicy
 */
export enum CodeRepositorySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CodeRepositorySpecForProvider
 */
export interface CodeRepositorySpecForProvider {
  /**
   * Specifies details about the repository. see Git Config details below.
   *
   * @schema CodeRepositorySpecForProvider#gitConfig
   */
  readonly gitConfig?: CodeRepositorySpecForProviderGitConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CodeRepositorySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema CodeRepositorySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CodeRepositorySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecForProvider(obj: CodeRepositorySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gitConfig': obj.gitConfig?.map(y => toJson_CodeRepositorySpecForProviderGitConfig(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CodeRepositorySpecInitProvider
 */
export interface CodeRepositorySpecInitProvider {
  /**
   * Specifies details about the repository. see Git Config details below.
   *
   * @schema CodeRepositorySpecInitProvider#gitConfig
   */
  readonly gitConfig?: CodeRepositorySpecInitProviderGitConfig[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CodeRepositorySpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CodeRepositorySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecInitProvider(obj: CodeRepositorySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gitConfig': obj.gitConfig?.map(y => toJson_CodeRepositorySpecInitProviderGitConfig(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CodeRepositorySpecManagementPolicies
 */
export enum CodeRepositorySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CodeRepositorySpecProviderConfigRef
 */
export interface CodeRepositorySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodeRepositorySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodeRepositorySpecProviderConfigRef#policy
   */
  readonly policy?: CodeRepositorySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CodeRepositorySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecProviderConfigRef(obj: CodeRepositorySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodeRepositorySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CodeRepositorySpecPublishConnectionDetailsTo
 */
export interface CodeRepositorySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CodeRepositorySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CodeRepositorySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CodeRepositorySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CodeRepositorySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CodeRepositorySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CodeRepositorySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecPublishConnectionDetailsTo(obj: CodeRepositorySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CodeRepositorySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CodeRepositorySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CodeRepositorySpecWriteConnectionSecretToRef
 */
export interface CodeRepositorySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CodeRepositorySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CodeRepositorySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CodeRepositorySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecWriteConnectionSecretToRef(obj: CodeRepositorySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodeRepositorySpecForProviderGitConfig
 */
export interface CodeRepositorySpecForProviderGitConfig {
  /**
   * The default branch for the Git repository.
   *
   * @schema CodeRepositorySpecForProviderGitConfig#branch
   */
  readonly branch?: string;

  /**
   * The URL where the Git repository is located.
   *
   * @schema CodeRepositorySpecForProviderGitConfig#repositoryUrl
   */
  readonly repositoryUrl?: string;

  /**
   * The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of AWSCURRENT and must be in the following format: {"username": UserName, "password": Password}
   *
   * @schema CodeRepositorySpecForProviderGitConfig#secretArn
   */
  readonly secretArn?: string;

  /**
   * Reference to a Secret in secretsmanager to populate secretArn.
   *
   * @schema CodeRepositorySpecForProviderGitConfig#secretArnRef
   */
  readonly secretArnRef?: CodeRepositorySpecForProviderGitConfigSecretArnRef;

  /**
   * Selector for a Secret in secretsmanager to populate secretArn.
   *
   * @schema CodeRepositorySpecForProviderGitConfig#secretArnSelector
   */
  readonly secretArnSelector?: CodeRepositorySpecForProviderGitConfigSecretArnSelector;

}

/**
 * Converts an object of type 'CodeRepositorySpecForProviderGitConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecForProviderGitConfig(obj: CodeRepositorySpecForProviderGitConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'repositoryUrl': obj.repositoryUrl,
    'secretArn': obj.secretArn,
    'secretArnRef': toJson_CodeRepositorySpecForProviderGitConfigSecretArnRef(obj.secretArnRef),
    'secretArnSelector': toJson_CodeRepositorySpecForProviderGitConfigSecretArnSelector(obj.secretArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodeRepositorySpecInitProviderGitConfig
 */
export interface CodeRepositorySpecInitProviderGitConfig {
  /**
   * The default branch for the Git repository.
   *
   * @schema CodeRepositorySpecInitProviderGitConfig#branch
   */
  readonly branch?: string;

  /**
   * The URL where the Git repository is located.
   *
   * @schema CodeRepositorySpecInitProviderGitConfig#repositoryUrl
   */
  readonly repositoryUrl?: string;

}

/**
 * Converts an object of type 'CodeRepositorySpecInitProviderGitConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecInitProviderGitConfig(obj: CodeRepositorySpecInitProviderGitConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'repositoryUrl': obj.repositoryUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodeRepositorySpecProviderConfigRefPolicy
 */
export interface CodeRepositorySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodeRepositorySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CodeRepositorySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodeRepositorySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CodeRepositorySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CodeRepositorySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecProviderConfigRefPolicy(obj: CodeRepositorySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CodeRepositorySpecPublishConnectionDetailsToConfigRef
 */
export interface CodeRepositorySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodeRepositorySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodeRepositorySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CodeRepositorySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecPublishConnectionDetailsToConfigRef(obj: CodeRepositorySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CodeRepositorySpecPublishConnectionDetailsToMetadata
 */
export interface CodeRepositorySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CodeRepositorySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CodeRepositorySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CodeRepositorySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CodeRepositorySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecPublishConnectionDetailsToMetadata(obj: CodeRepositorySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretsmanager to populate secretArn.
 *
 * @schema CodeRepositorySpecForProviderGitConfigSecretArnRef
 */
export interface CodeRepositorySpecForProviderGitConfigSecretArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodeRepositorySpecForProviderGitConfigSecretArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodeRepositorySpecForProviderGitConfigSecretArnRef#policy
   */
  readonly policy?: CodeRepositorySpecForProviderGitConfigSecretArnRefPolicy;

}

/**
 * Converts an object of type 'CodeRepositorySpecForProviderGitConfigSecretArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecForProviderGitConfigSecretArnRef(obj: CodeRepositorySpecForProviderGitConfigSecretArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodeRepositorySpecForProviderGitConfigSecretArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretsmanager to populate secretArn.
 *
 * @schema CodeRepositorySpecForProviderGitConfigSecretArnSelector
 */
export interface CodeRepositorySpecForProviderGitConfigSecretArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CodeRepositorySpecForProviderGitConfigSecretArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CodeRepositorySpecForProviderGitConfigSecretArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CodeRepositorySpecForProviderGitConfigSecretArnSelector#policy
   */
  readonly policy?: CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicy;

}

/**
 * Converts an object of type 'CodeRepositorySpecForProviderGitConfigSecretArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecForProviderGitConfigSecretArnSelector(obj: CodeRepositorySpecForProviderGitConfigSecretArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodeRepositorySpecProviderConfigRefPolicyResolution
 */
export enum CodeRepositorySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodeRepositorySpecProviderConfigRefPolicyResolve
 */
export enum CodeRepositorySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj: CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodeRepositorySpecForProviderGitConfigSecretArnRefPolicy
 */
export interface CodeRepositorySpecForProviderGitConfigSecretArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodeRepositorySpecForProviderGitConfigSecretArnRefPolicy#resolution
   */
  readonly resolution?: CodeRepositorySpecForProviderGitConfigSecretArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodeRepositorySpecForProviderGitConfigSecretArnRefPolicy#resolve
   */
  readonly resolve?: CodeRepositorySpecForProviderGitConfigSecretArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CodeRepositorySpecForProviderGitConfigSecretArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecForProviderGitConfigSecretArnRefPolicy(obj: CodeRepositorySpecForProviderGitConfigSecretArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicy
 */
export interface CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicy#resolution
   */
  readonly resolution?: CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicy#resolve
   */
  readonly resolve?: CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicy(obj: CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CodeRepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodeRepositorySpecForProviderGitConfigSecretArnRefPolicyResolution
 */
export enum CodeRepositorySpecForProviderGitConfigSecretArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodeRepositorySpecForProviderGitConfigSecretArnRefPolicyResolve
 */
export enum CodeRepositorySpecForProviderGitConfigSecretArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicyResolution
 */
export enum CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicyResolve
 */
export enum CodeRepositorySpecForProviderGitConfigSecretArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Device is the Schema for the Devices API. Provides a SageMaker Device resource.
 *
 * @schema Device
 */
export class Device extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Device"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'Device',
  }

  /**
   * Renders a Kubernetes manifest for "Device".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeviceProps): any {
    return {
      ...Device.GVK,
      ...toJson_DeviceProps(props),
    };
  }

  /**
   * Defines a "Device" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeviceProps) {
    super(scope, id, {
      ...Device.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Device.GVK,
      ...toJson_DeviceProps(resolved),
    };
  }
}

/**
 * Device is the Schema for the Devices API. Provides a SageMaker Device resource.
 *
 * @schema Device
 */
export interface DeviceProps {
  /**
   * @schema Device#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeviceSpec defines the desired state of Device
   *
   * @schema Device#spec
   */
  readonly spec: DeviceSpec;

}

/**
 * Converts an object of type 'DeviceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceProps(obj: DeviceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeviceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeviceSpec defines the desired state of Device
 *
 * @schema DeviceSpec
 */
export interface DeviceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeviceSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeviceSpecDeletionPolicy;

  /**
   * @schema DeviceSpec#forProvider
   */
  readonly forProvider: DeviceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DeviceSpec#initProvider
   */
  readonly initProvider?: DeviceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DeviceSpec#managementPolicies
   */
  readonly managementPolicies?: DeviceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeviceSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeviceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeviceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeviceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeviceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeviceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeviceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpec(obj: DeviceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeviceSpecForProvider(obj.forProvider),
    'initProvider': toJson_DeviceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DeviceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DeviceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeviceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeviceSpecDeletionPolicy
 */
export enum DeviceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeviceSpecForProvider
 */
export interface DeviceSpecForProvider {
  /**
   * The device to register with SageMaker Edge Manager. See Device details below.
   *
   * @schema DeviceSpecForProvider#device
   */
  readonly device?: DeviceSpecForProviderDevice[];

  /**
   * The name of the Device Fleet.
   *
   * @schema DeviceSpecForProvider#deviceFleetName
   */
  readonly deviceFleetName?: string;

  /**
   * Reference to a DeviceFleet in sagemaker to populate deviceFleetName.
   *
   * @schema DeviceSpecForProvider#deviceFleetNameRef
   */
  readonly deviceFleetNameRef?: DeviceSpecForProviderDeviceFleetNameRef;

  /**
   * Selector for a DeviceFleet in sagemaker to populate deviceFleetName.
   *
   * @schema DeviceSpecForProvider#deviceFleetNameSelector
   */
  readonly deviceFleetNameSelector?: DeviceSpecForProviderDeviceFleetNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DeviceSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DeviceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProvider(obj: DeviceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'device': obj.device?.map(y => toJson_DeviceSpecForProviderDevice(y)),
    'deviceFleetName': obj.deviceFleetName,
    'deviceFleetNameRef': toJson_DeviceSpecForProviderDeviceFleetNameRef(obj.deviceFleetNameRef),
    'deviceFleetNameSelector': toJson_DeviceSpecForProviderDeviceFleetNameSelector(obj.deviceFleetNameSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DeviceSpecInitProvider
 */
export interface DeviceSpecInitProvider {
  /**
   * The device to register with SageMaker Edge Manager. See Device details below.
   *
   * @schema DeviceSpecInitProvider#device
   */
  readonly device?: DeviceSpecInitProviderDevice[];

}

/**
 * Converts an object of type 'DeviceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecInitProvider(obj: DeviceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'device': obj.device?.map(y => toJson_DeviceSpecInitProviderDevice(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DeviceSpecManagementPolicies
 */
export enum DeviceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeviceSpecProviderConfigRef
 */
export interface DeviceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecProviderConfigRef#policy
   */
  readonly policy?: DeviceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecProviderConfigRef(obj: DeviceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeviceSpecPublishConnectionDetailsTo
 */
export interface DeviceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeviceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeviceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeviceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeviceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeviceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsTo(obj: DeviceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeviceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeviceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeviceSpecWriteConnectionSecretToRef
 */
export interface DeviceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeviceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeviceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeviceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecWriteConnectionSecretToRef(obj: DeviceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceSpecForProviderDevice
 */
export interface DeviceSpecForProviderDevice {
  /**
   * A description for the device.
   *
   * @schema DeviceSpecForProviderDevice#description
   */
  readonly description?: string;

  /**
   * The name of the device.
   *
   * @schema DeviceSpecForProviderDevice#deviceName
   */
  readonly deviceName?: string;

  /**
   * Amazon Web Services Internet of Things (IoT) object name.
   *
   * @schema DeviceSpecForProviderDevice#iotThingName
   */
  readonly iotThingName?: string;

}

/**
 * Converts an object of type 'DeviceSpecForProviderDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderDevice(obj: DeviceSpecForProviderDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'deviceName': obj.deviceName,
    'iotThingName': obj.iotThingName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DeviceFleet in sagemaker to populate deviceFleetName.
 *
 * @schema DeviceSpecForProviderDeviceFleetNameRef
 */
export interface DeviceSpecForProviderDeviceFleetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecForProviderDeviceFleetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecForProviderDeviceFleetNameRef#policy
   */
  readonly policy?: DeviceSpecForProviderDeviceFleetNameRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecForProviderDeviceFleetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderDeviceFleetNameRef(obj: DeviceSpecForProviderDeviceFleetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecForProviderDeviceFleetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DeviceFleet in sagemaker to populate deviceFleetName.
 *
 * @schema DeviceSpecForProviderDeviceFleetNameSelector
 */
export interface DeviceSpecForProviderDeviceFleetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeviceSpecForProviderDeviceFleetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeviceSpecForProviderDeviceFleetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeviceSpecForProviderDeviceFleetNameSelector#policy
   */
  readonly policy?: DeviceSpecForProviderDeviceFleetNameSelectorPolicy;

}

/**
 * Converts an object of type 'DeviceSpecForProviderDeviceFleetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderDeviceFleetNameSelector(obj: DeviceSpecForProviderDeviceFleetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeviceSpecForProviderDeviceFleetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceSpecInitProviderDevice
 */
export interface DeviceSpecInitProviderDevice {
  /**
   * A description for the device.
   *
   * @schema DeviceSpecInitProviderDevice#description
   */
  readonly description?: string;

  /**
   * The name of the device.
   *
   * @schema DeviceSpecInitProviderDevice#deviceName
   */
  readonly deviceName?: string;

  /**
   * Amazon Web Services Internet of Things (IoT) object name.
   *
   * @schema DeviceSpecInitProviderDevice#iotThingName
   */
  readonly iotThingName?: string;

}

/**
 * Converts an object of type 'DeviceSpecInitProviderDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecInitProviderDevice(obj: DeviceSpecInitProviderDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'deviceName': obj.deviceName,
    'iotThingName': obj.iotThingName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecProviderConfigRefPolicy
 */
export interface DeviceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecProviderConfigRefPolicy(obj: DeviceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRef
 */
export interface DeviceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeviceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsToConfigRef(obj: DeviceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeviceSpecPublishConnectionDetailsToMetadata
 */
export interface DeviceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeviceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeviceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeviceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsToMetadata(obj: DeviceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecForProviderDeviceFleetNameRefPolicy
 */
export interface DeviceSpecForProviderDeviceFleetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecForProviderDeviceFleetNameRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecForProviderDeviceFleetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecForProviderDeviceFleetNameRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecForProviderDeviceFleetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecForProviderDeviceFleetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderDeviceFleetNameRefPolicy(obj: DeviceSpecForProviderDeviceFleetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeviceSpecForProviderDeviceFleetNameSelectorPolicy
 */
export interface DeviceSpecForProviderDeviceFleetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecForProviderDeviceFleetNameSelectorPolicy#resolution
   */
  readonly resolution?: DeviceSpecForProviderDeviceFleetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecForProviderDeviceFleetNameSelectorPolicy#resolve
   */
  readonly resolve?: DeviceSpecForProviderDeviceFleetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecForProviderDeviceFleetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderDeviceFleetNameSelectorPolicy(obj: DeviceSpecForProviderDeviceFleetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecProviderConfigRefPolicyResolution
 */
export enum DeviceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecProviderConfigRefPolicyResolve
 */
export enum DeviceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeviceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeviceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecForProviderDeviceFleetNameRefPolicyResolution
 */
export enum DeviceSpecForProviderDeviceFleetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecForProviderDeviceFleetNameRefPolicyResolve
 */
export enum DeviceSpecForProviderDeviceFleetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecForProviderDeviceFleetNameSelectorPolicyResolution
 */
export enum DeviceSpecForProviderDeviceFleetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecForProviderDeviceFleetNameSelectorPolicyResolve
 */
export enum DeviceSpecForProviderDeviceFleetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DeviceFleet is the Schema for the DeviceFleets API. Provides a SageMaker Device Fleet resource.
 *
 * @schema DeviceFleet
 */
export class DeviceFleet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DeviceFleet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'DeviceFleet',
  }

  /**
   * Renders a Kubernetes manifest for "DeviceFleet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeviceFleetProps): any {
    return {
      ...DeviceFleet.GVK,
      ...toJson_DeviceFleetProps(props),
    };
  }

  /**
   * Defines a "DeviceFleet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeviceFleetProps) {
    super(scope, id, {
      ...DeviceFleet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DeviceFleet.GVK,
      ...toJson_DeviceFleetProps(resolved),
    };
  }
}

/**
 * DeviceFleet is the Schema for the DeviceFleets API. Provides a SageMaker Device Fleet resource.
 *
 * @schema DeviceFleet
 */
export interface DeviceFleetProps {
  /**
   * @schema DeviceFleet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeviceFleetSpec defines the desired state of DeviceFleet
   *
   * @schema DeviceFleet#spec
   */
  readonly spec: DeviceFleetSpec;

}

/**
 * Converts an object of type 'DeviceFleetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetProps(obj: DeviceFleetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeviceFleetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeviceFleetSpec defines the desired state of DeviceFleet
 *
 * @schema DeviceFleetSpec
 */
export interface DeviceFleetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeviceFleetSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeviceFleetSpecDeletionPolicy;

  /**
   * @schema DeviceFleetSpec#forProvider
   */
  readonly forProvider: DeviceFleetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DeviceFleetSpec#initProvider
   */
  readonly initProvider?: DeviceFleetSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DeviceFleetSpec#managementPolicies
   */
  readonly managementPolicies?: DeviceFleetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeviceFleetSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeviceFleetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeviceFleetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeviceFleetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeviceFleetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeviceFleetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeviceFleetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpec(obj: DeviceFleetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeviceFleetSpecForProvider(obj.forProvider),
    'initProvider': toJson_DeviceFleetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DeviceFleetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DeviceFleetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeviceFleetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeviceFleetSpecDeletionPolicy
 */
export enum DeviceFleetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeviceFleetSpecForProvider
 */
export interface DeviceFleetSpecForProvider {
  /**
   * A description of the fleet.
   *
   * @schema DeviceFleetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether to create an AWS IoT Role Alias during device fleet creation. The name of the role alias generated will match this pattern: "SageMakerEdge-{DeviceFleetName}".
   *
   * @schema DeviceFleetSpecForProvider#enableIotRoleAlias
   */
  readonly enableIotRoleAlias?: boolean;

  /**
   * Specifies details about the repository. see Output Config details below.
   *
   * @schema DeviceFleetSpecForProvider#outputConfig
   */
  readonly outputConfig?: DeviceFleetSpecForProviderOutputConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DeviceFleetSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) that has access to AWS Internet of Things (IoT).
   *
   * @schema DeviceFleetSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeviceFleetSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: DeviceFleetSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeviceFleetSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: DeviceFleetSpecForProviderRoleArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema DeviceFleetSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DeviceFleetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecForProvider(obj: DeviceFleetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enableIotRoleAlias': obj.enableIotRoleAlias,
    'outputConfig': obj.outputConfig?.map(y => toJson_DeviceFleetSpecForProviderOutputConfig(y)),
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeviceFleetSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeviceFleetSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DeviceFleetSpecInitProvider
 */
export interface DeviceFleetSpecInitProvider {
  /**
   * A description of the fleet.
   *
   * @schema DeviceFleetSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Whether to create an AWS IoT Role Alias during device fleet creation. The name of the role alias generated will match this pattern: "SageMakerEdge-{DeviceFleetName}".
   *
   * @schema DeviceFleetSpecInitProvider#enableIotRoleAlias
   */
  readonly enableIotRoleAlias?: boolean;

  /**
   * Specifies details about the repository. see Output Config details below.
   *
   * @schema DeviceFleetSpecInitProvider#outputConfig
   */
  readonly outputConfig?: DeviceFleetSpecInitProviderOutputConfig[];

  /**
   * Key-value map of resource tags.
   *
   * @schema DeviceFleetSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DeviceFleetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecInitProvider(obj: DeviceFleetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enableIotRoleAlias': obj.enableIotRoleAlias,
    'outputConfig': obj.outputConfig?.map(y => toJson_DeviceFleetSpecInitProviderOutputConfig(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DeviceFleetSpecManagementPolicies
 */
export enum DeviceFleetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeviceFleetSpecProviderConfigRef
 */
export interface DeviceFleetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceFleetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceFleetSpecProviderConfigRef#policy
   */
  readonly policy?: DeviceFleetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeviceFleetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecProviderConfigRef(obj: DeviceFleetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceFleetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeviceFleetSpecPublishConnectionDetailsTo
 */
export interface DeviceFleetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeviceFleetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeviceFleetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeviceFleetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeviceFleetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeviceFleetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeviceFleetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecPublishConnectionDetailsTo(obj: DeviceFleetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeviceFleetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeviceFleetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeviceFleetSpecWriteConnectionSecretToRef
 */
export interface DeviceFleetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeviceFleetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeviceFleetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeviceFleetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecWriteConnectionSecretToRef(obj: DeviceFleetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceFleetSpecForProviderOutputConfig
 */
export interface DeviceFleetSpecForProviderOutputConfig {
  /**
   * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.
   *
   * @schema DeviceFleetSpecForProviderOutputConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * The Amazon Simple Storage (S3) bucker URI.
   *
   * @schema DeviceFleetSpecForProviderOutputConfig#s3OutputLocation
   */
  readonly s3OutputLocation?: string;

}

/**
 * Converts an object of type 'DeviceFleetSpecForProviderOutputConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecForProviderOutputConfig(obj: DeviceFleetSpecForProviderOutputConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    's3OutputLocation': obj.s3OutputLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeviceFleetSpecForProviderRoleArnRef
 */
export interface DeviceFleetSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceFleetSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceFleetSpecForProviderRoleArnRef#policy
   */
  readonly policy?: DeviceFleetSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeviceFleetSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecForProviderRoleArnRef(obj: DeviceFleetSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceFleetSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeviceFleetSpecForProviderRoleArnSelector
 */
export interface DeviceFleetSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeviceFleetSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeviceFleetSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeviceFleetSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: DeviceFleetSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeviceFleetSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecForProviderRoleArnSelector(obj: DeviceFleetSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeviceFleetSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceFleetSpecInitProviderOutputConfig
 */
export interface DeviceFleetSpecInitProviderOutputConfig {
  /**
   * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.
   *
   * @schema DeviceFleetSpecInitProviderOutputConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * The Amazon Simple Storage (S3) bucker URI.
   *
   * @schema DeviceFleetSpecInitProviderOutputConfig#s3OutputLocation
   */
  readonly s3OutputLocation?: string;

}

/**
 * Converts an object of type 'DeviceFleetSpecInitProviderOutputConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecInitProviderOutputConfig(obj: DeviceFleetSpecInitProviderOutputConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    's3OutputLocation': obj.s3OutputLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeviceFleetSpecProviderConfigRefPolicy
 */
export interface DeviceFleetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceFleetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeviceFleetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceFleetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeviceFleetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceFleetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecProviderConfigRefPolicy(obj: DeviceFleetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeviceFleetSpecPublishConnectionDetailsToConfigRef
 */
export interface DeviceFleetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceFleetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceFleetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeviceFleetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecPublishConnectionDetailsToConfigRef(obj: DeviceFleetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeviceFleetSpecPublishConnectionDetailsToMetadata
 */
export interface DeviceFleetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeviceFleetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeviceFleetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeviceFleetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeviceFleetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecPublishConnectionDetailsToMetadata(obj: DeviceFleetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeviceFleetSpecForProviderRoleArnRefPolicy
 */
export interface DeviceFleetSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceFleetSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeviceFleetSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceFleetSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeviceFleetSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceFleetSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecForProviderRoleArnRefPolicy(obj: DeviceFleetSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeviceFleetSpecForProviderRoleArnSelectorPolicy
 */
export interface DeviceFleetSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceFleetSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeviceFleetSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceFleetSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeviceFleetSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeviceFleetSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecForProviderRoleArnSelectorPolicy(obj: DeviceFleetSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceFleetSpecProviderConfigRefPolicyResolution
 */
export enum DeviceFleetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceFleetSpecProviderConfigRefPolicyResolve
 */
export enum DeviceFleetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceFleetSpecForProviderRoleArnRefPolicyResolution
 */
export enum DeviceFleetSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceFleetSpecForProviderRoleArnRefPolicyResolve
 */
export enum DeviceFleetSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceFleetSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum DeviceFleetSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceFleetSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum DeviceFleetSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeviceFleetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Domain is the Schema for the Domains API. Provides a SageMaker Domain resource.
 *
 * @schema Domain
 */
export class Domain extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Domain"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'Domain',
  }

  /**
   * Renders a Kubernetes manifest for "Domain".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainProps): any {
    return {
      ...Domain.GVK,
      ...toJson_DomainProps(props),
    };
  }

  /**
   * Defines a "Domain" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainProps) {
    super(scope, id, {
      ...Domain.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Domain.GVK,
      ...toJson_DomainProps(resolved),
    };
  }
}

/**
 * Domain is the Schema for the Domains API. Provides a SageMaker Domain resource.
 *
 * @schema Domain
 */
export interface DomainProps {
  /**
   * @schema Domain#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainSpec defines the desired state of Domain
   *
   * @schema Domain#spec
   */
  readonly spec: DomainSpec;

}

/**
 * Converts an object of type 'DomainProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainProps(obj: DomainProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainSpec defines the desired state of Domain
 *
 * @schema DomainSpec
 */
export interface DomainSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainSpecDeletionPolicy;

  /**
   * @schema DomainSpec#forProvider
   */
  readonly forProvider: DomainSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DomainSpec#initProvider
   */
  readonly initProvider?: DomainSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DomainSpec#managementPolicies
   */
  readonly managementPolicies?: DomainSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpec(obj: DomainSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainSpecForProvider(obj.forProvider),
    'initProvider': toJson_DomainSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DomainSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DomainSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainSpecDeletionPolicy
 */
export enum DomainSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainSpecForProvider
 */
export interface DomainSpecForProvider {
  /**
   * Specifies the VPC used for non-EFS traffic. The default value is PublicInternetOnly. Valid values are PublicInternetOnly and VpcOnly.
   *
   * @schema DomainSpecForProvider#appNetworkAccessType
   */
  readonly appNetworkAccessType?: string;

  /**
   * The entity that creates and manages the required security groups for inter-app communication in VPCOnly mode. Valid values are Service and Customer.
   *
   * @schema DomainSpecForProvider#appSecurityGroupManagement
   */
  readonly appSecurityGroupManagement?: string;

  /**
   * The mode of authentication that members use to access the domain. Valid values are IAM and SSO.
   *
   * @schema DomainSpecForProvider#authMode
   */
  readonly authMode?: string;

  /**
   * The default space settings. See Default Space Settings below.
   *
   * @schema DomainSpecForProvider#defaultSpaceSettings
   */
  readonly defaultSpaceSettings?: DomainSpecForProviderDefaultSpaceSettings[];

  /**
   * The default user settings. See Default User Settings below.* domain_name -  The domain name.
   *
   * @schema DomainSpecForProvider#defaultUserSettings
   */
  readonly defaultUserSettings?: DomainSpecForProviderDefaultUserSettings[];

  /**
   * @schema DomainSpecForProvider#domainName
   */
  readonly domainName?: string;

  /**
   * The domain settings. See Domain Settings below.
   *
   * @schema DomainSpecForProvider#domainSettings
   */
  readonly domainSettings?: DomainSpecForProviderDomainSettings[];

  /**
   * The AWS KMS customer managed CMK used to encrypt the EFS volume attached to the domain.
   *
   * @schema DomainSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema DomainSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: DomainSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema DomainSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: DomainSpecForProviderKmsKeyIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainSpecForProvider#region
   */
  readonly region: string;

  /**
   * The retention policy for this domain, which specifies whether resources will be retained after the Domain is deleted. By default, all resources are retained. See Retention Policy below.
   *
   * @schema DomainSpecForProvider#retentionPolicy
   */
  readonly retentionPolicy?: DomainSpecForProviderRetentionPolicy[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema DomainSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: DomainSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema DomainSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: DomainSpecForProviderSubnetIdSelector;

  /**
   * The VPC subnets that Studio uses for communication.
   *
   * @schema DomainSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema DomainSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The ID of the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
   *
   * @schema DomainSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema DomainSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: DomainSpecForProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema DomainSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: DomainSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'DomainSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProvider(obj: DomainSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appNetworkAccessType': obj.appNetworkAccessType,
    'appSecurityGroupManagement': obj.appSecurityGroupManagement,
    'authMode': obj.authMode,
    'defaultSpaceSettings': obj.defaultSpaceSettings?.map(y => toJson_DomainSpecForProviderDefaultSpaceSettings(y)),
    'defaultUserSettings': obj.defaultUserSettings?.map(y => toJson_DomainSpecForProviderDefaultUserSettings(y)),
    'domainName': obj.domainName,
    'domainSettings': obj.domainSettings?.map(y => toJson_DomainSpecForProviderDomainSettings(y)),
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_DomainSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_DomainSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'region': obj.region,
    'retentionPolicy': obj.retentionPolicy?.map(y => toJson_DomainSpecForProviderRetentionPolicy(y)),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_DomainSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_DomainSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_DomainSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_DomainSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DomainSpecInitProvider
 */
export interface DomainSpecInitProvider {
  /**
   * Specifies the VPC used for non-EFS traffic. The default value is PublicInternetOnly. Valid values are PublicInternetOnly and VpcOnly.
   *
   * @schema DomainSpecInitProvider#appNetworkAccessType
   */
  readonly appNetworkAccessType?: string;

  /**
   * The entity that creates and manages the required security groups for inter-app communication in VPCOnly mode. Valid values are Service and Customer.
   *
   * @schema DomainSpecInitProvider#appSecurityGroupManagement
   */
  readonly appSecurityGroupManagement?: string;

  /**
   * The mode of authentication that members use to access the domain. Valid values are IAM and SSO.
   *
   * @schema DomainSpecInitProvider#authMode
   */
  readonly authMode?: string;

  /**
   * The default space settings. See Default Space Settings below.
   *
   * @schema DomainSpecInitProvider#defaultSpaceSettings
   */
  readonly defaultSpaceSettings?: DomainSpecInitProviderDefaultSpaceSettings[];

  /**
   * The default user settings. See Default User Settings below.* domain_name -  The domain name.
   *
   * @schema DomainSpecInitProvider#defaultUserSettings
   */
  readonly defaultUserSettings?: DomainSpecInitProviderDefaultUserSettings[];

  /**
   * @schema DomainSpecInitProvider#domainName
   */
  readonly domainName?: string;

  /**
   * The domain settings. See Domain Settings below.
   *
   * @schema DomainSpecInitProvider#domainSettings
   */
  readonly domainSettings?: DomainSpecInitProviderDomainSettings[];

  /**
   * The retention policy for this domain, which specifies whether resources will be retained after the Domain is deleted. By default, all resources are retained. See Retention Policy below.
   *
   * @schema DomainSpecInitProvider#retentionPolicy
   */
  readonly retentionPolicy?: DomainSpecInitProviderRetentionPolicy[];

  /**
   * Key-value map of resource tags.
   *
   * @schema DomainSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DomainSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProvider(obj: DomainSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appNetworkAccessType': obj.appNetworkAccessType,
    'appSecurityGroupManagement': obj.appSecurityGroupManagement,
    'authMode': obj.authMode,
    'defaultSpaceSettings': obj.defaultSpaceSettings?.map(y => toJson_DomainSpecInitProviderDefaultSpaceSettings(y)),
    'defaultUserSettings': obj.defaultUserSettings?.map(y => toJson_DomainSpecInitProviderDefaultUserSettings(y)),
    'domainName': obj.domainName,
    'domainSettings': obj.domainSettings?.map(y => toJson_DomainSpecInitProviderDomainSettings(y)),
    'retentionPolicy': obj.retentionPolicy?.map(y => toJson_DomainSpecInitProviderRetentionPolicy(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DomainSpecManagementPolicies
 */
export enum DomainSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainSpecProviderConfigRef
 */
export interface DomainSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecProviderConfigRef#policy
   */
  readonly policy?: DomainSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecProviderConfigRef(obj: DomainSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainSpecPublishConnectionDetailsTo
 */
export interface DomainSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsTo(obj: DomainSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainSpecWriteConnectionSecretToRef
 */
export interface DomainSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecWriteConnectionSecretToRef(obj: DomainSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultSpaceSettings
 */
export interface DomainSpecForProviderDefaultSpaceSettings {
  /**
   * The execution role for the space.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettings#executionRole
   */
  readonly executionRole?: string;

  /**
   * The Jupyter server's app settings. See Jupyter Server App Settings below.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettings#jupyterServerAppSettings
   */
  readonly jupyterServerAppSettings?: DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettings[];

  /**
   * The kernel gateway app settings. See Kernel Gateway App Settings below.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettings#kernelGatewayAppSettings
   */
  readonly kernelGatewayAppSettings?: DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettings[];

  /**
   * The security groups for the Amazon Virtual Private Cloud that the space uses for communication.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettings#securityGroups
   */
  readonly securityGroups?: string[];

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultSpaceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultSpaceSettings(obj: DomainSpecForProviderDefaultSpaceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionRole': obj.executionRole,
    'jupyterServerAppSettings': obj.jupyterServerAppSettings?.map(y => toJson_DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettings(y)),
    'kernelGatewayAppSettings': obj.kernelGatewayAppSettings?.map(y => toJson_DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettings(y)),
    'securityGroups': obj.securityGroups?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettings
 */
export interface DomainSpecForProviderDefaultUserSettings {
  /**
   * The Canvas app settings. See Canvas App Settings below.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#canvasAppSettings
   */
  readonly canvasAppSettings?: DomainSpecForProviderDefaultUserSettingsCanvasAppSettings[];

  /**
   * The execution role ARN for the user.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#executionRole
   */
  readonly executionRole?: string;

  /**
   * Reference to a Role in iam to populate executionRole.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#executionRoleRef
   */
  readonly executionRoleRef?: DomainSpecForProviderDefaultUserSettingsExecutionRoleRef;

  /**
   * Selector for a Role in iam to populate executionRole.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#executionRoleSelector
   */
  readonly executionRoleSelector?: DomainSpecForProviderDefaultUserSettingsExecutionRoleSelector;

  /**
   * The Jupyter server's app settings. See Jupyter Server App Settings below.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#jupyterServerAppSettings
   */
  readonly jupyterServerAppSettings?: DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettings[];

  /**
   * The kernel gateway app settings. See Kernel Gateway App Settings below.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#kernelGatewayAppSettings
   */
  readonly kernelGatewayAppSettings?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettings[];

  /**
   * The RSession app settings. See RSession App Settings below.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#rSessionAppSettings
   */
  readonly rSessionAppSettings?: DomainSpecForProviderDefaultUserSettingsRSessionAppSettings[];

  /**
   * A collection of settings that configure user interaction with the RStudioServerPro app. See RStudioServerProAppSettings below.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#rStudioServerProAppSettings
   */
  readonly rStudioServerProAppSettings?: DomainSpecForProviderDefaultUserSettingsRStudioServerProAppSettings[];

  /**
   * A list of security group IDs that will be attached to the user.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * The sharing settings. See Sharing Settings below.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#sharingSettings
   */
  readonly sharingSettings?: DomainSpecForProviderDefaultUserSettingsSharingSettings[];

  /**
   * The TensorBoard app settings. See TensorBoard App Settings below.
   *
   * @schema DomainSpecForProviderDefaultUserSettings#tensorBoardAppSettings
   */
  readonly tensorBoardAppSettings?: DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettings[];

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettings(obj: DomainSpecForProviderDefaultUserSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'canvasAppSettings': obj.canvasAppSettings?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsCanvasAppSettings(y)),
    'executionRole': obj.executionRole,
    'executionRoleRef': toJson_DomainSpecForProviderDefaultUserSettingsExecutionRoleRef(obj.executionRoleRef),
    'executionRoleSelector': toJson_DomainSpecForProviderDefaultUserSettingsExecutionRoleSelector(obj.executionRoleSelector),
    'jupyterServerAppSettings': obj.jupyterServerAppSettings?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettings(y)),
    'kernelGatewayAppSettings': obj.kernelGatewayAppSettings?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettings(y)),
    'rSessionAppSettings': obj.rSessionAppSettings?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsRSessionAppSettings(y)),
    'rStudioServerProAppSettings': obj.rStudioServerProAppSettings?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsRStudioServerProAppSettings(y)),
    'securityGroups': obj.securityGroups?.map(y => y),
    'sharingSettings': obj.sharingSettings?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsSharingSettings(y)),
    'tensorBoardAppSettings': obj.tensorBoardAppSettings?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDomainSettings
 */
export interface DomainSpecForProviderDomainSettings {
  /**
   * The configuration for attaching a SageMaker user profile name to the execution role as a sts:SourceIdentity key AWS Docs. Valid values are USER_PROFILE_NAME and DISABLED.
   *
   * @schema DomainSpecForProviderDomainSettings#executionRoleIdentityConfig
   */
  readonly executionRoleIdentityConfig?: string;

  /**
   * A collection of settings that configure the RStudioServerPro Domain-level app. see RStudioServerProDomainSettings below.
   *
   * @schema DomainSpecForProviderDomainSettings#rStudioServerProDomainSettings
   */
  readonly rStudioServerProDomainSettings?: DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings[];

  /**
   * The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
   *
   * @schema DomainSpecForProviderDomainSettings#securityGroupIds
   */
  readonly securityGroupIds?: string[];

}

/**
 * Converts an object of type 'DomainSpecForProviderDomainSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDomainSettings(obj: DomainSpecForProviderDomainSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionRoleIdentityConfig': obj.executionRoleIdentityConfig,
    'rStudioServerProDomainSettings': obj.rStudioServerProDomainSettings?.map(y => toJson_DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings(y)),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema DomainSpecForProviderKmsKeyIdRef
 */
export interface DomainSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: DomainSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderKmsKeyIdRef(obj: DomainSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema DomainSpecForProviderKmsKeyIdSelector
 */
export interface DomainSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: DomainSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderKmsKeyIdSelector(obj: DomainSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderRetentionPolicy
 */
export interface DomainSpecForProviderRetentionPolicy {
  /**
   * The retention policy for data stored on an Amazon Elastic File System (EFS) volume. Valid values are Retain or Delete.  Default value is Retain.
   *
   * @schema DomainSpecForProviderRetentionPolicy#homeEfsFileSystem
   */
  readonly homeEfsFileSystem?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderRetentionPolicy(obj: DomainSpecForProviderRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'homeEfsFileSystem': obj.homeEfsFileSystem,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DomainSpecForProviderSubnetIdRefs
 */
export interface DomainSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: DomainSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderSubnetIdRefs(obj: DomainSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema DomainSpecForProviderSubnetIdSelector
 */
export interface DomainSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: DomainSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderSubnetIdSelector(obj: DomainSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema DomainSpecForProviderVpcIdRef
 */
export interface DomainSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecForProviderVpcIdRef#policy
   */
  readonly policy?: DomainSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcIdRef(obj: DomainSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema DomainSpecForProviderVpcIdSelector
 */
export interface DomainSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: DomainSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcIdSelector(obj: DomainSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultSpaceSettings
 */
export interface DomainSpecInitProviderDefaultSpaceSettings {
  /**
   * The execution role for the space.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettings#executionRole
   */
  readonly executionRole?: string;

  /**
   * The Jupyter server's app settings. See Jupyter Server App Settings below.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettings#jupyterServerAppSettings
   */
  readonly jupyterServerAppSettings?: DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettings[];

  /**
   * The kernel gateway app settings. See Kernel Gateway App Settings below.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettings#kernelGatewayAppSettings
   */
  readonly kernelGatewayAppSettings?: DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettings[];

  /**
   * The security groups for the Amazon Virtual Private Cloud that the space uses for communication.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettings#securityGroups
   */
  readonly securityGroups?: string[];

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultSpaceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultSpaceSettings(obj: DomainSpecInitProviderDefaultSpaceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionRole': obj.executionRole,
    'jupyterServerAppSettings': obj.jupyterServerAppSettings?.map(y => toJson_DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettings(y)),
    'kernelGatewayAppSettings': obj.kernelGatewayAppSettings?.map(y => toJson_DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettings(y)),
    'securityGroups': obj.securityGroups?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettings
 */
export interface DomainSpecInitProviderDefaultUserSettings {
  /**
   * The Canvas app settings. See Canvas App Settings below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettings#canvasAppSettings
   */
  readonly canvasAppSettings?: DomainSpecInitProviderDefaultUserSettingsCanvasAppSettings[];

  /**
   * The Jupyter server's app settings. See Jupyter Server App Settings below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettings#jupyterServerAppSettings
   */
  readonly jupyterServerAppSettings?: DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettings[];

  /**
   * The kernel gateway app settings. See Kernel Gateway App Settings below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettings#kernelGatewayAppSettings
   */
  readonly kernelGatewayAppSettings?: DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettings[];

  /**
   * The RSession app settings. See RSession App Settings below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettings#rSessionAppSettings
   */
  readonly rSessionAppSettings?: DomainSpecInitProviderDefaultUserSettingsRSessionAppSettings[];

  /**
   * A collection of settings that configure user interaction with the RStudioServerPro app. See RStudioServerProAppSettings below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettings#rStudioServerProAppSettings
   */
  readonly rStudioServerProAppSettings?: DomainSpecInitProviderDefaultUserSettingsRStudioServerProAppSettings[];

  /**
   * A list of security group IDs that will be attached to the user.
   *
   * @schema DomainSpecInitProviderDefaultUserSettings#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * The sharing settings. See Sharing Settings below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettings#sharingSettings
   */
  readonly sharingSettings?: DomainSpecInitProviderDefaultUserSettingsSharingSettings[];

  /**
   * The TensorBoard app settings. See TensorBoard App Settings below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettings#tensorBoardAppSettings
   */
  readonly tensorBoardAppSettings?: DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettings[];

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettings(obj: DomainSpecInitProviderDefaultUserSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'canvasAppSettings': obj.canvasAppSettings?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsCanvasAppSettings(y)),
    'jupyterServerAppSettings': obj.jupyterServerAppSettings?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettings(y)),
    'kernelGatewayAppSettings': obj.kernelGatewayAppSettings?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettings(y)),
    'rSessionAppSettings': obj.rSessionAppSettings?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsRSessionAppSettings(y)),
    'rStudioServerProAppSettings': obj.rStudioServerProAppSettings?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsRStudioServerProAppSettings(y)),
    'securityGroups': obj.securityGroups?.map(y => y),
    'sharingSettings': obj.sharingSettings?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsSharingSettings(y)),
    'tensorBoardAppSettings': obj.tensorBoardAppSettings?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDomainSettings
 */
export interface DomainSpecInitProviderDomainSettings {
  /**
   * The configuration for attaching a SageMaker user profile name to the execution role as a sts:SourceIdentity key AWS Docs. Valid values are USER_PROFILE_NAME and DISABLED.
   *
   * @schema DomainSpecInitProviderDomainSettings#executionRoleIdentityConfig
   */
  readonly executionRoleIdentityConfig?: string;

  /**
   * A collection of settings that configure the RStudioServerPro Domain-level app. see RStudioServerProDomainSettings below.
   *
   * @schema DomainSpecInitProviderDomainSettings#rStudioServerProDomainSettings
   */
  readonly rStudioServerProDomainSettings?: DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings[];

  /**
   * The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
   *
   * @schema DomainSpecInitProviderDomainSettings#securityGroupIds
   */
  readonly securityGroupIds?: string[];

}

/**
 * Converts an object of type 'DomainSpecInitProviderDomainSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDomainSettings(obj: DomainSpecInitProviderDomainSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionRoleIdentityConfig': obj.executionRoleIdentityConfig,
    'rStudioServerProDomainSettings': obj.rStudioServerProDomainSettings?.map(y => toJson_DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings(y)),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderRetentionPolicy
 */
export interface DomainSpecInitProviderRetentionPolicy {
  /**
   * The retention policy for data stored on an Amazon Elastic File System (EFS) volume. Valid values are Retain or Delete.  Default value is Retain.
   *
   * @schema DomainSpecInitProviderRetentionPolicy#homeEfsFileSystem
   */
  readonly homeEfsFileSystem?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderRetentionPolicy(obj: DomainSpecInitProviderRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'homeEfsFileSystem': obj.homeEfsFileSystem,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecProviderConfigRefPolicy
 */
export interface DomainSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecProviderConfigRefPolicy(obj: DomainSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToConfigRef(obj: DomainSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainSpecPublishConnectionDetailsToMetadata
 */
export interface DomainSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToMetadata(obj: DomainSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettings
 */
export interface DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettings {
  /**
   * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettings#codeRepository
   */
  readonly codeRepository?: DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettings(obj: DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeRepository': obj.codeRepository?.map(y => toJson_DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettings
 */
export interface DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettings#customImage
   */
  readonly customImage?: DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettings(obj: DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsCanvasAppSettings
 */
export interface DomainSpecForProviderDefaultUserSettingsCanvasAppSettings {
  /**
   * The model registry settings for the SageMaker Canvas application. See Model Register Settings below.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsCanvasAppSettings#modelRegisterSettings
   */
  readonly modelRegisterSettings?: DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings[];

  /**
   * Time series forecast settings for the Canvas app. See Time Series Forecasting Settings below.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsCanvasAppSettings#timeSeriesForecastingSettings
   */
  readonly timeSeriesForecastingSettings?: DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings[];

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsCanvasAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsCanvasAppSettings(obj: DomainSpecForProviderDefaultUserSettingsCanvasAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'modelRegisterSettings': obj.modelRegisterSettings?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings(y)),
    'timeSeriesForecastingSettings': obj.timeSeriesForecastingSettings?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate executionRole.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleRef
 */
export interface DomainSpecForProviderDefaultUserSettingsExecutionRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleRef#policy
   */
  readonly policy?: DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsExecutionRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsExecutionRoleRef(obj: DomainSpecForProviderDefaultUserSettingsExecutionRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate executionRole.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleSelector
 */
export interface DomainSpecForProviderDefaultUserSettingsExecutionRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleSelector#policy
   */
  readonly policy?: DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsExecutionRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsExecutionRoleSelector(obj: DomainSpecForProviderDefaultUserSettingsExecutionRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettings
 */
export interface DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettings {
  /**
   * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettings#codeRepository
   */
  readonly codeRepository?: DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettings(obj: DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeRepository': obj.codeRepository?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettings
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettings#customImage
   */
  readonly customImage?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettings(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettings
 */
export interface DomainSpecForProviderDefaultUserSettingsRSessionAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettings#customImage
   */
  readonly customImage?: DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec[];

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsRSessionAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsRSessionAppSettings(obj: DomainSpecForProviderDefaultUserSettingsRSessionAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsRStudioServerProAppSettings
 */
export interface DomainSpecForProviderDefaultUserSettingsRStudioServerProAppSettings {
  /**
   * Indicates whether the current user has access to the RStudioServerPro app. Valid values are ENABLED and DISABLED.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRStudioServerProAppSettings#accessStatus
   */
  readonly accessStatus?: string;

  /**
   * The level of permissions that the user has within the RStudioServerPro app. This value defaults to R_STUDIO_USER. The R_STUDIO_ADMIN value allows the user access to the RStudio Administrative Dashboard. Valid values are R_STUDIO_USER and R_STUDIO_ADMIN.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRStudioServerProAppSettings#userGroup
   */
  readonly userGroup?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsRStudioServerProAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsRStudioServerProAppSettings(obj: DomainSpecForProviderDefaultUserSettingsRStudioServerProAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessStatus': obj.accessStatus,
    'userGroup': obj.userGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsSharingSettings
 */
export interface DomainSpecForProviderDefaultUserSettingsSharingSettings {
  /**
   * Whether to include the notebook cell output when sharing the notebook. The default is Disabled. Valid values are Allowed and Disabled.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsSharingSettings#notebookOutputOption
   */
  readonly notebookOutputOption?: string;

  /**
   * When notebook_output_option is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsSharingSettings#s3KmsKeyId
   */
  readonly s3KmsKeyId?: string;

  /**
   * When notebook_output_option is Allowed, the Amazon S3 bucket used to save the notebook cell output.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsSharingSettings#s3OutputPath
   */
  readonly s3OutputPath?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsSharingSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsSharingSettings(obj: DomainSpecForProviderDefaultUserSettingsSharingSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notebookOutputOption': obj.notebookOutputOption,
    's3KmsKeyId': obj.s3KmsKeyId,
    's3OutputPath': obj.s3OutputPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettings
 */
export interface DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettings {
  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec[];

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettings(obj: DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings
 */
export interface DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings {
  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec[];

  /**
   * The ARN of the execution role for the RStudioServerPro Domain-level app.
   *
   * @schema DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings#domainExecutionRoleArn
   */
  readonly domainExecutionRoleArn?: string;

  /**
   * A URL pointing to an RStudio Connect server.
   *
   * @schema DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings#rStudioConnectUrl
   */
  readonly rStudioConnectUrl?: string;

  /**
   * A URL pointing to an RStudio Package Manager server.
   *
   * @schema DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings#rStudioPackageManagerUrl
   */
  readonly rStudioPackageManagerUrl?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings(obj: DomainSpecForProviderDomainSettingsRStudioServerProDomainSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec(y)),
    'domainExecutionRoleArn': obj.domainExecutionRoleArn,
    'rStudioConnectUrl': obj.rStudioConnectUrl,
    'rStudioPackageManagerUrl': obj.rStudioPackageManagerUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecForProviderKmsKeyIdRefPolicy
 */
export interface DomainSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderKmsKeyIdRefPolicy(obj: DomainSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface DomainSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderKmsKeyIdSelectorPolicy(obj: DomainSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecForProviderSubnetIdRefsPolicy
 */
export interface DomainSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderSubnetIdRefsPolicy(obj: DomainSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainSpecForProviderSubnetIdSelectorPolicy
 */
export interface DomainSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderSubnetIdSelectorPolicy(obj: DomainSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecForProviderVpcIdRefPolicy
 */
export interface DomainSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcIdRefPolicy(obj: DomainSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainSpecForProviderVpcIdSelectorPolicy
 */
export interface DomainSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcIdSelectorPolicy(obj: DomainSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettings
 */
export interface DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettings {
  /**
   * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettings#codeRepository
   */
  readonly codeRepository?: DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettings(obj: DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeRepository': obj.codeRepository?.map(y => toJson_DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettings
 */
export interface DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettings#customImage
   */
  readonly customImage?: DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettings(obj: DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsCanvasAppSettings
 */
export interface DomainSpecInitProviderDefaultUserSettingsCanvasAppSettings {
  /**
   * The model registry settings for the SageMaker Canvas application. See Model Register Settings below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsCanvasAppSettings#modelRegisterSettings
   */
  readonly modelRegisterSettings?: DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings[];

  /**
   * Time series forecast settings for the Canvas app. See Time Series Forecasting Settings below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsCanvasAppSettings#timeSeriesForecastingSettings
   */
  readonly timeSeriesForecastingSettings?: DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings[];

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsCanvasAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsCanvasAppSettings(obj: DomainSpecInitProviderDefaultUserSettingsCanvasAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'modelRegisterSettings': obj.modelRegisterSettings?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings(y)),
    'timeSeriesForecastingSettings': obj.timeSeriesForecastingSettings?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettings
 */
export interface DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettings {
  /**
   * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettings#codeRepository
   */
  readonly codeRepository?: DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettings(obj: DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeRepository': obj.codeRepository?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettings
 */
export interface DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettings#customImage
   */
  readonly customImage?: DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettings(obj: DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettings
 */
export interface DomainSpecInitProviderDefaultUserSettingsRSessionAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettings#customImage
   */
  readonly customImage?: DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec[];

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsRSessionAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsRSessionAppSettings(obj: DomainSpecInitProviderDefaultUserSettingsRSessionAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsRStudioServerProAppSettings
 */
export interface DomainSpecInitProviderDefaultUserSettingsRStudioServerProAppSettings {
  /**
   * Indicates whether the current user has access to the RStudioServerPro app. Valid values are ENABLED and DISABLED.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRStudioServerProAppSettings#accessStatus
   */
  readonly accessStatus?: string;

  /**
   * The level of permissions that the user has within the RStudioServerPro app. This value defaults to R_STUDIO_USER. The R_STUDIO_ADMIN value allows the user access to the RStudio Administrative Dashboard. Valid values are R_STUDIO_USER and R_STUDIO_ADMIN.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRStudioServerProAppSettings#userGroup
   */
  readonly userGroup?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsRStudioServerProAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsRStudioServerProAppSettings(obj: DomainSpecInitProviderDefaultUserSettingsRStudioServerProAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessStatus': obj.accessStatus,
    'userGroup': obj.userGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsSharingSettings
 */
export interface DomainSpecInitProviderDefaultUserSettingsSharingSettings {
  /**
   * Whether to include the notebook cell output when sharing the notebook. The default is Disabled. Valid values are Allowed and Disabled.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsSharingSettings#notebookOutputOption
   */
  readonly notebookOutputOption?: string;

  /**
   * When notebook_output_option is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsSharingSettings#s3KmsKeyId
   */
  readonly s3KmsKeyId?: string;

  /**
   * When notebook_output_option is Allowed, the Amazon S3 bucket used to save the notebook cell output.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsSharingSettings#s3OutputPath
   */
  readonly s3OutputPath?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsSharingSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsSharingSettings(obj: DomainSpecInitProviderDefaultUserSettingsSharingSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notebookOutputOption': obj.notebookOutputOption,
    's3KmsKeyId': obj.s3KmsKeyId,
    's3OutputPath': obj.s3OutputPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettings
 */
export interface DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettings {
  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec[];

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettings(obj: DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings
 */
export interface DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings {
  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec[];

  /**
   * The ARN of the execution role for the RStudioServerPro Domain-level app.
   *
   * @schema DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings#domainExecutionRoleArn
   */
  readonly domainExecutionRoleArn?: string;

  /**
   * A URL pointing to an RStudio Connect server.
   *
   * @schema DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings#rStudioConnectUrl
   */
  readonly rStudioConnectUrl?: string;

  /**
   * A URL pointing to an RStudio Package Manager server.
   *
   * @schema DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings#rStudioPackageManagerUrl
   */
  readonly rStudioPackageManagerUrl?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings(obj: DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec(y)),
    'domainExecutionRoleArn': obj.domainExecutionRoleArn,
    'rStudioConnectUrl': obj.rStudioConnectUrl,
    'rStudioPackageManagerUrl': obj.rStudioPackageManagerUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecProviderConfigRefPolicyResolution
 */
export enum DomainSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecProviderConfigRefPolicyResolve
 */
export enum DomainSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository
 */
export interface DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository {
  /**
   * The URL of the Git repository.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository#repositoryUrl
   */
  readonly repositoryUrl?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository(obj: DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryUrl': obj.repositoryUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec
 */
export interface DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec(obj: DomainSpecForProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage
 */
export interface DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * The name of the Custom Image.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * The version number of the Custom Image.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage(obj: DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'imageName': obj.imageName,
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec
 */
export interface DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec(obj: DomainSpecForProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings
 */
export interface DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings {
  /**
   * The Amazon Resource Name (ARN) of the SageMaker model registry account. Required only to register model versions created by a different SageMaker Canvas AWS account than the AWS account in which SageMaker model registry is set up.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings#crossAccountModelRegisterRoleArn
   */
  readonly crossAccountModelRegisterRoleArn?: string;

  /**
   * Describes whether the integration to the model registry is enabled or disabled in the Canvas application.. Valid values are ENABLED and DISABLED.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings(obj: DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crossAccountModelRegisterRoleArn': obj.crossAccountModelRegisterRoleArn,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings
 */
export interface DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings {
  /**
   * The IAM role that Canvas passes to Amazon Forecast for time series forecasting. By default, Canvas uses the execution role specified in the UserProfile that launches the Canvas app. If an execution role is not specified in the UserProfile, Canvas uses the execution role specified in the Domain that owns the UserProfile. To allow time series forecasting, this IAM role should have the AmazonSageMakerCanvasForecastAccess policy attached and forecast.amazonaws.com added in the trust relationship as a service principal.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings#amazonForecastRoleArn
   */
  readonly amazonForecastRoleArn?: string;

  /**
   * Describes whether time series forecasting is enabled or disabled in the Canvas app. Valid values are ENABLED and DISABLED.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings(obj: DomainSpecForProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonForecastRoleArn': obj.amazonForecastRoleArn,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicy
 */
export interface DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicy(obj: DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicy
 */
export interface DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicy(obj: DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository
 */
export interface DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository {
  /**
   * The URL of the Git repository.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository#repositoryUrl
   */
  readonly repositoryUrl?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository(obj: DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryUrl': obj.repositoryUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec
 */
export interface DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec(obj: DomainSpecForProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * Reference to a AppImageConfig in sagemaker to populate appImageConfigName.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage#appImageConfigNameRef
   */
  readonly appImageConfigNameRef?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRef;

  /**
   * Selector for a AppImageConfig in sagemaker to populate appImageConfigName.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage#appImageConfigNameSelector
   */
  readonly appImageConfigNameSelector?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelector;

  /**
   * The name of the Custom Image.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * Reference to a ImageVersion in sagemaker to populate imageName.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage#imageNameRef
   */
  readonly imageNameRef?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRef;

  /**
   * Selector for a ImageVersion in sagemaker to populate imageName.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage#imageNameSelector
   */
  readonly imageNameSelector?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelector;

  /**
   * The version number of the Custom Image.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'appImageConfigNameRef': toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRef(obj.appImageConfigNameRef),
    'appImageConfigNameSelector': toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelector(obj.appImageConfigNameSelector),
    'imageName': obj.imageName,
    'imageNameRef': toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRef(obj.imageNameRef),
    'imageNameSelector': toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelector(obj.imageNameSelector),
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsCustomImage
 */
export interface DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * The name of the Custom Image.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * The version number of the Custom Image.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsCustomImage(obj: DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'imageName': obj.imageName,
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec
 */
export interface DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec(obj: DomainSpecForProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec
 */
export interface DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec(obj: DomainSpecForProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec
 */
export interface DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec(obj: DomainSpecForProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum DomainSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum DomainSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum DomainSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum DomainSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum DomainSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum DomainSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum DomainSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum DomainSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderVpcIdRefPolicyResolution
 */
export enum DomainSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderVpcIdRefPolicyResolve
 */
export enum DomainSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum DomainSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum DomainSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository
 */
export interface DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository {
  /**
   * The URL of the Git repository.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository#repositoryUrl
   */
  readonly repositoryUrl?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository(obj: DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryUrl': obj.repositoryUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec
 */
export interface DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec(obj: DomainSpecInitProviderDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage
 */
export interface DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * The name of the Custom Image.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * The version number of the Custom Image.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage(obj: DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'imageName': obj.imageName,
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec
 */
export interface DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec(obj: DomainSpecInitProviderDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings
 */
export interface DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings {
  /**
   * The Amazon Resource Name (ARN) of the SageMaker model registry account. Required only to register model versions created by a different SageMaker Canvas AWS account than the AWS account in which SageMaker model registry is set up.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings#crossAccountModelRegisterRoleArn
   */
  readonly crossAccountModelRegisterRoleArn?: string;

  /**
   * Describes whether the integration to the model registry is enabled or disabled in the Canvas application.. Valid values are ENABLED and DISABLED.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings(obj: DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsModelRegisterSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crossAccountModelRegisterRoleArn': obj.crossAccountModelRegisterRoleArn,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings
 */
export interface DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings {
  /**
   * The IAM role that Canvas passes to Amazon Forecast for time series forecasting. By default, Canvas uses the execution role specified in the UserProfile that launches the Canvas app. If an execution role is not specified in the UserProfile, Canvas uses the execution role specified in the Domain that owns the UserProfile. To allow time series forecasting, this IAM role should have the AmazonSageMakerCanvasForecastAccess policy attached and forecast.amazonaws.com added in the trust relationship as a service principal.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings#amazonForecastRoleArn
   */
  readonly amazonForecastRoleArn?: string;

  /**
   * Describes whether time series forecasting is enabled or disabled in the Canvas app. Valid values are ENABLED and DISABLED.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings(obj: DomainSpecInitProviderDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonForecastRoleArn': obj.amazonForecastRoleArn,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository
 */
export interface DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository {
  /**
   * The URL of the Git repository.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository#repositoryUrl
   */
  readonly repositoryUrl?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository(obj: DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsCodeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryUrl': obj.repositoryUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec
 */
export interface DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec(obj: DomainSpecInitProviderDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage
 */
export interface DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage {
  /**
   * The version number of the Custom Image.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage(obj: DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec
 */
export interface DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec(obj: DomainSpecInitProviderDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsCustomImage
 */
export interface DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * The name of the Custom Image.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * The version number of the Custom Image.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsCustomImage(obj: DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'imageName': obj.imageName,
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec
 */
export interface DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec(obj: DomainSpecInitProviderDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec
 */
export interface DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec(obj: DomainSpecInitProviderDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec
 */
export interface DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec {
  /**
   * The instance type that the image version runs on.. For valid values see SageMaker Instance Types.
   *
   * @schema DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The ARN of the SageMaker image that the image version belongs to.
   *
   * @schema DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec(obj: DomainSpecInitProviderDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicyResolution
 */
export enum DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicyResolve
 */
export enum DomainSpecForProviderDefaultUserSettingsExecutionRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicyResolution
 */
export enum DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicyResolve
 */
export enum DomainSpecForProviderDefaultUserSettingsExecutionRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a AppImageConfig in sagemaker to populate appImageConfigName.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRef
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRef#policy
   */
  readonly policy?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRef(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AppImageConfig in sagemaker to populate appImageConfigName.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelector
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelector#policy
   */
  readonly policy?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelector(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ImageVersion in sagemaker to populate imageName.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRef
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRef#policy
   */
  readonly policy?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRef(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ImageVersion in sagemaker to populate imageName.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelector
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelector#policy
   */
  readonly policy?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelector(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicy
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicy(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicy
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicy(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicy
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicy(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicy
 */
export interface DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicy(obj: DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicyResolution
 */
export enum DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicyResolve
 */
export enum DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicyResolution
 */
export enum DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicyResolve
 */
export enum DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageAppImageConfigNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicyResolution
 */
export enum DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicyResolve
 */
export enum DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicyResolution
 */
export enum DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicyResolve
 */
export enum DomainSpecForProviderDefaultUserSettingsKernelGatewayAppSettingsCustomImageImageNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EndpointConfiguration is the Schema for the EndpointConfigurations API. Provides a SageMaker Endpoint Configuration resource.
 *
 * @schema EndpointConfiguration
 */
export class EndpointConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EndpointConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'EndpointConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "EndpointConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EndpointConfigurationProps): any {
    return {
      ...EndpointConfiguration.GVK,
      ...toJson_EndpointConfigurationProps(props),
    };
  }

  /**
   * Defines a "EndpointConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EndpointConfigurationProps) {
    super(scope, id, {
      ...EndpointConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EndpointConfiguration.GVK,
      ...toJson_EndpointConfigurationProps(resolved),
    };
  }
}

/**
 * EndpointConfiguration is the Schema for the EndpointConfigurations API. Provides a SageMaker Endpoint Configuration resource.
 *
 * @schema EndpointConfiguration
 */
export interface EndpointConfigurationProps {
  /**
   * @schema EndpointConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EndpointConfigurationSpec defines the desired state of EndpointConfiguration
   *
   * @schema EndpointConfiguration#spec
   */
  readonly spec: EndpointConfigurationSpec;

}

/**
 * Converts an object of type 'EndpointConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationProps(obj: EndpointConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EndpointConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointConfigurationSpec defines the desired state of EndpointConfiguration
 *
 * @schema EndpointConfigurationSpec
 */
export interface EndpointConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EndpointConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: EndpointConfigurationSpecDeletionPolicy;

  /**
   * @schema EndpointConfigurationSpec#forProvider
   */
  readonly forProvider: EndpointConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema EndpointConfigurationSpec#initProvider
   */
  readonly initProvider?: EndpointConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema EndpointConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: EndpointConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EndpointConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: EndpointConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EndpointConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EndpointConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EndpointConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EndpointConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EndpointConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpec(obj: EndpointConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EndpointConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_EndpointConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_EndpointConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_EndpointConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EndpointConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EndpointConfigurationSpecDeletionPolicy
 */
export enum EndpointConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EndpointConfigurationSpecForProvider
 */
export interface EndpointConfigurationSpecForProvider {
  /**
   * Specifies configuration for how an endpoint performs asynchronous inference.
   *
   * @schema EndpointConfigurationSpecForProvider#asyncInferenceConfig
   */
  readonly asyncInferenceConfig?: EndpointConfigurationSpecForProviderAsyncInferenceConfig[];

  /**
   * Specifies the parameters to capture input/output of SageMaker models endpoints. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecForProvider#dataCaptureConfig
   */
  readonly dataCaptureConfig?: EndpointConfigurationSpecForProviderDataCaptureConfig[];

  /**
   * Amazon Resource Name (ARN) of a AWS Key Management Service key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint.
   *
   * @schema EndpointConfigurationSpecForProvider#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema EndpointConfigurationSpecForProvider#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: EndpointConfigurationSpecForProviderKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema EndpointConfigurationSpecForProvider#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: EndpointConfigurationSpecForProviderKmsKeyArnSelector;

  /**
   * An list of ProductionVariant objects, one for each model that you want to host at this endpoint. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecForProvider#productionVariants
   */
  readonly productionVariants?: EndpointConfigurationSpecForProviderProductionVariants[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EndpointConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Array of ProductionVariant objects. There is one for each model that you want to host at this endpoint in shadow mode with production traffic replicated from the model specified on ProductionVariants.If you use this field, you can only specify one variant for ProductionVariants and one variant for ShadowProductionVariants. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecForProvider#shadowProductionVariants
   */
  readonly shadowProductionVariants?: EndpointConfigurationSpecForProviderShadowProductionVariants[];

  /**
   * Key-value map of resource tags.
   *
   * @schema EndpointConfigurationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProvider(obj: EndpointConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'asyncInferenceConfig': obj.asyncInferenceConfig?.map(y => toJson_EndpointConfigurationSpecForProviderAsyncInferenceConfig(y)),
    'dataCaptureConfig': obj.dataCaptureConfig?.map(y => toJson_EndpointConfigurationSpecForProviderDataCaptureConfig(y)),
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_EndpointConfigurationSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_EndpointConfigurationSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'productionVariants': obj.productionVariants?.map(y => toJson_EndpointConfigurationSpecForProviderProductionVariants(y)),
    'region': obj.region,
    'shadowProductionVariants': obj.shadowProductionVariants?.map(y => toJson_EndpointConfigurationSpecForProviderShadowProductionVariants(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema EndpointConfigurationSpecInitProvider
 */
export interface EndpointConfigurationSpecInitProvider {
  /**
   * Specifies configuration for how an endpoint performs asynchronous inference.
   *
   * @schema EndpointConfigurationSpecInitProvider#asyncInferenceConfig
   */
  readonly asyncInferenceConfig?: EndpointConfigurationSpecInitProviderAsyncInferenceConfig[];

  /**
   * Specifies the parameters to capture input/output of SageMaker models endpoints. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecInitProvider#dataCaptureConfig
   */
  readonly dataCaptureConfig?: EndpointConfigurationSpecInitProviderDataCaptureConfig[];

  /**
   * An list of ProductionVariant objects, one for each model that you want to host at this endpoint. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecInitProvider#productionVariants
   */
  readonly productionVariants?: EndpointConfigurationSpecInitProviderProductionVariants[];

  /**
   * Array of ProductionVariant objects. There is one for each model that you want to host at this endpoint in shadow mode with production traffic replicated from the model specified on ProductionVariants.If you use this field, you can only specify one variant for ProductionVariants and one variant for ShadowProductionVariants. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecInitProvider#shadowProductionVariants
   */
  readonly shadowProductionVariants?: EndpointConfigurationSpecInitProviderShadowProductionVariants[];

  /**
   * Key-value map of resource tags.
   *
   * @schema EndpointConfigurationSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProvider(obj: EndpointConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'asyncInferenceConfig': obj.asyncInferenceConfig?.map(y => toJson_EndpointConfigurationSpecInitProviderAsyncInferenceConfig(y)),
    'dataCaptureConfig': obj.dataCaptureConfig?.map(y => toJson_EndpointConfigurationSpecInitProviderDataCaptureConfig(y)),
    'productionVariants': obj.productionVariants?.map(y => toJson_EndpointConfigurationSpecInitProviderProductionVariants(y)),
    'shadowProductionVariants': obj.shadowProductionVariants?.map(y => toJson_EndpointConfigurationSpecInitProviderShadowProductionVariants(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema EndpointConfigurationSpecManagementPolicies
 */
export enum EndpointConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EndpointConfigurationSpecProviderConfigRef
 */
export interface EndpointConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: EndpointConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecProviderConfigRef(obj: EndpointConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EndpointConfigurationSpecPublishConnectionDetailsTo
 */
export interface EndpointConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EndpointConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EndpointConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EndpointConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EndpointConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EndpointConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecPublishConnectionDetailsTo(obj: EndpointConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EndpointConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EndpointConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EndpointConfigurationSpecWriteConnectionSecretToRef
 */
export interface EndpointConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EndpointConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EndpointConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecWriteConnectionSecretToRef(obj: EndpointConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfig
 */
export interface EndpointConfigurationSpecForProviderAsyncInferenceConfig {
  /**
   * Configures the behavior of the client used by Amazon SageMaker to interact with the model container during asynchronous inference.
   *
   * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfig#clientConfig
   */
  readonly clientConfig?: EndpointConfigurationSpecForProviderAsyncInferenceConfigClientConfig[];

  /**
   * Specifies the configuration for asynchronous inference invocation outputs.
   *
   * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfig#outputConfig
   */
  readonly outputConfig?: EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig[];

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderAsyncInferenceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderAsyncInferenceConfig(obj: EndpointConfigurationSpecForProviderAsyncInferenceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientConfig': obj.clientConfig?.map(y => toJson_EndpointConfigurationSpecForProviderAsyncInferenceConfigClientConfig(y)),
    'outputConfig': obj.outputConfig?.map(y => toJson_EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderDataCaptureConfig
 */
export interface EndpointConfigurationSpecForProviderDataCaptureConfig {
  /**
   * The content type headers to capture. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecForProviderDataCaptureConfig#captureContentTypeHeader
   */
  readonly captureContentTypeHeader?: EndpointConfigurationSpecForProviderDataCaptureConfigCaptureContentTypeHeader[];

  /**
   * Specifies what data to capture. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecForProviderDataCaptureConfig#captureOptions
   */
  readonly captureOptions?: EndpointConfigurationSpecForProviderDataCaptureConfigCaptureOptions[];

  /**
   * The URL for S3 location where the captured data is stored.
   *
   * @schema EndpointConfigurationSpecForProviderDataCaptureConfig#destinationS3Uri
   */
  readonly destinationS3Uri?: string;

  /**
   * Flag to enable data capture. Defaults to false.
   *
   * @default false.
   * @schema EndpointConfigurationSpecForProviderDataCaptureConfig#enableCapture
   */
  readonly enableCapture?: boolean;

  /**
   * Portion of data to capture. Should be between 0 and 100.
   *
   * @schema EndpointConfigurationSpecForProviderDataCaptureConfig#initialSamplingPercentage
   */
  readonly initialSamplingPercentage?: number;

  /**
   * Amazon Resource Name (ARN) of a AWS Key Management Service key that Amazon SageMaker uses to encrypt the captured data on Amazon S3.
   *
   * @schema EndpointConfigurationSpecForProviderDataCaptureConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderDataCaptureConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderDataCaptureConfig(obj: EndpointConfigurationSpecForProviderDataCaptureConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'captureContentTypeHeader': obj.captureContentTypeHeader?.map(y => toJson_EndpointConfigurationSpecForProviderDataCaptureConfigCaptureContentTypeHeader(y)),
    'captureOptions': obj.captureOptions?.map(y => toJson_EndpointConfigurationSpecForProviderDataCaptureConfigCaptureOptions(y)),
    'destinationS3Uri': obj.destinationS3Uri,
    'enableCapture': obj.enableCapture,
    'initialSamplingPercentage': obj.initialSamplingPercentage,
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema EndpointConfigurationSpecForProviderKmsKeyArnRef
 */
export interface EndpointConfigurationSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointConfigurationSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointConfigurationSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: EndpointConfigurationSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderKmsKeyArnRef(obj: EndpointConfigurationSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointConfigurationSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema EndpointConfigurationSpecForProviderKmsKeyArnSelector
 */
export interface EndpointConfigurationSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EndpointConfigurationSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EndpointConfigurationSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EndpointConfigurationSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderKmsKeyArnSelector(obj: EndpointConfigurationSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderProductionVariants
 */
export interface EndpointConfigurationSpecForProviderProductionVariants {
  /**
   * The size of the Elastic Inference (EI) instance to use for the production variant.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#acceleratorType
   */
  readonly acceleratorType?: string;

  /**
   * The timeout value, in seconds, for your inference container to pass health check by SageMaker Hosting. For more information about health check, see How Your Container Should Respond to Health Check (Ping) Requests. Valid values between 60 and 3600.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#containerStartupHealthCheckTimeoutInSeconds
   */
  readonly containerStartupHealthCheckTimeoutInSeconds?: number;

  /**
   * Specifies configuration for a core dump from the model container when the process crashes. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#coreDumpConfig
   */
  readonly coreDumpConfig?: EndpointConfigurationSpecForProviderProductionVariantsCoreDumpConfig[];

  /**
   * You can use this parameter to turn on native Amazon Web Services Systems Manager (SSM) access for a production variant behind an endpoint. By default, SSM access is disabled for all production variants behind an endpoints.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#enableSsmAccess
   */
  readonly enableSsmAccess?: boolean;

  /**
   * Initial number of instances used for auto-scaling.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#initialInstanceCount
   */
  readonly initialInstanceCount?: number;

  /**
   * Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. If unspecified, it defaults to 1.0.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#initialVariantWeight
   */
  readonly initialVariantWeight?: number;

  /**
   * The type of instance to start.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#instanceType
   */
  readonly instanceType?: string;

  /**
   * The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this production variant. Valid values between 60 and 3600.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#modelDataDownloadTimeoutInSeconds
   */
  readonly modelDataDownloadTimeoutInSeconds?: number;

  /**
   * The name of the model to use.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#modelName
   */
  readonly modelName?: string;

  /**
   * Reference to a Model in sagemaker to populate modelName.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#modelNameRef
   */
  readonly modelNameRef?: EndpointConfigurationSpecForProviderProductionVariantsModelNameRef;

  /**
   * Selector for a Model in sagemaker to populate modelName.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#modelNameSelector
   */
  readonly modelNameSelector?: EndpointConfigurationSpecForProviderProductionVariantsModelNameSelector;

  /**
   * Specifies configuration for how an endpoint performs asynchronous inference.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#serverlessConfig
   */
  readonly serverlessConfig?: EndpointConfigurationSpecForProviderProductionVariantsServerlessConfig[];

  /**
   * The name of the variant.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#variantName
   */
  readonly variantName?: string;

  /**
   * The size, in GB, of the ML storage volume attached to individual inference instance associated with the production variant. Valid values between 1 and 512.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariants#volumeSizeInGb
   */
  readonly volumeSizeInGb?: number;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderProductionVariants' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderProductionVariants(obj: EndpointConfigurationSpecForProviderProductionVariants | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorType': obj.acceleratorType,
    'containerStartupHealthCheckTimeoutInSeconds': obj.containerStartupHealthCheckTimeoutInSeconds,
    'coreDumpConfig': obj.coreDumpConfig?.map(y => toJson_EndpointConfigurationSpecForProviderProductionVariantsCoreDumpConfig(y)),
    'enableSsmAccess': obj.enableSsmAccess,
    'initialInstanceCount': obj.initialInstanceCount,
    'initialVariantWeight': obj.initialVariantWeight,
    'instanceType': obj.instanceType,
    'modelDataDownloadTimeoutInSeconds': obj.modelDataDownloadTimeoutInSeconds,
    'modelName': obj.modelName,
    'modelNameRef': toJson_EndpointConfigurationSpecForProviderProductionVariantsModelNameRef(obj.modelNameRef),
    'modelNameSelector': toJson_EndpointConfigurationSpecForProviderProductionVariantsModelNameSelector(obj.modelNameSelector),
    'serverlessConfig': obj.serverlessConfig?.map(y => toJson_EndpointConfigurationSpecForProviderProductionVariantsServerlessConfig(y)),
    'variantName': obj.variantName,
    'volumeSizeInGb': obj.volumeSizeInGb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderShadowProductionVariants
 */
export interface EndpointConfigurationSpecForProviderShadowProductionVariants {
  /**
   * The size of the Elastic Inference (EI) instance to use for the production variant.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#acceleratorType
   */
  readonly acceleratorType?: string;

  /**
   * The timeout value, in seconds, for your inference container to pass health check by SageMaker Hosting. For more information about health check, see How Your Container Should Respond to Health Check (Ping) Requests. Valid values between 60 and 3600.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#containerStartupHealthCheckTimeoutInSeconds
   */
  readonly containerStartupHealthCheckTimeoutInSeconds?: number;

  /**
   * Specifies configuration for a core dump from the model container when the process crashes. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#coreDumpConfig
   */
  readonly coreDumpConfig?: EndpointConfigurationSpecForProviderShadowProductionVariantsCoreDumpConfig[];

  /**
   * You can use this parameter to turn on native Amazon Web Services Systems Manager (SSM) access for a production variant behind an endpoint. By default, SSM access is disabled for all production variants behind an endpoints.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#enableSsmAccess
   */
  readonly enableSsmAccess?: boolean;

  /**
   * Initial number of instances used for auto-scaling.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#initialInstanceCount
   */
  readonly initialInstanceCount?: number;

  /**
   * Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. If unspecified, it defaults to 1.0.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#initialVariantWeight
   */
  readonly initialVariantWeight?: number;

  /**
   * The type of instance to start.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#instanceType
   */
  readonly instanceType?: string;

  /**
   * The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this production variant. Valid values between 60 and 3600.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#modelDataDownloadTimeoutInSeconds
   */
  readonly modelDataDownloadTimeoutInSeconds?: number;

  /**
   * The name of the model to use.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#modelName
   */
  readonly modelName?: string;

  /**
   * Specifies configuration for how an endpoint performs asynchronous inference.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#serverlessConfig
   */
  readonly serverlessConfig?: EndpointConfigurationSpecForProviderShadowProductionVariantsServerlessConfig[];

  /**
   * The name of the variant.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#variantName
   */
  readonly variantName?: string;

  /**
   * The size, in GB, of the ML storage volume attached to individual inference instance associated with the production variant. Valid values between 1 and 512.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariants#volumeSizeInGb
   */
  readonly volumeSizeInGb?: number;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderShadowProductionVariants' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderShadowProductionVariants(obj: EndpointConfigurationSpecForProviderShadowProductionVariants | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorType': obj.acceleratorType,
    'containerStartupHealthCheckTimeoutInSeconds': obj.containerStartupHealthCheckTimeoutInSeconds,
    'coreDumpConfig': obj.coreDumpConfig?.map(y => toJson_EndpointConfigurationSpecForProviderShadowProductionVariantsCoreDumpConfig(y)),
    'enableSsmAccess': obj.enableSsmAccess,
    'initialInstanceCount': obj.initialInstanceCount,
    'initialVariantWeight': obj.initialVariantWeight,
    'instanceType': obj.instanceType,
    'modelDataDownloadTimeoutInSeconds': obj.modelDataDownloadTimeoutInSeconds,
    'modelName': obj.modelName,
    'serverlessConfig': obj.serverlessConfig?.map(y => toJson_EndpointConfigurationSpecForProviderShadowProductionVariantsServerlessConfig(y)),
    'variantName': obj.variantName,
    'volumeSizeInGb': obj.volumeSizeInGb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfig
 */
export interface EndpointConfigurationSpecInitProviderAsyncInferenceConfig {
  /**
   * Configures the behavior of the client used by Amazon SageMaker to interact with the model container during asynchronous inference.
   *
   * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfig#clientConfig
   */
  readonly clientConfig?: EndpointConfigurationSpecInitProviderAsyncInferenceConfigClientConfig[];

  /**
   * Specifies the configuration for asynchronous inference invocation outputs.
   *
   * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfig#outputConfig
   */
  readonly outputConfig?: EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig[];

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderAsyncInferenceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderAsyncInferenceConfig(obj: EndpointConfigurationSpecInitProviderAsyncInferenceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientConfig': obj.clientConfig?.map(y => toJson_EndpointConfigurationSpecInitProviderAsyncInferenceConfigClientConfig(y)),
    'outputConfig': obj.outputConfig?.map(y => toJson_EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderDataCaptureConfig
 */
export interface EndpointConfigurationSpecInitProviderDataCaptureConfig {
  /**
   * The content type headers to capture. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecInitProviderDataCaptureConfig#captureContentTypeHeader
   */
  readonly captureContentTypeHeader?: EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureContentTypeHeader[];

  /**
   * Specifies what data to capture. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecInitProviderDataCaptureConfig#captureOptions
   */
  readonly captureOptions?: EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureOptions[];

  /**
   * The URL for S3 location where the captured data is stored.
   *
   * @schema EndpointConfigurationSpecInitProviderDataCaptureConfig#destinationS3Uri
   */
  readonly destinationS3Uri?: string;

  /**
   * Flag to enable data capture. Defaults to false.
   *
   * @default false.
   * @schema EndpointConfigurationSpecInitProviderDataCaptureConfig#enableCapture
   */
  readonly enableCapture?: boolean;

  /**
   * Portion of data to capture. Should be between 0 and 100.
   *
   * @schema EndpointConfigurationSpecInitProviderDataCaptureConfig#initialSamplingPercentage
   */
  readonly initialSamplingPercentage?: number;

  /**
   * Amazon Resource Name (ARN) of a AWS Key Management Service key that Amazon SageMaker uses to encrypt the captured data on Amazon S3.
   *
   * @schema EndpointConfigurationSpecInitProviderDataCaptureConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderDataCaptureConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderDataCaptureConfig(obj: EndpointConfigurationSpecInitProviderDataCaptureConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'captureContentTypeHeader': obj.captureContentTypeHeader?.map(y => toJson_EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureContentTypeHeader(y)),
    'captureOptions': obj.captureOptions?.map(y => toJson_EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureOptions(y)),
    'destinationS3Uri': obj.destinationS3Uri,
    'enableCapture': obj.enableCapture,
    'initialSamplingPercentage': obj.initialSamplingPercentage,
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderProductionVariants
 */
export interface EndpointConfigurationSpecInitProviderProductionVariants {
  /**
   * The size of the Elastic Inference (EI) instance to use for the production variant.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#acceleratorType
   */
  readonly acceleratorType?: string;

  /**
   * The timeout value, in seconds, for your inference container to pass health check by SageMaker Hosting. For more information about health check, see How Your Container Should Respond to Health Check (Ping) Requests. Valid values between 60 and 3600.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#containerStartupHealthCheckTimeoutInSeconds
   */
  readonly containerStartupHealthCheckTimeoutInSeconds?: number;

  /**
   * Specifies configuration for a core dump from the model container when the process crashes. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#coreDumpConfig
   */
  readonly coreDumpConfig?: EndpointConfigurationSpecInitProviderProductionVariantsCoreDumpConfig[];

  /**
   * You can use this parameter to turn on native Amazon Web Services Systems Manager (SSM) access for a production variant behind an endpoint. By default, SSM access is disabled for all production variants behind an endpoints.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#enableSsmAccess
   */
  readonly enableSsmAccess?: boolean;

  /**
   * Initial number of instances used for auto-scaling.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#initialInstanceCount
   */
  readonly initialInstanceCount?: number;

  /**
   * Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. If unspecified, it defaults to 1.0.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#initialVariantWeight
   */
  readonly initialVariantWeight?: number;

  /**
   * The type of instance to start.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#instanceType
   */
  readonly instanceType?: string;

  /**
   * The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this production variant. Valid values between 60 and 3600.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#modelDataDownloadTimeoutInSeconds
   */
  readonly modelDataDownloadTimeoutInSeconds?: number;

  /**
   * Specifies configuration for how an endpoint performs asynchronous inference.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#serverlessConfig
   */
  readonly serverlessConfig?: EndpointConfigurationSpecInitProviderProductionVariantsServerlessConfig[];

  /**
   * The name of the variant.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#variantName
   */
  readonly variantName?: string;

  /**
   * The size, in GB, of the ML storage volume attached to individual inference instance associated with the production variant. Valid values between 1 and 512.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariants#volumeSizeInGb
   */
  readonly volumeSizeInGb?: number;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderProductionVariants' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderProductionVariants(obj: EndpointConfigurationSpecInitProviderProductionVariants | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorType': obj.acceleratorType,
    'containerStartupHealthCheckTimeoutInSeconds': obj.containerStartupHealthCheckTimeoutInSeconds,
    'coreDumpConfig': obj.coreDumpConfig?.map(y => toJson_EndpointConfigurationSpecInitProviderProductionVariantsCoreDumpConfig(y)),
    'enableSsmAccess': obj.enableSsmAccess,
    'initialInstanceCount': obj.initialInstanceCount,
    'initialVariantWeight': obj.initialVariantWeight,
    'instanceType': obj.instanceType,
    'modelDataDownloadTimeoutInSeconds': obj.modelDataDownloadTimeoutInSeconds,
    'serverlessConfig': obj.serverlessConfig?.map(y => toJson_EndpointConfigurationSpecInitProviderProductionVariantsServerlessConfig(y)),
    'variantName': obj.variantName,
    'volumeSizeInGb': obj.volumeSizeInGb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants
 */
export interface EndpointConfigurationSpecInitProviderShadowProductionVariants {
  /**
   * The size of the Elastic Inference (EI) instance to use for the production variant.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#acceleratorType
   */
  readonly acceleratorType?: string;

  /**
   * The timeout value, in seconds, for your inference container to pass health check by SageMaker Hosting. For more information about health check, see How Your Container Should Respond to Health Check (Ping) Requests. Valid values between 60 and 3600.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#containerStartupHealthCheckTimeoutInSeconds
   */
  readonly containerStartupHealthCheckTimeoutInSeconds?: number;

  /**
   * Specifies configuration for a core dump from the model container when the process crashes. Fields are documented below.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#coreDumpConfig
   */
  readonly coreDumpConfig?: EndpointConfigurationSpecInitProviderShadowProductionVariantsCoreDumpConfig[];

  /**
   * You can use this parameter to turn on native Amazon Web Services Systems Manager (SSM) access for a production variant behind an endpoint. By default, SSM access is disabled for all production variants behind an endpoints.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#enableSsmAccess
   */
  readonly enableSsmAccess?: boolean;

  /**
   * Initial number of instances used for auto-scaling.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#initialInstanceCount
   */
  readonly initialInstanceCount?: number;

  /**
   * Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. If unspecified, it defaults to 1.0.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#initialVariantWeight
   */
  readonly initialVariantWeight?: number;

  /**
   * The type of instance to start.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#instanceType
   */
  readonly instanceType?: string;

  /**
   * The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this production variant. Valid values between 60 and 3600.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#modelDataDownloadTimeoutInSeconds
   */
  readonly modelDataDownloadTimeoutInSeconds?: number;

  /**
   * The name of the model to use.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#modelName
   */
  readonly modelName?: string;

  /**
   * Specifies configuration for how an endpoint performs asynchronous inference.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#serverlessConfig
   */
  readonly serverlessConfig?: EndpointConfigurationSpecInitProviderShadowProductionVariantsServerlessConfig[];

  /**
   * The name of the variant.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#variantName
   */
  readonly variantName?: string;

  /**
   * The size, in GB, of the ML storage volume attached to individual inference instance associated with the production variant. Valid values between 1 and 512.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariants#volumeSizeInGb
   */
  readonly volumeSizeInGb?: number;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderShadowProductionVariants' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderShadowProductionVariants(obj: EndpointConfigurationSpecInitProviderShadowProductionVariants | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorType': obj.acceleratorType,
    'containerStartupHealthCheckTimeoutInSeconds': obj.containerStartupHealthCheckTimeoutInSeconds,
    'coreDumpConfig': obj.coreDumpConfig?.map(y => toJson_EndpointConfigurationSpecInitProviderShadowProductionVariantsCoreDumpConfig(y)),
    'enableSsmAccess': obj.enableSsmAccess,
    'initialInstanceCount': obj.initialInstanceCount,
    'initialVariantWeight': obj.initialVariantWeight,
    'instanceType': obj.instanceType,
    'modelDataDownloadTimeoutInSeconds': obj.modelDataDownloadTimeoutInSeconds,
    'modelName': obj.modelName,
    'serverlessConfig': obj.serverlessConfig?.map(y => toJson_EndpointConfigurationSpecInitProviderShadowProductionVariantsServerlessConfig(y)),
    'variantName': obj.variantName,
    'volumeSizeInGb': obj.volumeSizeInGb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointConfigurationSpecProviderConfigRefPolicy
 */
export interface EndpointConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecProviderConfigRefPolicy(obj: EndpointConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EndpointConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface EndpointConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecPublishConnectionDetailsToConfigRef(obj: EndpointConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EndpointConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface EndpointConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EndpointConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecPublishConnectionDetailsToMetadata(obj: EndpointConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigClientConfig
 */
export interface EndpointConfigurationSpecForProviderAsyncInferenceConfigClientConfig {
  /**
   * The maximum number of concurrent requests sent by the SageMaker client to the model container. If no value is provided, Amazon SageMaker will choose an optimal value for you.
   *
   * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigClientConfig#maxConcurrentInvocationsPerInstance
   */
  readonly maxConcurrentInvocationsPerInstance?: number;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderAsyncInferenceConfigClientConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderAsyncInferenceConfigClientConfig(obj: EndpointConfigurationSpecForProviderAsyncInferenceConfigClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConcurrentInvocationsPerInstance': obj.maxConcurrentInvocationsPerInstance,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig
 */
export interface EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig {
  /**
   * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the asynchronous inference output in Amazon S3.
   *
   * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Specifies the configuration for notifications of inference results for asynchronous inference.
   *
   * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig#notificationConfig
   */
  readonly notificationConfig?: EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfigNotificationConfig[];

  /**
   * The Amazon S3 location to upload failure inference responses to.
   *
   * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig#s3FailurePath
   */
  readonly s3FailurePath?: string;

  /**
   * The Amazon S3 location to upload inference responses to.
   *
   * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig#s3OutputPath
   */
  readonly s3OutputPath?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig(obj: EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    'notificationConfig': obj.notificationConfig?.map(y => toJson_EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfigNotificationConfig(y)),
    's3FailurePath': obj.s3FailurePath,
    's3OutputPath': obj.s3OutputPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderDataCaptureConfigCaptureContentTypeHeader
 */
export interface EndpointConfigurationSpecForProviderDataCaptureConfigCaptureContentTypeHeader {
  /**
   * The CSV content type headers to capture.
   *
   * @schema EndpointConfigurationSpecForProviderDataCaptureConfigCaptureContentTypeHeader#csvContentTypes
   */
  readonly csvContentTypes?: string[];

  /**
   * The JSON content type headers to capture.
   *
   * @schema EndpointConfigurationSpecForProviderDataCaptureConfigCaptureContentTypeHeader#jsonContentTypes
   */
  readonly jsonContentTypes?: string[];

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderDataCaptureConfigCaptureContentTypeHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderDataCaptureConfigCaptureContentTypeHeader(obj: EndpointConfigurationSpecForProviderDataCaptureConfigCaptureContentTypeHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvContentTypes': obj.csvContentTypes?.map(y => y),
    'jsonContentTypes': obj.jsonContentTypes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderDataCaptureConfigCaptureOptions
 */
export interface EndpointConfigurationSpecForProviderDataCaptureConfigCaptureOptions {
  /**
   * Specifies the data to be captured. Should be one of Input or Output.
   *
   * @schema EndpointConfigurationSpecForProviderDataCaptureConfigCaptureOptions#captureMode
   */
  readonly captureMode?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderDataCaptureConfigCaptureOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderDataCaptureConfigCaptureOptions(obj: EndpointConfigurationSpecForProviderDataCaptureConfigCaptureOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'captureMode': obj.captureMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointConfigurationSpecForProviderKmsKeyArnRefPolicy
 */
export interface EndpointConfigurationSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointConfigurationSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: EndpointConfigurationSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointConfigurationSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: EndpointConfigurationSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderKmsKeyArnRefPolicy(obj: EndpointConfigurationSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicy(obj: EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderProductionVariantsCoreDumpConfig
 */
export interface EndpointConfigurationSpecForProviderProductionVariantsCoreDumpConfig {
  /**
   * The Amazon S3 bucket to send the core dump to.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsCoreDumpConfig#destinationS3Uri
   */
  readonly destinationS3Uri?: string;

  /**
   * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsCoreDumpConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderProductionVariantsCoreDumpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderProductionVariantsCoreDumpConfig(obj: EndpointConfigurationSpecForProviderProductionVariantsCoreDumpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationS3Uri': obj.destinationS3Uri,
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Model in sagemaker to populate modelName.
 *
 * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameRef
 */
export interface EndpointConfigurationSpecForProviderProductionVariantsModelNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameRef#policy
   */
  readonly policy?: EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicy;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderProductionVariantsModelNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderProductionVariantsModelNameRef(obj: EndpointConfigurationSpecForProviderProductionVariantsModelNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Model in sagemaker to populate modelName.
 *
 * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameSelector
 */
export interface EndpointConfigurationSpecForProviderProductionVariantsModelNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameSelector#policy
   */
  readonly policy?: EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicy;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderProductionVariantsModelNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderProductionVariantsModelNameSelector(obj: EndpointConfigurationSpecForProviderProductionVariantsModelNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderProductionVariantsServerlessConfig
 */
export interface EndpointConfigurationSpecForProviderProductionVariantsServerlessConfig {
  /**
   * The maximum number of concurrent invocations your serverless endpoint can process. Valid values are between 1 and 200.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsServerlessConfig#maxConcurrency
   */
  readonly maxConcurrency?: number;

  /**
   * The memory size of your serverless endpoint. Valid values are in 1 GB increments: 1024 MB, 2048 MB, 3072 MB, 4096 MB, 5120 MB, or 6144 MB.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsServerlessConfig#memorySizeInMb
   */
  readonly memorySizeInMb?: number;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderProductionVariantsServerlessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderProductionVariantsServerlessConfig(obj: EndpointConfigurationSpecForProviderProductionVariantsServerlessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConcurrency': obj.maxConcurrency,
    'memorySizeInMb': obj.memorySizeInMb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderShadowProductionVariantsCoreDumpConfig
 */
export interface EndpointConfigurationSpecForProviderShadowProductionVariantsCoreDumpConfig {
  /**
   * The Amazon S3 bucket to send the core dump to.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariantsCoreDumpConfig#destinationS3Uri
   */
  readonly destinationS3Uri?: string;

  /**
   * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariantsCoreDumpConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderShadowProductionVariantsCoreDumpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderShadowProductionVariantsCoreDumpConfig(obj: EndpointConfigurationSpecForProviderShadowProductionVariantsCoreDumpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationS3Uri': obj.destinationS3Uri,
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderShadowProductionVariantsServerlessConfig
 */
export interface EndpointConfigurationSpecForProviderShadowProductionVariantsServerlessConfig {
  /**
   * The maximum number of concurrent invocations your serverless endpoint can process. Valid values are between 1 and 200.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariantsServerlessConfig#maxConcurrency
   */
  readonly maxConcurrency?: number;

  /**
   * The memory size of your serverless endpoint. Valid values are in 1 GB increments: 1024 MB, 2048 MB, 3072 MB, 4096 MB, 5120 MB, or 6144 MB.
   *
   * @schema EndpointConfigurationSpecForProviderShadowProductionVariantsServerlessConfig#memorySizeInMb
   */
  readonly memorySizeInMb?: number;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderShadowProductionVariantsServerlessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderShadowProductionVariantsServerlessConfig(obj: EndpointConfigurationSpecForProviderShadowProductionVariantsServerlessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConcurrency': obj.maxConcurrency,
    'memorySizeInMb': obj.memorySizeInMb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigClientConfig
 */
export interface EndpointConfigurationSpecInitProviderAsyncInferenceConfigClientConfig {
  /**
   * The maximum number of concurrent requests sent by the SageMaker client to the model container. If no value is provided, Amazon SageMaker will choose an optimal value for you.
   *
   * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigClientConfig#maxConcurrentInvocationsPerInstance
   */
  readonly maxConcurrentInvocationsPerInstance?: number;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderAsyncInferenceConfigClientConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderAsyncInferenceConfigClientConfig(obj: EndpointConfigurationSpecInitProviderAsyncInferenceConfigClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConcurrentInvocationsPerInstance': obj.maxConcurrentInvocationsPerInstance,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig
 */
export interface EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig {
  /**
   * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the asynchronous inference output in Amazon S3.
   *
   * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Specifies the configuration for notifications of inference results for asynchronous inference.
   *
   * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig#notificationConfig
   */
  readonly notificationConfig?: EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfigNotificationConfig[];

  /**
   * The Amazon S3 location to upload failure inference responses to.
   *
   * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig#s3FailurePath
   */
  readonly s3FailurePath?: string;

  /**
   * The Amazon S3 location to upload inference responses to.
   *
   * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig#s3OutputPath
   */
  readonly s3OutputPath?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig(obj: EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    'notificationConfig': obj.notificationConfig?.map(y => toJson_EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfigNotificationConfig(y)),
    's3FailurePath': obj.s3FailurePath,
    's3OutputPath': obj.s3OutputPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureContentTypeHeader
 */
export interface EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureContentTypeHeader {
  /**
   * The CSV content type headers to capture.
   *
   * @schema EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureContentTypeHeader#csvContentTypes
   */
  readonly csvContentTypes?: string[];

  /**
   * The JSON content type headers to capture.
   *
   * @schema EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureContentTypeHeader#jsonContentTypes
   */
  readonly jsonContentTypes?: string[];

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureContentTypeHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureContentTypeHeader(obj: EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureContentTypeHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvContentTypes': obj.csvContentTypes?.map(y => y),
    'jsonContentTypes': obj.jsonContentTypes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureOptions
 */
export interface EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureOptions {
  /**
   * Specifies the data to be captured. Should be one of Input or Output.
   *
   * @schema EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureOptions#captureMode
   */
  readonly captureMode?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureOptions(obj: EndpointConfigurationSpecInitProviderDataCaptureConfigCaptureOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'captureMode': obj.captureMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderProductionVariantsCoreDumpConfig
 */
export interface EndpointConfigurationSpecInitProviderProductionVariantsCoreDumpConfig {
  /**
   * The Amazon S3 bucket to send the core dump to.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariantsCoreDumpConfig#destinationS3Uri
   */
  readonly destinationS3Uri?: string;

  /**
   * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariantsCoreDumpConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderProductionVariantsCoreDumpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderProductionVariantsCoreDumpConfig(obj: EndpointConfigurationSpecInitProviderProductionVariantsCoreDumpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationS3Uri': obj.destinationS3Uri,
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderProductionVariantsServerlessConfig
 */
export interface EndpointConfigurationSpecInitProviderProductionVariantsServerlessConfig {
  /**
   * The maximum number of concurrent invocations your serverless endpoint can process. Valid values are between 1 and 200.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariantsServerlessConfig#maxConcurrency
   */
  readonly maxConcurrency?: number;

  /**
   * The memory size of your serverless endpoint. Valid values are in 1 GB increments: 1024 MB, 2048 MB, 3072 MB, 4096 MB, 5120 MB, or 6144 MB.
   *
   * @schema EndpointConfigurationSpecInitProviderProductionVariantsServerlessConfig#memorySizeInMb
   */
  readonly memorySizeInMb?: number;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderProductionVariantsServerlessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderProductionVariantsServerlessConfig(obj: EndpointConfigurationSpecInitProviderProductionVariantsServerlessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConcurrency': obj.maxConcurrency,
    'memorySizeInMb': obj.memorySizeInMb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderShadowProductionVariantsCoreDumpConfig
 */
export interface EndpointConfigurationSpecInitProviderShadowProductionVariantsCoreDumpConfig {
  /**
   * The Amazon S3 bucket to send the core dump to.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariantsCoreDumpConfig#destinationS3Uri
   */
  readonly destinationS3Uri?: string;

  /**
   * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariantsCoreDumpConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderShadowProductionVariantsCoreDumpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderShadowProductionVariantsCoreDumpConfig(obj: EndpointConfigurationSpecInitProviderShadowProductionVariantsCoreDumpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationS3Uri': obj.destinationS3Uri,
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderShadowProductionVariantsServerlessConfig
 */
export interface EndpointConfigurationSpecInitProviderShadowProductionVariantsServerlessConfig {
  /**
   * The maximum number of concurrent invocations your serverless endpoint can process. Valid values are between 1 and 200.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariantsServerlessConfig#maxConcurrency
   */
  readonly maxConcurrency?: number;

  /**
   * The memory size of your serverless endpoint. Valid values are in 1 GB increments: 1024 MB, 2048 MB, 3072 MB, 4096 MB, 5120 MB, or 6144 MB.
   *
   * @schema EndpointConfigurationSpecInitProviderShadowProductionVariantsServerlessConfig#memorySizeInMb
   */
  readonly memorySizeInMb?: number;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderShadowProductionVariantsServerlessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderShadowProductionVariantsServerlessConfig(obj: EndpointConfigurationSpecInitProviderShadowProductionVariantsServerlessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConcurrency': obj.maxConcurrency,
    'memorySizeInMb': obj.memorySizeInMb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum EndpointConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum EndpointConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfigNotificationConfig
 */
export interface EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfigNotificationConfig {
  /**
   * Amazon SNS topic to post a notification to when inference fails. If no topic is provided, no notification is sent on failure.
   *
   * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfigNotificationConfig#errorTopic
   */
  readonly errorTopic?: string;

  /**
   * The Amazon SNS topics where you want the inference response to be included. Valid values are SUCCESS_NOTIFICATION_TOPIC and ERROR_NOTIFICATION_TOPIC.
   *
   * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfigNotificationConfig#includeInferenceResponseIn
   */
  readonly includeInferenceResponseIn?: string[];

  /**
   * Amazon SNS topic to post a notification to when inference completes successfully. If no topic is provided, no notification is sent on success.
   *
   * @schema EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfigNotificationConfig#successTopic
   */
  readonly successTopic?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfigNotificationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfigNotificationConfig(obj: EndpointConfigurationSpecForProviderAsyncInferenceConfigOutputConfigNotificationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorTopic': obj.errorTopic,
    'includeInferenceResponseIn': obj.includeInferenceResponseIn?.map(y => y),
    'successTopic': obj.successTopic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointConfigurationSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum EndpointConfigurationSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointConfigurationSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum EndpointConfigurationSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum EndpointConfigurationSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicy
 */
export interface EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicy#resolution
   */
  readonly resolution?: EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicy#resolve
   */
  readonly resolve?: EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicy(obj: EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicy
 */
export interface EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicy#resolution
   */
  readonly resolution?: EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicy#resolve
   */
  readonly resolve?: EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicy(obj: EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfigNotificationConfig
 */
export interface EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfigNotificationConfig {
  /**
   * Amazon SNS topic to post a notification to when inference fails. If no topic is provided, no notification is sent on failure.
   *
   * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfigNotificationConfig#errorTopic
   */
  readonly errorTopic?: string;

  /**
   * The Amazon SNS topics where you want the inference response to be included. Valid values are SUCCESS_NOTIFICATION_TOPIC and ERROR_NOTIFICATION_TOPIC.
   *
   * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfigNotificationConfig#includeInferenceResponseIn
   */
  readonly includeInferenceResponseIn?: string[];

  /**
   * Amazon SNS topic to post a notification to when inference completes successfully. If no topic is provided, no notification is sent on success.
   *
   * @schema EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfigNotificationConfig#successTopic
   */
  readonly successTopic?: string;

}

/**
 * Converts an object of type 'EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfigNotificationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfigNotificationConfig(obj: EndpointConfigurationSpecInitProviderAsyncInferenceConfigOutputConfigNotificationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorTopic': obj.errorTopic,
    'includeInferenceResponseIn': obj.includeInferenceResponseIn?.map(y => y),
    'successTopic': obj.successTopic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EndpointConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicyResolution
 */
export enum EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicyResolve
 */
export enum EndpointConfigurationSpecForProviderProductionVariantsModelNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicyResolution
 */
export enum EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicyResolve
 */
export enum EndpointConfigurationSpecForProviderProductionVariantsModelNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FeatureGroup is the Schema for the FeatureGroups API. Provides a SageMaker Feature Group resource.
 *
 * @schema FeatureGroup
 */
export class FeatureGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FeatureGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'FeatureGroup',
  }

  /**
   * Renders a Kubernetes manifest for "FeatureGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FeatureGroupProps): any {
    return {
      ...FeatureGroup.GVK,
      ...toJson_FeatureGroupProps(props),
    };
  }

  /**
   * Defines a "FeatureGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FeatureGroupProps) {
    super(scope, id, {
      ...FeatureGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FeatureGroup.GVK,
      ...toJson_FeatureGroupProps(resolved),
    };
  }
}

/**
 * FeatureGroup is the Schema for the FeatureGroups API. Provides a SageMaker Feature Group resource.
 *
 * @schema FeatureGroup
 */
export interface FeatureGroupProps {
  /**
   * @schema FeatureGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FeatureGroupSpec defines the desired state of FeatureGroup
   *
   * @schema FeatureGroup#spec
   */
  readonly spec: FeatureGroupSpec;

}

/**
 * Converts an object of type 'FeatureGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupProps(obj: FeatureGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FeatureGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FeatureGroupSpec defines the desired state of FeatureGroup
 *
 * @schema FeatureGroupSpec
 */
export interface FeatureGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FeatureGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: FeatureGroupSpecDeletionPolicy;

  /**
   * @schema FeatureGroupSpec#forProvider
   */
  readonly forProvider: FeatureGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FeatureGroupSpec#initProvider
   */
  readonly initProvider?: FeatureGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FeatureGroupSpec#managementPolicies
   */
  readonly managementPolicies?: FeatureGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FeatureGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: FeatureGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FeatureGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FeatureGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FeatureGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FeatureGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FeatureGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpec(obj: FeatureGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FeatureGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_FeatureGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FeatureGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FeatureGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FeatureGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FeatureGroupSpecDeletionPolicy
 */
export enum FeatureGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FeatureGroupSpecForProvider
 */
export interface FeatureGroupSpecForProvider {
  /**
   * A free-form description of a Feature Group.
   *
   * @schema FeatureGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the feature that stores the EventTime of a Record in a Feature Group.
   *
   * @schema FeatureGroupSpecForProvider#eventTimeFeatureName
   */
  readonly eventTimeFeatureName?: string;

  /**
   * A list of Feature names and types. See Feature Definition Below.
   *
   * @schema FeatureGroupSpecForProvider#featureDefinition
   */
  readonly featureDefinition?: FeatureGroupSpecForProviderFeatureDefinition[];

  /**
   * The Offline Feature Store Configuration. See Offline Store Config Below.
   *
   * @schema FeatureGroupSpecForProvider#offlineStoreConfig
   */
  readonly offlineStoreConfig?: FeatureGroupSpecForProviderOfflineStoreConfig[];

  /**
   * The Online Feature Store Configuration. See Online Store Config Below.
   *
   * @schema FeatureGroupSpecForProvider#onlineStoreConfig
   */
  readonly onlineStoreConfig?: FeatureGroupSpecForProviderOnlineStoreConfig[];

  /**
   * The name of the Feature whose value uniquely identifies a Record defined in the Feature Store. Only the latest record per identifier value will be stored in the Online Store.
   *
   * @schema FeatureGroupSpecForProvider#recordIdentifierFeatureName
   */
  readonly recordIdentifierFeatureName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FeatureGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the IAM execution role used to persist data into the Offline Store if an offline_store_config is provided.
   *
   * @schema FeatureGroupSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema FeatureGroupSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: FeatureGroupSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema FeatureGroupSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: FeatureGroupSpecForProviderRoleArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema FeatureGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FeatureGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProvider(obj: FeatureGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'eventTimeFeatureName': obj.eventTimeFeatureName,
    'featureDefinition': obj.featureDefinition?.map(y => toJson_FeatureGroupSpecForProviderFeatureDefinition(y)),
    'offlineStoreConfig': obj.offlineStoreConfig?.map(y => toJson_FeatureGroupSpecForProviderOfflineStoreConfig(y)),
    'onlineStoreConfig': obj.onlineStoreConfig?.map(y => toJson_FeatureGroupSpecForProviderOnlineStoreConfig(y)),
    'recordIdentifierFeatureName': obj.recordIdentifierFeatureName,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_FeatureGroupSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_FeatureGroupSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FeatureGroupSpecInitProvider
 */
export interface FeatureGroupSpecInitProvider {
  /**
   * A free-form description of a Feature Group.
   *
   * @schema FeatureGroupSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The name of the feature that stores the EventTime of a Record in a Feature Group.
   *
   * @schema FeatureGroupSpecInitProvider#eventTimeFeatureName
   */
  readonly eventTimeFeatureName?: string;

  /**
   * A list of Feature names and types. See Feature Definition Below.
   *
   * @schema FeatureGroupSpecInitProvider#featureDefinition
   */
  readonly featureDefinition?: FeatureGroupSpecInitProviderFeatureDefinition[];

  /**
   * The Offline Feature Store Configuration. See Offline Store Config Below.
   *
   * @schema FeatureGroupSpecInitProvider#offlineStoreConfig
   */
  readonly offlineStoreConfig?: FeatureGroupSpecInitProviderOfflineStoreConfig[];

  /**
   * The Online Feature Store Configuration. See Online Store Config Below.
   *
   * @schema FeatureGroupSpecInitProvider#onlineStoreConfig
   */
  readonly onlineStoreConfig?: FeatureGroupSpecInitProviderOnlineStoreConfig[];

  /**
   * The name of the Feature whose value uniquely identifies a Record defined in the Feature Store. Only the latest record per identifier value will be stored in the Online Store.
   *
   * @schema FeatureGroupSpecInitProvider#recordIdentifierFeatureName
   */
  readonly recordIdentifierFeatureName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FeatureGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FeatureGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecInitProvider(obj: FeatureGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'eventTimeFeatureName': obj.eventTimeFeatureName,
    'featureDefinition': obj.featureDefinition?.map(y => toJson_FeatureGroupSpecInitProviderFeatureDefinition(y)),
    'offlineStoreConfig': obj.offlineStoreConfig?.map(y => toJson_FeatureGroupSpecInitProviderOfflineStoreConfig(y)),
    'onlineStoreConfig': obj.onlineStoreConfig?.map(y => toJson_FeatureGroupSpecInitProviderOnlineStoreConfig(y)),
    'recordIdentifierFeatureName': obj.recordIdentifierFeatureName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FeatureGroupSpecManagementPolicies
 */
export enum FeatureGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FeatureGroupSpecProviderConfigRef
 */
export interface FeatureGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeatureGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeatureGroupSpecProviderConfigRef#policy
   */
  readonly policy?: FeatureGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FeatureGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecProviderConfigRef(obj: FeatureGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeatureGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FeatureGroupSpecPublishConnectionDetailsTo
 */
export interface FeatureGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FeatureGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FeatureGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FeatureGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FeatureGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FeatureGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecPublishConnectionDetailsTo(obj: FeatureGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FeatureGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FeatureGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FeatureGroupSpecWriteConnectionSecretToRef
 */
export interface FeatureGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FeatureGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FeatureGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecWriteConnectionSecretToRef(obj: FeatureGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecForProviderFeatureDefinition
 */
export interface FeatureGroupSpecForProviderFeatureDefinition {
  /**
   * The name of a feature. feature_name cannot be any of the following: is_deleted, write_time, api_invocation_time.
   *
   * @schema FeatureGroupSpecForProviderFeatureDefinition#featureName
   */
  readonly featureName?: string;

  /**
   * The value type of a feature. Valid values are Integral, Fractional, or String.
   *
   * @schema FeatureGroupSpecForProviderFeatureDefinition#featureType
   */
  readonly featureType?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecForProviderFeatureDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProviderFeatureDefinition(obj: FeatureGroupSpecForProviderFeatureDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'featureName': obj.featureName,
    'featureType': obj.featureType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecForProviderOfflineStoreConfig
 */
export interface FeatureGroupSpecForProviderOfflineStoreConfig {
  /**
   * The meta data of the Glue table that is autogenerated when an OfflineStore is created. See Data Catalog Config Below.
   *
   * @schema FeatureGroupSpecForProviderOfflineStoreConfig#dataCatalogConfig
   */
  readonly dataCatalogConfig?: FeatureGroupSpecForProviderOfflineStoreConfigDataCatalogConfig[];

  /**
   * Set to true to turn Online Store On.
   *
   * @schema FeatureGroupSpecForProviderOfflineStoreConfig#disableGlueTableCreation
   */
  readonly disableGlueTableCreation?: boolean;

  /**
   * The Amazon Simple Storage (Amazon S3) location of OfflineStore. See S3 Storage Config Below.
   *
   * @schema FeatureGroupSpecForProviderOfflineStoreConfig#s3StorageConfig
   */
  readonly s3StorageConfig?: FeatureGroupSpecForProviderOfflineStoreConfigS3StorageConfig[];

  /**
   * Format for the offline store table. Supported formats are Glue (Default) and Apache Iceberg (https://iceberg.apache.org/).
   *
   * @schema FeatureGroupSpecForProviderOfflineStoreConfig#tableFormat
   */
  readonly tableFormat?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecForProviderOfflineStoreConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProviderOfflineStoreConfig(obj: FeatureGroupSpecForProviderOfflineStoreConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCatalogConfig': obj.dataCatalogConfig?.map(y => toJson_FeatureGroupSpecForProviderOfflineStoreConfigDataCatalogConfig(y)),
    'disableGlueTableCreation': obj.disableGlueTableCreation,
    's3StorageConfig': obj.s3StorageConfig?.map(y => toJson_FeatureGroupSpecForProviderOfflineStoreConfigS3StorageConfig(y)),
    'tableFormat': obj.tableFormat,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecForProviderOnlineStoreConfig
 */
export interface FeatureGroupSpecForProviderOnlineStoreConfig {
  /**
   * Set to true to disable the automatic creation of an AWS Glue table when configuring an OfflineStore.
   *
   * @schema FeatureGroupSpecForProviderOnlineStoreConfig#enableOnlineStore
   */
  readonly enableOnlineStore?: boolean;

  /**
   * Security config for at-rest encryption of your OnlineStore. See Security Config Below.
   *
   * @schema FeatureGroupSpecForProviderOnlineStoreConfig#securityConfig
   */
  readonly securityConfig?: FeatureGroupSpecForProviderOnlineStoreConfigSecurityConfig[];

}

/**
 * Converts an object of type 'FeatureGroupSpecForProviderOnlineStoreConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProviderOnlineStoreConfig(obj: FeatureGroupSpecForProviderOnlineStoreConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableOnlineStore': obj.enableOnlineStore,
    'securityConfig': obj.securityConfig?.map(y => toJson_FeatureGroupSpecForProviderOnlineStoreConfigSecurityConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema FeatureGroupSpecForProviderRoleArnRef
 */
export interface FeatureGroupSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeatureGroupSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeatureGroupSpecForProviderRoleArnRef#policy
   */
  readonly policy?: FeatureGroupSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'FeatureGroupSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProviderRoleArnRef(obj: FeatureGroupSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeatureGroupSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema FeatureGroupSpecForProviderRoleArnSelector
 */
export interface FeatureGroupSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FeatureGroupSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FeatureGroupSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FeatureGroupSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: FeatureGroupSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'FeatureGroupSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProviderRoleArnSelector(obj: FeatureGroupSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FeatureGroupSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecInitProviderFeatureDefinition
 */
export interface FeatureGroupSpecInitProviderFeatureDefinition {
  /**
   * The name of a feature. feature_name cannot be any of the following: is_deleted, write_time, api_invocation_time.
   *
   * @schema FeatureGroupSpecInitProviderFeatureDefinition#featureName
   */
  readonly featureName?: string;

  /**
   * The value type of a feature. Valid values are Integral, Fractional, or String.
   *
   * @schema FeatureGroupSpecInitProviderFeatureDefinition#featureType
   */
  readonly featureType?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecInitProviderFeatureDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecInitProviderFeatureDefinition(obj: FeatureGroupSpecInitProviderFeatureDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'featureName': obj.featureName,
    'featureType': obj.featureType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecInitProviderOfflineStoreConfig
 */
export interface FeatureGroupSpecInitProviderOfflineStoreConfig {
  /**
   * The meta data of the Glue table that is autogenerated when an OfflineStore is created. See Data Catalog Config Below.
   *
   * @schema FeatureGroupSpecInitProviderOfflineStoreConfig#dataCatalogConfig
   */
  readonly dataCatalogConfig?: FeatureGroupSpecInitProviderOfflineStoreConfigDataCatalogConfig[];

  /**
   * Set to true to turn Online Store On.
   *
   * @schema FeatureGroupSpecInitProviderOfflineStoreConfig#disableGlueTableCreation
   */
  readonly disableGlueTableCreation?: boolean;

  /**
   * The Amazon Simple Storage (Amazon S3) location of OfflineStore. See S3 Storage Config Below.
   *
   * @schema FeatureGroupSpecInitProviderOfflineStoreConfig#s3StorageConfig
   */
  readonly s3StorageConfig?: FeatureGroupSpecInitProviderOfflineStoreConfigS3StorageConfig[];

  /**
   * Format for the offline store table. Supported formats are Glue (Default) and Apache Iceberg (https://iceberg.apache.org/).
   *
   * @schema FeatureGroupSpecInitProviderOfflineStoreConfig#tableFormat
   */
  readonly tableFormat?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecInitProviderOfflineStoreConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecInitProviderOfflineStoreConfig(obj: FeatureGroupSpecInitProviderOfflineStoreConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCatalogConfig': obj.dataCatalogConfig?.map(y => toJson_FeatureGroupSpecInitProviderOfflineStoreConfigDataCatalogConfig(y)),
    'disableGlueTableCreation': obj.disableGlueTableCreation,
    's3StorageConfig': obj.s3StorageConfig?.map(y => toJson_FeatureGroupSpecInitProviderOfflineStoreConfigS3StorageConfig(y)),
    'tableFormat': obj.tableFormat,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecInitProviderOnlineStoreConfig
 */
export interface FeatureGroupSpecInitProviderOnlineStoreConfig {
  /**
   * Set to true to disable the automatic creation of an AWS Glue table when configuring an OfflineStore.
   *
   * @schema FeatureGroupSpecInitProviderOnlineStoreConfig#enableOnlineStore
   */
  readonly enableOnlineStore?: boolean;

  /**
   * Security config for at-rest encryption of your OnlineStore. See Security Config Below.
   *
   * @schema FeatureGroupSpecInitProviderOnlineStoreConfig#securityConfig
   */
  readonly securityConfig?: FeatureGroupSpecInitProviderOnlineStoreConfigSecurityConfig[];

}

/**
 * Converts an object of type 'FeatureGroupSpecInitProviderOnlineStoreConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecInitProviderOnlineStoreConfig(obj: FeatureGroupSpecInitProviderOnlineStoreConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableOnlineStore': obj.enableOnlineStore,
    'securityConfig': obj.securityConfig?.map(y => toJson_FeatureGroupSpecInitProviderOnlineStoreConfigSecurityConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FeatureGroupSpecProviderConfigRefPolicy
 */
export interface FeatureGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeatureGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FeatureGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeatureGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FeatureGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FeatureGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecProviderConfigRefPolicy(obj: FeatureGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FeatureGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface FeatureGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeatureGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeatureGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FeatureGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecPublishConnectionDetailsToConfigRef(obj: FeatureGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FeatureGroupSpecPublishConnectionDetailsToMetadata
 */
export interface FeatureGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FeatureGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FeatureGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FeatureGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecPublishConnectionDetailsToMetadata(obj: FeatureGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecForProviderOfflineStoreConfigDataCatalogConfig
 */
export interface FeatureGroupSpecForProviderOfflineStoreConfigDataCatalogConfig {
  /**
   * The name of the Glue table catalog.
   *
   * @schema FeatureGroupSpecForProviderOfflineStoreConfigDataCatalogConfig#catalog
   */
  readonly catalog?: string;

  /**
   * The name of the Glue table database.
   *
   * @schema FeatureGroupSpecForProviderOfflineStoreConfigDataCatalogConfig#database
   */
  readonly database?: string;

  /**
   * The name of the Glue table.
   *
   * @schema FeatureGroupSpecForProviderOfflineStoreConfigDataCatalogConfig#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecForProviderOfflineStoreConfigDataCatalogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProviderOfflineStoreConfigDataCatalogConfig(obj: FeatureGroupSpecForProviderOfflineStoreConfigDataCatalogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalog': obj.catalog,
    'database': obj.database,
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecForProviderOfflineStoreConfigS3StorageConfig
 */
export interface FeatureGroupSpecForProviderOfflineStoreConfigS3StorageConfig {
  /**
   * The AWS Key Management Service (KMS) key ID of the key used to encrypt any objects written into the OfflineStore S3 location.
   *
   * @schema FeatureGroupSpecForProviderOfflineStoreConfigS3StorageConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * The S3 URI, or location in Amazon S3, of OfflineStore.
   *
   * @schema FeatureGroupSpecForProviderOfflineStoreConfigS3StorageConfig#s3Uri
   */
  readonly s3Uri?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecForProviderOfflineStoreConfigS3StorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProviderOfflineStoreConfigS3StorageConfig(obj: FeatureGroupSpecForProviderOfflineStoreConfigS3StorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    's3Uri': obj.s3Uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecForProviderOnlineStoreConfigSecurityConfig
 */
export interface FeatureGroupSpecForProviderOnlineStoreConfigSecurityConfig {
  /**
   * The AWS Key Management Service (KMS) key ID of the key used to encrypt any objects written into the OfflineStore S3 location.
   *
   * @schema FeatureGroupSpecForProviderOnlineStoreConfigSecurityConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecForProviderOnlineStoreConfigSecurityConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProviderOnlineStoreConfigSecurityConfig(obj: FeatureGroupSpecForProviderOnlineStoreConfigSecurityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FeatureGroupSpecForProviderRoleArnRefPolicy
 */
export interface FeatureGroupSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeatureGroupSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: FeatureGroupSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeatureGroupSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: FeatureGroupSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FeatureGroupSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProviderRoleArnRefPolicy(obj: FeatureGroupSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FeatureGroupSpecForProviderRoleArnSelectorPolicy
 */
export interface FeatureGroupSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeatureGroupSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: FeatureGroupSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeatureGroupSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: FeatureGroupSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FeatureGroupSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecForProviderRoleArnSelectorPolicy(obj: FeatureGroupSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecInitProviderOfflineStoreConfigDataCatalogConfig
 */
export interface FeatureGroupSpecInitProviderOfflineStoreConfigDataCatalogConfig {
  /**
   * The name of the Glue table catalog.
   *
   * @schema FeatureGroupSpecInitProviderOfflineStoreConfigDataCatalogConfig#catalog
   */
  readonly catalog?: string;

  /**
   * The name of the Glue table database.
   *
   * @schema FeatureGroupSpecInitProviderOfflineStoreConfigDataCatalogConfig#database
   */
  readonly database?: string;

  /**
   * The name of the Glue table.
   *
   * @schema FeatureGroupSpecInitProviderOfflineStoreConfigDataCatalogConfig#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecInitProviderOfflineStoreConfigDataCatalogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecInitProviderOfflineStoreConfigDataCatalogConfig(obj: FeatureGroupSpecInitProviderOfflineStoreConfigDataCatalogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalog': obj.catalog,
    'database': obj.database,
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecInitProviderOfflineStoreConfigS3StorageConfig
 */
export interface FeatureGroupSpecInitProviderOfflineStoreConfigS3StorageConfig {
  /**
   * The AWS Key Management Service (KMS) key ID of the key used to encrypt any objects written into the OfflineStore S3 location.
   *
   * @schema FeatureGroupSpecInitProviderOfflineStoreConfigS3StorageConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * The S3 URI, or location in Amazon S3, of OfflineStore.
   *
   * @schema FeatureGroupSpecInitProviderOfflineStoreConfigS3StorageConfig#s3Uri
   */
  readonly s3Uri?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecInitProviderOfflineStoreConfigS3StorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecInitProviderOfflineStoreConfigS3StorageConfig(obj: FeatureGroupSpecInitProviderOfflineStoreConfigS3StorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    's3Uri': obj.s3Uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureGroupSpecInitProviderOnlineStoreConfigSecurityConfig
 */
export interface FeatureGroupSpecInitProviderOnlineStoreConfigSecurityConfig {
  /**
   * The AWS Key Management Service (KMS) key ID of the key used to encrypt any objects written into the OfflineStore S3 location.
   *
   * @schema FeatureGroupSpecInitProviderOnlineStoreConfigSecurityConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'FeatureGroupSpecInitProviderOnlineStoreConfigSecurityConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecInitProviderOnlineStoreConfigSecurityConfig(obj: FeatureGroupSpecInitProviderOnlineStoreConfigSecurityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeatureGroupSpecProviderConfigRefPolicyResolution
 */
export enum FeatureGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeatureGroupSpecProviderConfigRefPolicyResolve
 */
export enum FeatureGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeatureGroupSpecForProviderRoleArnRefPolicyResolution
 */
export enum FeatureGroupSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeatureGroupSpecForProviderRoleArnRefPolicyResolve
 */
export enum FeatureGroupSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeatureGroupSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum FeatureGroupSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeatureGroupSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum FeatureGroupSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FeatureGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Image is the Schema for the Images API. Provides a SageMaker Image resource.
 *
 * @schema Image
 */
export class Image extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Image"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'Image',
  }

  /**
   * Renders a Kubernetes manifest for "Image".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageProps): any {
    return {
      ...Image.GVK,
      ...toJson_ImageProps(props),
    };
  }

  /**
   * Defines a "Image" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageProps) {
    super(scope, id, {
      ...Image.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Image.GVK,
      ...toJson_ImageProps(resolved),
    };
  }
}

/**
 * Image is the Schema for the Images API. Provides a SageMaker Image resource.
 *
 * @schema Image
 */
export interface ImageProps {
  /**
   * @schema Image#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageSpec defines the desired state of Image
   *
   * @schema Image#spec
   */
  readonly spec: ImageSpec;

}

/**
 * Converts an object of type 'ImageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageProps(obj: ImageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageSpec defines the desired state of Image
 *
 * @schema ImageSpec
 */
export interface ImageSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ImageSpec#deletionPolicy
   */
  readonly deletionPolicy?: ImageSpecDeletionPolicy;

  /**
   * @schema ImageSpec#forProvider
   */
  readonly forProvider: ImageSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ImageSpec#initProvider
   */
  readonly initProvider?: ImageSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ImageSpec#managementPolicies
   */
  readonly managementPolicies?: ImageSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ImageSpec#providerConfigRef
   */
  readonly providerConfigRef?: ImageSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ImageSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ImageSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ImageSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ImageSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ImageSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpec(obj: ImageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ImageSpecForProvider(obj.forProvider),
    'initProvider': toJson_ImageSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ImageSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ImageSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ImageSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ImageSpecDeletionPolicy
 */
export enum ImageSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ImageSpecForProvider
 */
export interface ImageSpecForProvider {
  /**
   * The description of the image.
   *
   * @schema ImageSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The display name of the image. When the image is added to a domain (must be unique to the domain).
   *
   * @schema ImageSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ImageSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of an IAM role that enables Amazon SageMaker to perform tasks on your behalf.
   *
   * @schema ImageSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ImageSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ImageSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ImageSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ImageSpecForProviderRoleArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema ImageSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ImageSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProvider(obj: ImageSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ImageSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ImageSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ImageSpecInitProvider
 */
export interface ImageSpecInitProvider {
  /**
   * The description of the image.
   *
   * @schema ImageSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The display name of the image. When the image is added to a domain (must be unique to the domain).
   *
   * @schema ImageSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ImageSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ImageSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecInitProvider(obj: ImageSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ImageSpecManagementPolicies
 */
export enum ImageSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ImageSpecProviderConfigRef
 */
export interface ImageSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageSpecProviderConfigRef#policy
   */
  readonly policy?: ImageSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ImageSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecProviderConfigRef(obj: ImageSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ImageSpecPublishConnectionDetailsTo
 */
export interface ImageSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ImageSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ImageSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ImageSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ImageSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ImageSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImageSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecPublishConnectionDetailsTo(obj: ImageSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ImageSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ImageSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ImageSpecWriteConnectionSecretToRef
 */
export interface ImageSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ImageSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ImageSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ImageSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecWriteConnectionSecretToRef(obj: ImageSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ImageSpecForProviderRoleArnRef
 */
export interface ImageSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ImageSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ImageSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderRoleArnRef(obj: ImageSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ImageSpecForProviderRoleArnSelector
 */
export interface ImageSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ImageSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ImageSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ImageSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ImageSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ImageSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderRoleArnSelector(obj: ImageSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ImageSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageSpecProviderConfigRefPolicy
 */
export interface ImageSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ImageSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ImageSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecProviderConfigRefPolicy(obj: ImageSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ImageSpecPublishConnectionDetailsToConfigRef
 */
export interface ImageSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ImageSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ImageSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecPublishConnectionDetailsToConfigRef(obj: ImageSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ImageSpecPublishConnectionDetailsToMetadata
 */
export interface ImageSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImageSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImageSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ImageSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ImageSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecPublishConnectionDetailsToMetadata(obj: ImageSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageSpecForProviderRoleArnRefPolicy
 */
export interface ImageSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ImageSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ImageSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderRoleArnRefPolicy(obj: ImageSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ImageSpecForProviderRoleArnSelectorPolicy
 */
export interface ImageSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ImageSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ImageSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderRoleArnSelectorPolicy(obj: ImageSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecProviderConfigRefPolicyResolution
 */
export enum ImageSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecProviderConfigRefPolicyResolve
 */
export enum ImageSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ImageSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ImageSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ImageSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ImageSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecPublishConnectionDetailsToConfigRefPolicy(obj: ImageSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecForProviderRoleArnRefPolicyResolution
 */
export enum ImageSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecForProviderRoleArnRefPolicyResolve
 */
export enum ImageSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ImageSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ImageSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ImageSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ImageSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ImageVersion is the Schema for the ImageVersions API. Provides a SageMaker Image Version resource.
 *
 * @schema ImageVersion
 */
export class ImageVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImageVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'ImageVersion',
  }

  /**
   * Renders a Kubernetes manifest for "ImageVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageVersionProps): any {
    return {
      ...ImageVersion.GVK,
      ...toJson_ImageVersionProps(props),
    };
  }

  /**
   * Defines a "ImageVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageVersionProps) {
    super(scope, id, {
      ...ImageVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImageVersion.GVK,
      ...toJson_ImageVersionProps(resolved),
    };
  }
}

/**
 * ImageVersion is the Schema for the ImageVersions API. Provides a SageMaker Image Version resource.
 *
 * @schema ImageVersion
 */
export interface ImageVersionProps {
  /**
   * @schema ImageVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageVersionSpec defines the desired state of ImageVersion
   *
   * @schema ImageVersion#spec
   */
  readonly spec: ImageVersionSpec;

}

/**
 * Converts an object of type 'ImageVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionProps(obj: ImageVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageVersionSpec defines the desired state of ImageVersion
 *
 * @schema ImageVersionSpec
 */
export interface ImageVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ImageVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ImageVersionSpecDeletionPolicy;

  /**
   * @schema ImageVersionSpec#forProvider
   */
  readonly forProvider: ImageVersionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ImageVersionSpec#initProvider
   */
  readonly initProvider?: ImageVersionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ImageVersionSpec#managementPolicies
   */
  readonly managementPolicies?: ImageVersionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ImageVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ImageVersionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ImageVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ImageVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ImageVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ImageVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ImageVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpec(obj: ImageVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ImageVersionSpecForProvider(obj.forProvider),
    'initProvider': toJson_ImageVersionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ImageVersionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ImageVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ImageVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ImageVersionSpecDeletionPolicy
 */
export enum ImageVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ImageVersionSpecForProvider
 */
export interface ImageVersionSpecForProvider {
  /**
   * The registry path of the container image on which this image version is based.
   *
   * @schema ImageVersionSpecForProvider#baseImage
   */
  readonly baseImage?: string;

  /**
   * The name of the image. Must be unique to your account.
   *
   * @schema ImageVersionSpecForProvider#imageName
   */
  readonly imageName?: string;

  /**
   * Reference to a Image in sagemaker to populate imageName.
   *
   * @schema ImageVersionSpecForProvider#imageNameRef
   */
  readonly imageNameRef?: ImageVersionSpecForProviderImageNameRef;

  /**
   * Selector for a Image in sagemaker to populate imageName.
   *
   * @schema ImageVersionSpecForProvider#imageNameSelector
   */
  readonly imageNameSelector?: ImageVersionSpecForProviderImageNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ImageVersionSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ImageVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecForProvider(obj: ImageVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseImage': obj.baseImage,
    'imageName': obj.imageName,
    'imageNameRef': toJson_ImageVersionSpecForProviderImageNameRef(obj.imageNameRef),
    'imageNameSelector': toJson_ImageVersionSpecForProviderImageNameSelector(obj.imageNameSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ImageVersionSpecInitProvider
 */
export interface ImageVersionSpecInitProvider {
  /**
   * The registry path of the container image on which this image version is based.
   *
   * @schema ImageVersionSpecInitProvider#baseImage
   */
  readonly baseImage?: string;

}

/**
 * Converts an object of type 'ImageVersionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecInitProvider(obj: ImageVersionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseImage': obj.baseImage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ImageVersionSpecManagementPolicies
 */
export enum ImageVersionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ImageVersionSpecProviderConfigRef
 */
export interface ImageVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageVersionSpecProviderConfigRef#policy
   */
  readonly policy?: ImageVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ImageVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecProviderConfigRef(obj: ImageVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ImageVersionSpecPublishConnectionDetailsTo
 */
export interface ImageVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ImageVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ImageVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ImageVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ImageVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ImageVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImageVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecPublishConnectionDetailsTo(obj: ImageVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ImageVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ImageVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ImageVersionSpecWriteConnectionSecretToRef
 */
export interface ImageVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ImageVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ImageVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ImageVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecWriteConnectionSecretToRef(obj: ImageVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Image in sagemaker to populate imageName.
 *
 * @schema ImageVersionSpecForProviderImageNameRef
 */
export interface ImageVersionSpecForProviderImageNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageVersionSpecForProviderImageNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageVersionSpecForProviderImageNameRef#policy
   */
  readonly policy?: ImageVersionSpecForProviderImageNameRefPolicy;

}

/**
 * Converts an object of type 'ImageVersionSpecForProviderImageNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecForProviderImageNameRef(obj: ImageVersionSpecForProviderImageNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageVersionSpecForProviderImageNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Image in sagemaker to populate imageName.
 *
 * @schema ImageVersionSpecForProviderImageNameSelector
 */
export interface ImageVersionSpecForProviderImageNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ImageVersionSpecForProviderImageNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ImageVersionSpecForProviderImageNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ImageVersionSpecForProviderImageNameSelector#policy
   */
  readonly policy?: ImageVersionSpecForProviderImageNameSelectorPolicy;

}

/**
 * Converts an object of type 'ImageVersionSpecForProviderImageNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecForProviderImageNameSelector(obj: ImageVersionSpecForProviderImageNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ImageVersionSpecForProviderImageNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageVersionSpecProviderConfigRefPolicy
 */
export interface ImageVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ImageVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ImageVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecProviderConfigRefPolicy(obj: ImageVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ImageVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface ImageVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ImageVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ImageVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecPublishConnectionDetailsToConfigRef(obj: ImageVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ImageVersionSpecPublishConnectionDetailsToMetadata
 */
export interface ImageVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImageVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImageVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ImageVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ImageVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecPublishConnectionDetailsToMetadata(obj: ImageVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageVersionSpecForProviderImageNameRefPolicy
 */
export interface ImageVersionSpecForProviderImageNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageVersionSpecForProviderImageNameRefPolicy#resolution
   */
  readonly resolution?: ImageVersionSpecForProviderImageNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageVersionSpecForProviderImageNameRefPolicy#resolve
   */
  readonly resolve?: ImageVersionSpecForProviderImageNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageVersionSpecForProviderImageNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecForProviderImageNameRefPolicy(obj: ImageVersionSpecForProviderImageNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ImageVersionSpecForProviderImageNameSelectorPolicy
 */
export interface ImageVersionSpecForProviderImageNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageVersionSpecForProviderImageNameSelectorPolicy#resolution
   */
  readonly resolution?: ImageVersionSpecForProviderImageNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageVersionSpecForProviderImageNameSelectorPolicy#resolve
   */
  readonly resolve?: ImageVersionSpecForProviderImageNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ImageVersionSpecForProviderImageNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecForProviderImageNameSelectorPolicy(obj: ImageVersionSpecForProviderImageNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageVersionSpecProviderConfigRefPolicyResolution
 */
export enum ImageVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageVersionSpecProviderConfigRefPolicyResolve
 */
export enum ImageVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ImageVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ImageVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ImageVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ImageVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ImageVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageVersionSpecForProviderImageNameRefPolicyResolution
 */
export enum ImageVersionSpecForProviderImageNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageVersionSpecForProviderImageNameRefPolicyResolve
 */
export enum ImageVersionSpecForProviderImageNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageVersionSpecForProviderImageNameSelectorPolicyResolution
 */
export enum ImageVersionSpecForProviderImageNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageVersionSpecForProviderImageNameSelectorPolicyResolve
 */
export enum ImageVersionSpecForProviderImageNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ImageVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ImageVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Model is the Schema for the Models API. Provides a SageMaker model resource.
 *
 * @schema Model
 */
export class Model extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Model"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'Model',
  }

  /**
   * Renders a Kubernetes manifest for "Model".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ModelProps): any {
    return {
      ...Model.GVK,
      ...toJson_ModelProps(props),
    };
  }

  /**
   * Defines a "Model" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ModelProps) {
    super(scope, id, {
      ...Model.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Model.GVK,
      ...toJson_ModelProps(resolved),
    };
  }
}

/**
 * Model is the Schema for the Models API. Provides a SageMaker model resource.
 *
 * @schema Model
 */
export interface ModelProps {
  /**
   * @schema Model#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ModelSpec defines the desired state of Model
   *
   * @schema Model#spec
   */
  readonly spec: ModelSpec;

}

/**
 * Converts an object of type 'ModelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelProps(obj: ModelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ModelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ModelSpec defines the desired state of Model
 *
 * @schema ModelSpec
 */
export interface ModelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ModelSpec#deletionPolicy
   */
  readonly deletionPolicy?: ModelSpecDeletionPolicy;

  /**
   * @schema ModelSpec#forProvider
   */
  readonly forProvider: ModelSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ModelSpec#initProvider
   */
  readonly initProvider?: ModelSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ModelSpec#managementPolicies
   */
  readonly managementPolicies?: ModelSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ModelSpec#providerConfigRef
   */
  readonly providerConfigRef?: ModelSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ModelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ModelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ModelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ModelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ModelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpec(obj: ModelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ModelSpecForProvider(obj.forProvider),
    'initProvider': toJson_ModelSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ModelSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ModelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ModelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ModelSpecDeletionPolicy
 */
export enum ModelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ModelSpecForProvider
 */
export interface ModelSpecForProvider {
  /**
   * Specifies containers in the inference pipeline. If not specified, the primary_container argument is required. Fields are documented below.
   *
   * @schema ModelSpecForProvider#container
   */
  readonly container?: ModelSpecForProviderContainer[];

  /**
   * Isolates the model container. No inbound or outbound network calls can be made to or from the model container.
   *
   * @schema ModelSpecForProvider#enableNetworkIsolation
   */
  readonly enableNetworkIsolation?: boolean;

  /**
   * A role that SageMaker can assume to access model artifacts and docker images for deployment.
   *
   * @schema ModelSpecForProvider#executionRoleArn
   */
  readonly executionRoleArn?: string;

  /**
   * Reference to a Role in iam to populate executionRoleArn.
   *
   * @schema ModelSpecForProvider#executionRoleArnRef
   */
  readonly executionRoleArnRef?: ModelSpecForProviderExecutionRoleArnRef;

  /**
   * Selector for a Role in iam to populate executionRoleArn.
   *
   * @schema ModelSpecForProvider#executionRoleArnSelector
   */
  readonly executionRoleArnSelector?: ModelSpecForProviderExecutionRoleArnSelector;

  /**
   * Specifies details of how containers in a multi-container endpoint are called. see Inference Execution Config.
   *
   * @schema ModelSpecForProvider#inferenceExecutionConfig
   */
  readonly inferenceExecutionConfig?: ModelSpecForProviderInferenceExecutionConfig[];

  /**
   * The primary docker image containing inference code that is used when the model is deployed for predictions.  If not specified, the container argument is required. Fields are documented below.
   *
   * @schema ModelSpecForProvider#primaryContainer
   */
  readonly primaryContainer?: ModelSpecForProviderPrimaryContainer[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ModelSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ModelSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Specifies the VPC that you want your model to connect to. VpcConfig is used in hosting services and in batch transform.
   *
   * @schema ModelSpecForProvider#vpcConfig
   */
  readonly vpcConfig?: ModelSpecForProviderVpcConfig[];

}

/**
 * Converts an object of type 'ModelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProvider(obj: ModelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container?.map(y => toJson_ModelSpecForProviderContainer(y)),
    'enableNetworkIsolation': obj.enableNetworkIsolation,
    'executionRoleArn': obj.executionRoleArn,
    'executionRoleArnRef': toJson_ModelSpecForProviderExecutionRoleArnRef(obj.executionRoleArnRef),
    'executionRoleArnSelector': toJson_ModelSpecForProviderExecutionRoleArnSelector(obj.executionRoleArnSelector),
    'inferenceExecutionConfig': obj.inferenceExecutionConfig?.map(y => toJson_ModelSpecForProviderInferenceExecutionConfig(y)),
    'primaryContainer': obj.primaryContainer?.map(y => toJson_ModelSpecForProviderPrimaryContainer(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcConfig': obj.vpcConfig?.map(y => toJson_ModelSpecForProviderVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ModelSpecInitProvider
 */
export interface ModelSpecInitProvider {
  /**
   * Specifies containers in the inference pipeline. If not specified, the primary_container argument is required. Fields are documented below.
   *
   * @schema ModelSpecInitProvider#container
   */
  readonly container?: ModelSpecInitProviderContainer[];

  /**
   * Isolates the model container. No inbound or outbound network calls can be made to or from the model container.
   *
   * @schema ModelSpecInitProvider#enableNetworkIsolation
   */
  readonly enableNetworkIsolation?: boolean;

  /**
   * Specifies details of how containers in a multi-container endpoint are called. see Inference Execution Config.
   *
   * @schema ModelSpecInitProvider#inferenceExecutionConfig
   */
  readonly inferenceExecutionConfig?: ModelSpecInitProviderInferenceExecutionConfig[];

  /**
   * The primary docker image containing inference code that is used when the model is deployed for predictions.  If not specified, the container argument is required. Fields are documented below.
   *
   * @schema ModelSpecInitProvider#primaryContainer
   */
  readonly primaryContainer?: ModelSpecInitProviderPrimaryContainer[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ModelSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Specifies the VPC that you want your model to connect to. VpcConfig is used in hosting services and in batch transform.
   *
   * @schema ModelSpecInitProvider#vpcConfig
   */
  readonly vpcConfig?: ModelSpecInitProviderVpcConfig[];

}

/**
 * Converts an object of type 'ModelSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecInitProvider(obj: ModelSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container?.map(y => toJson_ModelSpecInitProviderContainer(y)),
    'enableNetworkIsolation': obj.enableNetworkIsolation,
    'inferenceExecutionConfig': obj.inferenceExecutionConfig?.map(y => toJson_ModelSpecInitProviderInferenceExecutionConfig(y)),
    'primaryContainer': obj.primaryContainer?.map(y => toJson_ModelSpecInitProviderPrimaryContainer(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcConfig': obj.vpcConfig?.map(y => toJson_ModelSpecInitProviderVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ModelSpecManagementPolicies
 */
export enum ModelSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ModelSpecProviderConfigRef
 */
export interface ModelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecProviderConfigRef#policy
   */
  readonly policy?: ModelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderConfigRef(obj: ModelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ModelSpecPublishConnectionDetailsTo
 */
export interface ModelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ModelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ModelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsTo(obj: ModelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ModelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ModelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ModelSpecWriteConnectionSecretToRef
 */
export interface ModelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ModelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ModelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ModelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecWriteConnectionSecretToRef(obj: ModelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecForProviderContainer
 */
export interface ModelSpecForProviderContainer {
  /**
   * The DNS host name for the container.
   *
   * @schema ModelSpecForProviderContainer#containerHostname
   */
  readonly containerHostname?: string;

  /**
   * Environment variables for the Docker container. A list of key value pairs.
   *
   * @schema ModelSpecForProviderContainer#environment
   */
  readonly environment?: { [key: string]: string };

  /**
   * The registry path where the inference code image is stored in Amazon ECR.
   *
   * @schema ModelSpecForProviderContainer#image
   */
  readonly image?: string;

  /**
   * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For more information see Using a Private Docker Registry for Real-Time Inference Containers. see Image Config.
   *
   * @schema ModelSpecForProviderContainer#imageConfig
   */
  readonly imageConfig?: ModelSpecForProviderContainerImageConfig[];

  /**
   * The container hosts value SingleModel/MultiModel. The default value is SingleModel.
   *
   * @schema ModelSpecForProviderContainer#mode
   */
  readonly mode?: string;

  /**
   * The URL for the S3 location where model artifacts are stored.
   *
   * @schema ModelSpecForProviderContainer#modelDataUrl
   */
  readonly modelDataUrl?: string;

}

/**
 * Converts an object of type 'ModelSpecForProviderContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderContainer(obj: ModelSpecForProviderContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerHostname': obj.containerHostname,
    'environment': ((obj.environment) === undefined) ? undefined : (Object.entries(obj.environment).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'image': obj.image,
    'imageConfig': obj.imageConfig?.map(y => toJson_ModelSpecForProviderContainerImageConfig(y)),
    'mode': obj.mode,
    'modelDataUrl': obj.modelDataUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate executionRoleArn.
 *
 * @schema ModelSpecForProviderExecutionRoleArnRef
 */
export interface ModelSpecForProviderExecutionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecForProviderExecutionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecForProviderExecutionRoleArnRef#policy
   */
  readonly policy?: ModelSpecForProviderExecutionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecForProviderExecutionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderExecutionRoleArnRef(obj: ModelSpecForProviderExecutionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecForProviderExecutionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate executionRoleArn.
 *
 * @schema ModelSpecForProviderExecutionRoleArnSelector
 */
export interface ModelSpecForProviderExecutionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ModelSpecForProviderExecutionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ModelSpecForProviderExecutionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ModelSpecForProviderExecutionRoleArnSelector#policy
   */
  readonly policy?: ModelSpecForProviderExecutionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ModelSpecForProviderExecutionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderExecutionRoleArnSelector(obj: ModelSpecForProviderExecutionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ModelSpecForProviderExecutionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecForProviderInferenceExecutionConfig
 */
export interface ModelSpecForProviderInferenceExecutionConfig {
  /**
   * The container hosts value SingleModel/MultiModel. The default value is SingleModel.
   *
   * @schema ModelSpecForProviderInferenceExecutionConfig#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'ModelSpecForProviderInferenceExecutionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderInferenceExecutionConfig(obj: ModelSpecForProviderInferenceExecutionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecForProviderPrimaryContainer
 */
export interface ModelSpecForProviderPrimaryContainer {
  /**
   * The DNS host name for the container.
   *
   * @schema ModelSpecForProviderPrimaryContainer#containerHostname
   */
  readonly containerHostname?: string;

  /**
   * Environment variables for the Docker container. A list of key value pairs.
   *
   * @schema ModelSpecForProviderPrimaryContainer#environment
   */
  readonly environment?: { [key: string]: string };

  /**
   * The registry path where the inference code image is stored in Amazon ECR.
   *
   * @schema ModelSpecForProviderPrimaryContainer#image
   */
  readonly image?: string;

  /**
   * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For more information see Using a Private Docker Registry for Real-Time Inference Containers. see Image Config.
   *
   * @schema ModelSpecForProviderPrimaryContainer#imageConfig
   */
  readonly imageConfig?: ModelSpecForProviderPrimaryContainerImageConfig[];

  /**
   * The container hosts value SingleModel/MultiModel. The default value is SingleModel.
   *
   * @schema ModelSpecForProviderPrimaryContainer#mode
   */
  readonly mode?: string;

  /**
   * The URL for the S3 location where model artifacts are stored.
   *
   * @schema ModelSpecForProviderPrimaryContainer#modelDataUrl
   */
  readonly modelDataUrl?: string;

}

/**
 * Converts an object of type 'ModelSpecForProviderPrimaryContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderPrimaryContainer(obj: ModelSpecForProviderPrimaryContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerHostname': obj.containerHostname,
    'environment': ((obj.environment) === undefined) ? undefined : (Object.entries(obj.environment).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'image': obj.image,
    'imageConfig': obj.imageConfig?.map(y => toJson_ModelSpecForProviderPrimaryContainerImageConfig(y)),
    'mode': obj.mode,
    'modelDataUrl': obj.modelDataUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecForProviderVpcConfig
 */
export interface ModelSpecForProviderVpcConfig {
  /**
   * @schema ModelSpecForProviderVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * @schema ModelSpecForProviderVpcConfig#subnets
   */
  readonly subnets?: string[];

}

/**
 * Converts an object of type 'ModelSpecForProviderVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderVpcConfig(obj: ModelSpecForProviderVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnets': obj.subnets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecInitProviderContainer
 */
export interface ModelSpecInitProviderContainer {
  /**
   * The DNS host name for the container.
   *
   * @schema ModelSpecInitProviderContainer#containerHostname
   */
  readonly containerHostname?: string;

  /**
   * Environment variables for the Docker container. A list of key value pairs.
   *
   * @schema ModelSpecInitProviderContainer#environment
   */
  readonly environment?: { [key: string]: string };

  /**
   * The registry path where the inference code image is stored in Amazon ECR.
   *
   * @schema ModelSpecInitProviderContainer#image
   */
  readonly image?: string;

  /**
   * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For more information see Using a Private Docker Registry for Real-Time Inference Containers. see Image Config.
   *
   * @schema ModelSpecInitProviderContainer#imageConfig
   */
  readonly imageConfig?: ModelSpecInitProviderContainerImageConfig[];

  /**
   * The container hosts value SingleModel/MultiModel. The default value is SingleModel.
   *
   * @schema ModelSpecInitProviderContainer#mode
   */
  readonly mode?: string;

  /**
   * The URL for the S3 location where model artifacts are stored.
   *
   * @schema ModelSpecInitProviderContainer#modelDataUrl
   */
  readonly modelDataUrl?: string;

}

/**
 * Converts an object of type 'ModelSpecInitProviderContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecInitProviderContainer(obj: ModelSpecInitProviderContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerHostname': obj.containerHostname,
    'environment': ((obj.environment) === undefined) ? undefined : (Object.entries(obj.environment).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'image': obj.image,
    'imageConfig': obj.imageConfig?.map(y => toJson_ModelSpecInitProviderContainerImageConfig(y)),
    'mode': obj.mode,
    'modelDataUrl': obj.modelDataUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecInitProviderInferenceExecutionConfig
 */
export interface ModelSpecInitProviderInferenceExecutionConfig {
  /**
   * The container hosts value SingleModel/MultiModel. The default value is SingleModel.
   *
   * @schema ModelSpecInitProviderInferenceExecutionConfig#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'ModelSpecInitProviderInferenceExecutionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecInitProviderInferenceExecutionConfig(obj: ModelSpecInitProviderInferenceExecutionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecInitProviderPrimaryContainer
 */
export interface ModelSpecInitProviderPrimaryContainer {
  /**
   * The DNS host name for the container.
   *
   * @schema ModelSpecInitProviderPrimaryContainer#containerHostname
   */
  readonly containerHostname?: string;

  /**
   * Environment variables for the Docker container. A list of key value pairs.
   *
   * @schema ModelSpecInitProviderPrimaryContainer#environment
   */
  readonly environment?: { [key: string]: string };

  /**
   * The registry path where the inference code image is stored in Amazon ECR.
   *
   * @schema ModelSpecInitProviderPrimaryContainer#image
   */
  readonly image?: string;

  /**
   * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For more information see Using a Private Docker Registry for Real-Time Inference Containers. see Image Config.
   *
   * @schema ModelSpecInitProviderPrimaryContainer#imageConfig
   */
  readonly imageConfig?: ModelSpecInitProviderPrimaryContainerImageConfig[];

  /**
   * The container hosts value SingleModel/MultiModel. The default value is SingleModel.
   *
   * @schema ModelSpecInitProviderPrimaryContainer#mode
   */
  readonly mode?: string;

  /**
   * The URL for the S3 location where model artifacts are stored.
   *
   * @schema ModelSpecInitProviderPrimaryContainer#modelDataUrl
   */
  readonly modelDataUrl?: string;

}

/**
 * Converts an object of type 'ModelSpecInitProviderPrimaryContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecInitProviderPrimaryContainer(obj: ModelSpecInitProviderPrimaryContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerHostname': obj.containerHostname,
    'environment': ((obj.environment) === undefined) ? undefined : (Object.entries(obj.environment).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'image': obj.image,
    'imageConfig': obj.imageConfig?.map(y => toJson_ModelSpecInitProviderPrimaryContainerImageConfig(y)),
    'mode': obj.mode,
    'modelDataUrl': obj.modelDataUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecInitProviderVpcConfig
 */
export interface ModelSpecInitProviderVpcConfig {
  /**
   * @schema ModelSpecInitProviderVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * @schema ModelSpecInitProviderVpcConfig#subnets
   */
  readonly subnets?: string[];

}

/**
 * Converts an object of type 'ModelSpecInitProviderVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecInitProviderVpcConfig(obj: ModelSpecInitProviderVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnets': obj.subnets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecProviderConfigRefPolicy
 */
export interface ModelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ModelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ModelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderConfigRefPolicy(obj: ModelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRef
 */
export interface ModelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ModelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToConfigRef(obj: ModelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ModelSpecPublishConnectionDetailsToMetadata
 */
export interface ModelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToMetadata(obj: ModelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecForProviderContainerImageConfig
 */
export interface ModelSpecForProviderContainerImageConfig {
  /**
   * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). Allowed values are: Platform and Vpc.
   *
   * @schema ModelSpecForProviderContainerImageConfig#repositoryAccessMode
   */
  readonly repositoryAccessMode?: string;

  /**
   * Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified Vpc as the value for the RepositoryAccessMode field, and the private Docker registry where the model image is hosted requires authentication. see Repository Auth Config.
   *
   * @schema ModelSpecForProviderContainerImageConfig#repositoryAuthConfig
   */
  readonly repositoryAuthConfig?: ModelSpecForProviderContainerImageConfigRepositoryAuthConfig[];

}

/**
 * Converts an object of type 'ModelSpecForProviderContainerImageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderContainerImageConfig(obj: ModelSpecForProviderContainerImageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryAccessMode': obj.repositoryAccessMode,
    'repositoryAuthConfig': obj.repositoryAuthConfig?.map(y => toJson_ModelSpecForProviderContainerImageConfigRepositoryAuthConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecForProviderExecutionRoleArnRefPolicy
 */
export interface ModelSpecForProviderExecutionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecForProviderExecutionRoleArnRefPolicy#resolution
   */
  readonly resolution?: ModelSpecForProviderExecutionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecForProviderExecutionRoleArnRefPolicy#resolve
   */
  readonly resolve?: ModelSpecForProviderExecutionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecForProviderExecutionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderExecutionRoleArnRefPolicy(obj: ModelSpecForProviderExecutionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ModelSpecForProviderExecutionRoleArnSelectorPolicy
 */
export interface ModelSpecForProviderExecutionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecForProviderExecutionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ModelSpecForProviderExecutionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecForProviderExecutionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ModelSpecForProviderExecutionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecForProviderExecutionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderExecutionRoleArnSelectorPolicy(obj: ModelSpecForProviderExecutionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecForProviderPrimaryContainerImageConfig
 */
export interface ModelSpecForProviderPrimaryContainerImageConfig {
  /**
   * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). Allowed values are: Platform and Vpc.
   *
   * @schema ModelSpecForProviderPrimaryContainerImageConfig#repositoryAccessMode
   */
  readonly repositoryAccessMode?: string;

  /**
   * Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified Vpc as the value for the RepositoryAccessMode field, and the private Docker registry where the model image is hosted requires authentication. see Repository Auth Config.
   *
   * @schema ModelSpecForProviderPrimaryContainerImageConfig#repositoryAuthConfig
   */
  readonly repositoryAuthConfig?: ModelSpecForProviderPrimaryContainerImageConfigRepositoryAuthConfig[];

}

/**
 * Converts an object of type 'ModelSpecForProviderPrimaryContainerImageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderPrimaryContainerImageConfig(obj: ModelSpecForProviderPrimaryContainerImageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryAccessMode': obj.repositoryAccessMode,
    'repositoryAuthConfig': obj.repositoryAuthConfig?.map(y => toJson_ModelSpecForProviderPrimaryContainerImageConfigRepositoryAuthConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecInitProviderContainerImageConfig
 */
export interface ModelSpecInitProviderContainerImageConfig {
  /**
   * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). Allowed values are: Platform and Vpc.
   *
   * @schema ModelSpecInitProviderContainerImageConfig#repositoryAccessMode
   */
  readonly repositoryAccessMode?: string;

  /**
   * Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified Vpc as the value for the RepositoryAccessMode field, and the private Docker registry where the model image is hosted requires authentication. see Repository Auth Config.
   *
   * @schema ModelSpecInitProviderContainerImageConfig#repositoryAuthConfig
   */
  readonly repositoryAuthConfig?: ModelSpecInitProviderContainerImageConfigRepositoryAuthConfig[];

}

/**
 * Converts an object of type 'ModelSpecInitProviderContainerImageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecInitProviderContainerImageConfig(obj: ModelSpecInitProviderContainerImageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryAccessMode': obj.repositoryAccessMode,
    'repositoryAuthConfig': obj.repositoryAuthConfig?.map(y => toJson_ModelSpecInitProviderContainerImageConfigRepositoryAuthConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecInitProviderPrimaryContainerImageConfig
 */
export interface ModelSpecInitProviderPrimaryContainerImageConfig {
  /**
   * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). Allowed values are: Platform and Vpc.
   *
   * @schema ModelSpecInitProviderPrimaryContainerImageConfig#repositoryAccessMode
   */
  readonly repositoryAccessMode?: string;

  /**
   * Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified Vpc as the value for the RepositoryAccessMode field, and the private Docker registry where the model image is hosted requires authentication. see Repository Auth Config.
   *
   * @schema ModelSpecInitProviderPrimaryContainerImageConfig#repositoryAuthConfig
   */
  readonly repositoryAuthConfig?: ModelSpecInitProviderPrimaryContainerImageConfigRepositoryAuthConfig[];

}

/**
 * Converts an object of type 'ModelSpecInitProviderPrimaryContainerImageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecInitProviderPrimaryContainerImageConfig(obj: ModelSpecInitProviderPrimaryContainerImageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryAccessMode': obj.repositoryAccessMode,
    'repositoryAuthConfig': obj.repositoryAuthConfig?.map(y => toJson_ModelSpecInitProviderPrimaryContainerImageConfigRepositoryAuthConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecProviderConfigRefPolicyResolution
 */
export enum ModelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecProviderConfigRefPolicyResolve
 */
export enum ModelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ModelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToConfigRefPolicy(obj: ModelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecForProviderContainerImageConfigRepositoryAuthConfig
 */
export interface ModelSpecForProviderContainerImageConfigRepositoryAuthConfig {
  /**
   * The Amazon Resource Name (ARN) of an AWS Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an AWS Lambda function, see Create a Lambda function with the console in the AWS Lambda Developer Guide.
   *
   * @schema ModelSpecForProviderContainerImageConfigRepositoryAuthConfig#repositoryCredentialsProviderArn
   */
  readonly repositoryCredentialsProviderArn?: string;

}

/**
 * Converts an object of type 'ModelSpecForProviderContainerImageConfigRepositoryAuthConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderContainerImageConfigRepositoryAuthConfig(obj: ModelSpecForProviderContainerImageConfigRepositoryAuthConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryCredentialsProviderArn': obj.repositoryCredentialsProviderArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecForProviderExecutionRoleArnRefPolicyResolution
 */
export enum ModelSpecForProviderExecutionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecForProviderExecutionRoleArnRefPolicyResolve
 */
export enum ModelSpecForProviderExecutionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecForProviderExecutionRoleArnSelectorPolicyResolution
 */
export enum ModelSpecForProviderExecutionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecForProviderExecutionRoleArnSelectorPolicyResolve
 */
export enum ModelSpecForProviderExecutionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ModelSpecForProviderPrimaryContainerImageConfigRepositoryAuthConfig
 */
export interface ModelSpecForProviderPrimaryContainerImageConfigRepositoryAuthConfig {
  /**
   * The Amazon Resource Name (ARN) of an AWS Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an AWS Lambda function, see Create a Lambda function with the console in the AWS Lambda Developer Guide.
   *
   * @schema ModelSpecForProviderPrimaryContainerImageConfigRepositoryAuthConfig#repositoryCredentialsProviderArn
   */
  readonly repositoryCredentialsProviderArn?: string;

}

/**
 * Converts an object of type 'ModelSpecForProviderPrimaryContainerImageConfigRepositoryAuthConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderPrimaryContainerImageConfigRepositoryAuthConfig(obj: ModelSpecForProviderPrimaryContainerImageConfigRepositoryAuthConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryCredentialsProviderArn': obj.repositoryCredentialsProviderArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecInitProviderContainerImageConfigRepositoryAuthConfig
 */
export interface ModelSpecInitProviderContainerImageConfigRepositoryAuthConfig {
  /**
   * The Amazon Resource Name (ARN) of an AWS Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an AWS Lambda function, see Create a Lambda function with the console in the AWS Lambda Developer Guide.
   *
   * @schema ModelSpecInitProviderContainerImageConfigRepositoryAuthConfig#repositoryCredentialsProviderArn
   */
  readonly repositoryCredentialsProviderArn?: string;

}

/**
 * Converts an object of type 'ModelSpecInitProviderContainerImageConfigRepositoryAuthConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecInitProviderContainerImageConfigRepositoryAuthConfig(obj: ModelSpecInitProviderContainerImageConfigRepositoryAuthConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryCredentialsProviderArn': obj.repositoryCredentialsProviderArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ModelSpecInitProviderPrimaryContainerImageConfigRepositoryAuthConfig
 */
export interface ModelSpecInitProviderPrimaryContainerImageConfigRepositoryAuthConfig {
  /**
   * The Amazon Resource Name (ARN) of an AWS Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an AWS Lambda function, see Create a Lambda function with the console in the AWS Lambda Developer Guide.
   *
   * @schema ModelSpecInitProviderPrimaryContainerImageConfigRepositoryAuthConfig#repositoryCredentialsProviderArn
   */
  readonly repositoryCredentialsProviderArn?: string;

}

/**
 * Converts an object of type 'ModelSpecInitProviderPrimaryContainerImageConfigRepositoryAuthConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecInitProviderPrimaryContainerImageConfigRepositoryAuthConfig(obj: ModelSpecInitProviderPrimaryContainerImageConfigRepositoryAuthConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryCredentialsProviderArn': obj.repositoryCredentialsProviderArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ModelPackageGroup is the Schema for the ModelPackageGroups API. Provides a SageMaker Model Package Group resource.
 *
 * @schema ModelPackageGroup
 */
export class ModelPackageGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ModelPackageGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'ModelPackageGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ModelPackageGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ModelPackageGroupProps): any {
    return {
      ...ModelPackageGroup.GVK,
      ...toJson_ModelPackageGroupProps(props),
    };
  }

  /**
   * Defines a "ModelPackageGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ModelPackageGroupProps) {
    super(scope, id, {
      ...ModelPackageGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ModelPackageGroup.GVK,
      ...toJson_ModelPackageGroupProps(resolved),
    };
  }
}

/**
 * ModelPackageGroup is the Schema for the ModelPackageGroups API. Provides a SageMaker Model Package Group resource.
 *
 * @schema ModelPackageGroup
 */
export interface ModelPackageGroupProps {
  /**
   * @schema ModelPackageGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ModelPackageGroupSpec defines the desired state of ModelPackageGroup
   *
   * @schema ModelPackageGroup#spec
   */
  readonly spec: ModelPackageGroupSpec;

}

/**
 * Converts an object of type 'ModelPackageGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupProps(obj: ModelPackageGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ModelPackageGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ModelPackageGroupSpec defines the desired state of ModelPackageGroup
 *
 * @schema ModelPackageGroupSpec
 */
export interface ModelPackageGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ModelPackageGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ModelPackageGroupSpecDeletionPolicy;

  /**
   * @schema ModelPackageGroupSpec#forProvider
   */
  readonly forProvider: ModelPackageGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ModelPackageGroupSpec#initProvider
   */
  readonly initProvider?: ModelPackageGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ModelPackageGroupSpec#managementPolicies
   */
  readonly managementPolicies?: ModelPackageGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ModelPackageGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ModelPackageGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ModelPackageGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ModelPackageGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ModelPackageGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ModelPackageGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ModelPackageGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupSpec(obj: ModelPackageGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ModelPackageGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_ModelPackageGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ModelPackageGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ModelPackageGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ModelPackageGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ModelPackageGroupSpecDeletionPolicy
 */
export enum ModelPackageGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ModelPackageGroupSpecForProvider
 */
export interface ModelPackageGroupSpecForProvider {
  /**
   * A description for the model group.
   *
   * @schema ModelPackageGroupSpecForProvider#modelPackageGroupDescription
   */
  readonly modelPackageGroupDescription?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ModelPackageGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ModelPackageGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ModelPackageGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupSpecForProvider(obj: ModelPackageGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'modelPackageGroupDescription': obj.modelPackageGroupDescription,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ModelPackageGroupSpecInitProvider
 */
export interface ModelPackageGroupSpecInitProvider {
  /**
   * A description for the model group.
   *
   * @schema ModelPackageGroupSpecInitProvider#modelPackageGroupDescription
   */
  readonly modelPackageGroupDescription?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ModelPackageGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ModelPackageGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupSpecInitProvider(obj: ModelPackageGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'modelPackageGroupDescription': obj.modelPackageGroupDescription,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ModelPackageGroupSpecManagementPolicies
 */
export enum ModelPackageGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ModelPackageGroupSpecProviderConfigRef
 */
export interface ModelPackageGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelPackageGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelPackageGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ModelPackageGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelPackageGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupSpecProviderConfigRef(obj: ModelPackageGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelPackageGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ModelPackageGroupSpecPublishConnectionDetailsTo
 */
export interface ModelPackageGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ModelPackageGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ModelPackageGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ModelPackageGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ModelPackageGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ModelPackageGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ModelPackageGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupSpecPublishConnectionDetailsTo(obj: ModelPackageGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ModelPackageGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ModelPackageGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ModelPackageGroupSpecWriteConnectionSecretToRef
 */
export interface ModelPackageGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ModelPackageGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ModelPackageGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ModelPackageGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupSpecWriteConnectionSecretToRef(obj: ModelPackageGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelPackageGroupSpecProviderConfigRefPolicy
 */
export interface ModelPackageGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelPackageGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ModelPackageGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelPackageGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ModelPackageGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelPackageGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupSpecProviderConfigRefPolicy(obj: ModelPackageGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ModelPackageGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ModelPackageGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelPackageGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelPackageGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelPackageGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupSpecPublishConnectionDetailsToConfigRef(obj: ModelPackageGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ModelPackageGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ModelPackageGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelPackageGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelPackageGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ModelPackageGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ModelPackageGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupSpecPublishConnectionDetailsToMetadata(obj: ModelPackageGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelPackageGroupSpecProviderConfigRefPolicyResolution
 */
export enum ModelPackageGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelPackageGroupSpecProviderConfigRefPolicyResolve
 */
export enum ModelPackageGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ModelPackageGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ModelPackageGroupPolicy is the Schema for the ModelPackageGroupPolicys API. Provides a SageMaker Model Package Group Policy resource.
 *
 * @schema ModelPackageGroupPolicy
 */
export class ModelPackageGroupPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ModelPackageGroupPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'ModelPackageGroupPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ModelPackageGroupPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ModelPackageGroupPolicyProps): any {
    return {
      ...ModelPackageGroupPolicy.GVK,
      ...toJson_ModelPackageGroupPolicyProps(props),
    };
  }

  /**
   * Defines a "ModelPackageGroupPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ModelPackageGroupPolicyProps) {
    super(scope, id, {
      ...ModelPackageGroupPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ModelPackageGroupPolicy.GVK,
      ...toJson_ModelPackageGroupPolicyProps(resolved),
    };
  }
}

/**
 * ModelPackageGroupPolicy is the Schema for the ModelPackageGroupPolicys API. Provides a SageMaker Model Package Group Policy resource.
 *
 * @schema ModelPackageGroupPolicy
 */
export interface ModelPackageGroupPolicyProps {
  /**
   * @schema ModelPackageGroupPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ModelPackageGroupPolicySpec defines the desired state of ModelPackageGroupPolicy
   *
   * @schema ModelPackageGroupPolicy#spec
   */
  readonly spec: ModelPackageGroupPolicySpec;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicyProps(obj: ModelPackageGroupPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ModelPackageGroupPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ModelPackageGroupPolicySpec defines the desired state of ModelPackageGroupPolicy
 *
 * @schema ModelPackageGroupPolicySpec
 */
export interface ModelPackageGroupPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ModelPackageGroupPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: ModelPackageGroupPolicySpecDeletionPolicy;

  /**
   * @schema ModelPackageGroupPolicySpec#forProvider
   */
  readonly forProvider: ModelPackageGroupPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ModelPackageGroupPolicySpec#initProvider
   */
  readonly initProvider?: ModelPackageGroupPolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ModelPackageGroupPolicySpec#managementPolicies
   */
  readonly managementPolicies?: ModelPackageGroupPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ModelPackageGroupPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: ModelPackageGroupPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ModelPackageGroupPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ModelPackageGroupPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ModelPackageGroupPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ModelPackageGroupPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpec(obj: ModelPackageGroupPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ModelPackageGroupPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_ModelPackageGroupPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ModelPackageGroupPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ModelPackageGroupPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ModelPackageGroupPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ModelPackageGroupPolicySpecDeletionPolicy
 */
export enum ModelPackageGroupPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ModelPackageGroupPolicySpecForProvider
 */
export interface ModelPackageGroupPolicySpecForProvider {
  /**
   * The name of the model package group.
   *
   * @schema ModelPackageGroupPolicySpecForProvider#modelPackageGroupName
   */
  readonly modelPackageGroupName?: string;

  /**
   * Reference to a ModelPackageGroup in sagemaker to populate modelPackageGroupName.
   *
   * @schema ModelPackageGroupPolicySpecForProvider#modelPackageGroupNameRef
   */
  readonly modelPackageGroupNameRef?: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRef;

  /**
   * Selector for a ModelPackageGroup in sagemaker to populate modelPackageGroupName.
   *
   * @schema ModelPackageGroupPolicySpecForProvider#modelPackageGroupNameSelector
   */
  readonly modelPackageGroupNameSelector?: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ModelPackageGroupPolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema ModelPackageGroupPolicySpecForProvider#resourcePolicy
   */
  readonly resourcePolicy?: string;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecForProvider(obj: ModelPackageGroupPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'modelPackageGroupName': obj.modelPackageGroupName,
    'modelPackageGroupNameRef': toJson_ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRef(obj.modelPackageGroupNameRef),
    'modelPackageGroupNameSelector': toJson_ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelector(obj.modelPackageGroupNameSelector),
    'region': obj.region,
    'resourcePolicy': obj.resourcePolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ModelPackageGroupPolicySpecInitProvider
 */
export interface ModelPackageGroupPolicySpecInitProvider {
  /**
   * @schema ModelPackageGroupPolicySpecInitProvider#resourcePolicy
   */
  readonly resourcePolicy?: string;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecInitProvider(obj: ModelPackageGroupPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourcePolicy': obj.resourcePolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ModelPackageGroupPolicySpecManagementPolicies
 */
export enum ModelPackageGroupPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ModelPackageGroupPolicySpecProviderConfigRef
 */
export interface ModelPackageGroupPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelPackageGroupPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelPackageGroupPolicySpecProviderConfigRef#policy
   */
  readonly policy?: ModelPackageGroupPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecProviderConfigRef(obj: ModelPackageGroupPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelPackageGroupPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsTo
 */
export interface ModelPackageGroupPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ModelPackageGroupPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecPublishConnectionDetailsTo(obj: ModelPackageGroupPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ModelPackageGroupPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ModelPackageGroupPolicySpecWriteConnectionSecretToRef
 */
export interface ModelPackageGroupPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ModelPackageGroupPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ModelPackageGroupPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecWriteConnectionSecretToRef(obj: ModelPackageGroupPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ModelPackageGroup in sagemaker to populate modelPackageGroupName.
 *
 * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRef
 */
export interface ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRef#policy
   */
  readonly policy?: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicy;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRef(obj: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ModelPackageGroup in sagemaker to populate modelPackageGroupName.
 *
 * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelector
 */
export interface ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelector#policy
   */
  readonly policy?: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelector(obj: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelPackageGroupPolicySpecProviderConfigRefPolicy
 */
export interface ModelPackageGroupPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelPackageGroupPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ModelPackageGroupPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelPackageGroupPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ModelPackageGroupPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecProviderConfigRefPolicy(obj: ModelPackageGroupPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRef(obj: ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToMetadata
 */
export interface ModelPackageGroupPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecPublishConnectionDetailsToMetadata(obj: ModelPackageGroupPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicy
 */
export interface ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicy#resolution
   */
  readonly resolution?: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicy#resolve
   */
  readonly resolve?: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicy(obj: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicy
 */
export interface ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicy(obj: ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelPackageGroupPolicySpecProviderConfigRefPolicyResolution
 */
export enum ModelPackageGroupPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelPackageGroupPolicySpecProviderConfigRefPolicyResolve
 */
export enum ModelPackageGroupPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicyResolution
 */
export enum ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicyResolve
 */
export enum ModelPackageGroupPolicySpecForProviderModelPackageGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicyResolution
 */
export enum ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicyResolve
 */
export enum ModelPackageGroupPolicySpecForProviderModelPackageGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ModelPackageGroupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * NotebookInstance is the Schema for the NotebookInstances API. Provides a SageMaker Notebook Instance resource.
 *
 * @schema NotebookInstance
 */
export class NotebookInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NotebookInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'NotebookInstance',
  }

  /**
   * Renders a Kubernetes manifest for "NotebookInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NotebookInstanceProps): any {
    return {
      ...NotebookInstance.GVK,
      ...toJson_NotebookInstanceProps(props),
    };
  }

  /**
   * Defines a "NotebookInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NotebookInstanceProps) {
    super(scope, id, {
      ...NotebookInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NotebookInstance.GVK,
      ...toJson_NotebookInstanceProps(resolved),
    };
  }
}

/**
 * NotebookInstance is the Schema for the NotebookInstances API. Provides a SageMaker Notebook Instance resource.
 *
 * @schema NotebookInstance
 */
export interface NotebookInstanceProps {
  /**
   * @schema NotebookInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NotebookInstanceSpec defines the desired state of NotebookInstance
   *
   * @schema NotebookInstance#spec
   */
  readonly spec: NotebookInstanceSpec;

}

/**
 * Converts an object of type 'NotebookInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceProps(obj: NotebookInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NotebookInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NotebookInstanceSpec defines the desired state of NotebookInstance
 *
 * @schema NotebookInstanceSpec
 */
export interface NotebookInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NotebookInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: NotebookInstanceSpecDeletionPolicy;

  /**
   * @schema NotebookInstanceSpec#forProvider
   */
  readonly forProvider: NotebookInstanceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema NotebookInstanceSpec#initProvider
   */
  readonly initProvider?: NotebookInstanceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NotebookInstanceSpec#managementPolicies
   */
  readonly managementPolicies?: NotebookInstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NotebookInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: NotebookInstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NotebookInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NotebookInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NotebookInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NotebookInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NotebookInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpec(obj: NotebookInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NotebookInstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_NotebookInstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NotebookInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_NotebookInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NotebookInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NotebookInstanceSpecDeletionPolicy
 */
export enum NotebookInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NotebookInstanceSpecForProvider
 */
export interface NotebookInstanceSpecForProvider {
  /**
   * A list of Elastic Inference (EI) instance types to associate with this notebook instance. See Elastic Inference Accelerator for more details. Valid values: ml.eia1.medium, ml.eia1.large, ml.eia1.xlarge, ml.eia2.medium, ml.eia2.large, ml.eia2.xlarge.
   *
   * @schema NotebookInstanceSpecForProvider#acceleratorTypes
   */
  readonly acceleratorTypes?: string[];

  /**
   * An array of up to three Git repositories to associate with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in AWS CodeCommit or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance.
   *
   * @schema NotebookInstanceSpecForProvider#additionalCodeRepositories
   */
  readonly additionalCodeRepositories?: string[];

  /**
   * The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in AWS CodeCommit or in any other Git repository.
   *
   * @schema NotebookInstanceSpecForProvider#defaultCodeRepository
   */
  readonly defaultCodeRepository?: string;

  /**
   * Reference to a CodeRepository in sagemaker to populate defaultCodeRepository.
   *
   * @schema NotebookInstanceSpecForProvider#defaultCodeRepositoryRef
   */
  readonly defaultCodeRepositoryRef?: NotebookInstanceSpecForProviderDefaultCodeRepositoryRef;

  /**
   * Selector for a CodeRepository in sagemaker to populate defaultCodeRepository.
   *
   * @schema NotebookInstanceSpecForProvider#defaultCodeRepositorySelector
   */
  readonly defaultCodeRepositorySelector?: NotebookInstanceSpecForProviderDefaultCodeRepositorySelector;

  /**
   * Set to Disabled to disable internet access to notebook. Requires security_groups and subnet_id to be set. Supported values: Enabled (Default) or Disabled. If set to Disabled, the notebook instance will be able to access resources only in your VPC, and will not be able to connect to Amazon SageMaker training and endpoint services unless your configure a NAT Gateway in your VPC.
   *
   * @schema NotebookInstanceSpecForProvider#directInternetAccess
   */
  readonly directInternetAccess?: string;

  /**
   * Information on the IMDS configuration of the notebook instance. Conflicts with instance_metadata_service_configuration. see details below.
   *
   * @schema NotebookInstanceSpecForProvider#instanceMetadataServiceConfiguration
   */
  readonly instanceMetadataServiceConfiguration?: NotebookInstanceSpecForProviderInstanceMetadataServiceConfiguration[];

  /**
   * The name of ML compute instance type.
   *
   * @schema NotebookInstanceSpecForProvider#instanceType
   */
  readonly instanceType?: string;

  /**
   * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
   *
   * @schema NotebookInstanceSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema NotebookInstanceSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: NotebookInstanceSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema NotebookInstanceSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: NotebookInstanceSpecForProviderKmsKeyIdSelector;

  /**
   * The name of a lifecycle configuration to associate with the notebook instance.
   *
   * @schema NotebookInstanceSpecForProvider#lifecycleConfigName
   */
  readonly lifecycleConfigName?: string;

  /**
   * The platform identifier of the notebook instance runtime environment. This value can be either notebook-al1-v1, notebook-al2-v1, or  notebook-al2-v2, depending on which version of Amazon Linux you require.
   *
   * @schema NotebookInstanceSpecForProvider#platformIdentifier
   */
  readonly platformIdentifier?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema NotebookInstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the IAM role to be used by the notebook instance which allows SageMaker to call other services on your behalf.
   *
   * @schema NotebookInstanceSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema NotebookInstanceSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: NotebookInstanceSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema NotebookInstanceSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: NotebookInstanceSpecForProviderRoleArnSelector;

  /**
   * Whether root access is Enabled or Disabled for users of the notebook instance. The default value is Enabled.
   *
   * @schema NotebookInstanceSpecForProvider#rootAccess
   */
  readonly rootAccess?: string;

  /**
   * The associated security groups.
   *
   * @schema NotebookInstanceSpecForProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * The VPC subnet ID.
   *
   * @schema NotebookInstanceSpecForProvider#subnetId
   */
  readonly subnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate subnetId.
   *
   * @schema NotebookInstanceSpecForProvider#subnetIdRef
   */
  readonly subnetIdRef?: NotebookInstanceSpecForProviderSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate subnetId.
   *
   * @schema NotebookInstanceSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: NotebookInstanceSpecForProviderSubnetIdSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema NotebookInstanceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The size, in GB, of the ML storage volume to attach to the notebook instance. The default value is 5 GB.
   *
   * @schema NotebookInstanceSpecForProvider#volumeSize
   */
  readonly volumeSize?: number;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProvider(obj: NotebookInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorTypes': obj.acceleratorTypes?.map(y => y),
    'additionalCodeRepositories': obj.additionalCodeRepositories?.map(y => y),
    'defaultCodeRepository': obj.defaultCodeRepository,
    'defaultCodeRepositoryRef': toJson_NotebookInstanceSpecForProviderDefaultCodeRepositoryRef(obj.defaultCodeRepositoryRef),
    'defaultCodeRepositorySelector': toJson_NotebookInstanceSpecForProviderDefaultCodeRepositorySelector(obj.defaultCodeRepositorySelector),
    'directInternetAccess': obj.directInternetAccess,
    'instanceMetadataServiceConfiguration': obj.instanceMetadataServiceConfiguration?.map(y => toJson_NotebookInstanceSpecForProviderInstanceMetadataServiceConfiguration(y)),
    'instanceType': obj.instanceType,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_NotebookInstanceSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_NotebookInstanceSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'lifecycleConfigName': obj.lifecycleConfigName,
    'platformIdentifier': obj.platformIdentifier,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_NotebookInstanceSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_NotebookInstanceSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'rootAccess': obj.rootAccess,
    'securityGroups': obj.securityGroups?.map(y => y),
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_NotebookInstanceSpecForProviderSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_NotebookInstanceSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'volumeSize': obj.volumeSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema NotebookInstanceSpecInitProvider
 */
export interface NotebookInstanceSpecInitProvider {
  /**
   * A list of Elastic Inference (EI) instance types to associate with this notebook instance. See Elastic Inference Accelerator for more details. Valid values: ml.eia1.medium, ml.eia1.large, ml.eia1.xlarge, ml.eia2.medium, ml.eia2.large, ml.eia2.xlarge.
   *
   * @schema NotebookInstanceSpecInitProvider#acceleratorTypes
   */
  readonly acceleratorTypes?: string[];

  /**
   * An array of up to three Git repositories to associate with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in AWS CodeCommit or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance.
   *
   * @schema NotebookInstanceSpecInitProvider#additionalCodeRepositories
   */
  readonly additionalCodeRepositories?: string[];

  /**
   * Set to Disabled to disable internet access to notebook. Requires security_groups and subnet_id to be set. Supported values: Enabled (Default) or Disabled. If set to Disabled, the notebook instance will be able to access resources only in your VPC, and will not be able to connect to Amazon SageMaker training and endpoint services unless your configure a NAT Gateway in your VPC.
   *
   * @schema NotebookInstanceSpecInitProvider#directInternetAccess
   */
  readonly directInternetAccess?: string;

  /**
   * Information on the IMDS configuration of the notebook instance. Conflicts with instance_metadata_service_configuration. see details below.
   *
   * @schema NotebookInstanceSpecInitProvider#instanceMetadataServiceConfiguration
   */
  readonly instanceMetadataServiceConfiguration?: NotebookInstanceSpecInitProviderInstanceMetadataServiceConfiguration[];

  /**
   * The name of ML compute instance type.
   *
   * @schema NotebookInstanceSpecInitProvider#instanceType
   */
  readonly instanceType?: string;

  /**
   * The name of a lifecycle configuration to associate with the notebook instance.
   *
   * @schema NotebookInstanceSpecInitProvider#lifecycleConfigName
   */
  readonly lifecycleConfigName?: string;

  /**
   * The platform identifier of the notebook instance runtime environment. This value can be either notebook-al1-v1, notebook-al2-v1, or  notebook-al2-v2, depending on which version of Amazon Linux you require.
   *
   * @schema NotebookInstanceSpecInitProvider#platformIdentifier
   */
  readonly platformIdentifier?: string;

  /**
   * Whether root access is Enabled or Disabled for users of the notebook instance. The default value is Enabled.
   *
   * @schema NotebookInstanceSpecInitProvider#rootAccess
   */
  readonly rootAccess?: string;

  /**
   * The associated security groups.
   *
   * @schema NotebookInstanceSpecInitProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema NotebookInstanceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The size, in GB, of the ML storage volume to attach to the notebook instance. The default value is 5 GB.
   *
   * @schema NotebookInstanceSpecInitProvider#volumeSize
   */
  readonly volumeSize?: number;

}

/**
 * Converts an object of type 'NotebookInstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecInitProvider(obj: NotebookInstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorTypes': obj.acceleratorTypes?.map(y => y),
    'additionalCodeRepositories': obj.additionalCodeRepositories?.map(y => y),
    'directInternetAccess': obj.directInternetAccess,
    'instanceMetadataServiceConfiguration': obj.instanceMetadataServiceConfiguration?.map(y => toJson_NotebookInstanceSpecInitProviderInstanceMetadataServiceConfiguration(y)),
    'instanceType': obj.instanceType,
    'lifecycleConfigName': obj.lifecycleConfigName,
    'platformIdentifier': obj.platformIdentifier,
    'rootAccess': obj.rootAccess,
    'securityGroups': obj.securityGroups?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'volumeSize': obj.volumeSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema NotebookInstanceSpecManagementPolicies
 */
export enum NotebookInstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NotebookInstanceSpecProviderConfigRef
 */
export interface NotebookInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotebookInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotebookInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: NotebookInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecProviderConfigRef(obj: NotebookInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotebookInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NotebookInstanceSpecPublishConnectionDetailsTo
 */
export interface NotebookInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NotebookInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NotebookInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NotebookInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NotebookInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NotebookInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NotebookInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecPublishConnectionDetailsTo(obj: NotebookInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NotebookInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NotebookInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NotebookInstanceSpecWriteConnectionSecretToRef
 */
export interface NotebookInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NotebookInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NotebookInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NotebookInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecWriteConnectionSecretToRef(obj: NotebookInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CodeRepository in sagemaker to populate defaultCodeRepository.
 *
 * @schema NotebookInstanceSpecForProviderDefaultCodeRepositoryRef
 */
export interface NotebookInstanceSpecForProviderDefaultCodeRepositoryRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotebookInstanceSpecForProviderDefaultCodeRepositoryRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotebookInstanceSpecForProviderDefaultCodeRepositoryRef#policy
   */
  readonly policy?: NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderDefaultCodeRepositoryRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderDefaultCodeRepositoryRef(obj: NotebookInstanceSpecForProviderDefaultCodeRepositoryRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CodeRepository in sagemaker to populate defaultCodeRepository.
 *
 * @schema NotebookInstanceSpecForProviderDefaultCodeRepositorySelector
 */
export interface NotebookInstanceSpecForProviderDefaultCodeRepositorySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NotebookInstanceSpecForProviderDefaultCodeRepositorySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NotebookInstanceSpecForProviderDefaultCodeRepositorySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NotebookInstanceSpecForProviderDefaultCodeRepositorySelector#policy
   */
  readonly policy?: NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderDefaultCodeRepositorySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderDefaultCodeRepositorySelector(obj: NotebookInstanceSpecForProviderDefaultCodeRepositorySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NotebookInstanceSpecForProviderInstanceMetadataServiceConfiguration
 */
export interface NotebookInstanceSpecForProviderInstanceMetadataServiceConfiguration {
  /**
   * Indicates the minimum IMDS version that the notebook instance supports. When passed "1" is passed. This means that both IMDSv1 and IMDSv2 are supported. Valid values are 1 and 2.
   *
   * @schema NotebookInstanceSpecForProviderInstanceMetadataServiceConfiguration#minimumInstanceMetadataServiceVersion
   */
  readonly minimumInstanceMetadataServiceVersion?: string;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderInstanceMetadataServiceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderInstanceMetadataServiceConfiguration(obj: NotebookInstanceSpecForProviderInstanceMetadataServiceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumInstanceMetadataServiceVersion': obj.minimumInstanceMetadataServiceVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema NotebookInstanceSpecForProviderKmsKeyIdRef
 */
export interface NotebookInstanceSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotebookInstanceSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotebookInstanceSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: NotebookInstanceSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderKmsKeyIdRef(obj: NotebookInstanceSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotebookInstanceSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema NotebookInstanceSpecForProviderKmsKeyIdSelector
 */
export interface NotebookInstanceSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NotebookInstanceSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NotebookInstanceSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NotebookInstanceSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderKmsKeyIdSelector(obj: NotebookInstanceSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema NotebookInstanceSpecForProviderRoleArnRef
 */
export interface NotebookInstanceSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotebookInstanceSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotebookInstanceSpecForProviderRoleArnRef#policy
   */
  readonly policy?: NotebookInstanceSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderRoleArnRef(obj: NotebookInstanceSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotebookInstanceSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema NotebookInstanceSpecForProviderRoleArnSelector
 */
export interface NotebookInstanceSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NotebookInstanceSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NotebookInstanceSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NotebookInstanceSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: NotebookInstanceSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderRoleArnSelector(obj: NotebookInstanceSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NotebookInstanceSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate subnetId.
 *
 * @schema NotebookInstanceSpecForProviderSubnetIdRef
 */
export interface NotebookInstanceSpecForProviderSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotebookInstanceSpecForProviderSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotebookInstanceSpecForProviderSubnetIdRef#policy
   */
  readonly policy?: NotebookInstanceSpecForProviderSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderSubnetIdRef(obj: NotebookInstanceSpecForProviderSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotebookInstanceSpecForProviderSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate subnetId.
 *
 * @schema NotebookInstanceSpecForProviderSubnetIdSelector
 */
export interface NotebookInstanceSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NotebookInstanceSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NotebookInstanceSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NotebookInstanceSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: NotebookInstanceSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderSubnetIdSelector(obj: NotebookInstanceSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NotebookInstanceSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NotebookInstanceSpecInitProviderInstanceMetadataServiceConfiguration
 */
export interface NotebookInstanceSpecInitProviderInstanceMetadataServiceConfiguration {
  /**
   * Indicates the minimum IMDS version that the notebook instance supports. When passed "1" is passed. This means that both IMDSv1 and IMDSv2 are supported. Valid values are 1 and 2.
   *
   * @schema NotebookInstanceSpecInitProviderInstanceMetadataServiceConfiguration#minimumInstanceMetadataServiceVersion
   */
  readonly minimumInstanceMetadataServiceVersion?: string;

}

/**
 * Converts an object of type 'NotebookInstanceSpecInitProviderInstanceMetadataServiceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecInitProviderInstanceMetadataServiceConfiguration(obj: NotebookInstanceSpecInitProviderInstanceMetadataServiceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumInstanceMetadataServiceVersion': obj.minimumInstanceMetadataServiceVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotebookInstanceSpecProviderConfigRefPolicy
 */
export interface NotebookInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NotebookInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NotebookInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecProviderConfigRefPolicy(obj: NotebookInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NotebookInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface NotebookInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotebookInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotebookInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecPublishConnectionDetailsToConfigRef(obj: NotebookInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NotebookInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface NotebookInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotebookInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotebookInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NotebookInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NotebookInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecPublishConnectionDetailsToMetadata(obj: NotebookInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicy
 */
export interface NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicy#resolution
   */
  readonly resolution?: NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicy#resolve
   */
  readonly resolve?: NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicy(obj: NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicy
 */
export interface NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicy#resolution
   */
  readonly resolution?: NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicy#resolve
   */
  readonly resolve?: NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicy(obj: NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotebookInstanceSpecForProviderKmsKeyIdRefPolicy
 */
export interface NotebookInstanceSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: NotebookInstanceSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: NotebookInstanceSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderKmsKeyIdRefPolicy(obj: NotebookInstanceSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicy(obj: NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotebookInstanceSpecForProviderRoleArnRefPolicy
 */
export interface NotebookInstanceSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: NotebookInstanceSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: NotebookInstanceSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderRoleArnRefPolicy(obj: NotebookInstanceSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NotebookInstanceSpecForProviderRoleArnSelectorPolicy
 */
export interface NotebookInstanceSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: NotebookInstanceSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: NotebookInstanceSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderRoleArnSelectorPolicy(obj: NotebookInstanceSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotebookInstanceSpecForProviderSubnetIdRefPolicy
 */
export interface NotebookInstanceSpecForProviderSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceSpecForProviderSubnetIdRefPolicy#resolution
   */
  readonly resolution?: NotebookInstanceSpecForProviderSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceSpecForProviderSubnetIdRefPolicy#resolve
   */
  readonly resolve?: NotebookInstanceSpecForProviderSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderSubnetIdRefPolicy(obj: NotebookInstanceSpecForProviderSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NotebookInstanceSpecForProviderSubnetIdSelectorPolicy
 */
export interface NotebookInstanceSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: NotebookInstanceSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: NotebookInstanceSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecForProviderSubnetIdSelectorPolicy(obj: NotebookInstanceSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceSpecProviderConfigRefPolicyResolution
 */
export enum NotebookInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceSpecProviderConfigRefPolicyResolve
 */
export enum NotebookInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicyResolution
 */
export enum NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicyResolve
 */
export enum NotebookInstanceSpecForProviderDefaultCodeRepositoryRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicyResolution
 */
export enum NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicyResolve
 */
export enum NotebookInstanceSpecForProviderDefaultCodeRepositorySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum NotebookInstanceSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum NotebookInstanceSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum NotebookInstanceSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceSpecForProviderRoleArnRefPolicyResolution
 */
export enum NotebookInstanceSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceSpecForProviderRoleArnRefPolicyResolve
 */
export enum NotebookInstanceSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum NotebookInstanceSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum NotebookInstanceSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceSpecForProviderSubnetIdRefPolicyResolution
 */
export enum NotebookInstanceSpecForProviderSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceSpecForProviderSubnetIdRefPolicyResolve
 */
export enum NotebookInstanceSpecForProviderSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum NotebookInstanceSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum NotebookInstanceSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NotebookInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * NotebookInstanceLifecycleConfiguration is the Schema for the NotebookInstanceLifecycleConfigurations API. Provides a lifecycle configuration for SageMaker Notebook Instances.
 *
 * @schema NotebookInstanceLifecycleConfiguration
 */
export class NotebookInstanceLifecycleConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NotebookInstanceLifecycleConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'NotebookInstanceLifecycleConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "NotebookInstanceLifecycleConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NotebookInstanceLifecycleConfigurationProps): any {
    return {
      ...NotebookInstanceLifecycleConfiguration.GVK,
      ...toJson_NotebookInstanceLifecycleConfigurationProps(props),
    };
  }

  /**
   * Defines a "NotebookInstanceLifecycleConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NotebookInstanceLifecycleConfigurationProps) {
    super(scope, id, {
      ...NotebookInstanceLifecycleConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NotebookInstanceLifecycleConfiguration.GVK,
      ...toJson_NotebookInstanceLifecycleConfigurationProps(resolved),
    };
  }
}

/**
 * NotebookInstanceLifecycleConfiguration is the Schema for the NotebookInstanceLifecycleConfigurations API. Provides a lifecycle configuration for SageMaker Notebook Instances.
 *
 * @schema NotebookInstanceLifecycleConfiguration
 */
export interface NotebookInstanceLifecycleConfigurationProps {
  /**
   * @schema NotebookInstanceLifecycleConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NotebookInstanceLifecycleConfigurationSpec defines the desired state of NotebookInstanceLifecycleConfiguration
   *
   * @schema NotebookInstanceLifecycleConfiguration#spec
   */
  readonly spec: NotebookInstanceLifecycleConfigurationSpec;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationProps(obj: NotebookInstanceLifecycleConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NotebookInstanceLifecycleConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NotebookInstanceLifecycleConfigurationSpec defines the desired state of NotebookInstanceLifecycleConfiguration
 *
 * @schema NotebookInstanceLifecycleConfigurationSpec
 */
export interface NotebookInstanceLifecycleConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NotebookInstanceLifecycleConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: NotebookInstanceLifecycleConfigurationSpecDeletionPolicy;

  /**
   * @schema NotebookInstanceLifecycleConfigurationSpec#forProvider
   */
  readonly forProvider: NotebookInstanceLifecycleConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpec#initProvider
   */
  readonly initProvider?: NotebookInstanceLifecycleConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NotebookInstanceLifecycleConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: NotebookInstanceLifecycleConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: NotebookInstanceLifecycleConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NotebookInstanceLifecycleConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationSpec(obj: NotebookInstanceLifecycleConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NotebookInstanceLifecycleConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_NotebookInstanceLifecycleConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NotebookInstanceLifecycleConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NotebookInstanceLifecycleConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecDeletionPolicy
 */
export enum NotebookInstanceLifecycleConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NotebookInstanceLifecycleConfigurationSpecForProvider
 */
export interface NotebookInstanceLifecycleConfigurationSpecForProvider {
  /**
   * A shell script (base64-encoded) that runs only once when the SageMaker Notebook Instance is created.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecForProvider#onCreate
   */
  readonly onCreate?: string;

  /**
   * A shell script (base64-encoded) that runs every time the SageMaker Notebook Instance is started including the time it's created.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecForProvider#onStart
   */
  readonly onStart?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationSpecForProvider(obj: NotebookInstanceLifecycleConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onCreate': obj.onCreate,
    'onStart': obj.onStart,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecInitProvider
 */
export interface NotebookInstanceLifecycleConfigurationSpecInitProvider {
  /**
   * A shell script (base64-encoded) that runs only once when the SageMaker Notebook Instance is created.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecInitProvider#onCreate
   */
  readonly onCreate?: string;

  /**
   * A shell script (base64-encoded) that runs every time the SageMaker Notebook Instance is started including the time it's created.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecInitProvider#onStart
   */
  readonly onStart?: string;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationSpecInitProvider(obj: NotebookInstanceLifecycleConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onCreate': obj.onCreate,
    'onStart': obj.onStart,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecManagementPolicies
 */
export enum NotebookInstanceLifecycleConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecProviderConfigRef
 */
export interface NotebookInstanceLifecycleConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationSpecProviderConfigRef(obj: NotebookInstanceLifecycleConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsTo
 */
export interface NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsTo(obj: NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecWriteConnectionSecretToRef
 */
export interface NotebookInstanceLifecycleConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationSpecWriteConnectionSecretToRef(obj: NotebookInstanceLifecycleConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicy
 */
export interface NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicy(obj: NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef(obj: NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToMetadata(obj: NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum NotebookInstanceLifecycleConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NotebookInstanceLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServicecatalogPortfolioStatus is the Schema for the ServicecatalogPortfolioStatuss API. Manages status of Service Catalog in SageMaker. Service Catalog is used to create SageMaker projects.
 *
 * @schema ServicecatalogPortfolioStatus
 */
export class ServicecatalogPortfolioStatus extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServicecatalogPortfolioStatus"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'ServicecatalogPortfolioStatus',
  }

  /**
   * Renders a Kubernetes manifest for "ServicecatalogPortfolioStatus".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServicecatalogPortfolioStatusProps): any {
    return {
      ...ServicecatalogPortfolioStatus.GVK,
      ...toJson_ServicecatalogPortfolioStatusProps(props),
    };
  }

  /**
   * Defines a "ServicecatalogPortfolioStatus" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServicecatalogPortfolioStatusProps) {
    super(scope, id, {
      ...ServicecatalogPortfolioStatus.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServicecatalogPortfolioStatus.GVK,
      ...toJson_ServicecatalogPortfolioStatusProps(resolved),
    };
  }
}

/**
 * ServicecatalogPortfolioStatus is the Schema for the ServicecatalogPortfolioStatuss API. Manages status of Service Catalog in SageMaker. Service Catalog is used to create SageMaker projects.
 *
 * @schema ServicecatalogPortfolioStatus
 */
export interface ServicecatalogPortfolioStatusProps {
  /**
   * @schema ServicecatalogPortfolioStatus#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServicecatalogPortfolioStatusSpec defines the desired state of ServicecatalogPortfolioStatus
   *
   * @schema ServicecatalogPortfolioStatus#spec
   */
  readonly spec: ServicecatalogPortfolioStatusSpec;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusProps(obj: ServicecatalogPortfolioStatusProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServicecatalogPortfolioStatusSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServicecatalogPortfolioStatusSpec defines the desired state of ServicecatalogPortfolioStatus
 *
 * @schema ServicecatalogPortfolioStatusSpec
 */
export interface ServicecatalogPortfolioStatusSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServicecatalogPortfolioStatusSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServicecatalogPortfolioStatusSpecDeletionPolicy;

  /**
   * @schema ServicecatalogPortfolioStatusSpec#forProvider
   */
  readonly forProvider: ServicecatalogPortfolioStatusSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ServicecatalogPortfolioStatusSpec#initProvider
   */
  readonly initProvider?: ServicecatalogPortfolioStatusSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServicecatalogPortfolioStatusSpec#managementPolicies
   */
  readonly managementPolicies?: ServicecatalogPortfolioStatusSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServicecatalogPortfolioStatusSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServicecatalogPortfolioStatusSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServicecatalogPortfolioStatusSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServicecatalogPortfolioStatusSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServicecatalogPortfolioStatusSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServicecatalogPortfolioStatusSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusSpec(obj: ServicecatalogPortfolioStatusSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServicecatalogPortfolioStatusSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServicecatalogPortfolioStatusSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServicecatalogPortfolioStatusSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServicecatalogPortfolioStatusSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServicecatalogPortfolioStatusSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServicecatalogPortfolioStatusSpecDeletionPolicy
 */
export enum ServicecatalogPortfolioStatusSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServicecatalogPortfolioStatusSpecForProvider
 */
export interface ServicecatalogPortfolioStatusSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ServicecatalogPortfolioStatusSpecForProvider#region
   */
  readonly region: string;

  /**
   * Whether Service Catalog is enabled or disabled in SageMaker. Valid values are Enabled and Disabled.
   *
   * @schema ServicecatalogPortfolioStatusSpecForProvider#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusSpecForProvider(obj: ServicecatalogPortfolioStatusSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ServicecatalogPortfolioStatusSpecInitProvider
 */
export interface ServicecatalogPortfolioStatusSpecInitProvider {
  /**
   * Whether Service Catalog is enabled or disabled in SageMaker. Valid values are Enabled and Disabled.
   *
   * @schema ServicecatalogPortfolioStatusSpecInitProvider#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusSpecInitProvider(obj: ServicecatalogPortfolioStatusSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServicecatalogPortfolioStatusSpecManagementPolicies
 */
export enum ServicecatalogPortfolioStatusSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServicecatalogPortfolioStatusSpecProviderConfigRef
 */
export interface ServicecatalogPortfolioStatusSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServicecatalogPortfolioStatusSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServicecatalogPortfolioStatusSpecProviderConfigRef#policy
   */
  readonly policy?: ServicecatalogPortfolioStatusSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusSpecProviderConfigRef(obj: ServicecatalogPortfolioStatusSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServicecatalogPortfolioStatusSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsTo
 */
export interface ServicecatalogPortfolioStatusSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusSpecPublishConnectionDetailsTo(obj: ServicecatalogPortfolioStatusSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServicecatalogPortfolioStatusSpecWriteConnectionSecretToRef
 */
export interface ServicecatalogPortfolioStatusSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServicecatalogPortfolioStatusSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServicecatalogPortfolioStatusSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusSpecWriteConnectionSecretToRef(obj: ServicecatalogPortfolioStatusSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServicecatalogPortfolioStatusSpecProviderConfigRefPolicy
 */
export interface ServicecatalogPortfolioStatusSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicecatalogPortfolioStatusSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServicecatalogPortfolioStatusSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicecatalogPortfolioStatusSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServicecatalogPortfolioStatusSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusSpecProviderConfigRefPolicy(obj: ServicecatalogPortfolioStatusSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRef
 */
export interface ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRef(obj: ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToMetadata
 */
export interface ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToMetadata(obj: ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicecatalogPortfolioStatusSpecProviderConfigRefPolicyResolution
 */
export enum ServicecatalogPortfolioStatusSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicecatalogPortfolioStatusSpecProviderConfigRefPolicyResolve
 */
export enum ServicecatalogPortfolioStatusSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServicecatalogPortfolioStatusSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Space is the Schema for the Spaces API. Provides a SageMaker Space resource.
 *
 * @schema Space
 */
export class Space extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Space"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'Space',
  }

  /**
   * Renders a Kubernetes manifest for "Space".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SpaceProps): any {
    return {
      ...Space.GVK,
      ...toJson_SpaceProps(props),
    };
  }

  /**
   * Defines a "Space" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SpaceProps) {
    super(scope, id, {
      ...Space.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Space.GVK,
      ...toJson_SpaceProps(resolved),
    };
  }
}

/**
 * Space is the Schema for the Spaces API. Provides a SageMaker Space resource.
 *
 * @schema Space
 */
export interface SpaceProps {
  /**
   * @schema Space#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SpaceSpec defines the desired state of Space
   *
   * @schema Space#spec
   */
  readonly spec: SpaceSpec;

}

/**
 * Converts an object of type 'SpaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceProps(obj: SpaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SpaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SpaceSpec defines the desired state of Space
 *
 * @schema SpaceSpec
 */
export interface SpaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SpaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: SpaceSpecDeletionPolicy;

  /**
   * @schema SpaceSpec#forProvider
   */
  readonly forProvider: SpaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SpaceSpec#initProvider
   */
  readonly initProvider?: SpaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SpaceSpec#managementPolicies
   */
  readonly managementPolicies?: SpaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SpaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: SpaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SpaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SpaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SpaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SpaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SpaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpec(obj: SpaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SpaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_SpaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SpaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SpaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SpaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SpaceSpecDeletionPolicy
 */
export enum SpaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SpaceSpecForProvider
 */
export interface SpaceSpecForProvider {
  /**
   * The ID of the associated Domain.
   *
   * @schema SpaceSpecForProvider#domainId
   */
  readonly domainId?: string;

  /**
   * Reference to a Domain in sagemaker to populate domainId.
   *
   * @schema SpaceSpecForProvider#domainIdRef
   */
  readonly domainIdRef?: SpaceSpecForProviderDomainIdRef;

  /**
   * Selector for a Domain in sagemaker to populate domainId.
   *
   * @schema SpaceSpecForProvider#domainIdSelector
   */
  readonly domainIdSelector?: SpaceSpecForProviderDomainIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SpaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the space.
   *
   * @schema SpaceSpecForProvider#spaceName
   */
  readonly spaceName?: string;

  /**
   * A collection of space settings. See Space Settings below.
   *
   * @schema SpaceSpecForProvider#spaceSettings
   */
  readonly spaceSettings?: SpaceSpecForProviderSpaceSettings[];

  /**
   * Key-value map of resource tags.
   *
   * @schema SpaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SpaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProvider(obj: SpaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainId': obj.domainId,
    'domainIdRef': toJson_SpaceSpecForProviderDomainIdRef(obj.domainIdRef),
    'domainIdSelector': toJson_SpaceSpecForProviderDomainIdSelector(obj.domainIdSelector),
    'region': obj.region,
    'spaceName': obj.spaceName,
    'spaceSettings': obj.spaceSettings?.map(y => toJson_SpaceSpecForProviderSpaceSettings(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SpaceSpecInitProvider
 */
export interface SpaceSpecInitProvider {
  /**
   * The name of the space.
   *
   * @schema SpaceSpecInitProvider#spaceName
   */
  readonly spaceName?: string;

  /**
   * A collection of space settings. See Space Settings below.
   *
   * @schema SpaceSpecInitProvider#spaceSettings
   */
  readonly spaceSettings?: SpaceSpecInitProviderSpaceSettings[];

  /**
   * Key-value map of resource tags.
   *
   * @schema SpaceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SpaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecInitProvider(obj: SpaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'spaceName': obj.spaceName,
    'spaceSettings': obj.spaceSettings?.map(y => toJson_SpaceSpecInitProviderSpaceSettings(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SpaceSpecManagementPolicies
 */
export enum SpaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SpaceSpecProviderConfigRef
 */
export interface SpaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SpaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SpaceSpecProviderConfigRef#policy
   */
  readonly policy?: SpaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SpaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecProviderConfigRef(obj: SpaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SpaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SpaceSpecPublishConnectionDetailsTo
 */
export interface SpaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SpaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SpaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SpaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SpaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SpaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SpaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecPublishConnectionDetailsTo(obj: SpaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SpaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SpaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SpaceSpecWriteConnectionSecretToRef
 */
export interface SpaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SpaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SpaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SpaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecWriteConnectionSecretToRef(obj: SpaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Domain in sagemaker to populate domainId.
 *
 * @schema SpaceSpecForProviderDomainIdRef
 */
export interface SpaceSpecForProviderDomainIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SpaceSpecForProviderDomainIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SpaceSpecForProviderDomainIdRef#policy
   */
  readonly policy?: SpaceSpecForProviderDomainIdRefPolicy;

}

/**
 * Converts an object of type 'SpaceSpecForProviderDomainIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderDomainIdRef(obj: SpaceSpecForProviderDomainIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SpaceSpecForProviderDomainIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Domain in sagemaker to populate domainId.
 *
 * @schema SpaceSpecForProviderDomainIdSelector
 */
export interface SpaceSpecForProviderDomainIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SpaceSpecForProviderDomainIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SpaceSpecForProviderDomainIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SpaceSpecForProviderDomainIdSelector#policy
   */
  readonly policy?: SpaceSpecForProviderDomainIdSelectorPolicy;

}

/**
 * Converts an object of type 'SpaceSpecForProviderDomainIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderDomainIdSelector(obj: SpaceSpecForProviderDomainIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SpaceSpecForProviderDomainIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecForProviderSpaceSettings
 */
export interface SpaceSpecForProviderSpaceSettings {
  /**
   * The Jupyter server's app settings. See Jupyter Server App Settings below.
   *
   * @schema SpaceSpecForProviderSpaceSettings#jupyterServerAppSettings
   */
  readonly jupyterServerAppSettings?: SpaceSpecForProviderSpaceSettingsJupyterServerAppSettings[];

  /**
   * The kernel gateway app settings. See Kernel Gateway App Settings below.
   *
   * @schema SpaceSpecForProviderSpaceSettings#kernelGatewayAppSettings
   */
  readonly kernelGatewayAppSettings?: SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettings[];

}

/**
 * Converts an object of type 'SpaceSpecForProviderSpaceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderSpaceSettings(obj: SpaceSpecForProviderSpaceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jupyterServerAppSettings': obj.jupyterServerAppSettings?.map(y => toJson_SpaceSpecForProviderSpaceSettingsJupyterServerAppSettings(y)),
    'kernelGatewayAppSettings': obj.kernelGatewayAppSettings?.map(y => toJson_SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecInitProviderSpaceSettings
 */
export interface SpaceSpecInitProviderSpaceSettings {
  /**
   * The Jupyter server's app settings. See Jupyter Server App Settings below.
   *
   * @schema SpaceSpecInitProviderSpaceSettings#jupyterServerAppSettings
   */
  readonly jupyterServerAppSettings?: SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettings[];

  /**
   * The kernel gateway app settings. See Kernel Gateway App Settings below.
   *
   * @schema SpaceSpecInitProviderSpaceSettings#kernelGatewayAppSettings
   */
  readonly kernelGatewayAppSettings?: SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettings[];

}

/**
 * Converts an object of type 'SpaceSpecInitProviderSpaceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecInitProviderSpaceSettings(obj: SpaceSpecInitProviderSpaceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jupyterServerAppSettings': obj.jupyterServerAppSettings?.map(y => toJson_SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettings(y)),
    'kernelGatewayAppSettings': obj.kernelGatewayAppSettings?.map(y => toJson_SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SpaceSpecProviderConfigRefPolicy
 */
export interface SpaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SpaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SpaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SpaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecProviderConfigRefPolicy(obj: SpaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SpaceSpecPublishConnectionDetailsToConfigRef
 */
export interface SpaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SpaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SpaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SpaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SpaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecPublishConnectionDetailsToConfigRef(obj: SpaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SpaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SpaceSpecPublishConnectionDetailsToMetadata
 */
export interface SpaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SpaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SpaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SpaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SpaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecPublishConnectionDetailsToMetadata(obj: SpaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SpaceSpecForProviderDomainIdRefPolicy
 */
export interface SpaceSpecForProviderDomainIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpaceSpecForProviderDomainIdRefPolicy#resolution
   */
  readonly resolution?: SpaceSpecForProviderDomainIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpaceSpecForProviderDomainIdRefPolicy#resolve
   */
  readonly resolve?: SpaceSpecForProviderDomainIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SpaceSpecForProviderDomainIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderDomainIdRefPolicy(obj: SpaceSpecForProviderDomainIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SpaceSpecForProviderDomainIdSelectorPolicy
 */
export interface SpaceSpecForProviderDomainIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpaceSpecForProviderDomainIdSelectorPolicy#resolution
   */
  readonly resolution?: SpaceSpecForProviderDomainIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpaceSpecForProviderDomainIdSelectorPolicy#resolve
   */
  readonly resolve?: SpaceSpecForProviderDomainIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SpaceSpecForProviderDomainIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderDomainIdSelectorPolicy(obj: SpaceSpecForProviderDomainIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettings
 */
export interface SpaceSpecForProviderSpaceSettingsJupyterServerAppSettings {
  /**
   * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
   *
   * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettings#codeRepository
   */
  readonly codeRepository?: SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsCodeRepository[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'SpaceSpecForProviderSpaceSettingsJupyterServerAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderSpaceSettingsJupyterServerAppSettings(obj: SpaceSpecForProviderSpaceSettingsJupyterServerAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeRepository': obj.codeRepository?.map(y => toJson_SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsCodeRepository(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettings
 */
export interface SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettings#customImage
   */
  readonly customImage?: SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettings(obj: SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettings
 */
export interface SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettings {
  /**
   * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettings#codeRepository
   */
  readonly codeRepository?: SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsCodeRepository[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettings(obj: SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeRepository': obj.codeRepository?.map(y => toJson_SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsCodeRepository(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettings
 */
export interface SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettings#customImage
   */
  readonly customImage?: SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettings(obj: SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpaceSpecProviderConfigRefPolicyResolution
 */
export enum SpaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpaceSpecProviderConfigRefPolicyResolve
 */
export enum SpaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SpaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SpaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SpaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SpaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SpaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: SpaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpaceSpecForProviderDomainIdRefPolicyResolution
 */
export enum SpaceSpecForProviderDomainIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpaceSpecForProviderDomainIdRefPolicyResolve
 */
export enum SpaceSpecForProviderDomainIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpaceSpecForProviderDomainIdSelectorPolicyResolution
 */
export enum SpaceSpecForProviderDomainIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpaceSpecForProviderDomainIdSelectorPolicyResolve
 */
export enum SpaceSpecForProviderDomainIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsCodeRepository
 */
export interface SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsCodeRepository {
  /**
   * The URL of the Git repository.
   *
   * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsCodeRepository#repositoryUrl
   */
  readonly repositoryUrl?: string;

}

/**
 * Converts an object of type 'SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsCodeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsCodeRepository(obj: SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsCodeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryUrl': obj.repositoryUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec
 */
export interface SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec(obj: SpaceSpecForProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsCustomImage
 */
export interface SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * The name of the Custom Image.
   *
   * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * The version number of the Custom Image.
   *
   * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsCustomImage(obj: SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'imageName': obj.imageName,
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec
 */
export interface SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec(obj: SpaceSpecForProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsCodeRepository
 */
export interface SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsCodeRepository {
  /**
   * The URL of the Git repository.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsCodeRepository#repositoryUrl
   */
  readonly repositoryUrl?: string;

}

/**
 * Converts an object of type 'SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsCodeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsCodeRepository(obj: SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsCodeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryUrl': obj.repositoryUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec
 */
export interface SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec(obj: SpaceSpecInitProviderSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsCustomImage
 */
export interface SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * The name of the Custom Image.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * The version number of the Custom Image.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsCustomImage(obj: SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'imageName': obj.imageName,
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec
 */
export interface SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec(obj: SpaceSpecInitProviderSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SpaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SpaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StudioLifecycleConfig is the Schema for the StudioLifecycleConfigs API. Provides a SageMaker Studio Lifecycle Config resource.
 *
 * @schema StudioLifecycleConfig
 */
export class StudioLifecycleConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StudioLifecycleConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'StudioLifecycleConfig',
  }

  /**
   * Renders a Kubernetes manifest for "StudioLifecycleConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StudioLifecycleConfigProps): any {
    return {
      ...StudioLifecycleConfig.GVK,
      ...toJson_StudioLifecycleConfigProps(props),
    };
  }

  /**
   * Defines a "StudioLifecycleConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StudioLifecycleConfigProps) {
    super(scope, id, {
      ...StudioLifecycleConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StudioLifecycleConfig.GVK,
      ...toJson_StudioLifecycleConfigProps(resolved),
    };
  }
}

/**
 * StudioLifecycleConfig is the Schema for the StudioLifecycleConfigs API. Provides a SageMaker Studio Lifecycle Config resource.
 *
 * @schema StudioLifecycleConfig
 */
export interface StudioLifecycleConfigProps {
  /**
   * @schema StudioLifecycleConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StudioLifecycleConfigSpec defines the desired state of StudioLifecycleConfig
   *
   * @schema StudioLifecycleConfig#spec
   */
  readonly spec: StudioLifecycleConfigSpec;

}

/**
 * Converts an object of type 'StudioLifecycleConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigProps(obj: StudioLifecycleConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StudioLifecycleConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StudioLifecycleConfigSpec defines the desired state of StudioLifecycleConfig
 *
 * @schema StudioLifecycleConfigSpec
 */
export interface StudioLifecycleConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StudioLifecycleConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: StudioLifecycleConfigSpecDeletionPolicy;

  /**
   * @schema StudioLifecycleConfigSpec#forProvider
   */
  readonly forProvider: StudioLifecycleConfigSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema StudioLifecycleConfigSpec#initProvider
   */
  readonly initProvider?: StudioLifecycleConfigSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StudioLifecycleConfigSpec#managementPolicies
   */
  readonly managementPolicies?: StudioLifecycleConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StudioLifecycleConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: StudioLifecycleConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StudioLifecycleConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StudioLifecycleConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StudioLifecycleConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StudioLifecycleConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StudioLifecycleConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigSpec(obj: StudioLifecycleConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StudioLifecycleConfigSpecForProvider(obj.forProvider),
    'initProvider': toJson_StudioLifecycleConfigSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StudioLifecycleConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StudioLifecycleConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StudioLifecycleConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StudioLifecycleConfigSpecDeletionPolicy
 */
export enum StudioLifecycleConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StudioLifecycleConfigSpecForProvider
 */
export interface StudioLifecycleConfigSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StudioLifecycleConfigSpecForProvider#region
   */
  readonly region: string;

  /**
   * The App type that the Lifecycle Configuration is attached to. Valid values are JupyterServer and KernelGateway.
   *
   * @schema StudioLifecycleConfigSpecForProvider#studioLifecycleConfigAppType
   */
  readonly studioLifecycleConfigAppType?: string;

  /**
   * The content of your Studio Lifecycle Configuration script. This content must be base64 encoded.
   *
   * @schema StudioLifecycleConfigSpecForProvider#studioLifecycleConfigContent
   */
  readonly studioLifecycleConfigContent?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StudioLifecycleConfigSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'StudioLifecycleConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigSpecForProvider(obj: StudioLifecycleConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'studioLifecycleConfigAppType': obj.studioLifecycleConfigAppType,
    'studioLifecycleConfigContent': obj.studioLifecycleConfigContent,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema StudioLifecycleConfigSpecInitProvider
 */
export interface StudioLifecycleConfigSpecInitProvider {
  /**
   * The App type that the Lifecycle Configuration is attached to. Valid values are JupyterServer and KernelGateway.
   *
   * @schema StudioLifecycleConfigSpecInitProvider#studioLifecycleConfigAppType
   */
  readonly studioLifecycleConfigAppType?: string;

  /**
   * The content of your Studio Lifecycle Configuration script. This content must be base64 encoded.
   *
   * @schema StudioLifecycleConfigSpecInitProvider#studioLifecycleConfigContent
   */
  readonly studioLifecycleConfigContent?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StudioLifecycleConfigSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'StudioLifecycleConfigSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigSpecInitProvider(obj: StudioLifecycleConfigSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'studioLifecycleConfigAppType': obj.studioLifecycleConfigAppType,
    'studioLifecycleConfigContent': obj.studioLifecycleConfigContent,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema StudioLifecycleConfigSpecManagementPolicies
 */
export enum StudioLifecycleConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StudioLifecycleConfigSpecProviderConfigRef
 */
export interface StudioLifecycleConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StudioLifecycleConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StudioLifecycleConfigSpecProviderConfigRef#policy
   */
  readonly policy?: StudioLifecycleConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StudioLifecycleConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigSpecProviderConfigRef(obj: StudioLifecycleConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StudioLifecycleConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StudioLifecycleConfigSpecPublishConnectionDetailsTo
 */
export interface StudioLifecycleConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StudioLifecycleConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StudioLifecycleConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StudioLifecycleConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StudioLifecycleConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StudioLifecycleConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigSpecPublishConnectionDetailsTo(obj: StudioLifecycleConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StudioLifecycleConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StudioLifecycleConfigSpecWriteConnectionSecretToRef
 */
export interface StudioLifecycleConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StudioLifecycleConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StudioLifecycleConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StudioLifecycleConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigSpecWriteConnectionSecretToRef(obj: StudioLifecycleConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StudioLifecycleConfigSpecProviderConfigRefPolicy
 */
export interface StudioLifecycleConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StudioLifecycleConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StudioLifecycleConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StudioLifecycleConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StudioLifecycleConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StudioLifecycleConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigSpecProviderConfigRefPolicy(obj: StudioLifecycleConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRef(obj: StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToMetadata
 */
export interface StudioLifecycleConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StudioLifecycleConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigSpecPublishConnectionDetailsToMetadata(obj: StudioLifecycleConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StudioLifecycleConfigSpecProviderConfigRefPolicyResolution
 */
export enum StudioLifecycleConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StudioLifecycleConfigSpecProviderConfigRefPolicyResolve
 */
export enum StudioLifecycleConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StudioLifecycleConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserProfile is the Schema for the UserProfiles API. Provides a SageMaker User Profile resource.
 *
 * @schema UserProfile
 */
export class UserProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'UserProfile',
  }

  /**
   * Renders a Kubernetes manifest for "UserProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserProfileProps): any {
    return {
      ...UserProfile.GVK,
      ...toJson_UserProfileProps(props),
    };
  }

  /**
   * Defines a "UserProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserProfileProps) {
    super(scope, id, {
      ...UserProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserProfile.GVK,
      ...toJson_UserProfileProps(resolved),
    };
  }
}

/**
 * UserProfile is the Schema for the UserProfiles API. Provides a SageMaker User Profile resource.
 *
 * @schema UserProfile
 */
export interface UserProfileProps {
  /**
   * @schema UserProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserProfileSpec defines the desired state of UserProfile
   *
   * @schema UserProfile#spec
   */
  readonly spec: UserProfileSpec;

}

/**
 * Converts an object of type 'UserProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileProps(obj: UserProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserProfileSpec defines the desired state of UserProfile
 *
 * @schema UserProfileSpec
 */
export interface UserProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserProfileSpecDeletionPolicy;

  /**
   * @schema UserProfileSpec#forProvider
   */
  readonly forProvider: UserProfileSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema UserProfileSpec#initProvider
   */
  readonly initProvider?: UserProfileSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserProfileSpec#managementPolicies
   */
  readonly managementPolicies?: UserProfileSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserProfileSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpec(obj: UserProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserProfileSpecForProvider(obj.forProvider),
    'initProvider': toJson_UserProfileSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserProfileSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserProfileSpecDeletionPolicy
 */
export enum UserProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserProfileSpecForProvider
 */
export interface UserProfileSpecForProvider {
  /**
   * The ID of the associated Domain.
   *
   * @schema UserProfileSpecForProvider#domainId
   */
  readonly domainId?: string;

  /**
   * Reference to a Domain in sagemaker to populate domainId.
   *
   * @schema UserProfileSpecForProvider#domainIdRef
   */
  readonly domainIdRef?: UserProfileSpecForProviderDomainIdRef;

  /**
   * Selector for a Domain in sagemaker to populate domainId.
   *
   * @schema UserProfileSpecForProvider#domainIdSelector
   */
  readonly domainIdSelector?: UserProfileSpecForProviderDomainIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserProfileSpecForProvider#region
   */
  readonly region: string;

  /**
   * A specifier for the type of value specified in single_sign_on_user_value. Currently, the only supported value is UserName. If the Domain's AuthMode is SSO, this field is required. If the Domain's AuthMode is not SSO, this field cannot be specified.
   *
   * @schema UserProfileSpecForProvider#singleSignOnUserIdentifier
   */
  readonly singleSignOnUserIdentifier?: string;

  /**
   * The username of the associated AWS Single Sign-On User for this User Profile. If the Domain's AuthMode is SSO, this field is required, and must match a valid username of a user in your directory. If the Domain's AuthMode is not SSO, this field cannot be specified.
   *
   * @schema UserProfileSpecForProvider#singleSignOnUserValue
   */
  readonly singleSignOnUserValue?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema UserProfileSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The name for the User Profile.
   *
   * @schema UserProfileSpecForProvider#userProfileName
   */
  readonly userProfileName?: string;

  /**
   * The user settings. See User Settings below.
   *
   * @schema UserProfileSpecForProvider#userSettings
   */
  readonly userSettings?: UserProfileSpecForProviderUserSettings[];

}

/**
 * Converts an object of type 'UserProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProvider(obj: UserProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainId': obj.domainId,
    'domainIdRef': toJson_UserProfileSpecForProviderDomainIdRef(obj.domainIdRef),
    'domainIdSelector': toJson_UserProfileSpecForProviderDomainIdSelector(obj.domainIdSelector),
    'region': obj.region,
    'singleSignOnUserIdentifier': obj.singleSignOnUserIdentifier,
    'singleSignOnUserValue': obj.singleSignOnUserValue,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'userProfileName': obj.userProfileName,
    'userSettings': obj.userSettings?.map(y => toJson_UserProfileSpecForProviderUserSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema UserProfileSpecInitProvider
 */
export interface UserProfileSpecInitProvider {
  /**
   * A specifier for the type of value specified in single_sign_on_user_value. Currently, the only supported value is UserName. If the Domain's AuthMode is SSO, this field is required. If the Domain's AuthMode is not SSO, this field cannot be specified.
   *
   * @schema UserProfileSpecInitProvider#singleSignOnUserIdentifier
   */
  readonly singleSignOnUserIdentifier?: string;

  /**
   * The username of the associated AWS Single Sign-On User for this User Profile. If the Domain's AuthMode is SSO, this field is required, and must match a valid username of a user in your directory. If the Domain's AuthMode is not SSO, this field cannot be specified.
   *
   * @schema UserProfileSpecInitProvider#singleSignOnUserValue
   */
  readonly singleSignOnUserValue?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema UserProfileSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The name for the User Profile.
   *
   * @schema UserProfileSpecInitProvider#userProfileName
   */
  readonly userProfileName?: string;

  /**
   * The user settings. See User Settings below.
   *
   * @schema UserProfileSpecInitProvider#userSettings
   */
  readonly userSettings?: UserProfileSpecInitProviderUserSettings[];

}

/**
 * Converts an object of type 'UserProfileSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProvider(obj: UserProfileSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'singleSignOnUserIdentifier': obj.singleSignOnUserIdentifier,
    'singleSignOnUserValue': obj.singleSignOnUserValue,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'userProfileName': obj.userProfileName,
    'userSettings': obj.userSettings?.map(y => toJson_UserProfileSpecInitProviderUserSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UserProfileSpecManagementPolicies
 */
export enum UserProfileSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserProfileSpecProviderConfigRef
 */
export interface UserProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserProfileSpecProviderConfigRef#policy
   */
  readonly policy?: UserProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecProviderConfigRef(obj: UserProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserProfileSpecPublishConnectionDetailsTo
 */
export interface UserProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecPublishConnectionDetailsTo(obj: UserProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserProfileSpecWriteConnectionSecretToRef
 */
export interface UserProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecWriteConnectionSecretToRef(obj: UserProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Domain in sagemaker to populate domainId.
 *
 * @schema UserProfileSpecForProviderDomainIdRef
 */
export interface UserProfileSpecForProviderDomainIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserProfileSpecForProviderDomainIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserProfileSpecForProviderDomainIdRef#policy
   */
  readonly policy?: UserProfileSpecForProviderDomainIdRefPolicy;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderDomainIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderDomainIdRef(obj: UserProfileSpecForProviderDomainIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserProfileSpecForProviderDomainIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Domain in sagemaker to populate domainId.
 *
 * @schema UserProfileSpecForProviderDomainIdSelector
 */
export interface UserProfileSpecForProviderDomainIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserProfileSpecForProviderDomainIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserProfileSpecForProviderDomainIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserProfileSpecForProviderDomainIdSelector#policy
   */
  readonly policy?: UserProfileSpecForProviderDomainIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderDomainIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderDomainIdSelector(obj: UserProfileSpecForProviderDomainIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserProfileSpecForProviderDomainIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettings
 */
export interface UserProfileSpecForProviderUserSettings {
  /**
   * The Canvas app settings. See Canvas App Settings below.
   *
   * @schema UserProfileSpecForProviderUserSettings#canvasAppSettings
   */
  readonly canvasAppSettings?: UserProfileSpecForProviderUserSettingsCanvasAppSettings[];

  /**
   * The execution role ARN for the user.
   *
   * @schema UserProfileSpecForProviderUserSettings#executionRole
   */
  readonly executionRole?: string;

  /**
   * The Jupyter server's app settings. See Jupyter Server App Settings below.
   *
   * @schema UserProfileSpecForProviderUserSettings#jupyterServerAppSettings
   */
  readonly jupyterServerAppSettings?: UserProfileSpecForProviderUserSettingsJupyterServerAppSettings[];

  /**
   * The kernel gateway app settings. See Kernel Gateway App Settings below.
   *
   * @schema UserProfileSpecForProviderUserSettings#kernelGatewayAppSettings
   */
  readonly kernelGatewayAppSettings?: UserProfileSpecForProviderUserSettingsKernelGatewayAppSettings[];

  /**
   * The RSession app settings. See RSession App Settings below.
   *
   * @schema UserProfileSpecForProviderUserSettings#rSessionAppSettings
   */
  readonly rSessionAppSettings?: UserProfileSpecForProviderUserSettingsRSessionAppSettings[];

  /**
   * A collection of settings that configure user interaction with the RStudioServerPro app. See RStudio Server Pro App Settings below.
   *
   * @schema UserProfileSpecForProviderUserSettings#rStudioServerProAppSettings
   */
  readonly rStudioServerProAppSettings?: UserProfileSpecForProviderUserSettingsRStudioServerProAppSettings[];

  /**
   * The security groups.
   *
   * @schema UserProfileSpecForProviderUserSettings#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * The sharing settings. See Sharing Settings below.
   *
   * @schema UserProfileSpecForProviderUserSettings#sharingSettings
   */
  readonly sharingSettings?: UserProfileSpecForProviderUserSettingsSharingSettings[];

  /**
   * The TensorBoard app settings. See TensorBoard App Settings below.
   *
   * @schema UserProfileSpecForProviderUserSettings#tensorBoardAppSettings
   */
  readonly tensorBoardAppSettings?: UserProfileSpecForProviderUserSettingsTensorBoardAppSettings[];

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettings(obj: UserProfileSpecForProviderUserSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'canvasAppSettings': obj.canvasAppSettings?.map(y => toJson_UserProfileSpecForProviderUserSettingsCanvasAppSettings(y)),
    'executionRole': obj.executionRole,
    'jupyterServerAppSettings': obj.jupyterServerAppSettings?.map(y => toJson_UserProfileSpecForProviderUserSettingsJupyterServerAppSettings(y)),
    'kernelGatewayAppSettings': obj.kernelGatewayAppSettings?.map(y => toJson_UserProfileSpecForProviderUserSettingsKernelGatewayAppSettings(y)),
    'rSessionAppSettings': obj.rSessionAppSettings?.map(y => toJson_UserProfileSpecForProviderUserSettingsRSessionAppSettings(y)),
    'rStudioServerProAppSettings': obj.rStudioServerProAppSettings?.map(y => toJson_UserProfileSpecForProviderUserSettingsRStudioServerProAppSettings(y)),
    'securityGroups': obj.securityGroups?.map(y => y),
    'sharingSettings': obj.sharingSettings?.map(y => toJson_UserProfileSpecForProviderUserSettingsSharingSettings(y)),
    'tensorBoardAppSettings': obj.tensorBoardAppSettings?.map(y => toJson_UserProfileSpecForProviderUserSettingsTensorBoardAppSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettings
 */
export interface UserProfileSpecInitProviderUserSettings {
  /**
   * The Canvas app settings. See Canvas App Settings below.
   *
   * @schema UserProfileSpecInitProviderUserSettings#canvasAppSettings
   */
  readonly canvasAppSettings?: UserProfileSpecInitProviderUserSettingsCanvasAppSettings[];

  /**
   * The execution role ARN for the user.
   *
   * @schema UserProfileSpecInitProviderUserSettings#executionRole
   */
  readonly executionRole?: string;

  /**
   * The Jupyter server's app settings. See Jupyter Server App Settings below.
   *
   * @schema UserProfileSpecInitProviderUserSettings#jupyterServerAppSettings
   */
  readonly jupyterServerAppSettings?: UserProfileSpecInitProviderUserSettingsJupyterServerAppSettings[];

  /**
   * The kernel gateway app settings. See Kernel Gateway App Settings below.
   *
   * @schema UserProfileSpecInitProviderUserSettings#kernelGatewayAppSettings
   */
  readonly kernelGatewayAppSettings?: UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettings[];

  /**
   * The RSession app settings. See RSession App Settings below.
   *
   * @schema UserProfileSpecInitProviderUserSettings#rSessionAppSettings
   */
  readonly rSessionAppSettings?: UserProfileSpecInitProviderUserSettingsRSessionAppSettings[];

  /**
   * A collection of settings that configure user interaction with the RStudioServerPro app. See RStudio Server Pro App Settings below.
   *
   * @schema UserProfileSpecInitProviderUserSettings#rStudioServerProAppSettings
   */
  readonly rStudioServerProAppSettings?: UserProfileSpecInitProviderUserSettingsRStudioServerProAppSettings[];

  /**
   * The security groups.
   *
   * @schema UserProfileSpecInitProviderUserSettings#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * The sharing settings. See Sharing Settings below.
   *
   * @schema UserProfileSpecInitProviderUserSettings#sharingSettings
   */
  readonly sharingSettings?: UserProfileSpecInitProviderUserSettingsSharingSettings[];

  /**
   * The TensorBoard app settings. See TensorBoard App Settings below.
   *
   * @schema UserProfileSpecInitProviderUserSettings#tensorBoardAppSettings
   */
  readonly tensorBoardAppSettings?: UserProfileSpecInitProviderUserSettingsTensorBoardAppSettings[];

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettings(obj: UserProfileSpecInitProviderUserSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'canvasAppSettings': obj.canvasAppSettings?.map(y => toJson_UserProfileSpecInitProviderUserSettingsCanvasAppSettings(y)),
    'executionRole': obj.executionRole,
    'jupyterServerAppSettings': obj.jupyterServerAppSettings?.map(y => toJson_UserProfileSpecInitProviderUserSettingsJupyterServerAppSettings(y)),
    'kernelGatewayAppSettings': obj.kernelGatewayAppSettings?.map(y => toJson_UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettings(y)),
    'rSessionAppSettings': obj.rSessionAppSettings?.map(y => toJson_UserProfileSpecInitProviderUserSettingsRSessionAppSettings(y)),
    'rStudioServerProAppSettings': obj.rStudioServerProAppSettings?.map(y => toJson_UserProfileSpecInitProviderUserSettingsRStudioServerProAppSettings(y)),
    'securityGroups': obj.securityGroups?.map(y => y),
    'sharingSettings': obj.sharingSettings?.map(y => toJson_UserProfileSpecInitProviderUserSettingsSharingSettings(y)),
    'tensorBoardAppSettings': obj.tensorBoardAppSettings?.map(y => toJson_UserProfileSpecInitProviderUserSettingsTensorBoardAppSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserProfileSpecProviderConfigRefPolicy
 */
export interface UserProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecProviderConfigRefPolicy(obj: UserProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface UserProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecPublishConnectionDetailsToConfigRef(obj: UserProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserProfileSpecPublishConnectionDetailsToMetadata
 */
export interface UserProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecPublishConnectionDetailsToMetadata(obj: UserProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserProfileSpecForProviderDomainIdRefPolicy
 */
export interface UserProfileSpecForProviderDomainIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserProfileSpecForProviderDomainIdRefPolicy#resolution
   */
  readonly resolution?: UserProfileSpecForProviderDomainIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserProfileSpecForProviderDomainIdRefPolicy#resolve
   */
  readonly resolve?: UserProfileSpecForProviderDomainIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderDomainIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderDomainIdRefPolicy(obj: UserProfileSpecForProviderDomainIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserProfileSpecForProviderDomainIdSelectorPolicy
 */
export interface UserProfileSpecForProviderDomainIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserProfileSpecForProviderDomainIdSelectorPolicy#resolution
   */
  readonly resolution?: UserProfileSpecForProviderDomainIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserProfileSpecForProviderDomainIdSelectorPolicy#resolve
   */
  readonly resolve?: UserProfileSpecForProviderDomainIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderDomainIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderDomainIdSelectorPolicy(obj: UserProfileSpecForProviderDomainIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsCanvasAppSettings
 */
export interface UserProfileSpecForProviderUserSettingsCanvasAppSettings {
  /**
   * The model registry settings for the SageMaker Canvas application. See Model Register Settings below.
   *
   * @schema UserProfileSpecForProviderUserSettingsCanvasAppSettings#modelRegisterSettings
   */
  readonly modelRegisterSettings?: UserProfileSpecForProviderUserSettingsCanvasAppSettingsModelRegisterSettings[];

  /**
   * Time series forecast settings for the Canvas app. see Time Series Forecasting Settings below.
   *
   * @schema UserProfileSpecForProviderUserSettingsCanvasAppSettings#timeSeriesForecastingSettings
   */
  readonly timeSeriesForecastingSettings?: UserProfileSpecForProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings[];

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsCanvasAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsCanvasAppSettings(obj: UserProfileSpecForProviderUserSettingsCanvasAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'modelRegisterSettings': obj.modelRegisterSettings?.map(y => toJson_UserProfileSpecForProviderUserSettingsCanvasAppSettingsModelRegisterSettings(y)),
    'timeSeriesForecastingSettings': obj.timeSeriesForecastingSettings?.map(y => toJson_UserProfileSpecForProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettings
 */
export interface UserProfileSpecForProviderUserSettingsJupyterServerAppSettings {
  /**
   * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
   *
   * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettings#codeRepository
   */
  readonly codeRepository?: UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsCodeRepository[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsJupyterServerAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsJupyterServerAppSettings(obj: UserProfileSpecForProviderUserSettingsJupyterServerAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeRepository': obj.codeRepository?.map(y => toJson_UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsCodeRepository(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettings
 */
export interface UserProfileSpecForProviderUserSettingsKernelGatewayAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettings#customImage
   */
  readonly customImage?: UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsKernelGatewayAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsKernelGatewayAppSettings(obj: UserProfileSpecForProviderUserSettingsKernelGatewayAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettings
 */
export interface UserProfileSpecForProviderUserSettingsRSessionAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettings#customImage
   */
  readonly customImage?: UserProfileSpecForProviderUserSettingsRSessionAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec[];

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsRSessionAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsRSessionAppSettings(obj: UserProfileSpecForProviderUserSettingsRSessionAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_UserProfileSpecForProviderUserSettingsRSessionAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsRStudioServerProAppSettings
 */
export interface UserProfileSpecForProviderUserSettingsRStudioServerProAppSettings {
  /**
   * Indicates whether the current user has access to the RStudioServerPro app. Valid values are ENABLED and DISABLED.
   *
   * @schema UserProfileSpecForProviderUserSettingsRStudioServerProAppSettings#accessStatus
   */
  readonly accessStatus?: string;

  /**
   * The level of permissions that the user has within the RStudioServerPro app. This value defaults to R_STUDIO_USER. The R_STUDIO_ADMIN value allows the user access to the RStudio Administrative Dashboard. Valid values are R_STUDIO_USER and R_STUDIO_ADMIN.
   *
   * @schema UserProfileSpecForProviderUserSettingsRStudioServerProAppSettings#userGroup
   */
  readonly userGroup?: string;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsRStudioServerProAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsRStudioServerProAppSettings(obj: UserProfileSpecForProviderUserSettingsRStudioServerProAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessStatus': obj.accessStatus,
    'userGroup': obj.userGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsSharingSettings
 */
export interface UserProfileSpecForProviderUserSettingsSharingSettings {
  /**
   * Whether to include the notebook cell output when sharing the notebook. The default is Disabled. Valid values are Allowed and Disabled.
   *
   * @schema UserProfileSpecForProviderUserSettingsSharingSettings#notebookOutputOption
   */
  readonly notebookOutputOption?: string;

  /**
   * When notebook_output_option is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
   *
   * @schema UserProfileSpecForProviderUserSettingsSharingSettings#s3KmsKeyId
   */
  readonly s3KmsKeyId?: string;

  /**
   * When notebook_output_option is Allowed, the Amazon S3 bucket used to save the notebook cell output.
   *
   * @schema UserProfileSpecForProviderUserSettingsSharingSettings#s3OutputPath
   */
  readonly s3OutputPath?: string;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsSharingSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsSharingSettings(obj: UserProfileSpecForProviderUserSettingsSharingSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notebookOutputOption': obj.notebookOutputOption,
    's3KmsKeyId': obj.s3KmsKeyId,
    's3OutputPath': obj.s3OutputPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsTensorBoardAppSettings
 */
export interface UserProfileSpecForProviderUserSettingsTensorBoardAppSettings {
  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema UserProfileSpecForProviderUserSettingsTensorBoardAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec[];

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsTensorBoardAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsTensorBoardAppSettings(obj: UserProfileSpecForProviderUserSettingsTensorBoardAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsCanvasAppSettings
 */
export interface UserProfileSpecInitProviderUserSettingsCanvasAppSettings {
  /**
   * The model registry settings for the SageMaker Canvas application. See Model Register Settings below.
   *
   * @schema UserProfileSpecInitProviderUserSettingsCanvasAppSettings#modelRegisterSettings
   */
  readonly modelRegisterSettings?: UserProfileSpecInitProviderUserSettingsCanvasAppSettingsModelRegisterSettings[];

  /**
   * Time series forecast settings for the Canvas app. see Time Series Forecasting Settings below.
   *
   * @schema UserProfileSpecInitProviderUserSettingsCanvasAppSettings#timeSeriesForecastingSettings
   */
  readonly timeSeriesForecastingSettings?: UserProfileSpecInitProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings[];

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsCanvasAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsCanvasAppSettings(obj: UserProfileSpecInitProviderUserSettingsCanvasAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'modelRegisterSettings': obj.modelRegisterSettings?.map(y => toJson_UserProfileSpecInitProviderUserSettingsCanvasAppSettingsModelRegisterSettings(y)),
    'timeSeriesForecastingSettings': obj.timeSeriesForecastingSettings?.map(y => toJson_UserProfileSpecInitProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettings
 */
export interface UserProfileSpecInitProviderUserSettingsJupyterServerAppSettings {
  /**
   * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
   *
   * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettings#codeRepository
   */
  readonly codeRepository?: UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsCodeRepository[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsJupyterServerAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsJupyterServerAppSettings(obj: UserProfileSpecInitProviderUserSettingsJupyterServerAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeRepository': obj.codeRepository?.map(y => toJson_UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsCodeRepository(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettings
 */
export interface UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettings#customImage
   */
  readonly customImage?: UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec[];

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
   *
   * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettings#lifecycleConfigArns
   */
  readonly lifecycleConfigArns?: string[];

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettings(obj: UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec(y)),
    'lifecycleConfigArns': obj.lifecycleConfigArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettings
 */
export interface UserProfileSpecInitProviderUserSettingsRSessionAppSettings {
  /**
   * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettings#customImage
   */
  readonly customImage?: UserProfileSpecInitProviderUserSettingsRSessionAppSettingsCustomImage[];

  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec[];

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsRSessionAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsRSessionAppSettings(obj: UserProfileSpecInitProviderUserSettingsRSessionAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customImage': obj.customImage?.map(y => toJson_UserProfileSpecInitProviderUserSettingsRSessionAppSettingsCustomImage(y)),
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsRStudioServerProAppSettings
 */
export interface UserProfileSpecInitProviderUserSettingsRStudioServerProAppSettings {
  /**
   * Indicates whether the current user has access to the RStudioServerPro app. Valid values are ENABLED and DISABLED.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRStudioServerProAppSettings#accessStatus
   */
  readonly accessStatus?: string;

  /**
   * The level of permissions that the user has within the RStudioServerPro app. This value defaults to R_STUDIO_USER. The R_STUDIO_ADMIN value allows the user access to the RStudio Administrative Dashboard. Valid values are R_STUDIO_USER and R_STUDIO_ADMIN.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRStudioServerProAppSettings#userGroup
   */
  readonly userGroup?: string;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsRStudioServerProAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsRStudioServerProAppSettings(obj: UserProfileSpecInitProviderUserSettingsRStudioServerProAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessStatus': obj.accessStatus,
    'userGroup': obj.userGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsSharingSettings
 */
export interface UserProfileSpecInitProviderUserSettingsSharingSettings {
  /**
   * Whether to include the notebook cell output when sharing the notebook. The default is Disabled. Valid values are Allowed and Disabled.
   *
   * @schema UserProfileSpecInitProviderUserSettingsSharingSettings#notebookOutputOption
   */
  readonly notebookOutputOption?: string;

  /**
   * When notebook_output_option is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
   *
   * @schema UserProfileSpecInitProviderUserSettingsSharingSettings#s3KmsKeyId
   */
  readonly s3KmsKeyId?: string;

  /**
   * When notebook_output_option is Allowed, the Amazon S3 bucket used to save the notebook cell output.
   *
   * @schema UserProfileSpecInitProviderUserSettingsSharingSettings#s3OutputPath
   */
  readonly s3OutputPath?: string;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsSharingSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsSharingSettings(obj: UserProfileSpecInitProviderUserSettingsSharingSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notebookOutputOption': obj.notebookOutputOption,
    's3KmsKeyId': obj.s3KmsKeyId,
    's3OutputPath': obj.s3OutputPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsTensorBoardAppSettings
 */
export interface UserProfileSpecInitProviderUserSettingsTensorBoardAppSettings {
  /**
   * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
   *
   * @schema UserProfileSpecInitProviderUserSettingsTensorBoardAppSettings#defaultResourceSpec
   */
  readonly defaultResourceSpec?: UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec[];

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsTensorBoardAppSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsTensorBoardAppSettings(obj: UserProfileSpecInitProviderUserSettingsTensorBoardAppSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultResourceSpec': obj.defaultResourceSpec?.map(y => toJson_UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserProfileSpecProviderConfigRefPolicyResolution
 */
export enum UserProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserProfileSpecProviderConfigRefPolicyResolve
 */
export enum UserProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserProfileSpecForProviderDomainIdRefPolicyResolution
 */
export enum UserProfileSpecForProviderDomainIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserProfileSpecForProviderDomainIdRefPolicyResolve
 */
export enum UserProfileSpecForProviderDomainIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserProfileSpecForProviderDomainIdSelectorPolicyResolution
 */
export enum UserProfileSpecForProviderDomainIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserProfileSpecForProviderDomainIdSelectorPolicyResolve
 */
export enum UserProfileSpecForProviderDomainIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema UserProfileSpecForProviderUserSettingsCanvasAppSettingsModelRegisterSettings
 */
export interface UserProfileSpecForProviderUserSettingsCanvasAppSettingsModelRegisterSettings {
  /**
   * The Amazon Resource Name (ARN) of the SageMaker model registry account. Required only to register model versions created by a different SageMaker Canvas AWS account than the AWS account in which SageMaker model registry is set up.
   *
   * @schema UserProfileSpecForProviderUserSettingsCanvasAppSettingsModelRegisterSettings#crossAccountModelRegisterRoleArn
   */
  readonly crossAccountModelRegisterRoleArn?: string;

  /**
   * Describes whether time series forecasting is enabled or disabled in the Canvas app. Valid values are ENABLED and DISABLED.
   *
   * @schema UserProfileSpecForProviderUserSettingsCanvasAppSettingsModelRegisterSettings#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsCanvasAppSettingsModelRegisterSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsCanvasAppSettingsModelRegisterSettings(obj: UserProfileSpecForProviderUserSettingsCanvasAppSettingsModelRegisterSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crossAccountModelRegisterRoleArn': obj.crossAccountModelRegisterRoleArn,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings
 */
export interface UserProfileSpecForProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings {
  /**
   * The IAM role that Canvas passes to Amazon Forecast for time series forecasting. By default, Canvas uses the execution role specified in the UserProfile that launches the Canvas app. If an execution role is not specified in the UserProfile, Canvas uses the execution role specified in the Domain that owns the UserProfile. To allow time series forecasting, this IAM role should have the AmazonSageMakerCanvasForecastAccess policy attached and forecast.amazonaws.com added in the trust relationship as a service principal.
   *
   * @schema UserProfileSpecForProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings#amazonForecastRoleArn
   */
  readonly amazonForecastRoleArn?: string;

  /**
   * Describes whether time series forecasting is enabled or disabled in the Canvas app. Valid values are ENABLED and DISABLED.
   *
   * @schema UserProfileSpecForProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings(obj: UserProfileSpecForProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonForecastRoleArn': obj.amazonForecastRoleArn,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsCodeRepository
 */
export interface UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsCodeRepository {
  /**
   * The URL of the Git repository.
   *
   * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsCodeRepository#repositoryUrl
   */
  readonly repositoryUrl?: string;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsCodeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsCodeRepository(obj: UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsCodeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryUrl': obj.repositoryUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec
 */
export interface UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec(obj: UserProfileSpecForProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsCustomImage
 */
export interface UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * The name of the Custom Image.
   *
   * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * The version number of the Custom Image.
   *
   * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsCustomImage(obj: UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'imageName': obj.imageName,
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec
 */
export interface UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec(obj: UserProfileSpecForProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettingsCustomImage
 */
export interface UserProfileSpecForProviderUserSettingsRSessionAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * The name of the Custom Image.
   *
   * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * The version number of the Custom Image.
   *
   * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsRSessionAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsRSessionAppSettingsCustomImage(obj: UserProfileSpecForProviderUserSettingsRSessionAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'imageName': obj.imageName,
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec
 */
export interface UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec(obj: UserProfileSpecForProviderUserSettingsRSessionAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec
 */
export interface UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec(obj: UserProfileSpecForProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsCanvasAppSettingsModelRegisterSettings
 */
export interface UserProfileSpecInitProviderUserSettingsCanvasAppSettingsModelRegisterSettings {
  /**
   * The Amazon Resource Name (ARN) of the SageMaker model registry account. Required only to register model versions created by a different SageMaker Canvas AWS account than the AWS account in which SageMaker model registry is set up.
   *
   * @schema UserProfileSpecInitProviderUserSettingsCanvasAppSettingsModelRegisterSettings#crossAccountModelRegisterRoleArn
   */
  readonly crossAccountModelRegisterRoleArn?: string;

  /**
   * Describes whether time series forecasting is enabled or disabled in the Canvas app. Valid values are ENABLED and DISABLED.
   *
   * @schema UserProfileSpecInitProviderUserSettingsCanvasAppSettingsModelRegisterSettings#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsCanvasAppSettingsModelRegisterSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsCanvasAppSettingsModelRegisterSettings(obj: UserProfileSpecInitProviderUserSettingsCanvasAppSettingsModelRegisterSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crossAccountModelRegisterRoleArn': obj.crossAccountModelRegisterRoleArn,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings
 */
export interface UserProfileSpecInitProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings {
  /**
   * The IAM role that Canvas passes to Amazon Forecast for time series forecasting. By default, Canvas uses the execution role specified in the UserProfile that launches the Canvas app. If an execution role is not specified in the UserProfile, Canvas uses the execution role specified in the Domain that owns the UserProfile. To allow time series forecasting, this IAM role should have the AmazonSageMakerCanvasForecastAccess policy attached and forecast.amazonaws.com added in the trust relationship as a service principal.
   *
   * @schema UserProfileSpecInitProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings#amazonForecastRoleArn
   */
  readonly amazonForecastRoleArn?: string;

  /**
   * Describes whether time series forecasting is enabled or disabled in the Canvas app. Valid values are ENABLED and DISABLED.
   *
   * @schema UserProfileSpecInitProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings(obj: UserProfileSpecInitProviderUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonForecastRoleArn': obj.amazonForecastRoleArn,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsCodeRepository
 */
export interface UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsCodeRepository {
  /**
   * The URL of the Git repository.
   *
   * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsCodeRepository#repositoryUrl
   */
  readonly repositoryUrl?: string;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsCodeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsCodeRepository(obj: UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsCodeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryUrl': obj.repositoryUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec
 */
export interface UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec(obj: UserProfileSpecInitProviderUserSettingsJupyterServerAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsCustomImage
 */
export interface UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * The name of the Custom Image.
   *
   * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * The version number of the Custom Image.
   *
   * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsCustomImage(obj: UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'imageName': obj.imageName,
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec
 */
export interface UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec(obj: UserProfileSpecInitProviderUserSettingsKernelGatewayAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettingsCustomImage
 */
export interface UserProfileSpecInitProviderUserSettingsRSessionAppSettingsCustomImage {
  /**
   * The name of the App Image Config.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettingsCustomImage#appImageConfigName
   */
  readonly appImageConfigName?: string;

  /**
   * The name of the Custom Image.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettingsCustomImage#imageName
   */
  readonly imageName?: string;

  /**
   * The version number of the Custom Image.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettingsCustomImage#imageVersionNumber
   */
  readonly imageVersionNumber?: number;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsRSessionAppSettingsCustomImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsRSessionAppSettingsCustomImage(obj: UserProfileSpecInitProviderUserSettingsRSessionAppSettingsCustomImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appImageConfigName': obj.appImageConfigName,
    'imageName': obj.imageName,
    'imageVersionNumber': obj.imageVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec
 */
export interface UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec(obj: UserProfileSpecInitProviderUserSettingsRSessionAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec
 */
export interface UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec {
  /**
   * The instance type.
   *
   * @schema UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec#instanceType
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
   *
   * @schema UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec#lifecycleConfigArn
   */
  readonly lifecycleConfigArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
   *
   * @schema UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec#sagemakerImageArn
   */
  readonly sagemakerImageArn?: string;

  /**
   * The ARN of the image version created on the instance.
   *
   * @schema UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec#sagemakerImageVersionArn
   */
  readonly sagemakerImageVersionArn?: string;

}

/**
 * Converts an object of type 'UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec(obj: UserProfileSpecInitProviderUserSettingsTensorBoardAppSettingsDefaultResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceType': obj.instanceType,
    'lifecycleConfigArn': obj.lifecycleConfigArn,
    'sagemakerImageArn': obj.sagemakerImageArn,
    'sagemakerImageVersionArn': obj.sagemakerImageVersionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Workforce is the Schema for the Workforces API. Provides a SageMaker Workforce resource.
 *
 * @schema Workforce
 */
export class Workforce extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Workforce"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'Workforce',
  }

  /**
   * Renders a Kubernetes manifest for "Workforce".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkforceProps): any {
    return {
      ...Workforce.GVK,
      ...toJson_WorkforceProps(props),
    };
  }

  /**
   * Defines a "Workforce" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkforceProps) {
    super(scope, id, {
      ...Workforce.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Workforce.GVK,
      ...toJson_WorkforceProps(resolved),
    };
  }
}

/**
 * Workforce is the Schema for the Workforces API. Provides a SageMaker Workforce resource.
 *
 * @schema Workforce
 */
export interface WorkforceProps {
  /**
   * @schema Workforce#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkforceSpec defines the desired state of Workforce
   *
   * @schema Workforce#spec
   */
  readonly spec: WorkforceSpec;

}

/**
 * Converts an object of type 'WorkforceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceProps(obj: WorkforceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkforceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkforceSpec defines the desired state of Workforce
 *
 * @schema WorkforceSpec
 */
export interface WorkforceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkforceSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkforceSpecDeletionPolicy;

  /**
   * @schema WorkforceSpec#forProvider
   */
  readonly forProvider: WorkforceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema WorkforceSpec#initProvider
   */
  readonly initProvider?: WorkforceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkforceSpec#managementPolicies
   */
  readonly managementPolicies?: WorkforceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkforceSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkforceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkforceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkforceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkforceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkforceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkforceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpec(obj: WorkforceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkforceSpecForProvider(obj.forProvider),
    'initProvider': toJson_WorkforceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkforceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkforceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkforceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkforceSpecDeletionPolicy
 */
export enum WorkforceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkforceSpecForProvider
 */
export interface WorkforceSpecForProvider {
  /**
   * Use this parameter to configure an Amazon Cognito private workforce. A single Cognito workforce is created using and corresponds to a single Amazon Cognito user pool. Conflicts with oidc_config. see Cognito Config details below.
   *
   * @schema WorkforceSpecForProvider#cognitoConfig
   */
  readonly cognitoConfig?: WorkforceSpecForProviderCognitoConfig[];

  /**
   * Use this parameter to configure a private workforce using your own OIDC Identity Provider. Conflicts with cognito_config. see OIDC Config details below.
   *
   * @schema WorkforceSpecForProvider#oidcConfig
   */
  readonly oidcConfig?: WorkforceSpecForProviderOidcConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkforceSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of IP address ranges Used to create an allow list of IP addresses for a private workforce. By default, a workforce isn't restricted to specific IP addresses. see Source Ip Config details below.
   *
   * @schema WorkforceSpecForProvider#sourceIpConfig
   */
  readonly sourceIpConfig?: WorkforceSpecForProviderSourceIpConfig[];

  /**
   * configure a workforce using VPC. see Workforce VPC Config details below.
   *
   * @schema WorkforceSpecForProvider#workforceVpcConfig
   */
  readonly workforceVpcConfig?: WorkforceSpecForProviderWorkforceVpcConfig[];

}

/**
 * Converts an object of type 'WorkforceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProvider(obj: WorkforceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cognitoConfig': obj.cognitoConfig?.map(y => toJson_WorkforceSpecForProviderCognitoConfig(y)),
    'oidcConfig': obj.oidcConfig?.map(y => toJson_WorkforceSpecForProviderOidcConfig(y)),
    'region': obj.region,
    'sourceIpConfig': obj.sourceIpConfig?.map(y => toJson_WorkforceSpecForProviderSourceIpConfig(y)),
    'workforceVpcConfig': obj.workforceVpcConfig?.map(y => toJson_WorkforceSpecForProviderWorkforceVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema WorkforceSpecInitProvider
 */
export interface WorkforceSpecInitProvider {
  /**
   * Use this parameter to configure an Amazon Cognito private workforce. A single Cognito workforce is created using and corresponds to a single Amazon Cognito user pool. Conflicts with oidc_config. see Cognito Config details below.
   *
   * @schema WorkforceSpecInitProvider#cognitoConfig
   */
  readonly cognitoConfig?: any[];

  /**
   * Use this parameter to configure a private workforce using your own OIDC Identity Provider. Conflicts with cognito_config. see OIDC Config details below.
   *
   * @schema WorkforceSpecInitProvider#oidcConfig
   */
  readonly oidcConfig?: WorkforceSpecInitProviderOidcConfig[];

  /**
   * A list of IP address ranges Used to create an allow list of IP addresses for a private workforce. By default, a workforce isn't restricted to specific IP addresses. see Source Ip Config details below.
   *
   * @schema WorkforceSpecInitProvider#sourceIpConfig
   */
  readonly sourceIpConfig?: WorkforceSpecInitProviderSourceIpConfig[];

  /**
   * configure a workforce using VPC. see Workforce VPC Config details below.
   *
   * @schema WorkforceSpecInitProvider#workforceVpcConfig
   */
  readonly workforceVpcConfig?: WorkforceSpecInitProviderWorkforceVpcConfig[];

}

/**
 * Converts an object of type 'WorkforceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecInitProvider(obj: WorkforceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cognitoConfig': obj.cognitoConfig?.map(y => y),
    'oidcConfig': obj.oidcConfig?.map(y => toJson_WorkforceSpecInitProviderOidcConfig(y)),
    'sourceIpConfig': obj.sourceIpConfig?.map(y => toJson_WorkforceSpecInitProviderSourceIpConfig(y)),
    'workforceVpcConfig': obj.workforceVpcConfig?.map(y => toJson_WorkforceSpecInitProviderWorkforceVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkforceSpecManagementPolicies
 */
export enum WorkforceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkforceSpecProviderConfigRef
 */
export interface WorkforceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkforceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkforceSpecProviderConfigRef#policy
   */
  readonly policy?: WorkforceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkforceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecProviderConfigRef(obj: WorkforceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkforceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkforceSpecPublishConnectionDetailsTo
 */
export interface WorkforceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkforceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkforceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkforceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkforceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkforceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkforceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecPublishConnectionDetailsTo(obj: WorkforceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkforceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkforceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkforceSpecWriteConnectionSecretToRef
 */
export interface WorkforceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkforceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkforceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkforceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecWriteConnectionSecretToRef(obj: WorkforceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkforceSpecForProviderCognitoConfig
 */
export interface WorkforceSpecForProviderCognitoConfig {
  /**
   * The client ID for your Amazon Cognito user pool.
   *
   * @schema WorkforceSpecForProviderCognitoConfig#clientId
   */
  readonly clientId?: string;

  /**
   * Reference to a UserPoolClient in cognitoidp to populate clientId.
   *
   * @schema WorkforceSpecForProviderCognitoConfig#clientIdRef
   */
  readonly clientIdRef?: WorkforceSpecForProviderCognitoConfigClientIdRef;

  /**
   * Selector for a UserPoolClient in cognitoidp to populate clientId.
   *
   * @schema WorkforceSpecForProviderCognitoConfig#clientIdSelector
   */
  readonly clientIdSelector?: WorkforceSpecForProviderCognitoConfigClientIdSelector;

  /**
   * ID for your Amazon Cognito user pool.
   *
   * @schema WorkforceSpecForProviderCognitoConfig#userPool
   */
  readonly userPool?: string;

  /**
   * Reference to a UserPoolDomain in cognitoidp to populate userPool.
   *
   * @schema WorkforceSpecForProviderCognitoConfig#userPoolRef
   */
  readonly userPoolRef?: WorkforceSpecForProviderCognitoConfigUserPoolRef;

  /**
   * Selector for a UserPoolDomain in cognitoidp to populate userPool.
   *
   * @schema WorkforceSpecForProviderCognitoConfig#userPoolSelector
   */
  readonly userPoolSelector?: WorkforceSpecForProviderCognitoConfigUserPoolSelector;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderCognitoConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderCognitoConfig(obj: WorkforceSpecForProviderCognitoConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientIdRef': toJson_WorkforceSpecForProviderCognitoConfigClientIdRef(obj.clientIdRef),
    'clientIdSelector': toJson_WorkforceSpecForProviderCognitoConfigClientIdSelector(obj.clientIdSelector),
    'userPool': obj.userPool,
    'userPoolRef': toJson_WorkforceSpecForProviderCognitoConfigUserPoolRef(obj.userPoolRef),
    'userPoolSelector': toJson_WorkforceSpecForProviderCognitoConfigUserPoolSelector(obj.userPoolSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkforceSpecForProviderOidcConfig
 */
export interface WorkforceSpecForProviderOidcConfig {
  /**
   * The OIDC IdP authorization endpoint used to configure your private workforce.
   *
   * @schema WorkforceSpecForProviderOidcConfig#authorizationEndpoint
   */
  readonly authorizationEndpoint?: string;

  /**
   * The client ID for your Amazon Cognito user pool.
   *
   * @schema WorkforceSpecForProviderOidcConfig#clientId
   */
  readonly clientId?: string;

  /**
   * The OIDC IdP client secret used to configure your private workforce.
   *
   * @schema WorkforceSpecForProviderOidcConfig#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: WorkforceSpecForProviderOidcConfigClientSecretSecretRef;

  /**
   * The OIDC IdP issuer used to configure your private workforce.
   *
   * @schema WorkforceSpecForProviderOidcConfig#issuer
   */
  readonly issuer?: string;

  /**
   * The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.
   *
   * @schema WorkforceSpecForProviderOidcConfig#jwksUri
   */
  readonly jwksUri?: string;

  /**
   * The OIDC IdP logout endpoint used to configure your private workforce.
   *
   * @schema WorkforceSpecForProviderOidcConfig#logoutEndpoint
   */
  readonly logoutEndpoint?: string;

  /**
   * The OIDC IdP token endpoint used to configure your private workforce.
   *
   * @schema WorkforceSpecForProviderOidcConfig#tokenEndpoint
   */
  readonly tokenEndpoint?: string;

  /**
   * The OIDC IdP user information endpoint used to configure your private workforce.
   *
   * @schema WorkforceSpecForProviderOidcConfig#userInfoEndpoint
   */
  readonly userInfoEndpoint?: string;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderOidcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderOidcConfig(obj: WorkforceSpecForProviderOidcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationEndpoint': obj.authorizationEndpoint,
    'clientId': obj.clientId,
    'clientSecretSecretRef': toJson_WorkforceSpecForProviderOidcConfigClientSecretSecretRef(obj.clientSecretSecretRef),
    'issuer': obj.issuer,
    'jwksUri': obj.jwksUri,
    'logoutEndpoint': obj.logoutEndpoint,
    'tokenEndpoint': obj.tokenEndpoint,
    'userInfoEndpoint': obj.userInfoEndpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkforceSpecForProviderSourceIpConfig
 */
export interface WorkforceSpecForProviderSourceIpConfig {
  /**
   * A list of up to 10 CIDR values.
   *
   * @schema WorkforceSpecForProviderSourceIpConfig#cidrs
   */
  readonly cidrs?: string[];

}

/**
 * Converts an object of type 'WorkforceSpecForProviderSourceIpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderSourceIpConfig(obj: WorkforceSpecForProviderSourceIpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrs': obj.cidrs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkforceSpecForProviderWorkforceVpcConfig
 */
export interface WorkforceSpecForProviderWorkforceVpcConfig {
  /**
   * The VPC security group IDs. The security groups must be for the same VPC as specified in the subnet.
   *
   * @schema WorkforceSpecForProviderWorkforceVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * The ID of the subnets in the VPC that you want to connect.
   *
   * @schema WorkforceSpecForProviderWorkforceVpcConfig#subnets
   */
  readonly subnets?: string[];

  /**
   * The ID of the VPC that the workforce uses for communication.
   *
   * @schema WorkforceSpecForProviderWorkforceVpcConfig#vpcId
   */
  readonly vpcId?: string;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderWorkforceVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderWorkforceVpcConfig(obj: WorkforceSpecForProviderWorkforceVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnets': obj.subnets?.map(y => y),
    'vpcId': obj.vpcId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkforceSpecInitProviderOidcConfig
 */
export interface WorkforceSpecInitProviderOidcConfig {
  /**
   * The OIDC IdP authorization endpoint used to configure your private workforce.
   *
   * @schema WorkforceSpecInitProviderOidcConfig#authorizationEndpoint
   */
  readonly authorizationEndpoint?: string;

  /**
   * The client ID for your Amazon Cognito user pool.
   *
   * @schema WorkforceSpecInitProviderOidcConfig#clientId
   */
  readonly clientId?: string;

  /**
   * The OIDC IdP issuer used to configure your private workforce.
   *
   * @schema WorkforceSpecInitProviderOidcConfig#issuer
   */
  readonly issuer?: string;

  /**
   * The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.
   *
   * @schema WorkforceSpecInitProviderOidcConfig#jwksUri
   */
  readonly jwksUri?: string;

  /**
   * The OIDC IdP logout endpoint used to configure your private workforce.
   *
   * @schema WorkforceSpecInitProviderOidcConfig#logoutEndpoint
   */
  readonly logoutEndpoint?: string;

  /**
   * The OIDC IdP token endpoint used to configure your private workforce.
   *
   * @schema WorkforceSpecInitProviderOidcConfig#tokenEndpoint
   */
  readonly tokenEndpoint?: string;

  /**
   * The OIDC IdP user information endpoint used to configure your private workforce.
   *
   * @schema WorkforceSpecInitProviderOidcConfig#userInfoEndpoint
   */
  readonly userInfoEndpoint?: string;

}

/**
 * Converts an object of type 'WorkforceSpecInitProviderOidcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecInitProviderOidcConfig(obj: WorkforceSpecInitProviderOidcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationEndpoint': obj.authorizationEndpoint,
    'clientId': obj.clientId,
    'issuer': obj.issuer,
    'jwksUri': obj.jwksUri,
    'logoutEndpoint': obj.logoutEndpoint,
    'tokenEndpoint': obj.tokenEndpoint,
    'userInfoEndpoint': obj.userInfoEndpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkforceSpecInitProviderSourceIpConfig
 */
export interface WorkforceSpecInitProviderSourceIpConfig {
  /**
   * A list of up to 10 CIDR values.
   *
   * @schema WorkforceSpecInitProviderSourceIpConfig#cidrs
   */
  readonly cidrs?: string[];

}

/**
 * Converts an object of type 'WorkforceSpecInitProviderSourceIpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecInitProviderSourceIpConfig(obj: WorkforceSpecInitProviderSourceIpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrs': obj.cidrs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkforceSpecInitProviderWorkforceVpcConfig
 */
export interface WorkforceSpecInitProviderWorkforceVpcConfig {
  /**
   * The VPC security group IDs. The security groups must be for the same VPC as specified in the subnet.
   *
   * @schema WorkforceSpecInitProviderWorkforceVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * The ID of the subnets in the VPC that you want to connect.
   *
   * @schema WorkforceSpecInitProviderWorkforceVpcConfig#subnets
   */
  readonly subnets?: string[];

  /**
   * The ID of the VPC that the workforce uses for communication.
   *
   * @schema WorkforceSpecInitProviderWorkforceVpcConfig#vpcId
   */
  readonly vpcId?: string;

}

/**
 * Converts an object of type 'WorkforceSpecInitProviderWorkforceVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecInitProviderWorkforceVpcConfig(obj: WorkforceSpecInitProviderWorkforceVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnets': obj.subnets?.map(y => y),
    'vpcId': obj.vpcId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkforceSpecProviderConfigRefPolicy
 */
export interface WorkforceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkforceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkforceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkforceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkforceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkforceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecProviderConfigRefPolicy(obj: WorkforceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkforceSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkforceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkforceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkforceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkforceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkforceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecPublishConnectionDetailsToConfigRef(obj: WorkforceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkforceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkforceSpecPublishConnectionDetailsToMetadata
 */
export interface WorkforceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkforceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkforceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkforceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkforceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecPublishConnectionDetailsToMetadata(obj: WorkforceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPoolClient in cognitoidp to populate clientId.
 *
 * @schema WorkforceSpecForProviderCognitoConfigClientIdRef
 */
export interface WorkforceSpecForProviderCognitoConfigClientIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkforceSpecForProviderCognitoConfigClientIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkforceSpecForProviderCognitoConfigClientIdRef#policy
   */
  readonly policy?: WorkforceSpecForProviderCognitoConfigClientIdRefPolicy;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderCognitoConfigClientIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderCognitoConfigClientIdRef(obj: WorkforceSpecForProviderCognitoConfigClientIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkforceSpecForProviderCognitoConfigClientIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPoolClient in cognitoidp to populate clientId.
 *
 * @schema WorkforceSpecForProviderCognitoConfigClientIdSelector
 */
export interface WorkforceSpecForProviderCognitoConfigClientIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkforceSpecForProviderCognitoConfigClientIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkforceSpecForProviderCognitoConfigClientIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkforceSpecForProviderCognitoConfigClientIdSelector#policy
   */
  readonly policy?: WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicy;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderCognitoConfigClientIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderCognitoConfigClientIdSelector(obj: WorkforceSpecForProviderCognitoConfigClientIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPoolDomain in cognitoidp to populate userPool.
 *
 * @schema WorkforceSpecForProviderCognitoConfigUserPoolRef
 */
export interface WorkforceSpecForProviderCognitoConfigUserPoolRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkforceSpecForProviderCognitoConfigUserPoolRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkforceSpecForProviderCognitoConfigUserPoolRef#policy
   */
  readonly policy?: WorkforceSpecForProviderCognitoConfigUserPoolRefPolicy;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderCognitoConfigUserPoolRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderCognitoConfigUserPoolRef(obj: WorkforceSpecForProviderCognitoConfigUserPoolRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkforceSpecForProviderCognitoConfigUserPoolRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPoolDomain in cognitoidp to populate userPool.
 *
 * @schema WorkforceSpecForProviderCognitoConfigUserPoolSelector
 */
export interface WorkforceSpecForProviderCognitoConfigUserPoolSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkforceSpecForProviderCognitoConfigUserPoolSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkforceSpecForProviderCognitoConfigUserPoolSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkforceSpecForProviderCognitoConfigUserPoolSelector#policy
   */
  readonly policy?: WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicy;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderCognitoConfigUserPoolSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderCognitoConfigUserPoolSelector(obj: WorkforceSpecForProviderCognitoConfigUserPoolSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The OIDC IdP client secret used to configure your private workforce.
 *
 * @schema WorkforceSpecForProviderOidcConfigClientSecretSecretRef
 */
export interface WorkforceSpecForProviderOidcConfigClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema WorkforceSpecForProviderOidcConfigClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema WorkforceSpecForProviderOidcConfigClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkforceSpecForProviderOidcConfigClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderOidcConfigClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderOidcConfigClientSecretSecretRef(obj: WorkforceSpecForProviderOidcConfigClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkforceSpecProviderConfigRefPolicyResolution
 */
export enum WorkforceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkforceSpecProviderConfigRefPolicyResolve
 */
export enum WorkforceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkforceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkforceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkforceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkforceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkforceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkforceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkforceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkforceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkforceSpecForProviderCognitoConfigClientIdRefPolicy
 */
export interface WorkforceSpecForProviderCognitoConfigClientIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkforceSpecForProviderCognitoConfigClientIdRefPolicy#resolution
   */
  readonly resolution?: WorkforceSpecForProviderCognitoConfigClientIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkforceSpecForProviderCognitoConfigClientIdRefPolicy#resolve
   */
  readonly resolve?: WorkforceSpecForProviderCognitoConfigClientIdRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderCognitoConfigClientIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderCognitoConfigClientIdRefPolicy(obj: WorkforceSpecForProviderCognitoConfigClientIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicy
 */
export interface WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicy#resolution
   */
  readonly resolution?: WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicy#resolve
   */
  readonly resolve?: WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicy(obj: WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkforceSpecForProviderCognitoConfigUserPoolRefPolicy
 */
export interface WorkforceSpecForProviderCognitoConfigUserPoolRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkforceSpecForProviderCognitoConfigUserPoolRefPolicy#resolution
   */
  readonly resolution?: WorkforceSpecForProviderCognitoConfigUserPoolRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkforceSpecForProviderCognitoConfigUserPoolRefPolicy#resolve
   */
  readonly resolve?: WorkforceSpecForProviderCognitoConfigUserPoolRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderCognitoConfigUserPoolRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderCognitoConfigUserPoolRefPolicy(obj: WorkforceSpecForProviderCognitoConfigUserPoolRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicy
 */
export interface WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicy#resolution
   */
  readonly resolution?: WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicy#resolve
   */
  readonly resolve?: WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicy(obj: WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkforceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkforceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkforceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkforceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkforceSpecForProviderCognitoConfigClientIdRefPolicyResolution
 */
export enum WorkforceSpecForProviderCognitoConfigClientIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkforceSpecForProviderCognitoConfigClientIdRefPolicyResolve
 */
export enum WorkforceSpecForProviderCognitoConfigClientIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicyResolution
 */
export enum WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicyResolve
 */
export enum WorkforceSpecForProviderCognitoConfigClientIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkforceSpecForProviderCognitoConfigUserPoolRefPolicyResolution
 */
export enum WorkforceSpecForProviderCognitoConfigUserPoolRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkforceSpecForProviderCognitoConfigUserPoolRefPolicyResolve
 */
export enum WorkforceSpecForProviderCognitoConfigUserPoolRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicyResolution
 */
export enum WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicyResolve
 */
export enum WorkforceSpecForProviderCognitoConfigUserPoolSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Workteam is the Schema for the Workteams API. Provides a SageMaker Workteam resource.
 *
 * @schema Workteam
 */
export class Workteam extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Workteam"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sagemaker.aws.upbound.io/v1beta1',
    kind: 'Workteam',
  }

  /**
   * Renders a Kubernetes manifest for "Workteam".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkteamProps): any {
    return {
      ...Workteam.GVK,
      ...toJson_WorkteamProps(props),
    };
  }

  /**
   * Defines a "Workteam" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkteamProps) {
    super(scope, id, {
      ...Workteam.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Workteam.GVK,
      ...toJson_WorkteamProps(resolved),
    };
  }
}

/**
 * Workteam is the Schema for the Workteams API. Provides a SageMaker Workteam resource.
 *
 * @schema Workteam
 */
export interface WorkteamProps {
  /**
   * @schema Workteam#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkteamSpec defines the desired state of Workteam
   *
   * @schema Workteam#spec
   */
  readonly spec: WorkteamSpec;

}

/**
 * Converts an object of type 'WorkteamProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamProps(obj: WorkteamProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkteamSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkteamSpec defines the desired state of Workteam
 *
 * @schema WorkteamSpec
 */
export interface WorkteamSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkteamSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkteamSpecDeletionPolicy;

  /**
   * @schema WorkteamSpec#forProvider
   */
  readonly forProvider: WorkteamSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema WorkteamSpec#initProvider
   */
  readonly initProvider?: WorkteamSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkteamSpec#managementPolicies
   */
  readonly managementPolicies?: WorkteamSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkteamSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkteamSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkteamSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkteamSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkteamSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkteamSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkteamSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpec(obj: WorkteamSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkteamSpecForProvider(obj.forProvider),
    'initProvider': toJson_WorkteamSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkteamSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkteamSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkteamSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkteamSpecDeletionPolicy
 */
export enum WorkteamSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkteamSpecForProvider
 */
export interface WorkteamSpecForProvider {
  /**
   * A description of the work team.
   *
   * @schema WorkteamSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A list of Member Definitions that contains objects that identify the workers that make up the work team. Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For private workforces created using Amazon Cognito use cognito_member_definition. For workforces created using your own OIDC identity provider (IdP) use oidc_member_definition. Do not provide input for both of these parameters in a single request. see Member Definition details below.
   *
   * @schema WorkteamSpecForProvider#memberDefinition
   */
  readonly memberDefinition?: WorkteamSpecForProviderMemberDefinition[];

  /**
   * Configures notification of workers regarding available or expiring work items. see Notification Configuration details below.
   *
   * @schema WorkteamSpecForProvider#notificationConfiguration
   */
  readonly notificationConfiguration?: WorkteamSpecForProviderNotificationConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkteamSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkteamSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The name of the Workteam (must be unique).
   *
   * @schema WorkteamSpecForProvider#workforceName
   */
  readonly workforceName?: string;

  /**
   * Reference to a Workforce in sagemaker to populate workforceName.
   *
   * @schema WorkteamSpecForProvider#workforceNameRef
   */
  readonly workforceNameRef?: WorkteamSpecForProviderWorkforceNameRef;

  /**
   * Selector for a Workforce in sagemaker to populate workforceName.
   *
   * @schema WorkteamSpecForProvider#workforceNameSelector
   */
  readonly workforceNameSelector?: WorkteamSpecForProviderWorkforceNameSelector;

}

/**
 * Converts an object of type 'WorkteamSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProvider(obj: WorkteamSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'memberDefinition': obj.memberDefinition?.map(y => toJson_WorkteamSpecForProviderMemberDefinition(y)),
    'notificationConfiguration': obj.notificationConfiguration?.map(y => toJson_WorkteamSpecForProviderNotificationConfiguration(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'workforceName': obj.workforceName,
    'workforceNameRef': toJson_WorkteamSpecForProviderWorkforceNameRef(obj.workforceNameRef),
    'workforceNameSelector': toJson_WorkteamSpecForProviderWorkforceNameSelector(obj.workforceNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema WorkteamSpecInitProvider
 */
export interface WorkteamSpecInitProvider {
  /**
   * A description of the work team.
   *
   * @schema WorkteamSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * A list of Member Definitions that contains objects that identify the workers that make up the work team. Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP). For private workforces created using Amazon Cognito use cognito_member_definition. For workforces created using your own OIDC identity provider (IdP) use oidc_member_definition. Do not provide input for both of these parameters in a single request. see Member Definition details below.
   *
   * @schema WorkteamSpecInitProvider#memberDefinition
   */
  readonly memberDefinition?: WorkteamSpecInitProviderMemberDefinition[];

  /**
   * Configures notification of workers regarding available or expiring work items. see Notification Configuration details below.
   *
   * @schema WorkteamSpecInitProvider#notificationConfiguration
   */
  readonly notificationConfiguration?: WorkteamSpecInitProviderNotificationConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkteamSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkteamSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecInitProvider(obj: WorkteamSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'memberDefinition': obj.memberDefinition?.map(y => toJson_WorkteamSpecInitProviderMemberDefinition(y)),
    'notificationConfiguration': obj.notificationConfiguration?.map(y => toJson_WorkteamSpecInitProviderNotificationConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkteamSpecManagementPolicies
 */
export enum WorkteamSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkteamSpecProviderConfigRef
 */
export interface WorkteamSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkteamSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkteamSpecProviderConfigRef#policy
   */
  readonly policy?: WorkteamSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkteamSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecProviderConfigRef(obj: WorkteamSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkteamSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkteamSpecPublishConnectionDetailsTo
 */
export interface WorkteamSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkteamSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkteamSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkteamSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkteamSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkteamSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkteamSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecPublishConnectionDetailsTo(obj: WorkteamSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkteamSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkteamSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkteamSpecWriteConnectionSecretToRef
 */
export interface WorkteamSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkteamSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkteamSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkteamSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecWriteConnectionSecretToRef(obj: WorkteamSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkteamSpecForProviderMemberDefinition
 */
export interface WorkteamSpecForProviderMemberDefinition {
  /**
   * The Amazon Cognito user group that is part of the work team. See Cognito Member Definition details below.
   *
   * @schema WorkteamSpecForProviderMemberDefinition#cognitoMemberDefinition
   */
  readonly cognitoMemberDefinition?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition[];

  /**
   * A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. See Cognito Member Definition details below.
   *
   * @schema WorkteamSpecForProviderMemberDefinition#oidcMemberDefinition
   */
  readonly oidcMemberDefinition?: WorkteamSpecForProviderMemberDefinitionOidcMemberDefinition[];

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinition(obj: WorkteamSpecForProviderMemberDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cognitoMemberDefinition': obj.cognitoMemberDefinition?.map(y => toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition(y)),
    'oidcMemberDefinition': obj.oidcMemberDefinition?.map(y => toJson_WorkteamSpecForProviderMemberDefinitionOidcMemberDefinition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkteamSpecForProviderNotificationConfiguration
 */
export interface WorkteamSpecForProviderNotificationConfiguration {
  /**
   * The ARN for the SNS topic to which notifications should be published.
   *
   * @schema WorkteamSpecForProviderNotificationConfiguration#notificationTopicArn
   */
  readonly notificationTopicArn?: string;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderNotificationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderNotificationConfiguration(obj: WorkteamSpecForProviderNotificationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notificationTopicArn': obj.notificationTopicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workforce in sagemaker to populate workforceName.
 *
 * @schema WorkteamSpecForProviderWorkforceNameRef
 */
export interface WorkteamSpecForProviderWorkforceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkteamSpecForProviderWorkforceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkteamSpecForProviderWorkforceNameRef#policy
   */
  readonly policy?: WorkteamSpecForProviderWorkforceNameRefPolicy;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderWorkforceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderWorkforceNameRef(obj: WorkteamSpecForProviderWorkforceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkteamSpecForProviderWorkforceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workforce in sagemaker to populate workforceName.
 *
 * @schema WorkteamSpecForProviderWorkforceNameSelector
 */
export interface WorkteamSpecForProviderWorkforceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkteamSpecForProviderWorkforceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkteamSpecForProviderWorkforceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkteamSpecForProviderWorkforceNameSelector#policy
   */
  readonly policy?: WorkteamSpecForProviderWorkforceNameSelectorPolicy;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderWorkforceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderWorkforceNameSelector(obj: WorkteamSpecForProviderWorkforceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkteamSpecForProviderWorkforceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkteamSpecInitProviderMemberDefinition
 */
export interface WorkteamSpecInitProviderMemberDefinition {
  /**
   * The Amazon Cognito user group that is part of the work team. See Cognito Member Definition details below.
   *
   * @schema WorkteamSpecInitProviderMemberDefinition#cognitoMemberDefinition
   */
  readonly cognitoMemberDefinition?: any[];

  /**
   * A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. See Cognito Member Definition details below.
   *
   * @schema WorkteamSpecInitProviderMemberDefinition#oidcMemberDefinition
   */
  readonly oidcMemberDefinition?: WorkteamSpecInitProviderMemberDefinitionOidcMemberDefinition[];

}

/**
 * Converts an object of type 'WorkteamSpecInitProviderMemberDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecInitProviderMemberDefinition(obj: WorkteamSpecInitProviderMemberDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cognitoMemberDefinition': obj.cognitoMemberDefinition?.map(y => y),
    'oidcMemberDefinition': obj.oidcMemberDefinition?.map(y => toJson_WorkteamSpecInitProviderMemberDefinitionOidcMemberDefinition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkteamSpecInitProviderNotificationConfiguration
 */
export interface WorkteamSpecInitProviderNotificationConfiguration {
  /**
   * The ARN for the SNS topic to which notifications should be published.
   *
   * @schema WorkteamSpecInitProviderNotificationConfiguration#notificationTopicArn
   */
  readonly notificationTopicArn?: string;

}

/**
 * Converts an object of type 'WorkteamSpecInitProviderNotificationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecInitProviderNotificationConfiguration(obj: WorkteamSpecInitProviderNotificationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notificationTopicArn': obj.notificationTopicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkteamSpecProviderConfigRefPolicy
 */
export interface WorkteamSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkteamSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkteamSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkteamSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkteamSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkteamSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecProviderConfigRefPolicy(obj: WorkteamSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkteamSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkteamSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkteamSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkteamSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkteamSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkteamSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecPublishConnectionDetailsToConfigRef(obj: WorkteamSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkteamSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkteamSpecPublishConnectionDetailsToMetadata
 */
export interface WorkteamSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkteamSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkteamSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkteamSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkteamSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecPublishConnectionDetailsToMetadata(obj: WorkteamSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition {
  /**
   * An identifier for an application client. You must create the app client ID using Amazon Cognito.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition#clientId
   */
  readonly clientId?: string;

  /**
   * Reference to a UserPoolClient in cognitoidp to populate clientId.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition#clientIdRef
   */
  readonly clientIdRef?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef;

  /**
   * Selector for a UserPoolClient in cognitoidp to populate clientId.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition#clientIdSelector
   */
  readonly clientIdSelector?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector;

  /**
   * An identifier for a user group.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition#userGroup
   */
  readonly userGroup?: string;

  /**
   * Reference to a UserGroup in cognitoidp to populate userGroup.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition#userGroupRef
   */
  readonly userGroupRef?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef;

  /**
   * Selector for a UserGroup in cognitoidp to populate userGroup.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition#userGroupSelector
   */
  readonly userGroupSelector?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector;

  /**
   * An identifier for a user pool. The user pool must be in the same region as the service that you are calling.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition#userPool
   */
  readonly userPool?: string;

  /**
   * Reference to a UserPoolDomain in cognitoidp to populate userPool.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition#userPoolRef
   */
  readonly userPoolRef?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef;

  /**
   * Selector for a UserPoolDomain in cognitoidp to populate userPool.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition#userPoolSelector
   */
  readonly userPoolSelector?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientIdRef': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef(obj.clientIdRef),
    'clientIdSelector': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector(obj.clientIdSelector),
    'userGroup': obj.userGroup,
    'userGroupRef': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef(obj.userGroupRef),
    'userGroupSelector': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector(obj.userGroupSelector),
    'userPool': obj.userPool,
    'userPoolRef': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef(obj.userPoolRef),
    'userPoolSelector': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector(obj.userPoolSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkteamSpecForProviderMemberDefinitionOidcMemberDefinition
 */
export interface WorkteamSpecForProviderMemberDefinitionOidcMemberDefinition {
  /**
   * A list of comma separated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionOidcMemberDefinition#groups
   */
  readonly groups?: string[];

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionOidcMemberDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionOidcMemberDefinition(obj: WorkteamSpecForProviderMemberDefinitionOidcMemberDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groups': obj.groups?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkteamSpecForProviderWorkforceNameRefPolicy
 */
export interface WorkteamSpecForProviderWorkforceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkteamSpecForProviderWorkforceNameRefPolicy#resolution
   */
  readonly resolution?: WorkteamSpecForProviderWorkforceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkteamSpecForProviderWorkforceNameRefPolicy#resolve
   */
  readonly resolve?: WorkteamSpecForProviderWorkforceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderWorkforceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderWorkforceNameRefPolicy(obj: WorkteamSpecForProviderWorkforceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkteamSpecForProviderWorkforceNameSelectorPolicy
 */
export interface WorkteamSpecForProviderWorkforceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkteamSpecForProviderWorkforceNameSelectorPolicy#resolution
   */
  readonly resolution?: WorkteamSpecForProviderWorkforceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkteamSpecForProviderWorkforceNameSelectorPolicy#resolve
   */
  readonly resolve?: WorkteamSpecForProviderWorkforceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderWorkforceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderWorkforceNameSelectorPolicy(obj: WorkteamSpecForProviderWorkforceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkteamSpecInitProviderMemberDefinitionOidcMemberDefinition
 */
export interface WorkteamSpecInitProviderMemberDefinitionOidcMemberDefinition {
  /**
   * A list of comma separated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.
   *
   * @schema WorkteamSpecInitProviderMemberDefinitionOidcMemberDefinition#groups
   */
  readonly groups?: string[];

}

/**
 * Converts an object of type 'WorkteamSpecInitProviderMemberDefinitionOidcMemberDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecInitProviderMemberDefinitionOidcMemberDefinition(obj: WorkteamSpecInitProviderMemberDefinitionOidcMemberDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groups': obj.groups?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkteamSpecProviderConfigRefPolicyResolution
 */
export enum WorkteamSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkteamSpecProviderConfigRefPolicyResolve
 */
export enum WorkteamSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkteamSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkteamSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkteamSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkteamSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkteamSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkteamSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkteamSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkteamSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPoolClient in cognitoidp to populate clientId.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef#policy
   */
  readonly policy?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPoolClient in cognitoidp to populate clientId.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector#policy
   */
  readonly policy?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserGroup in cognitoidp to populate userGroup.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef#policy
   */
  readonly policy?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserGroup in cognitoidp to populate userGroup.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector#policy
   */
  readonly policy?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPoolDomain in cognitoidp to populate userPool.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef#policy
   */
  readonly policy?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPoolDomain in cognitoidp to populate userPool.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector#policy
   */
  readonly policy?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkteamSpecForProviderWorkforceNameRefPolicyResolution
 */
export enum WorkteamSpecForProviderWorkforceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkteamSpecForProviderWorkforceNameRefPolicyResolve
 */
export enum WorkteamSpecForProviderWorkforceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkteamSpecForProviderWorkforceNameSelectorPolicyResolution
 */
export enum WorkteamSpecForProviderWorkforceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkteamSpecForProviderWorkforceNameSelectorPolicyResolve
 */
export enum WorkteamSpecForProviderWorkforceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkteamSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkteamSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkteamSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkteamSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy#resolution
   */
  readonly resolution?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy#resolve
   */
  readonly resolve?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy#resolution
   */
  readonly resolution?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy#resolve
   */
  readonly resolve?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy#resolution
   */
  readonly resolution?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy#resolve
   */
  readonly resolve?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy#resolution
   */
  readonly resolution?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy#resolve
   */
  readonly resolve?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy#resolution
   */
  readonly resolution?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy#resolve
   */
  readonly resolve?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy
 */
export interface WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy#resolution
   */
  readonly resolution?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy#resolve
   */
  readonly resolve?: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy(obj: WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolution
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolve
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolution
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolve
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionClientIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolution
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolve
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolution
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolve
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolution
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolve
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolution
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolve
 */
export enum WorkteamSpecForProviderMemberDefinitionCognitoMemberDefinitionUserPoolSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

