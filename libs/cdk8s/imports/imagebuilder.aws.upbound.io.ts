// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Component is the Schema for the Components API. Manage an Image Builder Component
 *
 * @schema Component
 */
export class Component extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Component"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'imagebuilder.aws.upbound.io/v1beta1',
    kind: 'Component',
  }

  /**
   * Renders a Kubernetes manifest for "Component".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComponentProps): any {
    return {
      ...Component.GVK,
      ...toJson_ComponentProps(props),
    };
  }

  /**
   * Defines a "Component" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComponentProps) {
    super(scope, id, {
      ...Component.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Component.GVK,
      ...toJson_ComponentProps(resolved),
    };
  }
}

/**
 * Component is the Schema for the Components API. Manage an Image Builder Component
 *
 * @schema Component
 */
export interface ComponentProps {
  /**
   * @schema Component#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ComponentSpec defines the desired state of Component
   *
   * @schema Component#spec
   */
  readonly spec: ComponentSpec;

}

/**
 * Converts an object of type 'ComponentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentProps(obj: ComponentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComponentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ComponentSpec defines the desired state of Component
 *
 * @schema ComponentSpec
 */
export interface ComponentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ComponentSpec#deletionPolicy
   */
  readonly deletionPolicy?: ComponentSpecDeletionPolicy;

  /**
   * @schema ComponentSpec#forProvider
   */
  readonly forProvider: ComponentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ComponentSpec#initProvider
   */
  readonly initProvider?: ComponentSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ComponentSpec#managementPolicies
   */
  readonly managementPolicies?: ComponentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ComponentSpec#providerConfigRef
   */
  readonly providerConfigRef?: ComponentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ComponentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ComponentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ComponentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ComponentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ComponentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpec(obj: ComponentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ComponentSpecForProvider(obj.forProvider),
    'initProvider': toJson_ComponentSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ComponentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ComponentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ComponentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ComponentSpecDeletionPolicy
 */
export enum ComponentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ComponentSpecForProvider
 */
export interface ComponentSpecForProvider {
  /**
   * Change description of the component.
   *
   * @schema ComponentSpecForProvider#changeDescription
   */
  readonly changeDescription?: string;

  /**
   * Inline YAML string with data of the component. Exactly one of data and uri can be specified.
   *
   * @schema ComponentSpecForProvider#data
   */
  readonly data?: string;

  /**
   * Description of the component.
   *
   * @schema ComponentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key used to encrypt the component.
   *
   * @schema ComponentSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema ComponentSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: ComponentSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema ComponentSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: ComponentSpecForProviderKmsKeyIdSelector;

  /**
   * Name of the component.
   *
   * @schema ComponentSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Platform of the component.
   *
   * @schema ComponentSpecForProvider#platform
   */
  readonly platform?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ComponentSpecForProvider#region
   */
  readonly region: string;

  /**
   * Whether to retain the old version when the resource is destroyed or replacement is necessary. Defaults to false.
   *
   * @default false.
   * @schema ComponentSpecForProvider#skipDestroy
   */
  readonly skipDestroy?: boolean;

  /**
   * Set of Operating Systems (OS) supported by the component.
   *
   * @schema ComponentSpecForProvider#supportedOsVersions
   */
  readonly supportedOsVersions?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ComponentSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * S3 URI with data of the component. Exactly one of data and uri can be specified.
   *
   * @schema ComponentSpecForProvider#uri
   */
  readonly uri?: string;

  /**
   * Version of the component.
   *
   * @schema ComponentSpecForProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ComponentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecForProvider(obj: ComponentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'changeDescription': obj.changeDescription,
    'data': obj.data,
    'description': obj.description,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_ComponentSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_ComponentSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'name': obj.name,
    'platform': obj.platform,
    'region': obj.region,
    'skipDestroy': obj.skipDestroy,
    'supportedOsVersions': obj.supportedOsVersions?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'uri': obj.uri,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ComponentSpecInitProvider
 */
export interface ComponentSpecInitProvider {
  /**
   * Change description of the component.
   *
   * @schema ComponentSpecInitProvider#changeDescription
   */
  readonly changeDescription?: string;

  /**
   * Inline YAML string with data of the component. Exactly one of data and uri can be specified.
   *
   * @schema ComponentSpecInitProvider#data
   */
  readonly data?: string;

  /**
   * Description of the component.
   *
   * @schema ComponentSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Name of the component.
   *
   * @schema ComponentSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Platform of the component.
   *
   * @schema ComponentSpecInitProvider#platform
   */
  readonly platform?: string;

  /**
   * Whether to retain the old version when the resource is destroyed or replacement is necessary. Defaults to false.
   *
   * @default false.
   * @schema ComponentSpecInitProvider#skipDestroy
   */
  readonly skipDestroy?: boolean;

  /**
   * Set of Operating Systems (OS) supported by the component.
   *
   * @schema ComponentSpecInitProvider#supportedOsVersions
   */
  readonly supportedOsVersions?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ComponentSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * S3 URI with data of the component. Exactly one of data and uri can be specified.
   *
   * @schema ComponentSpecInitProvider#uri
   */
  readonly uri?: string;

  /**
   * Version of the component.
   *
   * @schema ComponentSpecInitProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ComponentSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecInitProvider(obj: ComponentSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'changeDescription': obj.changeDescription,
    'data': obj.data,
    'description': obj.description,
    'name': obj.name,
    'platform': obj.platform,
    'skipDestroy': obj.skipDestroy,
    'supportedOsVersions': obj.supportedOsVersions?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'uri': obj.uri,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ComponentSpecManagementPolicies
 */
export enum ComponentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ComponentSpecProviderConfigRef
 */
export interface ComponentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ComponentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ComponentSpecProviderConfigRef#policy
   */
  readonly policy?: ComponentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ComponentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecProviderConfigRef(obj: ComponentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ComponentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ComponentSpecPublishConnectionDetailsTo
 */
export interface ComponentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ComponentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ComponentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ComponentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ComponentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ComponentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComponentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecPublishConnectionDetailsTo(obj: ComponentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ComponentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ComponentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ComponentSpecWriteConnectionSecretToRef
 */
export interface ComponentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ComponentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ComponentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ComponentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecWriteConnectionSecretToRef(obj: ComponentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema ComponentSpecForProviderKmsKeyIdRef
 */
export interface ComponentSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ComponentSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ComponentSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: ComponentSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'ComponentSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecForProviderKmsKeyIdRef(obj: ComponentSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ComponentSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema ComponentSpecForProviderKmsKeyIdSelector
 */
export interface ComponentSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ComponentSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ComponentSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ComponentSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: ComponentSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'ComponentSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecForProviderKmsKeyIdSelector(obj: ComponentSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ComponentSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ComponentSpecProviderConfigRefPolicy
 */
export interface ComponentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ComponentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ComponentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ComponentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ComponentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ComponentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecProviderConfigRefPolicy(obj: ComponentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ComponentSpecPublishConnectionDetailsToConfigRef
 */
export interface ComponentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ComponentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ComponentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ComponentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ComponentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecPublishConnectionDetailsToConfigRef(obj: ComponentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ComponentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ComponentSpecPublishConnectionDetailsToMetadata
 */
export interface ComponentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ComponentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ComponentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ComponentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ComponentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecPublishConnectionDetailsToMetadata(obj: ComponentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ComponentSpecForProviderKmsKeyIdRefPolicy
 */
export interface ComponentSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ComponentSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: ComponentSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ComponentSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: ComponentSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ComponentSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecForProviderKmsKeyIdRefPolicy(obj: ComponentSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ComponentSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface ComponentSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ComponentSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: ComponentSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ComponentSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: ComponentSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ComponentSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecForProviderKmsKeyIdSelectorPolicy(obj: ComponentSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ComponentSpecProviderConfigRefPolicyResolution
 */
export enum ComponentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ComponentSpecProviderConfigRefPolicyResolve
 */
export enum ComponentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ComponentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ComponentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ComponentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ComponentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ComponentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ComponentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ComponentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecPublishConnectionDetailsToConfigRefPolicy(obj: ComponentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ComponentSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum ComponentSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ComponentSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum ComponentSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ComponentSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum ComponentSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ComponentSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum ComponentSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ComponentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ComponentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ComponentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ComponentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ContainerRecipe is the Schema for the ContainerRecipes API. Manage an Image Builder Container Recipe
 *
 * @schema ContainerRecipe
 */
export class ContainerRecipe extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ContainerRecipe"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'imagebuilder.aws.upbound.io/v1beta1',
    kind: 'ContainerRecipe',
  }

  /**
   * Renders a Kubernetes manifest for "ContainerRecipe".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ContainerRecipeProps): any {
    return {
      ...ContainerRecipe.GVK,
      ...toJson_ContainerRecipeProps(props),
    };
  }

  /**
   * Defines a "ContainerRecipe" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ContainerRecipeProps) {
    super(scope, id, {
      ...ContainerRecipe.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ContainerRecipe.GVK,
      ...toJson_ContainerRecipeProps(resolved),
    };
  }
}

/**
 * ContainerRecipe is the Schema for the ContainerRecipes API. Manage an Image Builder Container Recipe
 *
 * @schema ContainerRecipe
 */
export interface ContainerRecipeProps {
  /**
   * @schema ContainerRecipe#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ContainerRecipeSpec defines the desired state of ContainerRecipe
   *
   * @schema ContainerRecipe#spec
   */
  readonly spec: ContainerRecipeSpec;

}

/**
 * Converts an object of type 'ContainerRecipeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeProps(obj: ContainerRecipeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContainerRecipeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerRecipeSpec defines the desired state of ContainerRecipe
 *
 * @schema ContainerRecipeSpec
 */
export interface ContainerRecipeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ContainerRecipeSpec#deletionPolicy
   */
  readonly deletionPolicy?: ContainerRecipeSpecDeletionPolicy;

  /**
   * @schema ContainerRecipeSpec#forProvider
   */
  readonly forProvider: ContainerRecipeSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ContainerRecipeSpec#initProvider
   */
  readonly initProvider?: ContainerRecipeSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ContainerRecipeSpec#managementPolicies
   */
  readonly managementPolicies?: ContainerRecipeSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ContainerRecipeSpec#providerConfigRef
   */
  readonly providerConfigRef?: ContainerRecipeSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ContainerRecipeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ContainerRecipeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ContainerRecipeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ContainerRecipeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ContainerRecipeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpec(obj: ContainerRecipeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ContainerRecipeSpecForProvider(obj.forProvider),
    'initProvider': toJson_ContainerRecipeSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ContainerRecipeSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ContainerRecipeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ContainerRecipeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ContainerRecipeSpecDeletionPolicy
 */
export enum ContainerRecipeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ContainerRecipeSpecForProvider
 */
export interface ContainerRecipeSpecForProvider {
  /**
   * Ordered configuration block(s) with components for the container recipe. Detailed below.
   *
   * @schema ContainerRecipeSpecForProvider#component
   */
  readonly component?: ContainerRecipeSpecForProviderComponent[];

  /**
   * The type of the container to create. Valid values: DOCKER.
   *
   * @schema ContainerRecipeSpecForProvider#containerType
   */
  readonly containerType?: string;

  /**
   * The description of the container recipe.
   *
   * @schema ContainerRecipeSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The Dockerfile template used to build the image as an inline data blob.
   *
   * @schema ContainerRecipeSpecForProvider#dockerfileTemplateData
   */
  readonly dockerfileTemplateData?: string;

  /**
   * The Amazon S3 URI for the Dockerfile that will be used to build the container image.
   *
   * @schema ContainerRecipeSpecForProvider#dockerfileTemplateUri
   */
  readonly dockerfileTemplateUri?: string;

  /**
   * Configuration block used to configure an instance for building and testing container images. Detailed below.
   *
   * @schema ContainerRecipeSpecForProvider#instanceConfiguration
   */
  readonly instanceConfiguration?: ContainerRecipeSpecForProviderInstanceConfiguration[];

  /**
   * The KMS key used to encrypt the container image.
   *
   * @schema ContainerRecipeSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema ContainerRecipeSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: ContainerRecipeSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema ContainerRecipeSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: ContainerRecipeSpecForProviderKmsKeyIdSelector;

  /**
   * The name of the container recipe.
   *
   * @schema ContainerRecipeSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The base image for the container recipe.
   *
   * @schema ContainerRecipeSpecForProvider#parentImage
   */
  readonly parentImage?: string;

  /**
   * Specifies the operating system platform when you use a custom base image.
   *
   * @schema ContainerRecipeSpecForProvider#platformOverride
   */
  readonly platformOverride?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ContainerRecipeSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ContainerRecipeSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The destination repository for the container image. Detailed below.
   *
   * @schema ContainerRecipeSpecForProvider#targetRepository
   */
  readonly targetRepository?: ContainerRecipeSpecForProviderTargetRepository[];

  /**
   * Version of the container recipe.
   *
   * @schema ContainerRecipeSpecForProvider#version
   */
  readonly version?: string;

  /**
   * The working directory to be used during build and test workflows.
   *
   * @schema ContainerRecipeSpecForProvider#workingDirectory
   */
  readonly workingDirectory?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProvider(obj: ContainerRecipeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'component': obj.component?.map(y => toJson_ContainerRecipeSpecForProviderComponent(y)),
    'containerType': obj.containerType,
    'description': obj.description,
    'dockerfileTemplateData': obj.dockerfileTemplateData,
    'dockerfileTemplateUri': obj.dockerfileTemplateUri,
    'instanceConfiguration': obj.instanceConfiguration?.map(y => toJson_ContainerRecipeSpecForProviderInstanceConfiguration(y)),
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_ContainerRecipeSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_ContainerRecipeSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'name': obj.name,
    'parentImage': obj.parentImage,
    'platformOverride': obj.platformOverride,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetRepository': obj.targetRepository?.map(y => toJson_ContainerRecipeSpecForProviderTargetRepository(y)),
    'version': obj.version,
    'workingDirectory': obj.workingDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ContainerRecipeSpecInitProvider
 */
export interface ContainerRecipeSpecInitProvider {
  /**
   * Ordered configuration block(s) with components for the container recipe. Detailed below.
   *
   * @schema ContainerRecipeSpecInitProvider#component
   */
  readonly component?: ContainerRecipeSpecInitProviderComponent[];

  /**
   * The type of the container to create. Valid values: DOCKER.
   *
   * @schema ContainerRecipeSpecInitProvider#containerType
   */
  readonly containerType?: string;

  /**
   * The description of the container recipe.
   *
   * @schema ContainerRecipeSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The Dockerfile template used to build the image as an inline data blob.
   *
   * @schema ContainerRecipeSpecInitProvider#dockerfileTemplateData
   */
  readonly dockerfileTemplateData?: string;

  /**
   * The Amazon S3 URI for the Dockerfile that will be used to build the container image.
   *
   * @schema ContainerRecipeSpecInitProvider#dockerfileTemplateUri
   */
  readonly dockerfileTemplateUri?: string;

  /**
   * Configuration block used to configure an instance for building and testing container images. Detailed below.
   *
   * @schema ContainerRecipeSpecInitProvider#instanceConfiguration
   */
  readonly instanceConfiguration?: ContainerRecipeSpecInitProviderInstanceConfiguration[];

  /**
   * The name of the container recipe.
   *
   * @schema ContainerRecipeSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The base image for the container recipe.
   *
   * @schema ContainerRecipeSpecInitProvider#parentImage
   */
  readonly parentImage?: string;

  /**
   * Specifies the operating system platform when you use a custom base image.
   *
   * @schema ContainerRecipeSpecInitProvider#platformOverride
   */
  readonly platformOverride?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ContainerRecipeSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The destination repository for the container image. Detailed below.
   *
   * @schema ContainerRecipeSpecInitProvider#targetRepository
   */
  readonly targetRepository?: ContainerRecipeSpecInitProviderTargetRepository[];

  /**
   * Version of the container recipe.
   *
   * @schema ContainerRecipeSpecInitProvider#version
   */
  readonly version?: string;

  /**
   * The working directory to be used during build and test workflows.
   *
   * @schema ContainerRecipeSpecInitProvider#workingDirectory
   */
  readonly workingDirectory?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecInitProvider(obj: ContainerRecipeSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'component': obj.component?.map(y => toJson_ContainerRecipeSpecInitProviderComponent(y)),
    'containerType': obj.containerType,
    'description': obj.description,
    'dockerfileTemplateData': obj.dockerfileTemplateData,
    'dockerfileTemplateUri': obj.dockerfileTemplateUri,
    'instanceConfiguration': obj.instanceConfiguration?.map(y => toJson_ContainerRecipeSpecInitProviderInstanceConfiguration(y)),
    'name': obj.name,
    'parentImage': obj.parentImage,
    'platformOverride': obj.platformOverride,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetRepository': obj.targetRepository?.map(y => toJson_ContainerRecipeSpecInitProviderTargetRepository(y)),
    'version': obj.version,
    'workingDirectory': obj.workingDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ContainerRecipeSpecManagementPolicies
 */
export enum ContainerRecipeSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ContainerRecipeSpecProviderConfigRef
 */
export interface ContainerRecipeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerRecipeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerRecipeSpecProviderConfigRef#policy
   */
  readonly policy?: ContainerRecipeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ContainerRecipeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecProviderConfigRef(obj: ContainerRecipeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerRecipeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ContainerRecipeSpecPublishConnectionDetailsTo
 */
export interface ContainerRecipeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ContainerRecipeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ContainerRecipeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ContainerRecipeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ContainerRecipeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ContainerRecipeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecPublishConnectionDetailsTo(obj: ContainerRecipeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ContainerRecipeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ContainerRecipeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ContainerRecipeSpecWriteConnectionSecretToRef
 */
export interface ContainerRecipeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ContainerRecipeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ContainerRecipeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecWriteConnectionSecretToRef(obj: ContainerRecipeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecForProviderComponent
 */
export interface ContainerRecipeSpecForProviderComponent {
  /**
   * Amazon Resource Name (ARN) of the Image Builder Component to associate.
   *
   * @schema ContainerRecipeSpecForProviderComponent#componentArn
   */
  readonly componentArn?: string;

  /**
   * Reference to a Component in imagebuilder to populate componentArn.
   *
   * @schema ContainerRecipeSpecForProviderComponent#componentArnRef
   */
  readonly componentArnRef?: ContainerRecipeSpecForProviderComponentComponentArnRef;

  /**
   * Selector for a Component in imagebuilder to populate componentArn.
   *
   * @schema ContainerRecipeSpecForProviderComponent#componentArnSelector
   */
  readonly componentArnSelector?: ContainerRecipeSpecForProviderComponentComponentArnSelector;

  /**
   * Configuration block(s) for parameters to configure the component. Detailed below.
   *
   * @schema ContainerRecipeSpecForProviderComponent#parameter
   */
  readonly parameter?: ContainerRecipeSpecForProviderComponentParameter[];

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderComponent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderComponent(obj: ContainerRecipeSpecForProviderComponent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'componentArn': obj.componentArn,
    'componentArnRef': toJson_ContainerRecipeSpecForProviderComponentComponentArnRef(obj.componentArnRef),
    'componentArnSelector': toJson_ContainerRecipeSpecForProviderComponentComponentArnSelector(obj.componentArnSelector),
    'parameter': obj.parameter?.map(y => toJson_ContainerRecipeSpecForProviderComponentParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecForProviderInstanceConfiguration
 */
export interface ContainerRecipeSpecForProviderInstanceConfiguration {
  /**
   * Configuration block(s) with block device mappings for the container recipe. Detailed below.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfiguration#blockDeviceMapping
   */
  readonly blockDeviceMapping?: ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping[];

  /**
   * The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfiguration#image
   */
  readonly image?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderInstanceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderInstanceConfiguration(obj: ContainerRecipeSpecForProviderInstanceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockDeviceMapping': obj.blockDeviceMapping?.map(y => toJson_ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping(y)),
    'image': obj.image,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema ContainerRecipeSpecForProviderKmsKeyIdRef
 */
export interface ContainerRecipeSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerRecipeSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerRecipeSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: ContainerRecipeSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderKmsKeyIdRef(obj: ContainerRecipeSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerRecipeSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema ContainerRecipeSpecForProviderKmsKeyIdSelector
 */
export interface ContainerRecipeSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ContainerRecipeSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ContainerRecipeSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ContainerRecipeSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderKmsKeyIdSelector(obj: ContainerRecipeSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecForProviderTargetRepository
 */
export interface ContainerRecipeSpecForProviderTargetRepository {
  /**
   * The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepository#repositoryName
   */
  readonly repositoryName?: string;

  /**
   * Reference to a Repository in ecr to populate repositoryName.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepository#repositoryNameRef
   */
  readonly repositoryNameRef?: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRef;

  /**
   * Selector for a Repository in ecr to populate repositoryName.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepository#repositoryNameSelector
   */
  readonly repositoryNameSelector?: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelector;

  /**
   * The service in which this image is registered. Valid values: ECR.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepository#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderTargetRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderTargetRepository(obj: ContainerRecipeSpecForProviderTargetRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryName': obj.repositoryName,
    'repositoryNameRef': toJson_ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRef(obj.repositoryNameRef),
    'repositoryNameSelector': toJson_ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelector(obj.repositoryNameSelector),
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecInitProviderComponent
 */
export interface ContainerRecipeSpecInitProviderComponent {
  /**
   * Configuration block(s) for parameters to configure the component. Detailed below.
   *
   * @schema ContainerRecipeSpecInitProviderComponent#parameter
   */
  readonly parameter?: ContainerRecipeSpecInitProviderComponentParameter[];

}

/**
 * Converts an object of type 'ContainerRecipeSpecInitProviderComponent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecInitProviderComponent(obj: ContainerRecipeSpecInitProviderComponent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameter': obj.parameter?.map(y => toJson_ContainerRecipeSpecInitProviderComponentParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecInitProviderInstanceConfiguration
 */
export interface ContainerRecipeSpecInitProviderInstanceConfiguration {
  /**
   * Configuration block(s) with block device mappings for the container recipe. Detailed below.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfiguration#blockDeviceMapping
   */
  readonly blockDeviceMapping?: ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping[];

  /**
   * The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfiguration#image
   */
  readonly image?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecInitProviderInstanceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecInitProviderInstanceConfiguration(obj: ContainerRecipeSpecInitProviderInstanceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockDeviceMapping': obj.blockDeviceMapping?.map(y => toJson_ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping(y)),
    'image': obj.image,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecInitProviderTargetRepository
 */
export interface ContainerRecipeSpecInitProviderTargetRepository {
  /**
   * The service in which this image is registered. Valid values: ECR.
   *
   * @schema ContainerRecipeSpecInitProviderTargetRepository#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecInitProviderTargetRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecInitProviderTargetRepository(obj: ContainerRecipeSpecInitProviderTargetRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContainerRecipeSpecProviderConfigRefPolicy
 */
export interface ContainerRecipeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerRecipeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ContainerRecipeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerRecipeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ContainerRecipeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerRecipeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecProviderConfigRefPolicy(obj: ContainerRecipeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ContainerRecipeSpecPublishConnectionDetailsToConfigRef
 */
export interface ContainerRecipeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerRecipeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerRecipeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ContainerRecipeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecPublishConnectionDetailsToConfigRef(obj: ContainerRecipeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ContainerRecipeSpecPublishConnectionDetailsToMetadata
 */
export interface ContainerRecipeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContainerRecipeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContainerRecipeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ContainerRecipeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecPublishConnectionDetailsToMetadata(obj: ContainerRecipeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Component in imagebuilder to populate componentArn.
 *
 * @schema ContainerRecipeSpecForProviderComponentComponentArnRef
 */
export interface ContainerRecipeSpecForProviderComponentComponentArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerRecipeSpecForProviderComponentComponentArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerRecipeSpecForProviderComponentComponentArnRef#policy
   */
  readonly policy?: ContainerRecipeSpecForProviderComponentComponentArnRefPolicy;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderComponentComponentArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderComponentComponentArnRef(obj: ContainerRecipeSpecForProviderComponentComponentArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerRecipeSpecForProviderComponentComponentArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Component in imagebuilder to populate componentArn.
 *
 * @schema ContainerRecipeSpecForProviderComponentComponentArnSelector
 */
export interface ContainerRecipeSpecForProviderComponentComponentArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ContainerRecipeSpecForProviderComponentComponentArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ContainerRecipeSpecForProviderComponentComponentArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ContainerRecipeSpecForProviderComponentComponentArnSelector#policy
   */
  readonly policy?: ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicy;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderComponentComponentArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderComponentComponentArnSelector(obj: ContainerRecipeSpecForProviderComponentComponentArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecForProviderComponentParameter
 */
export interface ContainerRecipeSpecForProviderComponentParameter {
  /**
   * The name of the component parameter.
   *
   * @schema ContainerRecipeSpecForProviderComponentParameter#name
   */
  readonly name?: string;

  /**
   * The value for the named component parameter.
   *
   * @schema ContainerRecipeSpecForProviderComponentParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderComponentParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderComponentParameter(obj: ContainerRecipeSpecForProviderComponentParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping
 */
export interface ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping {
  /**
   * Name of the device. For example, /dev/sda or /dev/xvdb.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping#deviceName
   */
  readonly deviceName?: string;

  /**
   * Configuration block with Elastic Block Storage (EBS) block device mapping settings. Detailed below.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping#ebs
   */
  readonly ebs?: ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs[];

  /**
   * Set to true to remove a mapping from the parent image.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping#noDevice
   */
  readonly noDevice?: boolean;

  /**
   * Virtual device name. For example, ephemeral0. Instance store volumes are numbered starting from 0.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping#virtualName
   */
  readonly virtualName?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping(obj: ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'ebs': obj.ebs?.map(y => toJson_ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs(y)),
    'noDevice': obj.noDevice,
    'virtualName': obj.virtualName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContainerRecipeSpecForProviderKmsKeyIdRefPolicy
 */
export interface ContainerRecipeSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerRecipeSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: ContainerRecipeSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerRecipeSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: ContainerRecipeSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderKmsKeyIdRefPolicy(obj: ContainerRecipeSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicy(obj: ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Repository in ecr to populate repositoryName.
 *
 * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRef
 */
export interface ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRef#policy
   */
  readonly policy?: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicy;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRef(obj: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Repository in ecr to populate repositoryName.
 *
 * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelector
 */
export interface ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelector#policy
   */
  readonly policy?: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicy;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelector(obj: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecInitProviderComponentParameter
 */
export interface ContainerRecipeSpecInitProviderComponentParameter {
  /**
   * The name of the component parameter.
   *
   * @schema ContainerRecipeSpecInitProviderComponentParameter#name
   */
  readonly name?: string;

  /**
   * The value for the named component parameter.
   *
   * @schema ContainerRecipeSpecInitProviderComponentParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecInitProviderComponentParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecInitProviderComponentParameter(obj: ContainerRecipeSpecInitProviderComponentParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping
 */
export interface ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping {
  /**
   * Name of the device. For example, /dev/sda or /dev/xvdb.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping#deviceName
   */
  readonly deviceName?: string;

  /**
   * Configuration block with Elastic Block Storage (EBS) block device mapping settings. Detailed below.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping#ebs
   */
  readonly ebs?: ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs[];

  /**
   * Set to true to remove a mapping from the parent image.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping#noDevice
   */
  readonly noDevice?: boolean;

  /**
   * Virtual device name. For example, ephemeral0. Instance store volumes are numbered starting from 0.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping#virtualName
   */
  readonly virtualName?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping(obj: ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'ebs': obj.ebs?.map(y => toJson_ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs(y)),
    'noDevice': obj.noDevice,
    'virtualName': obj.virtualName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerRecipeSpecProviderConfigRefPolicyResolution
 */
export enum ContainerRecipeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerRecipeSpecProviderConfigRefPolicyResolve
 */
export enum ContainerRecipeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicy(obj: ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContainerRecipeSpecForProviderComponentComponentArnRefPolicy
 */
export interface ContainerRecipeSpecForProviderComponentComponentArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerRecipeSpecForProviderComponentComponentArnRefPolicy#resolution
   */
  readonly resolution?: ContainerRecipeSpecForProviderComponentComponentArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerRecipeSpecForProviderComponentComponentArnRefPolicy#resolve
   */
  readonly resolve?: ContainerRecipeSpecForProviderComponentComponentArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderComponentComponentArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderComponentComponentArnRefPolicy(obj: ContainerRecipeSpecForProviderComponentComponentArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicy
 */
export interface ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicy#resolution
   */
  readonly resolution?: ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicy#resolve
   */
  readonly resolve?: ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicy(obj: ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs
 */
export interface ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs {
  /**
   * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
   *
   * @default unset, which is the value inherited from the parent image.
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs#deleteOnTermination
   */
  readonly deleteOnTermination?: string;

  /**
   * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
   *
   * @default unset, which is the value inherited from the parent image.
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs#encrypted
   */
  readonly encrypted?: string;

  /**
   * Number of Input/Output (I/O) operations per second to provision for an io1 or io2 volume.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs#iops
   */
  readonly iops?: number;

  /**
   * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key for encryption.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Identifier of the EC2 Volume Snapshot.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs#snapshotId
   */
  readonly snapshotId?: string;

  /**
   * For GP3 volumes only. The throughput in MiB/s that the volume supports.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs#throughput
   */
  readonly throughput?: number;

  /**
   * Size of the volume, in GiB.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * Type of the volume. For example, gp2 or io2.
   *
   * @schema ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs(obj: ContainerRecipeSpecForProviderInstanceConfigurationBlockDeviceMappingEbs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'kmsKeyId': obj.kmsKeyId,
    'snapshotId': obj.snapshotId,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerRecipeSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum ContainerRecipeSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerRecipeSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum ContainerRecipeSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum ContainerRecipeSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicy
 */
export interface ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicy#resolution
   */
  readonly resolution?: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicy#resolve
   */
  readonly resolve?: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicy(obj: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicy
 */
export interface ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicy#resolution
   */
  readonly resolution?: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicy#resolve
   */
  readonly resolve?: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicy(obj: ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs
 */
export interface ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs {
  /**
   * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
   *
   * @default unset, which is the value inherited from the parent image.
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs#deleteOnTermination
   */
  readonly deleteOnTermination?: string;

  /**
   * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
   *
   * @default unset, which is the value inherited from the parent image.
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs#encrypted
   */
  readonly encrypted?: string;

  /**
   * Number of Input/Output (I/O) operations per second to provision for an io1 or io2 volume.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs#iops
   */
  readonly iops?: number;

  /**
   * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key for encryption.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Identifier of the EC2 Volume Snapshot.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs#snapshotId
   */
  readonly snapshotId?: string;

  /**
   * For GP3 volumes only. The throughput in MiB/s that the volume supports.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs#throughput
   */
  readonly throughput?: number;

  /**
   * Size of the volume, in GiB.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * Type of the volume. For example, gp2 or io2.
   *
   * @schema ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs(obj: ContainerRecipeSpecInitProviderInstanceConfigurationBlockDeviceMappingEbs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'kmsKeyId': obj.kmsKeyId,
    'snapshotId': obj.snapshotId,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ContainerRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerRecipeSpecForProviderComponentComponentArnRefPolicyResolution
 */
export enum ContainerRecipeSpecForProviderComponentComponentArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerRecipeSpecForProviderComponentComponentArnRefPolicyResolve
 */
export enum ContainerRecipeSpecForProviderComponentComponentArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicyResolution
 */
export enum ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicyResolve
 */
export enum ContainerRecipeSpecForProviderComponentComponentArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicyResolution
 */
export enum ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicyResolve
 */
export enum ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicyResolution
 */
export enum ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicyResolve
 */
export enum ContainerRecipeSpecForProviderTargetRepositoryRepositoryNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DistributionConfiguration is the Schema for the DistributionConfigurations API. Manage an Image Builder Distribution Configuration
 *
 * @schema DistributionConfiguration
 */
export class DistributionConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DistributionConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'imagebuilder.aws.upbound.io/v1beta1',
    kind: 'DistributionConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "DistributionConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DistributionConfigurationProps): any {
    return {
      ...DistributionConfiguration.GVK,
      ...toJson_DistributionConfigurationProps(props),
    };
  }

  /**
   * Defines a "DistributionConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DistributionConfigurationProps) {
    super(scope, id, {
      ...DistributionConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DistributionConfiguration.GVK,
      ...toJson_DistributionConfigurationProps(resolved),
    };
  }
}

/**
 * DistributionConfiguration is the Schema for the DistributionConfigurations API. Manage an Image Builder Distribution Configuration
 *
 * @schema DistributionConfiguration
 */
export interface DistributionConfigurationProps {
  /**
   * @schema DistributionConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DistributionConfigurationSpec defines the desired state of DistributionConfiguration
   *
   * @schema DistributionConfiguration#spec
   */
  readonly spec: DistributionConfigurationSpec;

}

/**
 * Converts an object of type 'DistributionConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationProps(obj: DistributionConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DistributionConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DistributionConfigurationSpec defines the desired state of DistributionConfiguration
 *
 * @schema DistributionConfigurationSpec
 */
export interface DistributionConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DistributionConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: DistributionConfigurationSpecDeletionPolicy;

  /**
   * @schema DistributionConfigurationSpec#forProvider
   */
  readonly forProvider: DistributionConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DistributionConfigurationSpec#initProvider
   */
  readonly initProvider?: DistributionConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DistributionConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: DistributionConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DistributionConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: DistributionConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DistributionConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DistributionConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DistributionConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DistributionConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DistributionConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpec(obj: DistributionConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DistributionConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_DistributionConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DistributionConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DistributionConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DistributionConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DistributionConfigurationSpecDeletionPolicy
 */
export enum DistributionConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DistributionConfigurationSpecForProvider
 */
export interface DistributionConfigurationSpecForProvider {
  /**
   * Description of the distribution configuration.
   *
   * @schema DistributionConfigurationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * One or more configuration blocks with distribution settings. Detailed below.
   *
   * @schema DistributionConfigurationSpecForProvider#distribution
   */
  readonly distribution?: DistributionConfigurationSpecForProviderDistribution[];

  /**
   * Name of the distribution configuration.
   *
   * @schema DistributionConfigurationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * AWS Region for the distribution. Region is the region you'd like your resource to be created in.
   *
   * @schema DistributionConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DistributionConfigurationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DistributionConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecForProvider(obj: DistributionConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'distribution': obj.distribution?.map(y => toJson_DistributionConfigurationSpecForProviderDistribution(y)),
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DistributionConfigurationSpecInitProvider
 */
export interface DistributionConfigurationSpecInitProvider {
  /**
   * Description of the distribution configuration.
   *
   * @schema DistributionConfigurationSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * One or more configuration blocks with distribution settings. Detailed below.
   *
   * @schema DistributionConfigurationSpecInitProvider#distribution
   */
  readonly distribution?: DistributionConfigurationSpecInitProviderDistribution[];

  /**
   * Name of the distribution configuration.
   *
   * @schema DistributionConfigurationSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DistributionConfigurationSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DistributionConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecInitProvider(obj: DistributionConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'distribution': obj.distribution?.map(y => toJson_DistributionConfigurationSpecInitProviderDistribution(y)),
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DistributionConfigurationSpecManagementPolicies
 */
export enum DistributionConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DistributionConfigurationSpecProviderConfigRef
 */
export interface DistributionConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DistributionConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DistributionConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: DistributionConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecProviderConfigRef(obj: DistributionConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DistributionConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DistributionConfigurationSpecPublishConnectionDetailsTo
 */
export interface DistributionConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DistributionConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DistributionConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DistributionConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DistributionConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DistributionConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecPublishConnectionDetailsTo(obj: DistributionConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DistributionConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DistributionConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DistributionConfigurationSpecWriteConnectionSecretToRef
 */
export interface DistributionConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DistributionConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DistributionConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecWriteConnectionSecretToRef(obj: DistributionConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecForProviderDistribution
 */
export interface DistributionConfigurationSpecForProviderDistribution {
  /**
   * Configuration block with Amazon Machine Image (AMI) distribution settings. Detailed below.
   *
   * @schema DistributionConfigurationSpecForProviderDistribution#amiDistributionConfiguration
   */
  readonly amiDistributionConfiguration?: DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration[];

  /**
   * Configuration block with container distribution settings. Detailed below.
   *
   * @schema DistributionConfigurationSpecForProviderDistribution#containerDistributionConfiguration
   */
  readonly containerDistributionConfiguration?: DistributionConfigurationSpecForProviderDistributionContainerDistributionConfiguration[];

  /**
   * Set of Windows faster-launching configurations to use for AMI distribution. Detailed below.
   *
   * @schema DistributionConfigurationSpecForProviderDistribution#fastLaunchConfiguration
   */
  readonly fastLaunchConfiguration?: DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration[];

  /**
   * Set of launch template configuration settings that apply to image distribution. Detailed below.
   *
   * @schema DistributionConfigurationSpecForProviderDistribution#launchTemplateConfiguration
   */
  readonly launchTemplateConfiguration?: DistributionConfigurationSpecForProviderDistributionLaunchTemplateConfiguration[];

  /**
   * Set of Amazon Resource Names (ARNs) of License Manager License Configurations.
   *
   * @schema DistributionConfigurationSpecForProviderDistribution#licenseConfigurationArns
   */
  readonly licenseConfigurationArns?: string[];

  /**
   * AWS Region for the distribution.
   *
   * @schema DistributionConfigurationSpecForProviderDistribution#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecForProviderDistribution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecForProviderDistribution(obj: DistributionConfigurationSpecForProviderDistribution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amiDistributionConfiguration': obj.amiDistributionConfiguration?.map(y => toJson_DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration(y)),
    'containerDistributionConfiguration': obj.containerDistributionConfiguration?.map(y => toJson_DistributionConfigurationSpecForProviderDistributionContainerDistributionConfiguration(y)),
    'fastLaunchConfiguration': obj.fastLaunchConfiguration?.map(y => toJson_DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration(y)),
    'launchTemplateConfiguration': obj.launchTemplateConfiguration?.map(y => toJson_DistributionConfigurationSpecForProviderDistributionLaunchTemplateConfiguration(y)),
    'licenseConfigurationArns': obj.licenseConfigurationArns?.map(y => y),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecInitProviderDistribution
 */
export interface DistributionConfigurationSpecInitProviderDistribution {
  /**
   * Configuration block with Amazon Machine Image (AMI) distribution settings. Detailed below.
   *
   * @schema DistributionConfigurationSpecInitProviderDistribution#amiDistributionConfiguration
   */
  readonly amiDistributionConfiguration?: DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration[];

  /**
   * Configuration block with container distribution settings. Detailed below.
   *
   * @schema DistributionConfigurationSpecInitProviderDistribution#containerDistributionConfiguration
   */
  readonly containerDistributionConfiguration?: DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfiguration[];

  /**
   * Set of Windows faster-launching configurations to use for AMI distribution. Detailed below.
   *
   * @schema DistributionConfigurationSpecInitProviderDistribution#fastLaunchConfiguration
   */
  readonly fastLaunchConfiguration?: DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration[];

  /**
   * Set of launch template configuration settings that apply to image distribution. Detailed below.
   *
   * @schema DistributionConfigurationSpecInitProviderDistribution#launchTemplateConfiguration
   */
  readonly launchTemplateConfiguration?: DistributionConfigurationSpecInitProviderDistributionLaunchTemplateConfiguration[];

  /**
   * Set of Amazon Resource Names (ARNs) of License Manager License Configurations.
   *
   * @schema DistributionConfigurationSpecInitProviderDistribution#licenseConfigurationArns
   */
  readonly licenseConfigurationArns?: string[];

}

/**
 * Converts an object of type 'DistributionConfigurationSpecInitProviderDistribution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecInitProviderDistribution(obj: DistributionConfigurationSpecInitProviderDistribution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amiDistributionConfiguration': obj.amiDistributionConfiguration?.map(y => toJson_DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration(y)),
    'containerDistributionConfiguration': obj.containerDistributionConfiguration?.map(y => toJson_DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfiguration(y)),
    'fastLaunchConfiguration': obj.fastLaunchConfiguration?.map(y => toJson_DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration(y)),
    'launchTemplateConfiguration': obj.launchTemplateConfiguration?.map(y => toJson_DistributionConfigurationSpecInitProviderDistributionLaunchTemplateConfiguration(y)),
    'licenseConfigurationArns': obj.licenseConfigurationArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DistributionConfigurationSpecProviderConfigRefPolicy
 */
export interface DistributionConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DistributionConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DistributionConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecProviderConfigRefPolicy(obj: DistributionConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DistributionConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface DistributionConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DistributionConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DistributionConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecPublishConnectionDetailsToConfigRef(obj: DistributionConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DistributionConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface DistributionConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DistributionConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DistributionConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DistributionConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecPublishConnectionDetailsToMetadata(obj: DistributionConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration
 */
export interface DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration {
  /**
   * Key-value map of tags to apply to the distributed AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration#amiTags
   */
  readonly amiTags?: { [key: string]: string };

  /**
   * Description to apply to the distributed AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration#description
   */
  readonly description?: string;

  /**
   * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key to encrypt the distributed AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Configuration block of EC2 launch permissions to apply to the distributed AMI. Detailed below.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration#launchPermission
   */
  readonly launchPermission?: DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission[];

  /**
   * Name to apply to the distributed AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration#name
   */
  readonly name?: string;

  /**
   * Set of AWS Account identifiers to distribute the AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration#targetAccountIds
   */
  readonly targetAccountIds?: string[];

}

/**
 * Converts an object of type 'DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration(obj: DistributionConfigurationSpecForProviderDistributionAmiDistributionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amiTags': ((obj.amiTags) === undefined) ? undefined : (Object.entries(obj.amiTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'description': obj.description,
    'kmsKeyId': obj.kmsKeyId,
    'launchPermission': obj.launchPermission?.map(y => toJson_DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission(y)),
    'name': obj.name,
    'targetAccountIds': obj.targetAccountIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecForProviderDistributionContainerDistributionConfiguration
 */
export interface DistributionConfigurationSpecForProviderDistributionContainerDistributionConfiguration {
  /**
   * Set of tags that are attached to the container distribution configuration.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionContainerDistributionConfiguration#containerTags
   */
  readonly containerTags?: string[];

  /**
   * Description of the container distribution configuration.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionContainerDistributionConfiguration#description
   */
  readonly description?: string;

  /**
   * Configuration block with the destination repository for the container distribution configuration.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionContainerDistributionConfiguration#targetRepository
   */
  readonly targetRepository?: DistributionConfigurationSpecForProviderDistributionContainerDistributionConfigurationTargetRepository[];

}

/**
 * Converts an object of type 'DistributionConfigurationSpecForProviderDistributionContainerDistributionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecForProviderDistributionContainerDistributionConfiguration(obj: DistributionConfigurationSpecForProviderDistributionContainerDistributionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerTags': obj.containerTags?.map(y => y),
    'description': obj.description,
    'targetRepository': obj.targetRepository?.map(y => toJson_DistributionConfigurationSpecForProviderDistributionContainerDistributionConfigurationTargetRepository(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration
 */
export interface DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration {
  /**
   * The owner account ID for the fast-launch enabled Windows AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration#accountId
   */
  readonly accountId?: string;

  /**
   * A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Configuration block for the launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots. Detailed below.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration#launchTemplate
   */
  readonly launchTemplate?: DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationLaunchTemplate[];

  /**
   * The maximum number of parallel instances that are launched for creating resources.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration#maxParallelLaunches
   */
  readonly maxParallelLaunches?: number;

  /**
   * Configuration block for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled. Detailed below.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration#snapshotConfiguration
   */
  readonly snapshotConfiguration?: DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationSnapshotConfiguration[];

}

/**
 * Converts an object of type 'DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration(obj: DistributionConfigurationSpecForProviderDistributionFastLaunchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'enabled': obj.enabled,
    'launchTemplate': obj.launchTemplate?.map(y => toJson_DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationLaunchTemplate(y)),
    'maxParallelLaunches': obj.maxParallelLaunches,
    'snapshotConfiguration': obj.snapshotConfiguration?.map(y => toJson_DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationSnapshotConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecForProviderDistributionLaunchTemplateConfiguration
 */
export interface DistributionConfigurationSpecForProviderDistributionLaunchTemplateConfiguration {
  /**
   * The account ID that this configuration applies to.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionLaunchTemplateConfiguration#accountId
   */
  readonly accountId?: string;

  /**
   * Indicates whether to set the specified Amazon EC2 launch template as the default launch template. Defaults to true.
   *
   * @default true.
   * @schema DistributionConfigurationSpecForProviderDistributionLaunchTemplateConfiguration#default
   */
  readonly default?: boolean;

  /**
   * The ID of the Amazon EC2 launch template to use.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionLaunchTemplateConfiguration#launchTemplateId
   */
  readonly launchTemplateId?: string;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecForProviderDistributionLaunchTemplateConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecForProviderDistributionLaunchTemplateConfiguration(obj: DistributionConfigurationSpecForProviderDistributionLaunchTemplateConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'default': obj.default,
    'launchTemplateId': obj.launchTemplateId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration
 */
export interface DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration {
  /**
   * Key-value map of tags to apply to the distributed AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration#amiTags
   */
  readonly amiTags?: { [key: string]: string };

  /**
   * Description to apply to the distributed AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration#description
   */
  readonly description?: string;

  /**
   * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key to encrypt the distributed AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Configuration block of EC2 launch permissions to apply to the distributed AMI. Detailed below.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration#launchPermission
   */
  readonly launchPermission?: DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission[];

  /**
   * Name to apply to the distributed AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration#name
   */
  readonly name?: string;

  /**
   * Set of AWS Account identifiers to distribute the AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration#targetAccountIds
   */
  readonly targetAccountIds?: string[];

}

/**
 * Converts an object of type 'DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration(obj: DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amiTags': ((obj.amiTags) === undefined) ? undefined : (Object.entries(obj.amiTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'description': obj.description,
    'kmsKeyId': obj.kmsKeyId,
    'launchPermission': obj.launchPermission?.map(y => toJson_DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission(y)),
    'name': obj.name,
    'targetAccountIds': obj.targetAccountIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfiguration
 */
export interface DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfiguration {
  /**
   * Set of tags that are attached to the container distribution configuration.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfiguration#containerTags
   */
  readonly containerTags?: string[];

  /**
   * Description of the container distribution configuration.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfiguration#description
   */
  readonly description?: string;

  /**
   * Configuration block with the destination repository for the container distribution configuration.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfiguration#targetRepository
   */
  readonly targetRepository?: DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfigurationTargetRepository[];

}

/**
 * Converts an object of type 'DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfiguration(obj: DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerTags': obj.containerTags?.map(y => y),
    'description': obj.description,
    'targetRepository': obj.targetRepository?.map(y => toJson_DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfigurationTargetRepository(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration
 */
export interface DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration {
  /**
   * The owner account ID for the fast-launch enabled Windows AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration#accountId
   */
  readonly accountId?: string;

  /**
   * A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Configuration block for the launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots. Detailed below.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration#launchTemplate
   */
  readonly launchTemplate?: DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationLaunchTemplate[];

  /**
   * The maximum number of parallel instances that are launched for creating resources.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration#maxParallelLaunches
   */
  readonly maxParallelLaunches?: number;

  /**
   * Configuration block for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled. Detailed below.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration#snapshotConfiguration
   */
  readonly snapshotConfiguration?: DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationSnapshotConfiguration[];

}

/**
 * Converts an object of type 'DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration(obj: DistributionConfigurationSpecInitProviderDistributionFastLaunchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'enabled': obj.enabled,
    'launchTemplate': obj.launchTemplate?.map(y => toJson_DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationLaunchTemplate(y)),
    'maxParallelLaunches': obj.maxParallelLaunches,
    'snapshotConfiguration': obj.snapshotConfiguration?.map(y => toJson_DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationSnapshotConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecInitProviderDistributionLaunchTemplateConfiguration
 */
export interface DistributionConfigurationSpecInitProviderDistributionLaunchTemplateConfiguration {
  /**
   * The account ID that this configuration applies to.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionLaunchTemplateConfiguration#accountId
   */
  readonly accountId?: string;

  /**
   * Indicates whether to set the specified Amazon EC2 launch template as the default launch template. Defaults to true.
   *
   * @default true.
   * @schema DistributionConfigurationSpecInitProviderDistributionLaunchTemplateConfiguration#default
   */
  readonly default?: boolean;

  /**
   * The ID of the Amazon EC2 launch template to use.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionLaunchTemplateConfiguration#launchTemplateId
   */
  readonly launchTemplateId?: string;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecInitProviderDistributionLaunchTemplateConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecInitProviderDistributionLaunchTemplateConfiguration(obj: DistributionConfigurationSpecInitProviderDistributionLaunchTemplateConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'default': obj.default,
    'launchTemplateId': obj.launchTemplateId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum DistributionConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum DistributionConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission
 */
export interface DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission {
  /**
   * Set of AWS Organization ARNs to assign.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission#organizationArns
   */
  readonly organizationArns?: string[];

  /**
   * Set of AWS Organizational Unit ARNs to assign.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission#organizationalUnitArns
   */
  readonly organizationalUnitArns?: string[];

  /**
   * Set of EC2 launch permission user groups to assign. Use all to distribute a public AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission#userGroups
   */
  readonly userGroups?: string[];

  /**
   * Set of AWS Account identifiers to assign.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission#userIds
   */
  readonly userIds?: string[];

}

/**
 * Converts an object of type 'DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission(obj: DistributionConfigurationSpecForProviderDistributionAmiDistributionConfigurationLaunchPermission | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'organizationArns': obj.organizationArns?.map(y => y),
    'organizationalUnitArns': obj.organizationalUnitArns?.map(y => y),
    'userGroups': obj.userGroups?.map(y => y),
    'userIds': obj.userIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecForProviderDistributionContainerDistributionConfigurationTargetRepository
 */
export interface DistributionConfigurationSpecForProviderDistributionContainerDistributionConfigurationTargetRepository {
  /**
   * The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionContainerDistributionConfigurationTargetRepository#repositoryName
   */
  readonly repositoryName?: string;

  /**
   * The service in which this image is registered. Valid values: ECR.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionContainerDistributionConfigurationTargetRepository#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecForProviderDistributionContainerDistributionConfigurationTargetRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecForProviderDistributionContainerDistributionConfigurationTargetRepository(obj: DistributionConfigurationSpecForProviderDistributionContainerDistributionConfigurationTargetRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryName': obj.repositoryName,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationLaunchTemplate
 */
export interface DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationLaunchTemplate {
  /**
   * The ID of the launch template to use for faster launching for a Windows AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationLaunchTemplate#launchTemplateId
   */
  readonly launchTemplateId?: string;

  /**
   * The name of the launch template to use for faster launching for a Windows AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationLaunchTemplate#launchTemplateName
   */
  readonly launchTemplateName?: string;

  /**
   * The version of the launch template to use for faster launching for a Windows AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationLaunchTemplate#launchTemplateVersion
   */
  readonly launchTemplateVersion?: string;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationLaunchTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationLaunchTemplate(obj: DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationLaunchTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateId': obj.launchTemplateId,
    'launchTemplateName': obj.launchTemplateName,
    'launchTemplateVersion': obj.launchTemplateVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationSnapshotConfiguration
 */
export interface DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationSnapshotConfiguration {
  /**
   * The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
   *
   * @schema DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationSnapshotConfiguration#targetResourceCount
   */
  readonly targetResourceCount?: number;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationSnapshotConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationSnapshotConfiguration(obj: DistributionConfigurationSpecForProviderDistributionFastLaunchConfigurationSnapshotConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetResourceCount': obj.targetResourceCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission
 */
export interface DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission {
  /**
   * Set of AWS Organization ARNs to assign.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission#organizationArns
   */
  readonly organizationArns?: string[];

  /**
   * Set of AWS Organizational Unit ARNs to assign.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission#organizationalUnitArns
   */
  readonly organizationalUnitArns?: string[];

  /**
   * Set of EC2 launch permission user groups to assign. Use all to distribute a public AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission#userGroups
   */
  readonly userGroups?: string[];

  /**
   * Set of AWS Account identifiers to assign.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission#userIds
   */
  readonly userIds?: string[];

}

/**
 * Converts an object of type 'DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission(obj: DistributionConfigurationSpecInitProviderDistributionAmiDistributionConfigurationLaunchPermission | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'organizationArns': obj.organizationArns?.map(y => y),
    'organizationalUnitArns': obj.organizationalUnitArns?.map(y => y),
    'userGroups': obj.userGroups?.map(y => y),
    'userIds': obj.userIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfigurationTargetRepository
 */
export interface DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfigurationTargetRepository {
  /**
   * The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfigurationTargetRepository#repositoryName
   */
  readonly repositoryName?: string;

  /**
   * The service in which this image is registered. Valid values: ECR.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfigurationTargetRepository#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfigurationTargetRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfigurationTargetRepository(obj: DistributionConfigurationSpecInitProviderDistributionContainerDistributionConfigurationTargetRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryName': obj.repositoryName,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationLaunchTemplate
 */
export interface DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationLaunchTemplate {
  /**
   * The ID of the launch template to use for faster launching for a Windows AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationLaunchTemplate#launchTemplateId
   */
  readonly launchTemplateId?: string;

  /**
   * The name of the launch template to use for faster launching for a Windows AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationLaunchTemplate#launchTemplateName
   */
  readonly launchTemplateName?: string;

  /**
   * The version of the launch template to use for faster launching for a Windows AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationLaunchTemplate#launchTemplateVersion
   */
  readonly launchTemplateVersion?: string;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationLaunchTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationLaunchTemplate(obj: DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationLaunchTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateId': obj.launchTemplateId,
    'launchTemplateName': obj.launchTemplateName,
    'launchTemplateVersion': obj.launchTemplateVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationSnapshotConfiguration
 */
export interface DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationSnapshotConfiguration {
  /**
   * The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
   *
   * @schema DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationSnapshotConfiguration#targetResourceCount
   */
  readonly targetResourceCount?: number;

}

/**
 * Converts an object of type 'DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationSnapshotConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationSnapshotConfiguration(obj: DistributionConfigurationSpecInitProviderDistributionFastLaunchConfigurationSnapshotConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetResourceCount': obj.targetResourceCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DistributionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Image is the Schema for the Images API. Manages an Image Builder Image
 *
 * @schema Image
 */
export class Image extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Image"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'imagebuilder.aws.upbound.io/v1beta1',
    kind: 'Image',
  }

  /**
   * Renders a Kubernetes manifest for "Image".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageProps): any {
    return {
      ...Image.GVK,
      ...toJson_ImageProps(props),
    };
  }

  /**
   * Defines a "Image" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageProps) {
    super(scope, id, {
      ...Image.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Image.GVK,
      ...toJson_ImageProps(resolved),
    };
  }
}

/**
 * Image is the Schema for the Images API. Manages an Image Builder Image
 *
 * @schema Image
 */
export interface ImageProps {
  /**
   * @schema Image#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageSpec defines the desired state of Image
   *
   * @schema Image#spec
   */
  readonly spec: ImageSpec;

}

/**
 * Converts an object of type 'ImageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageProps(obj: ImageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageSpec defines the desired state of Image
 *
 * @schema ImageSpec
 */
export interface ImageSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ImageSpec#deletionPolicy
   */
  readonly deletionPolicy?: ImageSpecDeletionPolicy;

  /**
   * @schema ImageSpec#forProvider
   */
  readonly forProvider: ImageSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ImageSpec#initProvider
   */
  readonly initProvider?: ImageSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ImageSpec#managementPolicies
   */
  readonly managementPolicies?: ImageSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ImageSpec#providerConfigRef
   */
  readonly providerConfigRef?: ImageSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ImageSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ImageSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ImageSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ImageSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ImageSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpec(obj: ImageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ImageSpecForProvider(obj.forProvider),
    'initProvider': toJson_ImageSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ImageSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ImageSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ImageSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ImageSpecDeletionPolicy
 */
export enum ImageSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ImageSpecForProvider
 */
export interface ImageSpecForProvider {
  /**
   * - Amazon Resource Name (ARN) of the container recipe.
   *
   * @schema ImageSpecForProvider#containerRecipeArn
   */
  readonly containerRecipeArn?: string;

  /**
   * Amazon Resource Name (ARN) of the Image Builder Distribution Configuration.
   *
   * @schema ImageSpecForProvider#distributionConfigurationArn
   */
  readonly distributionConfigurationArn?: string;

  /**
   * Reference to a DistributionConfiguration in imagebuilder to populate distributionConfigurationArn.
   *
   * @schema ImageSpecForProvider#distributionConfigurationArnRef
   */
  readonly distributionConfigurationArnRef?: ImageSpecForProviderDistributionConfigurationArnRef;

  /**
   * Selector for a DistributionConfiguration in imagebuilder to populate distributionConfigurationArn.
   *
   * @schema ImageSpecForProvider#distributionConfigurationArnSelector
   */
  readonly distributionConfigurationArnSelector?: ImageSpecForProviderDistributionConfigurationArnSelector;

  /**
   * Whether additional information about the image being created is collected. Defaults to true.
   *
   * @default true.
   * @schema ImageSpecForProvider#enhancedImageMetadataEnabled
   */
  readonly enhancedImageMetadataEnabled?: boolean;

  /**
   * Amazon Resource Name (ARN) of the image recipe.
   *
   * @schema ImageSpecForProvider#imageRecipeArn
   */
  readonly imageRecipeArn?: string;

  /**
   * Reference to a ImageRecipe in imagebuilder to populate imageRecipeArn.
   *
   * @schema ImageSpecForProvider#imageRecipeArnRef
   */
  readonly imageRecipeArnRef?: ImageSpecForProviderImageRecipeArnRef;

  /**
   * Selector for a ImageRecipe in imagebuilder to populate imageRecipeArn.
   *
   * @schema ImageSpecForProvider#imageRecipeArnSelector
   */
  readonly imageRecipeArnSelector?: ImageSpecForProviderImageRecipeArnSelector;

  /**
   * Configuration block with image tests configuration. Detailed below.
   *
   * @schema ImageSpecForProvider#imageTestsConfiguration
   */
  readonly imageTestsConfiguration?: ImageSpecForProviderImageTestsConfiguration[];

  /**
   * Amazon Resource Name (ARN) of the Image Builder Infrastructure Configuration.
   *
   * @schema ImageSpecForProvider#infrastructureConfigurationArn
   */
  readonly infrastructureConfigurationArn?: string;

  /**
   * Reference to a InfrastructureConfiguration in imagebuilder to populate infrastructureConfigurationArn.
   *
   * @schema ImageSpecForProvider#infrastructureConfigurationArnRef
   */
  readonly infrastructureConfigurationArnRef?: ImageSpecForProviderInfrastructureConfigurationArnRef;

  /**
   * Selector for a InfrastructureConfiguration in imagebuilder to populate infrastructureConfigurationArn.
   *
   * @schema ImageSpecForProvider#infrastructureConfigurationArnSelector
   */
  readonly infrastructureConfigurationArnSelector?: ImageSpecForProviderInfrastructureConfigurationArnSelector;

  /**
   * Region of the AMI. Region is the region you'd like your resource to be created in.
   *
   * @schema ImageSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ImageSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ImageSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProvider(obj: ImageSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerRecipeArn': obj.containerRecipeArn,
    'distributionConfigurationArn': obj.distributionConfigurationArn,
    'distributionConfigurationArnRef': toJson_ImageSpecForProviderDistributionConfigurationArnRef(obj.distributionConfigurationArnRef),
    'distributionConfigurationArnSelector': toJson_ImageSpecForProviderDistributionConfigurationArnSelector(obj.distributionConfigurationArnSelector),
    'enhancedImageMetadataEnabled': obj.enhancedImageMetadataEnabled,
    'imageRecipeArn': obj.imageRecipeArn,
    'imageRecipeArnRef': toJson_ImageSpecForProviderImageRecipeArnRef(obj.imageRecipeArnRef),
    'imageRecipeArnSelector': toJson_ImageSpecForProviderImageRecipeArnSelector(obj.imageRecipeArnSelector),
    'imageTestsConfiguration': obj.imageTestsConfiguration?.map(y => toJson_ImageSpecForProviderImageTestsConfiguration(y)),
    'infrastructureConfigurationArn': obj.infrastructureConfigurationArn,
    'infrastructureConfigurationArnRef': toJson_ImageSpecForProviderInfrastructureConfigurationArnRef(obj.infrastructureConfigurationArnRef),
    'infrastructureConfigurationArnSelector': toJson_ImageSpecForProviderInfrastructureConfigurationArnSelector(obj.infrastructureConfigurationArnSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ImageSpecInitProvider
 */
export interface ImageSpecInitProvider {
  /**
   * - Amazon Resource Name (ARN) of the container recipe.
   *
   * @schema ImageSpecInitProvider#containerRecipeArn
   */
  readonly containerRecipeArn?: string;

  /**
   * Whether additional information about the image being created is collected. Defaults to true.
   *
   * @default true.
   * @schema ImageSpecInitProvider#enhancedImageMetadataEnabled
   */
  readonly enhancedImageMetadataEnabled?: boolean;

  /**
   * Configuration block with image tests configuration. Detailed below.
   *
   * @schema ImageSpecInitProvider#imageTestsConfiguration
   */
  readonly imageTestsConfiguration?: ImageSpecInitProviderImageTestsConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ImageSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ImageSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecInitProvider(obj: ImageSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerRecipeArn': obj.containerRecipeArn,
    'enhancedImageMetadataEnabled': obj.enhancedImageMetadataEnabled,
    'imageTestsConfiguration': obj.imageTestsConfiguration?.map(y => toJson_ImageSpecInitProviderImageTestsConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ImageSpecManagementPolicies
 */
export enum ImageSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ImageSpecProviderConfigRef
 */
export interface ImageSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageSpecProviderConfigRef#policy
   */
  readonly policy?: ImageSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ImageSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecProviderConfigRef(obj: ImageSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ImageSpecPublishConnectionDetailsTo
 */
export interface ImageSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ImageSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ImageSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ImageSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ImageSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ImageSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImageSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecPublishConnectionDetailsTo(obj: ImageSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ImageSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ImageSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ImageSpecWriteConnectionSecretToRef
 */
export interface ImageSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ImageSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ImageSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ImageSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecWriteConnectionSecretToRef(obj: ImageSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DistributionConfiguration in imagebuilder to populate distributionConfigurationArn.
 *
 * @schema ImageSpecForProviderDistributionConfigurationArnRef
 */
export interface ImageSpecForProviderDistributionConfigurationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageSpecForProviderDistributionConfigurationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageSpecForProviderDistributionConfigurationArnRef#policy
   */
  readonly policy?: ImageSpecForProviderDistributionConfigurationArnRefPolicy;

}

/**
 * Converts an object of type 'ImageSpecForProviderDistributionConfigurationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderDistributionConfigurationArnRef(obj: ImageSpecForProviderDistributionConfigurationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageSpecForProviderDistributionConfigurationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DistributionConfiguration in imagebuilder to populate distributionConfigurationArn.
 *
 * @schema ImageSpecForProviderDistributionConfigurationArnSelector
 */
export interface ImageSpecForProviderDistributionConfigurationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ImageSpecForProviderDistributionConfigurationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ImageSpecForProviderDistributionConfigurationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ImageSpecForProviderDistributionConfigurationArnSelector#policy
   */
  readonly policy?: ImageSpecForProviderDistributionConfigurationArnSelectorPolicy;

}

/**
 * Converts an object of type 'ImageSpecForProviderDistributionConfigurationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderDistributionConfigurationArnSelector(obj: ImageSpecForProviderDistributionConfigurationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ImageSpecForProviderDistributionConfigurationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ImageRecipe in imagebuilder to populate imageRecipeArn.
 *
 * @schema ImageSpecForProviderImageRecipeArnRef
 */
export interface ImageSpecForProviderImageRecipeArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageSpecForProviderImageRecipeArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageSpecForProviderImageRecipeArnRef#policy
   */
  readonly policy?: ImageSpecForProviderImageRecipeArnRefPolicy;

}

/**
 * Converts an object of type 'ImageSpecForProviderImageRecipeArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderImageRecipeArnRef(obj: ImageSpecForProviderImageRecipeArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageSpecForProviderImageRecipeArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ImageRecipe in imagebuilder to populate imageRecipeArn.
 *
 * @schema ImageSpecForProviderImageRecipeArnSelector
 */
export interface ImageSpecForProviderImageRecipeArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ImageSpecForProviderImageRecipeArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ImageSpecForProviderImageRecipeArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ImageSpecForProviderImageRecipeArnSelector#policy
   */
  readonly policy?: ImageSpecForProviderImageRecipeArnSelectorPolicy;

}

/**
 * Converts an object of type 'ImageSpecForProviderImageRecipeArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderImageRecipeArnSelector(obj: ImageSpecForProviderImageRecipeArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ImageSpecForProviderImageRecipeArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageSpecForProviderImageTestsConfiguration
 */
export interface ImageSpecForProviderImageTestsConfiguration {
  /**
   * Whether image tests are enabled. Defaults to true.
   *
   * @default true.
   * @schema ImageSpecForProviderImageTestsConfiguration#imageTestsEnabled
   */
  readonly imageTestsEnabled?: boolean;

  /**
   * Number of minutes before image tests time out. Valid values are between 60 and 1440. Defaults to 720.
   *
   * @default 720.
   * @schema ImageSpecForProviderImageTestsConfiguration#timeoutMinutes
   */
  readonly timeoutMinutes?: number;

}

/**
 * Converts an object of type 'ImageSpecForProviderImageTestsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderImageTestsConfiguration(obj: ImageSpecForProviderImageTestsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageTestsEnabled': obj.imageTestsEnabled,
    'timeoutMinutes': obj.timeoutMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a InfrastructureConfiguration in imagebuilder to populate infrastructureConfigurationArn.
 *
 * @schema ImageSpecForProviderInfrastructureConfigurationArnRef
 */
export interface ImageSpecForProviderInfrastructureConfigurationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageSpecForProviderInfrastructureConfigurationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageSpecForProviderInfrastructureConfigurationArnRef#policy
   */
  readonly policy?: ImageSpecForProviderInfrastructureConfigurationArnRefPolicy;

}

/**
 * Converts an object of type 'ImageSpecForProviderInfrastructureConfigurationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderInfrastructureConfigurationArnRef(obj: ImageSpecForProviderInfrastructureConfigurationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageSpecForProviderInfrastructureConfigurationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a InfrastructureConfiguration in imagebuilder to populate infrastructureConfigurationArn.
 *
 * @schema ImageSpecForProviderInfrastructureConfigurationArnSelector
 */
export interface ImageSpecForProviderInfrastructureConfigurationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ImageSpecForProviderInfrastructureConfigurationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ImageSpecForProviderInfrastructureConfigurationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ImageSpecForProviderInfrastructureConfigurationArnSelector#policy
   */
  readonly policy?: ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicy;

}

/**
 * Converts an object of type 'ImageSpecForProviderInfrastructureConfigurationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderInfrastructureConfigurationArnSelector(obj: ImageSpecForProviderInfrastructureConfigurationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageSpecInitProviderImageTestsConfiguration
 */
export interface ImageSpecInitProviderImageTestsConfiguration {
  /**
   * Whether image tests are enabled. Defaults to true.
   *
   * @default true.
   * @schema ImageSpecInitProviderImageTestsConfiguration#imageTestsEnabled
   */
  readonly imageTestsEnabled?: boolean;

  /**
   * Number of minutes before image tests time out. Valid values are between 60 and 1440. Defaults to 720.
   *
   * @default 720.
   * @schema ImageSpecInitProviderImageTestsConfiguration#timeoutMinutes
   */
  readonly timeoutMinutes?: number;

}

/**
 * Converts an object of type 'ImageSpecInitProviderImageTestsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecInitProviderImageTestsConfiguration(obj: ImageSpecInitProviderImageTestsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageTestsEnabled': obj.imageTestsEnabled,
    'timeoutMinutes': obj.timeoutMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageSpecProviderConfigRefPolicy
 */
export interface ImageSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ImageSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ImageSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecProviderConfigRefPolicy(obj: ImageSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ImageSpecPublishConnectionDetailsToConfigRef
 */
export interface ImageSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ImageSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ImageSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecPublishConnectionDetailsToConfigRef(obj: ImageSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ImageSpecPublishConnectionDetailsToMetadata
 */
export interface ImageSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImageSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImageSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ImageSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ImageSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecPublishConnectionDetailsToMetadata(obj: ImageSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageSpecForProviderDistributionConfigurationArnRefPolicy
 */
export interface ImageSpecForProviderDistributionConfigurationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecForProviderDistributionConfigurationArnRefPolicy#resolution
   */
  readonly resolution?: ImageSpecForProviderDistributionConfigurationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecForProviderDistributionConfigurationArnRefPolicy#resolve
   */
  readonly resolve?: ImageSpecForProviderDistributionConfigurationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecForProviderDistributionConfigurationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderDistributionConfigurationArnRefPolicy(obj: ImageSpecForProviderDistributionConfigurationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ImageSpecForProviderDistributionConfigurationArnSelectorPolicy
 */
export interface ImageSpecForProviderDistributionConfigurationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecForProviderDistributionConfigurationArnSelectorPolicy#resolution
   */
  readonly resolution?: ImageSpecForProviderDistributionConfigurationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecForProviderDistributionConfigurationArnSelectorPolicy#resolve
   */
  readonly resolve?: ImageSpecForProviderDistributionConfigurationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecForProviderDistributionConfigurationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderDistributionConfigurationArnSelectorPolicy(obj: ImageSpecForProviderDistributionConfigurationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageSpecForProviderImageRecipeArnRefPolicy
 */
export interface ImageSpecForProviderImageRecipeArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecForProviderImageRecipeArnRefPolicy#resolution
   */
  readonly resolution?: ImageSpecForProviderImageRecipeArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecForProviderImageRecipeArnRefPolicy#resolve
   */
  readonly resolve?: ImageSpecForProviderImageRecipeArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecForProviderImageRecipeArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderImageRecipeArnRefPolicy(obj: ImageSpecForProviderImageRecipeArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ImageSpecForProviderImageRecipeArnSelectorPolicy
 */
export interface ImageSpecForProviderImageRecipeArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecForProviderImageRecipeArnSelectorPolicy#resolution
   */
  readonly resolution?: ImageSpecForProviderImageRecipeArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecForProviderImageRecipeArnSelectorPolicy#resolve
   */
  readonly resolve?: ImageSpecForProviderImageRecipeArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecForProviderImageRecipeArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderImageRecipeArnSelectorPolicy(obj: ImageSpecForProviderImageRecipeArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageSpecForProviderInfrastructureConfigurationArnRefPolicy
 */
export interface ImageSpecForProviderInfrastructureConfigurationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecForProviderInfrastructureConfigurationArnRefPolicy#resolution
   */
  readonly resolution?: ImageSpecForProviderInfrastructureConfigurationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecForProviderInfrastructureConfigurationArnRefPolicy#resolve
   */
  readonly resolve?: ImageSpecForProviderInfrastructureConfigurationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecForProviderInfrastructureConfigurationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderInfrastructureConfigurationArnRefPolicy(obj: ImageSpecForProviderInfrastructureConfigurationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicy
 */
export interface ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicy#resolution
   */
  readonly resolution?: ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicy#resolve
   */
  readonly resolve?: ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicy(obj: ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecProviderConfigRefPolicyResolution
 */
export enum ImageSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecProviderConfigRefPolicyResolve
 */
export enum ImageSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ImageSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ImageSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ImageSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ImageSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageSpecPublishConnectionDetailsToConfigRefPolicy(obj: ImageSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecForProviderDistributionConfigurationArnRefPolicyResolution
 */
export enum ImageSpecForProviderDistributionConfigurationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecForProviderDistributionConfigurationArnRefPolicyResolve
 */
export enum ImageSpecForProviderDistributionConfigurationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecForProviderDistributionConfigurationArnSelectorPolicyResolution
 */
export enum ImageSpecForProviderDistributionConfigurationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecForProviderDistributionConfigurationArnSelectorPolicyResolve
 */
export enum ImageSpecForProviderDistributionConfigurationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecForProviderImageRecipeArnRefPolicyResolution
 */
export enum ImageSpecForProviderImageRecipeArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecForProviderImageRecipeArnRefPolicyResolve
 */
export enum ImageSpecForProviderImageRecipeArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecForProviderImageRecipeArnSelectorPolicyResolution
 */
export enum ImageSpecForProviderImageRecipeArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecForProviderImageRecipeArnSelectorPolicyResolve
 */
export enum ImageSpecForProviderImageRecipeArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecForProviderInfrastructureConfigurationArnRefPolicyResolution
 */
export enum ImageSpecForProviderInfrastructureConfigurationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecForProviderInfrastructureConfigurationArnRefPolicyResolve
 */
export enum ImageSpecForProviderInfrastructureConfigurationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolution
 */
export enum ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolve
 */
export enum ImageSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ImageSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ImageSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ImagePipeline is the Schema for the ImagePipelines API. Manages an Image Builder Image Pipeline
 *
 * @schema ImagePipeline
 */
export class ImagePipeline extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImagePipeline"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'imagebuilder.aws.upbound.io/v1beta1',
    kind: 'ImagePipeline',
  }

  /**
   * Renders a Kubernetes manifest for "ImagePipeline".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImagePipelineProps): any {
    return {
      ...ImagePipeline.GVK,
      ...toJson_ImagePipelineProps(props),
    };
  }

  /**
   * Defines a "ImagePipeline" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImagePipelineProps) {
    super(scope, id, {
      ...ImagePipeline.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImagePipeline.GVK,
      ...toJson_ImagePipelineProps(resolved),
    };
  }
}

/**
 * ImagePipeline is the Schema for the ImagePipelines API. Manages an Image Builder Image Pipeline
 *
 * @schema ImagePipeline
 */
export interface ImagePipelineProps {
  /**
   * @schema ImagePipeline#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImagePipelineSpec defines the desired state of ImagePipeline
   *
   * @schema ImagePipeline#spec
   */
  readonly spec: ImagePipelineSpec;

}

/**
 * Converts an object of type 'ImagePipelineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineProps(obj: ImagePipelineProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImagePipelineSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImagePipelineSpec defines the desired state of ImagePipeline
 *
 * @schema ImagePipelineSpec
 */
export interface ImagePipelineSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ImagePipelineSpec#deletionPolicy
   */
  readonly deletionPolicy?: ImagePipelineSpecDeletionPolicy;

  /**
   * @schema ImagePipelineSpec#forProvider
   */
  readonly forProvider: ImagePipelineSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ImagePipelineSpec#initProvider
   */
  readonly initProvider?: ImagePipelineSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ImagePipelineSpec#managementPolicies
   */
  readonly managementPolicies?: ImagePipelineSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ImagePipelineSpec#providerConfigRef
   */
  readonly providerConfigRef?: ImagePipelineSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ImagePipelineSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ImagePipelineSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ImagePipelineSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ImagePipelineSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ImagePipelineSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpec(obj: ImagePipelineSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ImagePipelineSpecForProvider(obj.forProvider),
    'initProvider': toJson_ImagePipelineSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ImagePipelineSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ImagePipelineSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ImagePipelineSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ImagePipelineSpecDeletionPolicy
 */
export enum ImagePipelineSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ImagePipelineSpecForProvider
 */
export interface ImagePipelineSpecForProvider {
  /**
   * Amazon Resource Name (ARN) of the container recipe.
   *
   * @schema ImagePipelineSpecForProvider#containerRecipeArn
   */
  readonly containerRecipeArn?: string;

  /**
   * Description of the image pipeline.
   *
   * @schema ImagePipelineSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Amazon Resource Name (ARN) of the Image Builder Distribution Configuration.
   *
   * @schema ImagePipelineSpecForProvider#distributionConfigurationArn
   */
  readonly distributionConfigurationArn?: string;

  /**
   * Whether additional information about the image being created is collected. Defaults to true.
   *
   * @default true.
   * @schema ImagePipelineSpecForProvider#enhancedImageMetadataEnabled
   */
  readonly enhancedImageMetadataEnabled?: boolean;

  /**
   * Amazon Resource Name (ARN) of the image recipe.
   *
   * @schema ImagePipelineSpecForProvider#imageRecipeArn
   */
  readonly imageRecipeArn?: string;

  /**
   * Reference to a ImageRecipe in imagebuilder to populate imageRecipeArn.
   *
   * @schema ImagePipelineSpecForProvider#imageRecipeArnRef
   */
  readonly imageRecipeArnRef?: ImagePipelineSpecForProviderImageRecipeArnRef;

  /**
   * Selector for a ImageRecipe in imagebuilder to populate imageRecipeArn.
   *
   * @schema ImagePipelineSpecForProvider#imageRecipeArnSelector
   */
  readonly imageRecipeArnSelector?: ImagePipelineSpecForProviderImageRecipeArnSelector;

  /**
   * Configuration block with image tests configuration. Detailed below.
   *
   * @schema ImagePipelineSpecForProvider#imageTestsConfiguration
   */
  readonly imageTestsConfiguration?: ImagePipelineSpecForProviderImageTestsConfiguration[];

  /**
   * Amazon Resource Name (ARN) of the Image Builder Infrastructure Configuration.
   *
   * @schema ImagePipelineSpecForProvider#infrastructureConfigurationArn
   */
  readonly infrastructureConfigurationArn?: string;

  /**
   * Reference to a InfrastructureConfiguration in imagebuilder to populate infrastructureConfigurationArn.
   *
   * @schema ImagePipelineSpecForProvider#infrastructureConfigurationArnRef
   */
  readonly infrastructureConfigurationArnRef?: ImagePipelineSpecForProviderInfrastructureConfigurationArnRef;

  /**
   * Selector for a InfrastructureConfiguration in imagebuilder to populate infrastructureConfigurationArn.
   *
   * @schema ImagePipelineSpecForProvider#infrastructureConfigurationArnSelector
   */
  readonly infrastructureConfigurationArnSelector?: ImagePipelineSpecForProviderInfrastructureConfigurationArnSelector;

  /**
   * Name of the image pipeline.
   *
   * @schema ImagePipelineSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ImagePipelineSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block with schedule settings. Detailed below.
   *
   * @schema ImagePipelineSpecForProvider#schedule
   */
  readonly schedule?: ImagePipelineSpecForProviderSchedule[];

  /**
   * Status of the image pipeline. Valid values are DISABLED and ENABLED. Defaults to ENABLED.
   *
   * @default ENABLED.
   * @schema ImagePipelineSpecForProvider#status
   */
  readonly status?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ImagePipelineSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ImagePipelineSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProvider(obj: ImagePipelineSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerRecipeArn': obj.containerRecipeArn,
    'description': obj.description,
    'distributionConfigurationArn': obj.distributionConfigurationArn,
    'enhancedImageMetadataEnabled': obj.enhancedImageMetadataEnabled,
    'imageRecipeArn': obj.imageRecipeArn,
    'imageRecipeArnRef': toJson_ImagePipelineSpecForProviderImageRecipeArnRef(obj.imageRecipeArnRef),
    'imageRecipeArnSelector': toJson_ImagePipelineSpecForProviderImageRecipeArnSelector(obj.imageRecipeArnSelector),
    'imageTestsConfiguration': obj.imageTestsConfiguration?.map(y => toJson_ImagePipelineSpecForProviderImageTestsConfiguration(y)),
    'infrastructureConfigurationArn': obj.infrastructureConfigurationArn,
    'infrastructureConfigurationArnRef': toJson_ImagePipelineSpecForProviderInfrastructureConfigurationArnRef(obj.infrastructureConfigurationArnRef),
    'infrastructureConfigurationArnSelector': toJson_ImagePipelineSpecForProviderInfrastructureConfigurationArnSelector(obj.infrastructureConfigurationArnSelector),
    'name': obj.name,
    'region': obj.region,
    'schedule': obj.schedule?.map(y => toJson_ImagePipelineSpecForProviderSchedule(y)),
    'status': obj.status,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ImagePipelineSpecInitProvider
 */
export interface ImagePipelineSpecInitProvider {
  /**
   * Amazon Resource Name (ARN) of the container recipe.
   *
   * @schema ImagePipelineSpecInitProvider#containerRecipeArn
   */
  readonly containerRecipeArn?: string;

  /**
   * Description of the image pipeline.
   *
   * @schema ImagePipelineSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Amazon Resource Name (ARN) of the Image Builder Distribution Configuration.
   *
   * @schema ImagePipelineSpecInitProvider#distributionConfigurationArn
   */
  readonly distributionConfigurationArn?: string;

  /**
   * Whether additional information about the image being created is collected. Defaults to true.
   *
   * @default true.
   * @schema ImagePipelineSpecInitProvider#enhancedImageMetadataEnabled
   */
  readonly enhancedImageMetadataEnabled?: boolean;

  /**
   * Configuration block with image tests configuration. Detailed below.
   *
   * @schema ImagePipelineSpecInitProvider#imageTestsConfiguration
   */
  readonly imageTestsConfiguration?: ImagePipelineSpecInitProviderImageTestsConfiguration[];

  /**
   * Name of the image pipeline.
   *
   * @schema ImagePipelineSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Configuration block with schedule settings. Detailed below.
   *
   * @schema ImagePipelineSpecInitProvider#schedule
   */
  readonly schedule?: ImagePipelineSpecInitProviderSchedule[];

  /**
   * Status of the image pipeline. Valid values are DISABLED and ENABLED. Defaults to ENABLED.
   *
   * @default ENABLED.
   * @schema ImagePipelineSpecInitProvider#status
   */
  readonly status?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ImagePipelineSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ImagePipelineSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecInitProvider(obj: ImagePipelineSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerRecipeArn': obj.containerRecipeArn,
    'description': obj.description,
    'distributionConfigurationArn': obj.distributionConfigurationArn,
    'enhancedImageMetadataEnabled': obj.enhancedImageMetadataEnabled,
    'imageTestsConfiguration': obj.imageTestsConfiguration?.map(y => toJson_ImagePipelineSpecInitProviderImageTestsConfiguration(y)),
    'name': obj.name,
    'schedule': obj.schedule?.map(y => toJson_ImagePipelineSpecInitProviderSchedule(y)),
    'status': obj.status,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ImagePipelineSpecManagementPolicies
 */
export enum ImagePipelineSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ImagePipelineSpecProviderConfigRef
 */
export interface ImagePipelineSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImagePipelineSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImagePipelineSpecProviderConfigRef#policy
   */
  readonly policy?: ImagePipelineSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ImagePipelineSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecProviderConfigRef(obj: ImagePipelineSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImagePipelineSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ImagePipelineSpecPublishConnectionDetailsTo
 */
export interface ImagePipelineSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ImagePipelineSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ImagePipelineSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ImagePipelineSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ImagePipelineSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ImagePipelineSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImagePipelineSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecPublishConnectionDetailsTo(obj: ImagePipelineSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ImagePipelineSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ImagePipelineSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ImagePipelineSpecWriteConnectionSecretToRef
 */
export interface ImagePipelineSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ImagePipelineSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ImagePipelineSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ImagePipelineSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecWriteConnectionSecretToRef(obj: ImagePipelineSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ImageRecipe in imagebuilder to populate imageRecipeArn.
 *
 * @schema ImagePipelineSpecForProviderImageRecipeArnRef
 */
export interface ImagePipelineSpecForProviderImageRecipeArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImagePipelineSpecForProviderImageRecipeArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImagePipelineSpecForProviderImageRecipeArnRef#policy
   */
  readonly policy?: ImagePipelineSpecForProviderImageRecipeArnRefPolicy;

}

/**
 * Converts an object of type 'ImagePipelineSpecForProviderImageRecipeArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProviderImageRecipeArnRef(obj: ImagePipelineSpecForProviderImageRecipeArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImagePipelineSpecForProviderImageRecipeArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ImageRecipe in imagebuilder to populate imageRecipeArn.
 *
 * @schema ImagePipelineSpecForProviderImageRecipeArnSelector
 */
export interface ImagePipelineSpecForProviderImageRecipeArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ImagePipelineSpecForProviderImageRecipeArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ImagePipelineSpecForProviderImageRecipeArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ImagePipelineSpecForProviderImageRecipeArnSelector#policy
   */
  readonly policy?: ImagePipelineSpecForProviderImageRecipeArnSelectorPolicy;

}

/**
 * Converts an object of type 'ImagePipelineSpecForProviderImageRecipeArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProviderImageRecipeArnSelector(obj: ImagePipelineSpecForProviderImageRecipeArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ImagePipelineSpecForProviderImageRecipeArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImagePipelineSpecForProviderImageTestsConfiguration
 */
export interface ImagePipelineSpecForProviderImageTestsConfiguration {
  /**
   * Whether image tests are enabled. Defaults to true.
   *
   * @default true.
   * @schema ImagePipelineSpecForProviderImageTestsConfiguration#imageTestsEnabled
   */
  readonly imageTestsEnabled?: boolean;

  /**
   * Number of minutes before image tests time out. Valid values are between 60 and 1440. Defaults to 720.
   *
   * @default 720.
   * @schema ImagePipelineSpecForProviderImageTestsConfiguration#timeoutMinutes
   */
  readonly timeoutMinutes?: number;

}

/**
 * Converts an object of type 'ImagePipelineSpecForProviderImageTestsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProviderImageTestsConfiguration(obj: ImagePipelineSpecForProviderImageTestsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageTestsEnabled': obj.imageTestsEnabled,
    'timeoutMinutes': obj.timeoutMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a InfrastructureConfiguration in imagebuilder to populate infrastructureConfigurationArn.
 *
 * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnRef
 */
export interface ImagePipelineSpecForProviderInfrastructureConfigurationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnRef#policy
   */
  readonly policy?: ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicy;

}

/**
 * Converts an object of type 'ImagePipelineSpecForProviderInfrastructureConfigurationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProviderInfrastructureConfigurationArnRef(obj: ImagePipelineSpecForProviderInfrastructureConfigurationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a InfrastructureConfiguration in imagebuilder to populate infrastructureConfigurationArn.
 *
 * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnSelector
 */
export interface ImagePipelineSpecForProviderInfrastructureConfigurationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnSelector#policy
   */
  readonly policy?: ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicy;

}

/**
 * Converts an object of type 'ImagePipelineSpecForProviderInfrastructureConfigurationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProviderInfrastructureConfigurationArnSelector(obj: ImagePipelineSpecForProviderInfrastructureConfigurationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImagePipelineSpecForProviderSchedule
 */
export interface ImagePipelineSpecForProviderSchedule {
  /**
   * Condition when the pipeline should trigger a new image build. Valid values are EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE and EXPRESSION_MATCH_ONLY. Defaults to EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE.
   *
   * @default EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE.
   * @schema ImagePipelineSpecForProviderSchedule#pipelineExecutionStartCondition
   */
  readonly pipelineExecutionStartCondition?: string;

  /**
   * Cron expression of how often the pipeline start condition is evaluated. For example, cron(0 0 * * ? *) is evaluated every day at midnight UTC. Configurations using the five field syntax that was previously accepted by the API, such as cron(0 0 * * *), must be updated to the six field syntax. For more information, see the Image Builder User Guide.
   *
   * @schema ImagePipelineSpecForProviderSchedule#scheduleExpression
   */
  readonly scheduleExpression?: string;

  /**
   * The timezone that applies to the scheduling expression. For example, "Etc/UTC", "America/Los_Angeles" in the IANA timezone format. If not specified this defaults to UTC.
   *
   * @schema ImagePipelineSpecForProviderSchedule#timezone
   */
  readonly timezone?: string;

}

/**
 * Converts an object of type 'ImagePipelineSpecForProviderSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProviderSchedule(obj: ImagePipelineSpecForProviderSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pipelineExecutionStartCondition': obj.pipelineExecutionStartCondition,
    'scheduleExpression': obj.scheduleExpression,
    'timezone': obj.timezone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImagePipelineSpecInitProviderImageTestsConfiguration
 */
export interface ImagePipelineSpecInitProviderImageTestsConfiguration {
  /**
   * Whether image tests are enabled. Defaults to true.
   *
   * @default true.
   * @schema ImagePipelineSpecInitProviderImageTestsConfiguration#imageTestsEnabled
   */
  readonly imageTestsEnabled?: boolean;

  /**
   * Number of minutes before image tests time out. Valid values are between 60 and 1440. Defaults to 720.
   *
   * @default 720.
   * @schema ImagePipelineSpecInitProviderImageTestsConfiguration#timeoutMinutes
   */
  readonly timeoutMinutes?: number;

}

/**
 * Converts an object of type 'ImagePipelineSpecInitProviderImageTestsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecInitProviderImageTestsConfiguration(obj: ImagePipelineSpecInitProviderImageTestsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageTestsEnabled': obj.imageTestsEnabled,
    'timeoutMinutes': obj.timeoutMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImagePipelineSpecInitProviderSchedule
 */
export interface ImagePipelineSpecInitProviderSchedule {
  /**
   * Condition when the pipeline should trigger a new image build. Valid values are EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE and EXPRESSION_MATCH_ONLY. Defaults to EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE.
   *
   * @default EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE.
   * @schema ImagePipelineSpecInitProviderSchedule#pipelineExecutionStartCondition
   */
  readonly pipelineExecutionStartCondition?: string;

  /**
   * Cron expression of how often the pipeline start condition is evaluated. For example, cron(0 0 * * ? *) is evaluated every day at midnight UTC. Configurations using the five field syntax that was previously accepted by the API, such as cron(0 0 * * *), must be updated to the six field syntax. For more information, see the Image Builder User Guide.
   *
   * @schema ImagePipelineSpecInitProviderSchedule#scheduleExpression
   */
  readonly scheduleExpression?: string;

  /**
   * The timezone that applies to the scheduling expression. For example, "Etc/UTC", "America/Los_Angeles" in the IANA timezone format. If not specified this defaults to UTC.
   *
   * @schema ImagePipelineSpecInitProviderSchedule#timezone
   */
  readonly timezone?: string;

}

/**
 * Converts an object of type 'ImagePipelineSpecInitProviderSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecInitProviderSchedule(obj: ImagePipelineSpecInitProviderSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pipelineExecutionStartCondition': obj.pipelineExecutionStartCondition,
    'scheduleExpression': obj.scheduleExpression,
    'timezone': obj.timezone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImagePipelineSpecProviderConfigRefPolicy
 */
export interface ImagePipelineSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImagePipelineSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ImagePipelineSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImagePipelineSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ImagePipelineSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImagePipelineSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecProviderConfigRefPolicy(obj: ImagePipelineSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ImagePipelineSpecPublishConnectionDetailsToConfigRef
 */
export interface ImagePipelineSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImagePipelineSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImagePipelineSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ImagePipelineSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecPublishConnectionDetailsToConfigRef(obj: ImagePipelineSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ImagePipelineSpecPublishConnectionDetailsToMetadata
 */
export interface ImagePipelineSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImagePipelineSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImagePipelineSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ImagePipelineSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ImagePipelineSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecPublishConnectionDetailsToMetadata(obj: ImagePipelineSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImagePipelineSpecForProviderImageRecipeArnRefPolicy
 */
export interface ImagePipelineSpecForProviderImageRecipeArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImagePipelineSpecForProviderImageRecipeArnRefPolicy#resolution
   */
  readonly resolution?: ImagePipelineSpecForProviderImageRecipeArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImagePipelineSpecForProviderImageRecipeArnRefPolicy#resolve
   */
  readonly resolve?: ImagePipelineSpecForProviderImageRecipeArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ImagePipelineSpecForProviderImageRecipeArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProviderImageRecipeArnRefPolicy(obj: ImagePipelineSpecForProviderImageRecipeArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ImagePipelineSpecForProviderImageRecipeArnSelectorPolicy
 */
export interface ImagePipelineSpecForProviderImageRecipeArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImagePipelineSpecForProviderImageRecipeArnSelectorPolicy#resolution
   */
  readonly resolution?: ImagePipelineSpecForProviderImageRecipeArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImagePipelineSpecForProviderImageRecipeArnSelectorPolicy#resolve
   */
  readonly resolve?: ImagePipelineSpecForProviderImageRecipeArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ImagePipelineSpecForProviderImageRecipeArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProviderImageRecipeArnSelectorPolicy(obj: ImagePipelineSpecForProviderImageRecipeArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicy
 */
export interface ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicy#resolution
   */
  readonly resolution?: ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicy#resolve
   */
  readonly resolve?: ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicy(obj: ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicy
 */
export interface ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicy#resolution
   */
  readonly resolution?: ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicy#resolve
   */
  readonly resolve?: ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicy(obj: ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImagePipelineSpecProviderConfigRefPolicyResolution
 */
export enum ImagePipelineSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImagePipelineSpecProviderConfigRefPolicyResolve
 */
export enum ImagePipelineSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicy(obj: ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImagePipelineSpecForProviderImageRecipeArnRefPolicyResolution
 */
export enum ImagePipelineSpecForProviderImageRecipeArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImagePipelineSpecForProviderImageRecipeArnRefPolicyResolve
 */
export enum ImagePipelineSpecForProviderImageRecipeArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImagePipelineSpecForProviderImageRecipeArnSelectorPolicyResolution
 */
export enum ImagePipelineSpecForProviderImageRecipeArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImagePipelineSpecForProviderImageRecipeArnSelectorPolicyResolve
 */
export enum ImagePipelineSpecForProviderImageRecipeArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicyResolution
 */
export enum ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicyResolve
 */
export enum ImagePipelineSpecForProviderInfrastructureConfigurationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolution
 */
export enum ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolve
 */
export enum ImagePipelineSpecForProviderInfrastructureConfigurationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ImagePipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ImageRecipe is the Schema for the ImageRecipes API. Manage an Image Builder Image Recipe
 *
 * @schema ImageRecipe
 */
export class ImageRecipe extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImageRecipe"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'imagebuilder.aws.upbound.io/v1beta1',
    kind: 'ImageRecipe',
  }

  /**
   * Renders a Kubernetes manifest for "ImageRecipe".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageRecipeProps): any {
    return {
      ...ImageRecipe.GVK,
      ...toJson_ImageRecipeProps(props),
    };
  }

  /**
   * Defines a "ImageRecipe" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageRecipeProps) {
    super(scope, id, {
      ...ImageRecipe.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImageRecipe.GVK,
      ...toJson_ImageRecipeProps(resolved),
    };
  }
}

/**
 * ImageRecipe is the Schema for the ImageRecipes API. Manage an Image Builder Image Recipe
 *
 * @schema ImageRecipe
 */
export interface ImageRecipeProps {
  /**
   * @schema ImageRecipe#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageRecipeSpec defines the desired state of ImageRecipe
   *
   * @schema ImageRecipe#spec
   */
  readonly spec: ImageRecipeSpec;

}

/**
 * Converts an object of type 'ImageRecipeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeProps(obj: ImageRecipeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageRecipeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRecipeSpec defines the desired state of ImageRecipe
 *
 * @schema ImageRecipeSpec
 */
export interface ImageRecipeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ImageRecipeSpec#deletionPolicy
   */
  readonly deletionPolicy?: ImageRecipeSpecDeletionPolicy;

  /**
   * @schema ImageRecipeSpec#forProvider
   */
  readonly forProvider: ImageRecipeSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ImageRecipeSpec#initProvider
   */
  readonly initProvider?: ImageRecipeSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ImageRecipeSpec#managementPolicies
   */
  readonly managementPolicies?: ImageRecipeSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ImageRecipeSpec#providerConfigRef
   */
  readonly providerConfigRef?: ImageRecipeSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ImageRecipeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ImageRecipeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ImageRecipeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ImageRecipeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ImageRecipeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpec(obj: ImageRecipeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ImageRecipeSpecForProvider(obj.forProvider),
    'initProvider': toJson_ImageRecipeSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ImageRecipeSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ImageRecipeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ImageRecipeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ImageRecipeSpecDeletionPolicy
 */
export enum ImageRecipeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ImageRecipeSpecForProvider
 */
export interface ImageRecipeSpecForProvider {
  /**
   * Configuration block(s) with block device mappings for the image recipe. Detailed below.
   *
   * @schema ImageRecipeSpecForProvider#blockDeviceMapping
   */
  readonly blockDeviceMapping?: ImageRecipeSpecForProviderBlockDeviceMapping[];

  /**
   * Ordered configuration block(s) with components for the image recipe. Detailed below.
   *
   * @schema ImageRecipeSpecForProvider#component
   */
  readonly component?: ImageRecipeSpecForProviderComponent[];

  /**
   * Description of the image recipe.
   *
   * @schema ImageRecipeSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Name of the image recipe.
   *
   * @schema ImageRecipeSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The image recipe uses this image as a base from which to build your customized image. The value can be the base image ARN or an AMI ID.
   *
   * @schema ImageRecipeSpecForProvider#parentImage
   */
  readonly parentImage?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ImageRecipeSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block for the Systems Manager Agent installed by default by Image Builder. Detailed below.
   *
   * @schema ImageRecipeSpecForProvider#systemsManagerAgent
   */
  readonly systemsManagerAgent?: ImageRecipeSpecForProviderSystemsManagerAgent[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ImageRecipeSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Base64 encoded user data. Use this to provide commands or a command script to run when you launch your build instance.
   *
   * @schema ImageRecipeSpecForProvider#userDataBase64
   */
  readonly userDataBase64?: string;

  /**
   * The semantic version of the image recipe, which specifies the version in the following format, with numeric values in each position to indicate a specific version: major.minor.patch. For example: 1.0.0.
   *
   * @schema ImageRecipeSpecForProvider#version
   */
  readonly version?: string;

  /**
   * The working directory to be used during build and test workflows.
   *
   * @schema ImageRecipeSpecForProvider#workingDirectory
   */
  readonly workingDirectory?: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecForProvider(obj: ImageRecipeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockDeviceMapping': obj.blockDeviceMapping?.map(y => toJson_ImageRecipeSpecForProviderBlockDeviceMapping(y)),
    'component': obj.component?.map(y => toJson_ImageRecipeSpecForProviderComponent(y)),
    'description': obj.description,
    'name': obj.name,
    'parentImage': obj.parentImage,
    'region': obj.region,
    'systemsManagerAgent': obj.systemsManagerAgent?.map(y => toJson_ImageRecipeSpecForProviderSystemsManagerAgent(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'userDataBase64': obj.userDataBase64,
    'version': obj.version,
    'workingDirectory': obj.workingDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ImageRecipeSpecInitProvider
 */
export interface ImageRecipeSpecInitProvider {
  /**
   * Configuration block(s) with block device mappings for the image recipe. Detailed below.
   *
   * @schema ImageRecipeSpecInitProvider#blockDeviceMapping
   */
  readonly blockDeviceMapping?: ImageRecipeSpecInitProviderBlockDeviceMapping[];

  /**
   * Ordered configuration block(s) with components for the image recipe. Detailed below.
   *
   * @schema ImageRecipeSpecInitProvider#component
   */
  readonly component?: ImageRecipeSpecInitProviderComponent[];

  /**
   * Description of the image recipe.
   *
   * @schema ImageRecipeSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Name of the image recipe.
   *
   * @schema ImageRecipeSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The image recipe uses this image as a base from which to build your customized image. The value can be the base image ARN or an AMI ID.
   *
   * @schema ImageRecipeSpecInitProvider#parentImage
   */
  readonly parentImage?: string;

  /**
   * Configuration block for the Systems Manager Agent installed by default by Image Builder. Detailed below.
   *
   * @schema ImageRecipeSpecInitProvider#systemsManagerAgent
   */
  readonly systemsManagerAgent?: ImageRecipeSpecInitProviderSystemsManagerAgent[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ImageRecipeSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Base64 encoded user data. Use this to provide commands or a command script to run when you launch your build instance.
   *
   * @schema ImageRecipeSpecInitProvider#userDataBase64
   */
  readonly userDataBase64?: string;

  /**
   * The semantic version of the image recipe, which specifies the version in the following format, with numeric values in each position to indicate a specific version: major.minor.patch. For example: 1.0.0.
   *
   * @schema ImageRecipeSpecInitProvider#version
   */
  readonly version?: string;

  /**
   * The working directory to be used during build and test workflows.
   *
   * @schema ImageRecipeSpecInitProvider#workingDirectory
   */
  readonly workingDirectory?: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecInitProvider(obj: ImageRecipeSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockDeviceMapping': obj.blockDeviceMapping?.map(y => toJson_ImageRecipeSpecInitProviderBlockDeviceMapping(y)),
    'component': obj.component?.map(y => toJson_ImageRecipeSpecInitProviderComponent(y)),
    'description': obj.description,
    'name': obj.name,
    'parentImage': obj.parentImage,
    'systemsManagerAgent': obj.systemsManagerAgent?.map(y => toJson_ImageRecipeSpecInitProviderSystemsManagerAgent(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'userDataBase64': obj.userDataBase64,
    'version': obj.version,
    'workingDirectory': obj.workingDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ImageRecipeSpecManagementPolicies
 */
export enum ImageRecipeSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ImageRecipeSpecProviderConfigRef
 */
export interface ImageRecipeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageRecipeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageRecipeSpecProviderConfigRef#policy
   */
  readonly policy?: ImageRecipeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ImageRecipeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecProviderConfigRef(obj: ImageRecipeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageRecipeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ImageRecipeSpecPublishConnectionDetailsTo
 */
export interface ImageRecipeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ImageRecipeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ImageRecipeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ImageRecipeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ImageRecipeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ImageRecipeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecPublishConnectionDetailsTo(obj: ImageRecipeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ImageRecipeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ImageRecipeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ImageRecipeSpecWriteConnectionSecretToRef
 */
export interface ImageRecipeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ImageRecipeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ImageRecipeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecWriteConnectionSecretToRef(obj: ImageRecipeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageRecipeSpecForProviderBlockDeviceMapping
 */
export interface ImageRecipeSpecForProviderBlockDeviceMapping {
  /**
   * Name of the device. For example, /dev/sda or /dev/xvdb.
   *
   * @schema ImageRecipeSpecForProviderBlockDeviceMapping#deviceName
   */
  readonly deviceName?: string;

  /**
   * Configuration block with Elastic Block Storage (EBS) block device mapping settings. Detailed below.
   *
   * @schema ImageRecipeSpecForProviderBlockDeviceMapping#ebs
   */
  readonly ebs?: ImageRecipeSpecForProviderBlockDeviceMappingEbs[];

  /**
   * Set to true to remove a mapping from the parent image.
   *
   * @schema ImageRecipeSpecForProviderBlockDeviceMapping#noDevice
   */
  readonly noDevice?: boolean;

  /**
   * Virtual device name. For example, ephemeral0. Instance store volumes are numbered starting from 0.
   *
   * @schema ImageRecipeSpecForProviderBlockDeviceMapping#virtualName
   */
  readonly virtualName?: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecForProviderBlockDeviceMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecForProviderBlockDeviceMapping(obj: ImageRecipeSpecForProviderBlockDeviceMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'ebs': obj.ebs?.map(y => toJson_ImageRecipeSpecForProviderBlockDeviceMappingEbs(y)),
    'noDevice': obj.noDevice,
    'virtualName': obj.virtualName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageRecipeSpecForProviderComponent
 */
export interface ImageRecipeSpecForProviderComponent {
  /**
   * Amazon Resource Name (ARN) of the Image Builder Component to associate.
   *
   * @schema ImageRecipeSpecForProviderComponent#componentArn
   */
  readonly componentArn?: string;

  /**
   * Reference to a Component in imagebuilder to populate componentArn.
   *
   * @schema ImageRecipeSpecForProviderComponent#componentArnRef
   */
  readonly componentArnRef?: ImageRecipeSpecForProviderComponentComponentArnRef;

  /**
   * Selector for a Component in imagebuilder to populate componentArn.
   *
   * @schema ImageRecipeSpecForProviderComponent#componentArnSelector
   */
  readonly componentArnSelector?: ImageRecipeSpecForProviderComponentComponentArnSelector;

  /**
   * Configuration block(s) for parameters to configure the component. Detailed below.
   *
   * @schema ImageRecipeSpecForProviderComponent#parameter
   */
  readonly parameter?: ImageRecipeSpecForProviderComponentParameter[];

}

/**
 * Converts an object of type 'ImageRecipeSpecForProviderComponent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecForProviderComponent(obj: ImageRecipeSpecForProviderComponent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'componentArn': obj.componentArn,
    'componentArnRef': toJson_ImageRecipeSpecForProviderComponentComponentArnRef(obj.componentArnRef),
    'componentArnSelector': toJson_ImageRecipeSpecForProviderComponentComponentArnSelector(obj.componentArnSelector),
    'parameter': obj.parameter?.map(y => toJson_ImageRecipeSpecForProviderComponentParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageRecipeSpecForProviderSystemsManagerAgent
 */
export interface ImageRecipeSpecForProviderSystemsManagerAgent {
  /**
   * Whether to remove the Systems Manager Agent after the image has been built. Defaults to false.
   *
   * @default false.
   * @schema ImageRecipeSpecForProviderSystemsManagerAgent#uninstallAfterBuild
   */
  readonly uninstallAfterBuild?: boolean;

}

/**
 * Converts an object of type 'ImageRecipeSpecForProviderSystemsManagerAgent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecForProviderSystemsManagerAgent(obj: ImageRecipeSpecForProviderSystemsManagerAgent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'uninstallAfterBuild': obj.uninstallAfterBuild,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageRecipeSpecInitProviderBlockDeviceMapping
 */
export interface ImageRecipeSpecInitProviderBlockDeviceMapping {
  /**
   * Name of the device. For example, /dev/sda or /dev/xvdb.
   *
   * @schema ImageRecipeSpecInitProviderBlockDeviceMapping#deviceName
   */
  readonly deviceName?: string;

  /**
   * Configuration block with Elastic Block Storage (EBS) block device mapping settings. Detailed below.
   *
   * @schema ImageRecipeSpecInitProviderBlockDeviceMapping#ebs
   */
  readonly ebs?: ImageRecipeSpecInitProviderBlockDeviceMappingEbs[];

  /**
   * Set to true to remove a mapping from the parent image.
   *
   * @schema ImageRecipeSpecInitProviderBlockDeviceMapping#noDevice
   */
  readonly noDevice?: boolean;

  /**
   * Virtual device name. For example, ephemeral0. Instance store volumes are numbered starting from 0.
   *
   * @schema ImageRecipeSpecInitProviderBlockDeviceMapping#virtualName
   */
  readonly virtualName?: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecInitProviderBlockDeviceMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecInitProviderBlockDeviceMapping(obj: ImageRecipeSpecInitProviderBlockDeviceMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'ebs': obj.ebs?.map(y => toJson_ImageRecipeSpecInitProviderBlockDeviceMappingEbs(y)),
    'noDevice': obj.noDevice,
    'virtualName': obj.virtualName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageRecipeSpecInitProviderComponent
 */
export interface ImageRecipeSpecInitProviderComponent {
  /**
   * Configuration block(s) for parameters to configure the component. Detailed below.
   *
   * @schema ImageRecipeSpecInitProviderComponent#parameter
   */
  readonly parameter?: ImageRecipeSpecInitProviderComponentParameter[];

}

/**
 * Converts an object of type 'ImageRecipeSpecInitProviderComponent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecInitProviderComponent(obj: ImageRecipeSpecInitProviderComponent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameter': obj.parameter?.map(y => toJson_ImageRecipeSpecInitProviderComponentParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageRecipeSpecInitProviderSystemsManagerAgent
 */
export interface ImageRecipeSpecInitProviderSystemsManagerAgent {
  /**
   * Whether to remove the Systems Manager Agent after the image has been built. Defaults to false.
   *
   * @default false.
   * @schema ImageRecipeSpecInitProviderSystemsManagerAgent#uninstallAfterBuild
   */
  readonly uninstallAfterBuild?: boolean;

}

/**
 * Converts an object of type 'ImageRecipeSpecInitProviderSystemsManagerAgent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecInitProviderSystemsManagerAgent(obj: ImageRecipeSpecInitProviderSystemsManagerAgent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'uninstallAfterBuild': obj.uninstallAfterBuild,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageRecipeSpecProviderConfigRefPolicy
 */
export interface ImageRecipeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageRecipeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ImageRecipeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageRecipeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ImageRecipeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageRecipeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecProviderConfigRefPolicy(obj: ImageRecipeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ImageRecipeSpecPublishConnectionDetailsToConfigRef
 */
export interface ImageRecipeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageRecipeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageRecipeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ImageRecipeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecPublishConnectionDetailsToConfigRef(obj: ImageRecipeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ImageRecipeSpecPublishConnectionDetailsToMetadata
 */
export interface ImageRecipeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImageRecipeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImageRecipeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ImageRecipeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecPublishConnectionDetailsToMetadata(obj: ImageRecipeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageRecipeSpecForProviderBlockDeviceMappingEbs
 */
export interface ImageRecipeSpecForProviderBlockDeviceMappingEbs {
  /**
   * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
   *
   * @default unset, which is the value inherited from the parent image.
   * @schema ImageRecipeSpecForProviderBlockDeviceMappingEbs#deleteOnTermination
   */
  readonly deleteOnTermination?: string;

  /**
   * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
   *
   * @default unset, which is the value inherited from the parent image.
   * @schema ImageRecipeSpecForProviderBlockDeviceMappingEbs#encrypted
   */
  readonly encrypted?: string;

  /**
   * Number of Input/Output (I/O) operations per second to provision for an io1 or io2 volume.
   *
   * @schema ImageRecipeSpecForProviderBlockDeviceMappingEbs#iops
   */
  readonly iops?: number;

  /**
   * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key for encryption.
   *
   * @schema ImageRecipeSpecForProviderBlockDeviceMappingEbs#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Identifier of the EC2 Volume Snapshot.
   *
   * @schema ImageRecipeSpecForProviderBlockDeviceMappingEbs#snapshotId
   */
  readonly snapshotId?: string;

  /**
   * For GP3 volumes only. The throughput in MiB/s that the volume supports.
   *
   * @schema ImageRecipeSpecForProviderBlockDeviceMappingEbs#throughput
   */
  readonly throughput?: number;

  /**
   * Size of the volume, in GiB.
   *
   * @schema ImageRecipeSpecForProviderBlockDeviceMappingEbs#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * Type of the volume. For example, gp2 or io2.
   *
   * @schema ImageRecipeSpecForProviderBlockDeviceMappingEbs#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecForProviderBlockDeviceMappingEbs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecForProviderBlockDeviceMappingEbs(obj: ImageRecipeSpecForProviderBlockDeviceMappingEbs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'kmsKeyId': obj.kmsKeyId,
    'snapshotId': obj.snapshotId,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Component in imagebuilder to populate componentArn.
 *
 * @schema ImageRecipeSpecForProviderComponentComponentArnRef
 */
export interface ImageRecipeSpecForProviderComponentComponentArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageRecipeSpecForProviderComponentComponentArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageRecipeSpecForProviderComponentComponentArnRef#policy
   */
  readonly policy?: ImageRecipeSpecForProviderComponentComponentArnRefPolicy;

}

/**
 * Converts an object of type 'ImageRecipeSpecForProviderComponentComponentArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecForProviderComponentComponentArnRef(obj: ImageRecipeSpecForProviderComponentComponentArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageRecipeSpecForProviderComponentComponentArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Component in imagebuilder to populate componentArn.
 *
 * @schema ImageRecipeSpecForProviderComponentComponentArnSelector
 */
export interface ImageRecipeSpecForProviderComponentComponentArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ImageRecipeSpecForProviderComponentComponentArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ImageRecipeSpecForProviderComponentComponentArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ImageRecipeSpecForProviderComponentComponentArnSelector#policy
   */
  readonly policy?: ImageRecipeSpecForProviderComponentComponentArnSelectorPolicy;

}

/**
 * Converts an object of type 'ImageRecipeSpecForProviderComponentComponentArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecForProviderComponentComponentArnSelector(obj: ImageRecipeSpecForProviderComponentComponentArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ImageRecipeSpecForProviderComponentComponentArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageRecipeSpecForProviderComponentParameter
 */
export interface ImageRecipeSpecForProviderComponentParameter {
  /**
   * The name of the component parameter.
   *
   * @schema ImageRecipeSpecForProviderComponentParameter#name
   */
  readonly name?: string;

  /**
   * The value for the named component parameter.
   *
   * @schema ImageRecipeSpecForProviderComponentParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecForProviderComponentParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecForProviderComponentParameter(obj: ImageRecipeSpecForProviderComponentParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageRecipeSpecInitProviderBlockDeviceMappingEbs
 */
export interface ImageRecipeSpecInitProviderBlockDeviceMappingEbs {
  /**
   * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
   *
   * @default unset, which is the value inherited from the parent image.
   * @schema ImageRecipeSpecInitProviderBlockDeviceMappingEbs#deleteOnTermination
   */
  readonly deleteOnTermination?: string;

  /**
   * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
   *
   * @default unset, which is the value inherited from the parent image.
   * @schema ImageRecipeSpecInitProviderBlockDeviceMappingEbs#encrypted
   */
  readonly encrypted?: string;

  /**
   * Number of Input/Output (I/O) operations per second to provision for an io1 or io2 volume.
   *
   * @schema ImageRecipeSpecInitProviderBlockDeviceMappingEbs#iops
   */
  readonly iops?: number;

  /**
   * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key for encryption.
   *
   * @schema ImageRecipeSpecInitProviderBlockDeviceMappingEbs#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Identifier of the EC2 Volume Snapshot.
   *
   * @schema ImageRecipeSpecInitProviderBlockDeviceMappingEbs#snapshotId
   */
  readonly snapshotId?: string;

  /**
   * For GP3 volumes only. The throughput in MiB/s that the volume supports.
   *
   * @schema ImageRecipeSpecInitProviderBlockDeviceMappingEbs#throughput
   */
  readonly throughput?: number;

  /**
   * Size of the volume, in GiB.
   *
   * @schema ImageRecipeSpecInitProviderBlockDeviceMappingEbs#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * Type of the volume. For example, gp2 or io2.
   *
   * @schema ImageRecipeSpecInitProviderBlockDeviceMappingEbs#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecInitProviderBlockDeviceMappingEbs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecInitProviderBlockDeviceMappingEbs(obj: ImageRecipeSpecInitProviderBlockDeviceMappingEbs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'kmsKeyId': obj.kmsKeyId,
    'snapshotId': obj.snapshotId,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageRecipeSpecInitProviderComponentParameter
 */
export interface ImageRecipeSpecInitProviderComponentParameter {
  /**
   * The name of the component parameter.
   *
   * @schema ImageRecipeSpecInitProviderComponentParameter#name
   */
  readonly name?: string;

  /**
   * The value for the named component parameter.
   *
   * @schema ImageRecipeSpecInitProviderComponentParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ImageRecipeSpecInitProviderComponentParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecInitProviderComponentParameter(obj: ImageRecipeSpecInitProviderComponentParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageRecipeSpecProviderConfigRefPolicyResolution
 */
export enum ImageRecipeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageRecipeSpecProviderConfigRefPolicyResolve
 */
export enum ImageRecipeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicy(obj: ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageRecipeSpecForProviderComponentComponentArnRefPolicy
 */
export interface ImageRecipeSpecForProviderComponentComponentArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageRecipeSpecForProviderComponentComponentArnRefPolicy#resolution
   */
  readonly resolution?: ImageRecipeSpecForProviderComponentComponentArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageRecipeSpecForProviderComponentComponentArnRefPolicy#resolve
   */
  readonly resolve?: ImageRecipeSpecForProviderComponentComponentArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageRecipeSpecForProviderComponentComponentArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecForProviderComponentComponentArnRefPolicy(obj: ImageRecipeSpecForProviderComponentComponentArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ImageRecipeSpecForProviderComponentComponentArnSelectorPolicy
 */
export interface ImageRecipeSpecForProviderComponentComponentArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageRecipeSpecForProviderComponentComponentArnSelectorPolicy#resolution
   */
  readonly resolution?: ImageRecipeSpecForProviderComponentComponentArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageRecipeSpecForProviderComponentComponentArnSelectorPolicy#resolve
   */
  readonly resolve?: ImageRecipeSpecForProviderComponentComponentArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ImageRecipeSpecForProviderComponentComponentArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRecipeSpecForProviderComponentComponentArnSelectorPolicy(obj: ImageRecipeSpecForProviderComponentComponentArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ImageRecipeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageRecipeSpecForProviderComponentComponentArnRefPolicyResolution
 */
export enum ImageRecipeSpecForProviderComponentComponentArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageRecipeSpecForProviderComponentComponentArnRefPolicyResolve
 */
export enum ImageRecipeSpecForProviderComponentComponentArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageRecipeSpecForProviderComponentComponentArnSelectorPolicyResolution
 */
export enum ImageRecipeSpecForProviderComponentComponentArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageRecipeSpecForProviderComponentComponentArnSelectorPolicyResolve
 */
export enum ImageRecipeSpecForProviderComponentComponentArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InfrastructureConfiguration is the Schema for the InfrastructureConfigurations API. Manages an Image Builder Infrastructure Configuration
 *
 * @schema InfrastructureConfiguration
 */
export class InfrastructureConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InfrastructureConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'imagebuilder.aws.upbound.io/v1beta1',
    kind: 'InfrastructureConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "InfrastructureConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InfrastructureConfigurationProps): any {
    return {
      ...InfrastructureConfiguration.GVK,
      ...toJson_InfrastructureConfigurationProps(props),
    };
  }

  /**
   * Defines a "InfrastructureConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InfrastructureConfigurationProps) {
    super(scope, id, {
      ...InfrastructureConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InfrastructureConfiguration.GVK,
      ...toJson_InfrastructureConfigurationProps(resolved),
    };
  }
}

/**
 * InfrastructureConfiguration is the Schema for the InfrastructureConfigurations API. Manages an Image Builder Infrastructure Configuration
 *
 * @schema InfrastructureConfiguration
 */
export interface InfrastructureConfigurationProps {
  /**
   * @schema InfrastructureConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InfrastructureConfigurationSpec defines the desired state of InfrastructureConfiguration
   *
   * @schema InfrastructureConfiguration#spec
   */
  readonly spec: InfrastructureConfigurationSpec;

}

/**
 * Converts an object of type 'InfrastructureConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationProps(obj: InfrastructureConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InfrastructureConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InfrastructureConfigurationSpec defines the desired state of InfrastructureConfiguration
 *
 * @schema InfrastructureConfigurationSpec
 */
export interface InfrastructureConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InfrastructureConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: InfrastructureConfigurationSpecDeletionPolicy;

  /**
   * @schema InfrastructureConfigurationSpec#forProvider
   */
  readonly forProvider: InfrastructureConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InfrastructureConfigurationSpec#initProvider
   */
  readonly initProvider?: InfrastructureConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InfrastructureConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: InfrastructureConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InfrastructureConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: InfrastructureConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InfrastructureConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InfrastructureConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InfrastructureConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InfrastructureConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpec(obj: InfrastructureConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InfrastructureConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_InfrastructureConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InfrastructureConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InfrastructureConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InfrastructureConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InfrastructureConfigurationSpecDeletionPolicy
 */
export enum InfrastructureConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InfrastructureConfigurationSpecForProvider
 */
export interface InfrastructureConfigurationSpecForProvider {
  /**
   * Description for the configuration.
   *
   * @schema InfrastructureConfigurationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Configuration block with instance metadata options for the HTTP requests that pipeline builds use to launch EC2 build and test instances. Detailed below.
   *
   * @schema InfrastructureConfigurationSpecForProvider#instanceMetadataOptions
   */
  readonly instanceMetadataOptions?: InfrastructureConfigurationSpecForProviderInstanceMetadataOptions[];

  /**
   * Name of IAM Instance Profile.
   *
   * @schema InfrastructureConfigurationSpecForProvider#instanceProfileName
   */
  readonly instanceProfileName?: string;

  /**
   * Reference to a InstanceProfile in iam to populate instanceProfileName.
   *
   * @schema InfrastructureConfigurationSpecForProvider#instanceProfileNameRef
   */
  readonly instanceProfileNameRef?: InfrastructureConfigurationSpecForProviderInstanceProfileNameRef;

  /**
   * Selector for a InstanceProfile in iam to populate instanceProfileName.
   *
   * @schema InfrastructureConfigurationSpecForProvider#instanceProfileNameSelector
   */
  readonly instanceProfileNameSelector?: InfrastructureConfigurationSpecForProviderInstanceProfileNameSelector;

  /**
   * Set of EC2 Instance Types.
   *
   * @schema InfrastructureConfigurationSpecForProvider#instanceTypes
   */
  readonly instanceTypes?: string[];

  /**
   * Name of EC2 Key Pair.
   *
   * @schema InfrastructureConfigurationSpecForProvider#keyPair
   */
  readonly keyPair?: string;

  /**
   * Reference to a KeyPair in ec2 to populate keyPair.
   *
   * @schema InfrastructureConfigurationSpecForProvider#keyPairRef
   */
  readonly keyPairRef?: InfrastructureConfigurationSpecForProviderKeyPairRef;

  /**
   * Selector for a KeyPair in ec2 to populate keyPair.
   *
   * @schema InfrastructureConfigurationSpecForProvider#keyPairSelector
   */
  readonly keyPairSelector?: InfrastructureConfigurationSpecForProviderKeyPairSelector;

  /**
   * Configuration block with logging settings. Detailed below.
   *
   * @schema InfrastructureConfigurationSpecForProvider#logging
   */
  readonly logging?: InfrastructureConfigurationSpecForProviderLogging[];

  /**
   * Name for the configuration.
   *
   * @schema InfrastructureConfigurationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InfrastructureConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags to assign to infrastructure created by the configuration.
   *
   * @schema InfrastructureConfigurationSpecForProvider#resourceTags
   */
  readonly resourceTags?: { [key: string]: string };

  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema InfrastructureConfigurationSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: InfrastructureConfigurationSpecForProviderSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema InfrastructureConfigurationSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: InfrastructureConfigurationSpecForProviderSecurityGroupIdSelector;

  /**
   * Set of EC2 Security Group identifiers.
   *
   * @schema InfrastructureConfigurationSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * Amazon Resource Name (ARN) of SNS Topic.
   *
   * @schema InfrastructureConfigurationSpecForProvider#snsTopicArn
   */
  readonly snsTopicArn?: string;

  /**
   * Reference to a Topic in sns to populate snsTopicArn.
   *
   * @schema InfrastructureConfigurationSpecForProvider#snsTopicArnRef
   */
  readonly snsTopicArnRef?: InfrastructureConfigurationSpecForProviderSnsTopicArnRef;

  /**
   * Selector for a Topic in sns to populate snsTopicArn.
   *
   * @schema InfrastructureConfigurationSpecForProvider#snsTopicArnSelector
   */
  readonly snsTopicArnSelector?: InfrastructureConfigurationSpecForProviderSnsTopicArnSelector;

  /**
   * EC2 Subnet identifier. Also requires security_group_ids argument.
   *
   * @schema InfrastructureConfigurationSpecForProvider#subnetId
   */
  readonly subnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate subnetId.
   *
   * @schema InfrastructureConfigurationSpecForProvider#subnetIdRef
   */
  readonly subnetIdRef?: InfrastructureConfigurationSpecForProviderSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate subnetId.
   *
   * @schema InfrastructureConfigurationSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: InfrastructureConfigurationSpecForProviderSubnetIdSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema InfrastructureConfigurationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Enable if the instance should be terminated when the pipeline fails. Defaults to false.
   *
   * @default false.
   * @schema InfrastructureConfigurationSpecForProvider#terminateInstanceOnFailure
   */
  readonly terminateInstanceOnFailure?: boolean;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProvider(obj: InfrastructureConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceMetadataOptions': obj.instanceMetadataOptions?.map(y => toJson_InfrastructureConfigurationSpecForProviderInstanceMetadataOptions(y)),
    'instanceProfileName': obj.instanceProfileName,
    'instanceProfileNameRef': toJson_InfrastructureConfigurationSpecForProviderInstanceProfileNameRef(obj.instanceProfileNameRef),
    'instanceProfileNameSelector': toJson_InfrastructureConfigurationSpecForProviderInstanceProfileNameSelector(obj.instanceProfileNameSelector),
    'instanceTypes': obj.instanceTypes?.map(y => y),
    'keyPair': obj.keyPair,
    'keyPairRef': toJson_InfrastructureConfigurationSpecForProviderKeyPairRef(obj.keyPairRef),
    'keyPairSelector': toJson_InfrastructureConfigurationSpecForProviderKeyPairSelector(obj.keyPairSelector),
    'logging': obj.logging?.map(y => toJson_InfrastructureConfigurationSpecForProviderLogging(y)),
    'name': obj.name,
    'region': obj.region,
    'resourceTags': ((obj.resourceTags) === undefined) ? undefined : (Object.entries(obj.resourceTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_InfrastructureConfigurationSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_InfrastructureConfigurationSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'snsTopicArn': obj.snsTopicArn,
    'snsTopicArnRef': toJson_InfrastructureConfigurationSpecForProviderSnsTopicArnRef(obj.snsTopicArnRef),
    'snsTopicArnSelector': toJson_InfrastructureConfigurationSpecForProviderSnsTopicArnSelector(obj.snsTopicArnSelector),
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_InfrastructureConfigurationSpecForProviderSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_InfrastructureConfigurationSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'terminateInstanceOnFailure': obj.terminateInstanceOnFailure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema InfrastructureConfigurationSpecInitProvider
 */
export interface InfrastructureConfigurationSpecInitProvider {
  /**
   * Description for the configuration.
   *
   * @schema InfrastructureConfigurationSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Configuration block with instance metadata options for the HTTP requests that pipeline builds use to launch EC2 build and test instances. Detailed below.
   *
   * @schema InfrastructureConfigurationSpecInitProvider#instanceMetadataOptions
   */
  readonly instanceMetadataOptions?: InfrastructureConfigurationSpecInitProviderInstanceMetadataOptions[];

  /**
   * Set of EC2 Instance Types.
   *
   * @schema InfrastructureConfigurationSpecInitProvider#instanceTypes
   */
  readonly instanceTypes?: string[];

  /**
   * Configuration block with logging settings. Detailed below.
   *
   * @schema InfrastructureConfigurationSpecInitProvider#logging
   */
  readonly logging?: InfrastructureConfigurationSpecInitProviderLogging[];

  /**
   * Name for the configuration.
   *
   * @schema InfrastructureConfigurationSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags to assign to infrastructure created by the configuration.
   *
   * @schema InfrastructureConfigurationSpecInitProvider#resourceTags
   */
  readonly resourceTags?: { [key: string]: string };

  /**
   * Key-value map of resource tags.
   *
   * @schema InfrastructureConfigurationSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Enable if the instance should be terminated when the pipeline fails. Defaults to false.
   *
   * @default false.
   * @schema InfrastructureConfigurationSpecInitProvider#terminateInstanceOnFailure
   */
  readonly terminateInstanceOnFailure?: boolean;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecInitProvider(obj: InfrastructureConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceMetadataOptions': obj.instanceMetadataOptions?.map(y => toJson_InfrastructureConfigurationSpecInitProviderInstanceMetadataOptions(y)),
    'instanceTypes': obj.instanceTypes?.map(y => y),
    'logging': obj.logging?.map(y => toJson_InfrastructureConfigurationSpecInitProviderLogging(y)),
    'name': obj.name,
    'resourceTags': ((obj.resourceTags) === undefined) ? undefined : (Object.entries(obj.resourceTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'terminateInstanceOnFailure': obj.terminateInstanceOnFailure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InfrastructureConfigurationSpecManagementPolicies
 */
export enum InfrastructureConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InfrastructureConfigurationSpecProviderConfigRef
 */
export interface InfrastructureConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InfrastructureConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InfrastructureConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: InfrastructureConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecProviderConfigRef(obj: InfrastructureConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InfrastructureConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InfrastructureConfigurationSpecPublishConnectionDetailsTo
 */
export interface InfrastructureConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InfrastructureConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InfrastructureConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InfrastructureConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InfrastructureConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecPublishConnectionDetailsTo(obj: InfrastructureConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InfrastructureConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InfrastructureConfigurationSpecWriteConnectionSecretToRef
 */
export interface InfrastructureConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InfrastructureConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InfrastructureConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecWriteConnectionSecretToRef(obj: InfrastructureConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InfrastructureConfigurationSpecForProviderInstanceMetadataOptions
 */
export interface InfrastructureConfigurationSpecForProviderInstanceMetadataOptions {
  /**
   * The number of hops that an instance can traverse to reach its destonation.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceMetadataOptions#httpPutResponseHopLimit
   */
  readonly httpPutResponseHopLimit?: number;

  /**
   * Whether a signed token is required for instance metadata retrieval requests. Valid values: required, optional.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceMetadataOptions#httpTokens
   */
  readonly httpTokens?: string;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderInstanceMetadataOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderInstanceMetadataOptions(obj: InfrastructureConfigurationSpecForProviderInstanceMetadataOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpPutResponseHopLimit': obj.httpPutResponseHopLimit,
    'httpTokens': obj.httpTokens,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a InstanceProfile in iam to populate instanceProfileName.
 *
 * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameRef
 */
export interface InfrastructureConfigurationSpecForProviderInstanceProfileNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameRef#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderInstanceProfileNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderInstanceProfileNameRef(obj: InfrastructureConfigurationSpecForProviderInstanceProfileNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a InstanceProfile in iam to populate instanceProfileName.
 *
 * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameSelector
 */
export interface InfrastructureConfigurationSpecForProviderInstanceProfileNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameSelector#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderInstanceProfileNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderInstanceProfileNameSelector(obj: InfrastructureConfigurationSpecForProviderInstanceProfileNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a KeyPair in ec2 to populate keyPair.
 *
 * @schema InfrastructureConfigurationSpecForProviderKeyPairRef
 */
export interface InfrastructureConfigurationSpecForProviderKeyPairRef {
  /**
   * Name of the referenced object.
   *
   * @schema InfrastructureConfigurationSpecForProviderKeyPairRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InfrastructureConfigurationSpecForProviderKeyPairRef#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderKeyPairRefPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderKeyPairRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderKeyPairRef(obj: InfrastructureConfigurationSpecForProviderKeyPairRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InfrastructureConfigurationSpecForProviderKeyPairRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a KeyPair in ec2 to populate keyPair.
 *
 * @schema InfrastructureConfigurationSpecForProviderKeyPairSelector
 */
export interface InfrastructureConfigurationSpecForProviderKeyPairSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderKeyPairSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderKeyPairSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InfrastructureConfigurationSpecForProviderKeyPairSelector#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderKeyPairSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderKeyPairSelector(obj: InfrastructureConfigurationSpecForProviderKeyPairSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InfrastructureConfigurationSpecForProviderLogging
 */
export interface InfrastructureConfigurationSpecForProviderLogging {
  /**
   * Configuration block with S3 logging settings. Detailed below.
   *
   * @schema InfrastructureConfigurationSpecForProviderLogging#s3Logs
   */
  readonly s3Logs?: InfrastructureConfigurationSpecForProviderLoggingS3Logs[];

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderLogging(obj: InfrastructureConfigurationSpecForProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3Logs': obj.s3Logs?.map(y => toJson_InfrastructureConfigurationSpecForProviderLoggingS3Logs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdRefs
 */
export interface InfrastructureConfigurationSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSecurityGroupIdRefs(obj: InfrastructureConfigurationSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdSelector
 */
export interface InfrastructureConfigurationSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSecurityGroupIdSelector(obj: InfrastructureConfigurationSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate snsTopicArn.
 *
 * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnRef
 */
export interface InfrastructureConfigurationSpecForProviderSnsTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnRef#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSnsTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSnsTopicArnRef(obj: InfrastructureConfigurationSpecForProviderSnsTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate snsTopicArn.
 *
 * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnSelector
 */
export interface InfrastructureConfigurationSpecForProviderSnsTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnSelector#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSnsTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSnsTopicArnSelector(obj: InfrastructureConfigurationSpecForProviderSnsTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate subnetId.
 *
 * @schema InfrastructureConfigurationSpecForProviderSubnetIdRef
 */
export interface InfrastructureConfigurationSpecForProviderSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InfrastructureConfigurationSpecForProviderSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InfrastructureConfigurationSpecForProviderSubnetIdRef#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSubnetIdRef(obj: InfrastructureConfigurationSpecForProviderSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InfrastructureConfigurationSpecForProviderSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate subnetId.
 *
 * @schema InfrastructureConfigurationSpecForProviderSubnetIdSelector
 */
export interface InfrastructureConfigurationSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InfrastructureConfigurationSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSubnetIdSelector(obj: InfrastructureConfigurationSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InfrastructureConfigurationSpecInitProviderInstanceMetadataOptions
 */
export interface InfrastructureConfigurationSpecInitProviderInstanceMetadataOptions {
  /**
   * The number of hops that an instance can traverse to reach its destonation.
   *
   * @schema InfrastructureConfigurationSpecInitProviderInstanceMetadataOptions#httpPutResponseHopLimit
   */
  readonly httpPutResponseHopLimit?: number;

  /**
   * Whether a signed token is required for instance metadata retrieval requests. Valid values: required, optional.
   *
   * @schema InfrastructureConfigurationSpecInitProviderInstanceMetadataOptions#httpTokens
   */
  readonly httpTokens?: string;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecInitProviderInstanceMetadataOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecInitProviderInstanceMetadataOptions(obj: InfrastructureConfigurationSpecInitProviderInstanceMetadataOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpPutResponseHopLimit': obj.httpPutResponseHopLimit,
    'httpTokens': obj.httpTokens,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InfrastructureConfigurationSpecInitProviderLogging
 */
export interface InfrastructureConfigurationSpecInitProviderLogging {
  /**
   * Configuration block with S3 logging settings. Detailed below.
   *
   * @schema InfrastructureConfigurationSpecInitProviderLogging#s3Logs
   */
  readonly s3Logs?: InfrastructureConfigurationSpecInitProviderLoggingS3Logs[];

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecInitProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecInitProviderLogging(obj: InfrastructureConfigurationSpecInitProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3Logs': obj.s3Logs?.map(y => toJson_InfrastructureConfigurationSpecInitProviderLoggingS3Logs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InfrastructureConfigurationSpecProviderConfigRefPolicy
 */
export interface InfrastructureConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecProviderConfigRefPolicy(obj: InfrastructureConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRef(obj: InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface InfrastructureConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecPublishConnectionDetailsToMetadata(obj: InfrastructureConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicy
 */
export interface InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicy(obj: InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicy
 */
export interface InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicy(obj: InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InfrastructureConfigurationSpecForProviderKeyPairRefPolicy
 */
export interface InfrastructureConfigurationSpecForProviderKeyPairRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderKeyPairRefPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderKeyPairRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderKeyPairRefPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderKeyPairRefPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderKeyPairRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderKeyPairRefPolicy(obj: InfrastructureConfigurationSpecForProviderKeyPairRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicy
 */
export interface InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicy(obj: InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InfrastructureConfigurationSpecForProviderLoggingS3Logs
 */
export interface InfrastructureConfigurationSpecForProviderLoggingS3Logs {
  /**
   * Name of the S3 Bucket.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3Logs#s3BucketName
   */
  readonly s3BucketName?: string;

  /**
   * Reference to a Bucket in s3 to populate s3BucketName.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3Logs#s3BucketNameRef
   */
  readonly s3BucketNameRef?: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRef;

  /**
   * Selector for a Bucket in s3 to populate s3BucketName.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3Logs#s3BucketNameSelector
   */
  readonly s3BucketNameSelector?: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelector;

  /**
   * Prefix to use for S3 logs. Defaults to /.
   *
   * @default .
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3Logs#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderLoggingS3Logs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderLoggingS3Logs(obj: InfrastructureConfigurationSpecForProviderLoggingS3Logs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3BucketName': obj.s3BucketName,
    's3BucketNameRef': toJson_InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRef(obj.s3BucketNameRef),
    's3BucketNameSelector': toJson_InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelector(obj.s3BucketNameSelector),
    's3KeyPrefix': obj.s3KeyPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicy(obj: InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicy(obj: InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicy
 */
export interface InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicy(obj: InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicy
 */
export interface InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicy(obj: InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InfrastructureConfigurationSpecForProviderSubnetIdRefPolicy
 */
export interface InfrastructureConfigurationSpecForProviderSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderSubnetIdRefPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderSubnetIdRefPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSubnetIdRefPolicy(obj: InfrastructureConfigurationSpecForProviderSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicy
 */
export interface InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicy(obj: InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InfrastructureConfigurationSpecInitProviderLoggingS3Logs
 */
export interface InfrastructureConfigurationSpecInitProviderLoggingS3Logs {
  /**
   * Prefix to use for S3 logs. Defaults to /.
   *
   * @default .
   * @schema InfrastructureConfigurationSpecInitProviderLoggingS3Logs#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecInitProviderLoggingS3Logs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecInitProviderLoggingS3Logs(obj: InfrastructureConfigurationSpecInitProviderLoggingS3Logs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3KeyPrefix': obj.s3KeyPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum InfrastructureConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum InfrastructureConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderInstanceProfileNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderInstanceProfileNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderKeyPairRefPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderKeyPairRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderKeyPairRefPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderKeyPairRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderKeyPairSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Bucket in s3 to populate s3BucketName.
 *
 * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRef
 */
export interface InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRef#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRef(obj: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate s3BucketName.
 *
 * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelector
 */
export interface InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelector#policy
   */
  readonly policy?: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelector(obj: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderSnsTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderSnsTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderSubnetIdRefPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderSubnetIdRefPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InfrastructureConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicy
 */
export interface InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicy(obj: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicy
 */
export interface InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicy#resolution
   */
  readonly resolution?: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicy#resolve
   */
  readonly resolve?: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicy(obj: InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicyResolution
 */
export enum InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicyResolve
 */
export enum InfrastructureConfigurationSpecForProviderLoggingS3LogsS3BucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

