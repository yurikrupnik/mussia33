// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * App is the Schema for the Apps API. Provides an Amplify App resource.
 *
 * @schema App
 */
export class App extends ApiObject {
  /**
   * Returns the apiVersion and kind for "App"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'amplify.aws.upbound.io/v1beta1',
    kind: 'App',
  }

  /**
   * Renders a Kubernetes manifest for "App".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppProps): any {
    return {
      ...App.GVK,
      ...toJson_AppProps(props),
    };
  }

  /**
   * Defines a "App" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppProps) {
    super(scope, id, {
      ...App.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...App.GVK,
      ...toJson_AppProps(resolved),
    };
  }
}

/**
 * App is the Schema for the Apps API. Provides an Amplify App resource.
 *
 * @schema App
 */
export interface AppProps {
  /**
   * @schema App#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppSpec defines the desired state of App
   *
   * @schema App#spec
   */
  readonly spec: AppSpec;

}

/**
 * Converts an object of type 'AppProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppProps(obj: AppProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppSpec defines the desired state of App
 *
 * @schema AppSpec
 */
export interface AppSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppSpecDeletionPolicy;

  /**
   * @schema AppSpec#forProvider
   */
  readonly forProvider: AppSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppSpec#managementPolicy
   */
  readonly managementPolicy?: AppSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AppSpec#providerRef
   */
  readonly providerRef?: AppSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpec(obj: AppSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AppSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AppSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AppSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppSpecDeletionPolicy
 */
export enum AppSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppSpecForProvider
 */
export interface AppSpecForProvider {
  /**
   * Personal access token for a third-party source control system for an Amplify app. The personal access token is used to create a webhook and a read-only deploy key. The token is not stored.
   *
   * @schema AppSpecForProvider#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: AppSpecForProviderAccessTokenSecretRef;

  /**
   * Automated branch creation configuration for an Amplify app. An auto_branch_creation_config block is documented below.
   *
   * @schema AppSpecForProvider#autoBranchCreationConfig
   */
  readonly autoBranchCreationConfig?: AppSpecForProviderAutoBranchCreationConfig[];

  /**
   * Automated branch creation glob patterns for an Amplify app.
   *
   * @schema AppSpecForProvider#autoBranchCreationPatterns
   */
  readonly autoBranchCreationPatterns?: string[];

  /**
   * Credentials for basic authorization for an Amplify app.
   *
   * @schema AppSpecForProvider#basicAuthCredentialsSecretRef
   */
  readonly basicAuthCredentialsSecretRef?: AppSpecForProviderBasicAuthCredentialsSecretRef;

  /**
   * The build specification (build spec) for an Amplify app.
   *
   * @schema AppSpecForProvider#buildSpec
   */
  readonly buildSpec?: string;

  /**
   * Custom rewrite and redirect rules for an Amplify app. A custom_rule block is documented below.
   *
   * @schema AppSpecForProvider#customRule
   */
  readonly customRule?: AppSpecForProviderCustomRule[];

  /**
   * Description for an Amplify app.
   *
   * @schema AppSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Enables automated branch creation for an Amplify app.
   *
   * @schema AppSpecForProvider#enableAutoBranchCreation
   */
  readonly enableAutoBranchCreation?: boolean;

  /**
   * Enables basic authorization for an Amplify app. This will apply to all branches that are part of this app.
   *
   * @schema AppSpecForProvider#enableBasicAuth
   */
  readonly enableBasicAuth?: boolean;

  /**
   * Enables auto-building of branches for the Amplify App.
   *
   * @schema AppSpecForProvider#enableBranchAutoBuild
   */
  readonly enableBranchAutoBuild?: boolean;

  /**
   * Automatically disconnects a branch in the Amplify Console when you delete a branch from your Git repository.
   *
   * @schema AppSpecForProvider#enableBranchAutoDeletion
   */
  readonly enableBranchAutoDeletion?: boolean;

  /**
   * Environment variables map for an Amplify app.
   *
   * @schema AppSpecForProvider#environmentVariables
   */
  readonly environmentVariables?: { [key: string]: string };

  /**
   * AWS Identity and Access Management (IAM) service role for an Amplify app.
   *
   * @schema AppSpecForProvider#iamServiceRoleArn
   */
  readonly iamServiceRoleArn?: string;

  /**
   * Reference to a Role in iam to populate iamServiceRoleArn.
   *
   * @schema AppSpecForProvider#iamServiceRoleArnRef
   */
  readonly iamServiceRoleArnRef?: AppSpecForProviderIamServiceRoleArnRef;

  /**
   * Selector for a Role in iam to populate iamServiceRoleArn.
   *
   * @schema AppSpecForProvider#iamServiceRoleArnSelector
   */
  readonly iamServiceRoleArnSelector?: AppSpecForProviderIamServiceRoleArnSelector;

  /**
   * Name for an Amplify app.
   *
   * @schema AppSpecForProvider#name
   */
  readonly name?: string;

  /**
   * OAuth token for a third-party source control system for an Amplify app. The OAuth token is used to create a webhook and a read-only deploy key. The OAuth token is not stored.
   *
   * @schema AppSpecForProvider#oauthTokenSecretRef
   */
  readonly oauthTokenSecretRef?: AppSpecForProviderOauthTokenSecretRef;

  /**
   * Platform or framework for an Amplify app. Valid values: WEB, WEB_COMPUTE. Default value: WEB.
   *
   * @schema AppSpecForProvider#platform
   */
  readonly platform?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AppSpecForProvider#region
   */
  readonly region: string;

  /**
   * Repository for an Amplify app.
   *
   * @schema AppSpecForProvider#repository
   */
  readonly repository?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AppSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AppSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProvider(obj: AppSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_AppSpecForProviderAccessTokenSecretRef(obj.accessTokenSecretRef),
    'autoBranchCreationConfig': obj.autoBranchCreationConfig?.map(y => toJson_AppSpecForProviderAutoBranchCreationConfig(y)),
    'autoBranchCreationPatterns': obj.autoBranchCreationPatterns?.map(y => y),
    'basicAuthCredentialsSecretRef': toJson_AppSpecForProviderBasicAuthCredentialsSecretRef(obj.basicAuthCredentialsSecretRef),
    'buildSpec': obj.buildSpec,
    'customRule': obj.customRule?.map(y => toJson_AppSpecForProviderCustomRule(y)),
    'description': obj.description,
    'enableAutoBranchCreation': obj.enableAutoBranchCreation,
    'enableBasicAuth': obj.enableBasicAuth,
    'enableBranchAutoBuild': obj.enableBranchAutoBuild,
    'enableBranchAutoDeletion': obj.enableBranchAutoDeletion,
    'environmentVariables': ((obj.environmentVariables) === undefined) ? undefined : (Object.entries(obj.environmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'iamServiceRoleArn': obj.iamServiceRoleArn,
    'iamServiceRoleArnRef': toJson_AppSpecForProviderIamServiceRoleArnRef(obj.iamServiceRoleArnRef),
    'iamServiceRoleArnSelector': toJson_AppSpecForProviderIamServiceRoleArnSelector(obj.iamServiceRoleArnSelector),
    'name': obj.name,
    'oauthTokenSecretRef': toJson_AppSpecForProviderOauthTokenSecretRef(obj.oauthTokenSecretRef),
    'platform': obj.platform,
    'region': obj.region,
    'repository': obj.repository,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppSpecManagementPolicy
 */
export enum AppSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppSpecProviderConfigRef
 */
export interface AppSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecProviderConfigRef#policy
   */
  readonly policy?: AppSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderConfigRef(obj: AppSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AppSpecProviderRef
 */
export interface AppSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecProviderRef#policy
   */
  readonly policy?: AppSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AppSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderRef(obj: AppSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppSpecPublishConnectionDetailsTo
 */
export interface AppSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsTo(obj: AppSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppSpecWriteConnectionSecretToRef
 */
export interface AppSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecWriteConnectionSecretToRef(obj: AppSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Personal access token for a third-party source control system for an Amplify app. The personal access token is used to create a webhook and a read-only deploy key. The token is not stored.
 *
 * @schema AppSpecForProviderAccessTokenSecretRef
 */
export interface AppSpecForProviderAccessTokenSecretRef {
  /**
   * The key to select.
   *
   * @schema AppSpecForProviderAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema AppSpecForProviderAccessTokenSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppSpecForProviderAccessTokenSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppSpecForProviderAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderAccessTokenSecretRef(obj: AppSpecForProviderAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecForProviderAutoBranchCreationConfig
 */
export interface AppSpecForProviderAutoBranchCreationConfig {
  /**
   * Basic authorization credentials for the autocreated branch.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfig#basicAuthCredentialsSecretRef
   */
  readonly basicAuthCredentialsSecretRef?: AppSpecForProviderAutoBranchCreationConfigBasicAuthCredentialsSecretRef;

  /**
   * Build specification (build spec) for the autocreated branch.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfig#buildSpec
   */
  readonly buildSpec?: string;

  /**
   * Enables auto building for the autocreated branch.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfig#enableAutoBuild
   */
  readonly enableAutoBuild?: boolean;

  /**
   * Enables basic authorization for the autocreated branch.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfig#enableBasicAuth
   */
  readonly enableBasicAuth?: boolean;

  /**
   * Enables performance mode for the branch.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfig#enablePerformanceMode
   */
  readonly enablePerformanceMode?: boolean;

  /**
   * Enables pull request previews for the autocreated branch.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfig#enablePullRequestPreview
   */
  readonly enablePullRequestPreview?: boolean;

  /**
   * Environment variables for the autocreated branch.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfig#environmentVariables
   */
  readonly environmentVariables?: { [key: string]: string };

  /**
   * Framework for the autocreated branch.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfig#framework
   */
  readonly framework?: string;

  /**
   * Amplify environment name for the pull request.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfig#pullRequestEnvironmentName
   */
  readonly pullRequestEnvironmentName?: string;

  /**
   * Describes the current stage for the autocreated branch. Valid values: PRODUCTION, BETA, DEVELOPMENT, EXPERIMENTAL, PULL_REQUEST.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfig#stage
   */
  readonly stage?: string;

}

/**
 * Converts an object of type 'AppSpecForProviderAutoBranchCreationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderAutoBranchCreationConfig(obj: AppSpecForProviderAutoBranchCreationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuthCredentialsSecretRef': toJson_AppSpecForProviderAutoBranchCreationConfigBasicAuthCredentialsSecretRef(obj.basicAuthCredentialsSecretRef),
    'buildSpec': obj.buildSpec,
    'enableAutoBuild': obj.enableAutoBuild,
    'enableBasicAuth': obj.enableBasicAuth,
    'enablePerformanceMode': obj.enablePerformanceMode,
    'enablePullRequestPreview': obj.enablePullRequestPreview,
    'environmentVariables': ((obj.environmentVariables) === undefined) ? undefined : (Object.entries(obj.environmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'framework': obj.framework,
    'pullRequestEnvironmentName': obj.pullRequestEnvironmentName,
    'stage': obj.stage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Credentials for basic authorization for an Amplify app.
 *
 * @schema AppSpecForProviderBasicAuthCredentialsSecretRef
 */
export interface AppSpecForProviderBasicAuthCredentialsSecretRef {
  /**
   * The key to select.
   *
   * @schema AppSpecForProviderBasicAuthCredentialsSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema AppSpecForProviderBasicAuthCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppSpecForProviderBasicAuthCredentialsSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppSpecForProviderBasicAuthCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderBasicAuthCredentialsSecretRef(obj: AppSpecForProviderBasicAuthCredentialsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecForProviderCustomRule
 */
export interface AppSpecForProviderCustomRule {
  /**
   * Condition for a URL rewrite or redirect rule, such as a country code.
   *
   * @schema AppSpecForProviderCustomRule#condition
   */
  readonly condition?: string;

  /**
   * Source pattern for a URL rewrite or redirect rule.
   *
   * @schema AppSpecForProviderCustomRule#source
   */
  readonly source: string;

  /**
   * Status code for a URL rewrite or redirect rule. Valid values: 200, 301, 302, 404, 404-200.
   *
   * @schema AppSpecForProviderCustomRule#status
   */
  readonly status?: string;

  /**
   * Target pattern for a URL rewrite or redirect rule.
   *
   * @schema AppSpecForProviderCustomRule#target
   */
  readonly target: string;

}

/**
 * Converts an object of type 'AppSpecForProviderCustomRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderCustomRule(obj: AppSpecForProviderCustomRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition,
    'source': obj.source,
    'status': obj.status,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamServiceRoleArn.
 *
 * @schema AppSpecForProviderIamServiceRoleArnRef
 */
export interface AppSpecForProviderIamServiceRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecForProviderIamServiceRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecForProviderIamServiceRoleArnRef#policy
   */
  readonly policy?: AppSpecForProviderIamServiceRoleArnRefPolicy;

}

/**
 * Converts an object of type 'AppSpecForProviderIamServiceRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderIamServiceRoleArnRef(obj: AppSpecForProviderIamServiceRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecForProviderIamServiceRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamServiceRoleArn.
 *
 * @schema AppSpecForProviderIamServiceRoleArnSelector
 */
export interface AppSpecForProviderIamServiceRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AppSpecForProviderIamServiceRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AppSpecForProviderIamServiceRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AppSpecForProviderIamServiceRoleArnSelector#policy
   */
  readonly policy?: AppSpecForProviderIamServiceRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'AppSpecForProviderIamServiceRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderIamServiceRoleArnSelector(obj: AppSpecForProviderIamServiceRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AppSpecForProviderIamServiceRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth token for a third-party source control system for an Amplify app. The OAuth token is used to create a webhook and a read-only deploy key. The OAuth token is not stored.
 *
 * @schema AppSpecForProviderOauthTokenSecretRef
 */
export interface AppSpecForProviderOauthTokenSecretRef {
  /**
   * The key to select.
   *
   * @schema AppSpecForProviderOauthTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema AppSpecForProviderOauthTokenSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppSpecForProviderOauthTokenSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppSpecForProviderOauthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderOauthTokenSecretRef(obj: AppSpecForProviderOauthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecProviderConfigRefPolicy
 */
export interface AppSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderConfigRefPolicy(obj: AppSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecProviderRefPolicy
 */
export interface AppSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AppSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AppSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderRefPolicy(obj: AppSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRef
 */
export interface AppSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToConfigRef(obj: AppSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppSpecPublishConnectionDetailsToMetadata
 */
export interface AppSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToMetadata(obj: AppSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Basic authorization credentials for the autocreated branch.
 *
 * @schema AppSpecForProviderAutoBranchCreationConfigBasicAuthCredentialsSecretRef
 */
export interface AppSpecForProviderAutoBranchCreationConfigBasicAuthCredentialsSecretRef {
  /**
   * The key to select.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfigBasicAuthCredentialsSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfigBasicAuthCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppSpecForProviderAutoBranchCreationConfigBasicAuthCredentialsSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppSpecForProviderAutoBranchCreationConfigBasicAuthCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderAutoBranchCreationConfigBasicAuthCredentialsSecretRef(obj: AppSpecForProviderAutoBranchCreationConfigBasicAuthCredentialsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecForProviderIamServiceRoleArnRefPolicy
 */
export interface AppSpecForProviderIamServiceRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecForProviderIamServiceRoleArnRefPolicy#resolution
   */
  readonly resolution?: AppSpecForProviderIamServiceRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecForProviderIamServiceRoleArnRefPolicy#resolve
   */
  readonly resolve?: AppSpecForProviderIamServiceRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecForProviderIamServiceRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderIamServiceRoleArnRefPolicy(obj: AppSpecForProviderIamServiceRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AppSpecForProviderIamServiceRoleArnSelectorPolicy
 */
export interface AppSpecForProviderIamServiceRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecForProviderIamServiceRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: AppSpecForProviderIamServiceRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecForProviderIamServiceRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: AppSpecForProviderIamServiceRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecForProviderIamServiceRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderIamServiceRoleArnSelectorPolicy(obj: AppSpecForProviderIamServiceRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecProviderConfigRefPolicyResolution
 */
export enum AppSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecProviderConfigRefPolicyResolve
 */
export enum AppSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecProviderRefPolicyResolution
 */
export enum AppSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecProviderRefPolicyResolve
 */
export enum AppSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecForProviderIamServiceRoleArnRefPolicyResolution
 */
export enum AppSpecForProviderIamServiceRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecForProviderIamServiceRoleArnRefPolicyResolve
 */
export enum AppSpecForProviderIamServiceRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecForProviderIamServiceRoleArnSelectorPolicyResolution
 */
export enum AppSpecForProviderIamServiceRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecForProviderIamServiceRoleArnSelectorPolicyResolve
 */
export enum AppSpecForProviderIamServiceRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BackendEnvironment is the Schema for the BackendEnvironments API. Provides an Amplify Backend Environment resource.
 *
 * @schema BackendEnvironment
 */
export class BackendEnvironment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackendEnvironment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'amplify.aws.upbound.io/v1beta1',
    kind: 'BackendEnvironment',
  }

  /**
   * Renders a Kubernetes manifest for "BackendEnvironment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackendEnvironmentProps): any {
    return {
      ...BackendEnvironment.GVK,
      ...toJson_BackendEnvironmentProps(props),
    };
  }

  /**
   * Defines a "BackendEnvironment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackendEnvironmentProps) {
    super(scope, id, {
      ...BackendEnvironment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackendEnvironment.GVK,
      ...toJson_BackendEnvironmentProps(resolved),
    };
  }
}

/**
 * BackendEnvironment is the Schema for the BackendEnvironments API. Provides an Amplify Backend Environment resource.
 *
 * @schema BackendEnvironment
 */
export interface BackendEnvironmentProps {
  /**
   * @schema BackendEnvironment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackendEnvironmentSpec defines the desired state of BackendEnvironment
   *
   * @schema BackendEnvironment#spec
   */
  readonly spec: BackendEnvironmentSpec;

}

/**
 * Converts an object of type 'BackendEnvironmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentProps(obj: BackendEnvironmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackendEnvironmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackendEnvironmentSpec defines the desired state of BackendEnvironment
 *
 * @schema BackendEnvironmentSpec
 */
export interface BackendEnvironmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BackendEnvironmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: BackendEnvironmentSpecDeletionPolicy;

  /**
   * @schema BackendEnvironmentSpec#forProvider
   */
  readonly forProvider: BackendEnvironmentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BackendEnvironmentSpec#managementPolicy
   */
  readonly managementPolicy?: BackendEnvironmentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BackendEnvironmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: BackendEnvironmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BackendEnvironmentSpec#providerRef
   */
  readonly providerRef?: BackendEnvironmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BackendEnvironmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BackendEnvironmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BackendEnvironmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BackendEnvironmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BackendEnvironmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpec(obj: BackendEnvironmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BackendEnvironmentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_BackendEnvironmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BackendEnvironmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BackendEnvironmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BackendEnvironmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BackendEnvironmentSpecDeletionPolicy
 */
export enum BackendEnvironmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BackendEnvironmentSpecForProvider
 */
export interface BackendEnvironmentSpecForProvider {
  /**
   * Unique ID for an Amplify app.
   *
   * @schema BackendEnvironmentSpecForProvider#appId
   */
  readonly appId?: string;

  /**
   * Reference to a App in amplify to populate appId.
   *
   * @schema BackendEnvironmentSpecForProvider#appIdRef
   */
  readonly appIdRef?: BackendEnvironmentSpecForProviderAppIdRef;

  /**
   * Selector for a App in amplify to populate appId.
   *
   * @schema BackendEnvironmentSpecForProvider#appIdSelector
   */
  readonly appIdSelector?: BackendEnvironmentSpecForProviderAppIdSelector;

  /**
   * Name of deployment artifacts.
   *
   * @schema BackendEnvironmentSpecForProvider#deploymentArtifacts
   */
  readonly deploymentArtifacts?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BackendEnvironmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * AWS CloudFormation stack name of a backend environment.
   *
   * @schema BackendEnvironmentSpecForProvider#stackName
   */
  readonly stackName?: string;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecForProvider(obj: BackendEnvironmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appId': obj.appId,
    'appIdRef': toJson_BackendEnvironmentSpecForProviderAppIdRef(obj.appIdRef),
    'appIdSelector': toJson_BackendEnvironmentSpecForProviderAppIdSelector(obj.appIdSelector),
    'deploymentArtifacts': obj.deploymentArtifacts,
    'region': obj.region,
    'stackName': obj.stackName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BackendEnvironmentSpecManagementPolicy
 */
export enum BackendEnvironmentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BackendEnvironmentSpecProviderConfigRef
 */
export interface BackendEnvironmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackendEnvironmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackendEnvironmentSpecProviderConfigRef#policy
   */
  readonly policy?: BackendEnvironmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecProviderConfigRef(obj: BackendEnvironmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackendEnvironmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BackendEnvironmentSpecProviderRef
 */
export interface BackendEnvironmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackendEnvironmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackendEnvironmentSpecProviderRef#policy
   */
  readonly policy?: BackendEnvironmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecProviderRef(obj: BackendEnvironmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackendEnvironmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BackendEnvironmentSpecPublishConnectionDetailsTo
 */
export interface BackendEnvironmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BackendEnvironmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BackendEnvironmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BackendEnvironmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BackendEnvironmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BackendEnvironmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecPublishConnectionDetailsTo(obj: BackendEnvironmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BackendEnvironmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BackendEnvironmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BackendEnvironmentSpecWriteConnectionSecretToRef
 */
export interface BackendEnvironmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BackendEnvironmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BackendEnvironmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecWriteConnectionSecretToRef(obj: BackendEnvironmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a App in amplify to populate appId.
 *
 * @schema BackendEnvironmentSpecForProviderAppIdRef
 */
export interface BackendEnvironmentSpecForProviderAppIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackendEnvironmentSpecForProviderAppIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackendEnvironmentSpecForProviderAppIdRef#policy
   */
  readonly policy?: BackendEnvironmentSpecForProviderAppIdRefPolicy;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecForProviderAppIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecForProviderAppIdRef(obj: BackendEnvironmentSpecForProviderAppIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackendEnvironmentSpecForProviderAppIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a App in amplify to populate appId.
 *
 * @schema BackendEnvironmentSpecForProviderAppIdSelector
 */
export interface BackendEnvironmentSpecForProviderAppIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BackendEnvironmentSpecForProviderAppIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BackendEnvironmentSpecForProviderAppIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BackendEnvironmentSpecForProviderAppIdSelector#policy
   */
  readonly policy?: BackendEnvironmentSpecForProviderAppIdSelectorPolicy;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecForProviderAppIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecForProviderAppIdSelector(obj: BackendEnvironmentSpecForProviderAppIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BackendEnvironmentSpecForProviderAppIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackendEnvironmentSpecProviderConfigRefPolicy
 */
export interface BackendEnvironmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackendEnvironmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BackendEnvironmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackendEnvironmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BackendEnvironmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecProviderConfigRefPolicy(obj: BackendEnvironmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackendEnvironmentSpecProviderRefPolicy
 */
export interface BackendEnvironmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackendEnvironmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BackendEnvironmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackendEnvironmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BackendEnvironmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecProviderRefPolicy(obj: BackendEnvironmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BackendEnvironmentSpecPublishConnectionDetailsToConfigRef
 */
export interface BackendEnvironmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackendEnvironmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackendEnvironmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecPublishConnectionDetailsToConfigRef(obj: BackendEnvironmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BackendEnvironmentSpecPublishConnectionDetailsToMetadata
 */
export interface BackendEnvironmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackendEnvironmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackendEnvironmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BackendEnvironmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecPublishConnectionDetailsToMetadata(obj: BackendEnvironmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackendEnvironmentSpecForProviderAppIdRefPolicy
 */
export interface BackendEnvironmentSpecForProviderAppIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackendEnvironmentSpecForProviderAppIdRefPolicy#resolution
   */
  readonly resolution?: BackendEnvironmentSpecForProviderAppIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackendEnvironmentSpecForProviderAppIdRefPolicy#resolve
   */
  readonly resolve?: BackendEnvironmentSpecForProviderAppIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecForProviderAppIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecForProviderAppIdRefPolicy(obj: BackendEnvironmentSpecForProviderAppIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BackendEnvironmentSpecForProviderAppIdSelectorPolicy
 */
export interface BackendEnvironmentSpecForProviderAppIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackendEnvironmentSpecForProviderAppIdSelectorPolicy#resolution
   */
  readonly resolution?: BackendEnvironmentSpecForProviderAppIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackendEnvironmentSpecForProviderAppIdSelectorPolicy#resolve
   */
  readonly resolve?: BackendEnvironmentSpecForProviderAppIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecForProviderAppIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecForProviderAppIdSelectorPolicy(obj: BackendEnvironmentSpecForProviderAppIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackendEnvironmentSpecProviderConfigRefPolicyResolution
 */
export enum BackendEnvironmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackendEnvironmentSpecProviderConfigRefPolicyResolve
 */
export enum BackendEnvironmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackendEnvironmentSpecProviderRefPolicyResolution
 */
export enum BackendEnvironmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackendEnvironmentSpecProviderRefPolicyResolve
 */
export enum BackendEnvironmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackendEnvironmentSpecForProviderAppIdRefPolicyResolution
 */
export enum BackendEnvironmentSpecForProviderAppIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackendEnvironmentSpecForProviderAppIdRefPolicyResolve
 */
export enum BackendEnvironmentSpecForProviderAppIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackendEnvironmentSpecForProviderAppIdSelectorPolicyResolution
 */
export enum BackendEnvironmentSpecForProviderAppIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackendEnvironmentSpecForProviderAppIdSelectorPolicyResolve
 */
export enum BackendEnvironmentSpecForProviderAppIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BackendEnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Branch is the Schema for the Branchs API. Provides an Amplify Branch resource.
 *
 * @schema Branch
 */
export class Branch extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Branch"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'amplify.aws.upbound.io/v1beta1',
    kind: 'Branch',
  }

  /**
   * Renders a Kubernetes manifest for "Branch".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BranchProps): any {
    return {
      ...Branch.GVK,
      ...toJson_BranchProps(props),
    };
  }

  /**
   * Defines a "Branch" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BranchProps) {
    super(scope, id, {
      ...Branch.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Branch.GVK,
      ...toJson_BranchProps(resolved),
    };
  }
}

/**
 * Branch is the Schema for the Branchs API. Provides an Amplify Branch resource.
 *
 * @schema Branch
 */
export interface BranchProps {
  /**
   * @schema Branch#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BranchSpec defines the desired state of Branch
   *
   * @schema Branch#spec
   */
  readonly spec: BranchSpec;

}

/**
 * Converts an object of type 'BranchProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchProps(obj: BranchProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BranchSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BranchSpec defines the desired state of Branch
 *
 * @schema BranchSpec
 */
export interface BranchSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BranchSpec#deletionPolicy
   */
  readonly deletionPolicy?: BranchSpecDeletionPolicy;

  /**
   * @schema BranchSpec#forProvider
   */
  readonly forProvider: BranchSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BranchSpec#managementPolicy
   */
  readonly managementPolicy?: BranchSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BranchSpec#providerConfigRef
   */
  readonly providerConfigRef?: BranchSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BranchSpec#providerRef
   */
  readonly providerRef?: BranchSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BranchSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BranchSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BranchSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BranchSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BranchSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpec(obj: BranchSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BranchSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_BranchSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BranchSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BranchSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BranchSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BranchSpecDeletionPolicy
 */
export enum BranchSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BranchSpecForProvider
 */
export interface BranchSpecForProvider {
  /**
   * Unique ID for an Amplify app.
   *
   * @schema BranchSpecForProvider#appId
   */
  readonly appId?: string;

  /**
   * Reference to a App in amplify to populate appId.
   *
   * @schema BranchSpecForProvider#appIdRef
   */
  readonly appIdRef?: BranchSpecForProviderAppIdRef;

  /**
   * Selector for a App in amplify to populate appId.
   *
   * @schema BranchSpecForProvider#appIdSelector
   */
  readonly appIdSelector?: BranchSpecForProviderAppIdSelector;

  /**
   * ARN for a backend environment that is part of an Amplify app.
   *
   * @schema BranchSpecForProvider#backendEnvironmentArn
   */
  readonly backendEnvironmentArn?: string;

  /**
   * Basic authorization credentials for the branch.
   *
   * @schema BranchSpecForProvider#basicAuthCredentialsSecretRef
   */
  readonly basicAuthCredentialsSecretRef?: BranchSpecForProviderBasicAuthCredentialsSecretRef;

  /**
   * Description for the branch.
   *
   * @schema BranchSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Display name for a branch. This is used as the default domain prefix.
   *
   * @schema BranchSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Enables auto building for the branch.
   *
   * @schema BranchSpecForProvider#enableAutoBuild
   */
  readonly enableAutoBuild?: boolean;

  /**
   * Enables basic authorization for the branch.
   *
   * @schema BranchSpecForProvider#enableBasicAuth
   */
  readonly enableBasicAuth?: boolean;

  /**
   * Enables notifications for the branch.
   *
   * @schema BranchSpecForProvider#enableNotification
   */
  readonly enableNotification?: boolean;

  /**
   * Enables performance mode for the branch.
   *
   * @schema BranchSpecForProvider#enablePerformanceMode
   */
  readonly enablePerformanceMode?: boolean;

  /**
   * Enables pull request previews for this branch.
   *
   * @schema BranchSpecForProvider#enablePullRequestPreview
   */
  readonly enablePullRequestPreview?: boolean;

  /**
   * Environment variables for the branch.
   *
   * @schema BranchSpecForProvider#environmentVariables
   */
  readonly environmentVariables?: { [key: string]: string };

  /**
   * Framework for the branch.
   *
   * @schema BranchSpecForProvider#framework
   */
  readonly framework?: string;

  /**
   * Amplify environment name for the pull request.
   *
   * @schema BranchSpecForProvider#pullRequestEnvironmentName
   */
  readonly pullRequestEnvironmentName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BranchSpecForProvider#region
   */
  readonly region: string;

  /**
   * Describes the current stage for the branch. Valid values: PRODUCTION, BETA, DEVELOPMENT, EXPERIMENTAL, PULL_REQUEST.
   *
   * @schema BranchSpecForProvider#stage
   */
  readonly stage?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema BranchSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Content Time To Live (TTL) for the website in seconds.
   *
   * @schema BranchSpecForProvider#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'BranchSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecForProvider(obj: BranchSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appId': obj.appId,
    'appIdRef': toJson_BranchSpecForProviderAppIdRef(obj.appIdRef),
    'appIdSelector': toJson_BranchSpecForProviderAppIdSelector(obj.appIdSelector),
    'backendEnvironmentArn': obj.backendEnvironmentArn,
    'basicAuthCredentialsSecretRef': toJson_BranchSpecForProviderBasicAuthCredentialsSecretRef(obj.basicAuthCredentialsSecretRef),
    'description': obj.description,
    'displayName': obj.displayName,
    'enableAutoBuild': obj.enableAutoBuild,
    'enableBasicAuth': obj.enableBasicAuth,
    'enableNotification': obj.enableNotification,
    'enablePerformanceMode': obj.enablePerformanceMode,
    'enablePullRequestPreview': obj.enablePullRequestPreview,
    'environmentVariables': ((obj.environmentVariables) === undefined) ? undefined : (Object.entries(obj.environmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'framework': obj.framework,
    'pullRequestEnvironmentName': obj.pullRequestEnvironmentName,
    'region': obj.region,
    'stage': obj.stage,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BranchSpecManagementPolicy
 */
export enum BranchSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BranchSpecProviderConfigRef
 */
export interface BranchSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BranchSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BranchSpecProviderConfigRef#policy
   */
  readonly policy?: BranchSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BranchSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecProviderConfigRef(obj: BranchSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BranchSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BranchSpecProviderRef
 */
export interface BranchSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BranchSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BranchSpecProviderRef#policy
   */
  readonly policy?: BranchSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BranchSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecProviderRef(obj: BranchSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BranchSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BranchSpecPublishConnectionDetailsTo
 */
export interface BranchSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BranchSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BranchSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BranchSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BranchSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BranchSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BranchSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecPublishConnectionDetailsTo(obj: BranchSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BranchSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BranchSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BranchSpecWriteConnectionSecretToRef
 */
export interface BranchSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BranchSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BranchSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BranchSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecWriteConnectionSecretToRef(obj: BranchSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a App in amplify to populate appId.
 *
 * @schema BranchSpecForProviderAppIdRef
 */
export interface BranchSpecForProviderAppIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BranchSpecForProviderAppIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BranchSpecForProviderAppIdRef#policy
   */
  readonly policy?: BranchSpecForProviderAppIdRefPolicy;

}

/**
 * Converts an object of type 'BranchSpecForProviderAppIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecForProviderAppIdRef(obj: BranchSpecForProviderAppIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BranchSpecForProviderAppIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a App in amplify to populate appId.
 *
 * @schema BranchSpecForProviderAppIdSelector
 */
export interface BranchSpecForProviderAppIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BranchSpecForProviderAppIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BranchSpecForProviderAppIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BranchSpecForProviderAppIdSelector#policy
   */
  readonly policy?: BranchSpecForProviderAppIdSelectorPolicy;

}

/**
 * Converts an object of type 'BranchSpecForProviderAppIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecForProviderAppIdSelector(obj: BranchSpecForProviderAppIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BranchSpecForProviderAppIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Basic authorization credentials for the branch.
 *
 * @schema BranchSpecForProviderBasicAuthCredentialsSecretRef
 */
export interface BranchSpecForProviderBasicAuthCredentialsSecretRef {
  /**
   * The key to select.
   *
   * @schema BranchSpecForProviderBasicAuthCredentialsSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema BranchSpecForProviderBasicAuthCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BranchSpecForProviderBasicAuthCredentialsSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BranchSpecForProviderBasicAuthCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecForProviderBasicAuthCredentialsSecretRef(obj: BranchSpecForProviderBasicAuthCredentialsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BranchSpecProviderConfigRefPolicy
 */
export interface BranchSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BranchSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BranchSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BranchSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BranchSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BranchSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecProviderConfigRefPolicy(obj: BranchSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BranchSpecProviderRefPolicy
 */
export interface BranchSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BranchSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BranchSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BranchSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BranchSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BranchSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecProviderRefPolicy(obj: BranchSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BranchSpecPublishConnectionDetailsToConfigRef
 */
export interface BranchSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BranchSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BranchSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BranchSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BranchSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecPublishConnectionDetailsToConfigRef(obj: BranchSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BranchSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BranchSpecPublishConnectionDetailsToMetadata
 */
export interface BranchSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BranchSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BranchSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BranchSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BranchSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecPublishConnectionDetailsToMetadata(obj: BranchSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BranchSpecForProviderAppIdRefPolicy
 */
export interface BranchSpecForProviderAppIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BranchSpecForProviderAppIdRefPolicy#resolution
   */
  readonly resolution?: BranchSpecForProviderAppIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BranchSpecForProviderAppIdRefPolicy#resolve
   */
  readonly resolve?: BranchSpecForProviderAppIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BranchSpecForProviderAppIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecForProviderAppIdRefPolicy(obj: BranchSpecForProviderAppIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BranchSpecForProviderAppIdSelectorPolicy
 */
export interface BranchSpecForProviderAppIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BranchSpecForProviderAppIdSelectorPolicy#resolution
   */
  readonly resolution?: BranchSpecForProviderAppIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BranchSpecForProviderAppIdSelectorPolicy#resolve
   */
  readonly resolve?: BranchSpecForProviderAppIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BranchSpecForProviderAppIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecForProviderAppIdSelectorPolicy(obj: BranchSpecForProviderAppIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BranchSpecProviderConfigRefPolicyResolution
 */
export enum BranchSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BranchSpecProviderConfigRefPolicyResolve
 */
export enum BranchSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BranchSpecProviderRefPolicyResolution
 */
export enum BranchSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BranchSpecProviderRefPolicyResolve
 */
export enum BranchSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BranchSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BranchSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BranchSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BranchSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BranchSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BranchSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BranchSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BranchSpecPublishConnectionDetailsToConfigRefPolicy(obj: BranchSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BranchSpecForProviderAppIdRefPolicyResolution
 */
export enum BranchSpecForProviderAppIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BranchSpecForProviderAppIdRefPolicyResolve
 */
export enum BranchSpecForProviderAppIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BranchSpecForProviderAppIdSelectorPolicyResolution
 */
export enum BranchSpecForProviderAppIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BranchSpecForProviderAppIdSelectorPolicyResolve
 */
export enum BranchSpecForProviderAppIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BranchSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BranchSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BranchSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BranchSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Webhook is the Schema for the Webhooks API. Provides an Amplify Webhook resource.
 *
 * @schema Webhook
 */
export class Webhook extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Webhook"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'amplify.aws.upbound.io/v1beta1',
    kind: 'Webhook',
  }

  /**
   * Renders a Kubernetes manifest for "Webhook".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WebhookProps): any {
    return {
      ...Webhook.GVK,
      ...toJson_WebhookProps(props),
    };
  }

  /**
   * Defines a "Webhook" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WebhookProps) {
    super(scope, id, {
      ...Webhook.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Webhook.GVK,
      ...toJson_WebhookProps(resolved),
    };
  }
}

/**
 * Webhook is the Schema for the Webhooks API. Provides an Amplify Webhook resource.
 *
 * @schema Webhook
 */
export interface WebhookProps {
  /**
   * @schema Webhook#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WebhookSpec defines the desired state of Webhook
   *
   * @schema Webhook#spec
   */
  readonly spec: WebhookSpec;

}

/**
 * Converts an object of type 'WebhookProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookProps(obj: WebhookProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WebhookSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebhookSpec defines the desired state of Webhook
 *
 * @schema WebhookSpec
 */
export interface WebhookSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WebhookSpec#deletionPolicy
   */
  readonly deletionPolicy?: WebhookSpecDeletionPolicy;

  /**
   * @schema WebhookSpec#forProvider
   */
  readonly forProvider: WebhookSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WebhookSpec#managementPolicy
   */
  readonly managementPolicy?: WebhookSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WebhookSpec#providerConfigRef
   */
  readonly providerConfigRef?: WebhookSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WebhookSpec#providerRef
   */
  readonly providerRef?: WebhookSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WebhookSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WebhookSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WebhookSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WebhookSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WebhookSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpec(obj: WebhookSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WebhookSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_WebhookSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WebhookSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WebhookSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WebhookSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WebhookSpecDeletionPolicy
 */
export enum WebhookSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WebhookSpecForProvider
 */
export interface WebhookSpecForProvider {
  /**
   * Unique ID for an Amplify app.
   *
   * @schema WebhookSpecForProvider#appId
   */
  readonly appId?: string;

  /**
   * Reference to a App in amplify to populate appId.
   *
   * @schema WebhookSpecForProvider#appIdRef
   */
  readonly appIdRef?: WebhookSpecForProviderAppIdRef;

  /**
   * Selector for a App in amplify to populate appId.
   *
   * @schema WebhookSpecForProvider#appIdSelector
   */
  readonly appIdSelector?: WebhookSpecForProviderAppIdSelector;

  /**
   * Name for a branch that is part of the Amplify app.
   *
   * @schema WebhookSpecForProvider#branchName
   */
  readonly branchName?: string;

  /**
   * Reference to a Branch in amplify to populate branchName.
   *
   * @schema WebhookSpecForProvider#branchNameRef
   */
  readonly branchNameRef?: WebhookSpecForProviderBranchNameRef;

  /**
   * Selector for a Branch in amplify to populate branchName.
   *
   * @schema WebhookSpecForProvider#branchNameSelector
   */
  readonly branchNameSelector?: WebhookSpecForProviderBranchNameSelector;

  /**
   * Description for a webhook.
   *
   * @schema WebhookSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WebhookSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'WebhookSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProvider(obj: WebhookSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appId': obj.appId,
    'appIdRef': toJson_WebhookSpecForProviderAppIdRef(obj.appIdRef),
    'appIdSelector': toJson_WebhookSpecForProviderAppIdSelector(obj.appIdSelector),
    'branchName': obj.branchName,
    'branchNameRef': toJson_WebhookSpecForProviderBranchNameRef(obj.branchNameRef),
    'branchNameSelector': toJson_WebhookSpecForProviderBranchNameSelector(obj.branchNameSelector),
    'description': obj.description,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WebhookSpecManagementPolicy
 */
export enum WebhookSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WebhookSpecProviderConfigRef
 */
export interface WebhookSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecProviderConfigRef#policy
   */
  readonly policy?: WebhookSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderConfigRef(obj: WebhookSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WebhookSpecProviderRef
 */
export interface WebhookSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecProviderRef#policy
   */
  readonly policy?: WebhookSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderRef(obj: WebhookSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WebhookSpecPublishConnectionDetailsTo
 */
export interface WebhookSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WebhookSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WebhookSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsTo(obj: WebhookSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WebhookSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WebhookSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WebhookSpecWriteConnectionSecretToRef
 */
export interface WebhookSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WebhookSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebhookSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebhookSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecWriteConnectionSecretToRef(obj: WebhookSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a App in amplify to populate appId.
 *
 * @schema WebhookSpecForProviderAppIdRef
 */
export interface WebhookSpecForProviderAppIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecForProviderAppIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecForProviderAppIdRef#policy
   */
  readonly policy?: WebhookSpecForProviderAppIdRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecForProviderAppIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderAppIdRef(obj: WebhookSpecForProviderAppIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecForProviderAppIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a App in amplify to populate appId.
 *
 * @schema WebhookSpecForProviderAppIdSelector
 */
export interface WebhookSpecForProviderAppIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WebhookSpecForProviderAppIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WebhookSpecForProviderAppIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WebhookSpecForProviderAppIdSelector#policy
   */
  readonly policy?: WebhookSpecForProviderAppIdSelectorPolicy;

}

/**
 * Converts an object of type 'WebhookSpecForProviderAppIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderAppIdSelector(obj: WebhookSpecForProviderAppIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WebhookSpecForProviderAppIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Branch in amplify to populate branchName.
 *
 * @schema WebhookSpecForProviderBranchNameRef
 */
export interface WebhookSpecForProviderBranchNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecForProviderBranchNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecForProviderBranchNameRef#policy
   */
  readonly policy?: WebhookSpecForProviderBranchNameRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecForProviderBranchNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderBranchNameRef(obj: WebhookSpecForProviderBranchNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecForProviderBranchNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Branch in amplify to populate branchName.
 *
 * @schema WebhookSpecForProviderBranchNameSelector
 */
export interface WebhookSpecForProviderBranchNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WebhookSpecForProviderBranchNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WebhookSpecForProviderBranchNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WebhookSpecForProviderBranchNameSelector#policy
   */
  readonly policy?: WebhookSpecForProviderBranchNameSelectorPolicy;

}

/**
 * Converts an object of type 'WebhookSpecForProviderBranchNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderBranchNameSelector(obj: WebhookSpecForProviderBranchNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WebhookSpecForProviderBranchNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecProviderConfigRefPolicy
 */
export interface WebhookSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderConfigRefPolicy(obj: WebhookSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecProviderRefPolicy
 */
export interface WebhookSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderRefPolicy(obj: WebhookSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRef
 */
export interface WebhookSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WebhookSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToConfigRef(obj: WebhookSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WebhookSpecPublishConnectionDetailsToMetadata
 */
export interface WebhookSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToMetadata(obj: WebhookSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecForProviderAppIdRefPolicy
 */
export interface WebhookSpecForProviderAppIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecForProviderAppIdRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecForProviderAppIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecForProviderAppIdRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecForProviderAppIdRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecForProviderAppIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderAppIdRefPolicy(obj: WebhookSpecForProviderAppIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WebhookSpecForProviderAppIdSelectorPolicy
 */
export interface WebhookSpecForProviderAppIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecForProviderAppIdSelectorPolicy#resolution
   */
  readonly resolution?: WebhookSpecForProviderAppIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecForProviderAppIdSelectorPolicy#resolve
   */
  readonly resolve?: WebhookSpecForProviderAppIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecForProviderAppIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderAppIdSelectorPolicy(obj: WebhookSpecForProviderAppIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecForProviderBranchNameRefPolicy
 */
export interface WebhookSpecForProviderBranchNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecForProviderBranchNameRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecForProviderBranchNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecForProviderBranchNameRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecForProviderBranchNameRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecForProviderBranchNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderBranchNameRefPolicy(obj: WebhookSpecForProviderBranchNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WebhookSpecForProviderBranchNameSelectorPolicy
 */
export interface WebhookSpecForProviderBranchNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecForProviderBranchNameSelectorPolicy#resolution
   */
  readonly resolution?: WebhookSpecForProviderBranchNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecForProviderBranchNameSelectorPolicy#resolve
   */
  readonly resolve?: WebhookSpecForProviderBranchNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecForProviderBranchNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderBranchNameSelectorPolicy(obj: WebhookSpecForProviderBranchNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecProviderConfigRefPolicyResolution
 */
export enum WebhookSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecProviderConfigRefPolicyResolve
 */
export enum WebhookSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecProviderRefPolicyResolution
 */
export enum WebhookSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecProviderRefPolicyResolve
 */
export enum WebhookSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WebhookSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToConfigRefPolicy(obj: WebhookSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecForProviderAppIdRefPolicyResolution
 */
export enum WebhookSpecForProviderAppIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecForProviderAppIdRefPolicyResolve
 */
export enum WebhookSpecForProviderAppIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecForProviderAppIdSelectorPolicyResolution
 */
export enum WebhookSpecForProviderAppIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecForProviderAppIdSelectorPolicyResolve
 */
export enum WebhookSpecForProviderAppIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecForProviderBranchNameRefPolicyResolution
 */
export enum WebhookSpecForProviderBranchNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecForProviderBranchNameRefPolicyResolve
 */
export enum WebhookSpecForProviderBranchNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecForProviderBranchNameSelectorPolicyResolution
 */
export enum WebhookSpecForProviderBranchNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecForProviderBranchNameSelectorPolicyResolve
 */
export enum WebhookSpecForProviderBranchNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

