// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ConditionalForwarder is the Schema for the ConditionalForwarders API. Provides a conditional forwarder for managed Microsoft AD in AWS Directory Service.
 *
 * @schema ConditionalForwarder
 */
export class ConditionalForwarder extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConditionalForwarder"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ds.aws.upbound.io/v1beta1',
    kind: 'ConditionalForwarder',
  }

  /**
   * Renders a Kubernetes manifest for "ConditionalForwarder".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConditionalForwarderProps): any {
    return {
      ...ConditionalForwarder.GVK,
      ...toJson_ConditionalForwarderProps(props),
    };
  }

  /**
   * Defines a "ConditionalForwarder" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConditionalForwarderProps) {
    super(scope, id, {
      ...ConditionalForwarder.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConditionalForwarder.GVK,
      ...toJson_ConditionalForwarderProps(resolved),
    };
  }
}

/**
 * ConditionalForwarder is the Schema for the ConditionalForwarders API. Provides a conditional forwarder for managed Microsoft AD in AWS Directory Service.
 *
 * @schema ConditionalForwarder
 */
export interface ConditionalForwarderProps {
  /**
   * @schema ConditionalForwarder#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConditionalForwarderSpec defines the desired state of ConditionalForwarder
   *
   * @schema ConditionalForwarder#spec
   */
  readonly spec: ConditionalForwarderSpec;

}

/**
 * Converts an object of type 'ConditionalForwarderProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderProps(obj: ConditionalForwarderProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConditionalForwarderSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConditionalForwarderSpec defines the desired state of ConditionalForwarder
 *
 * @schema ConditionalForwarderSpec
 */
export interface ConditionalForwarderSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConditionalForwarderSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConditionalForwarderSpecDeletionPolicy;

  /**
   * @schema ConditionalForwarderSpec#forProvider
   */
  readonly forProvider: ConditionalForwarderSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ConditionalForwarderSpec#initProvider
   */
  readonly initProvider?: ConditionalForwarderSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConditionalForwarderSpec#managementPolicies
   */
  readonly managementPolicies?: ConditionalForwarderSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConditionalForwarderSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConditionalForwarderSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConditionalForwarderSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConditionalForwarderSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConditionalForwarderSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConditionalForwarderSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConditionalForwarderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpec(obj: ConditionalForwarderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConditionalForwarderSpecForProvider(obj.forProvider),
    'initProvider': toJson_ConditionalForwarderSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConditionalForwarderSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConditionalForwarderSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConditionalForwarderSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConditionalForwarderSpecDeletionPolicy
 */
export enum ConditionalForwarderSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConditionalForwarderSpecForProvider
 */
export interface ConditionalForwarderSpecForProvider {
  /**
   * ID of directory.
   *
   * @schema ConditionalForwarderSpecForProvider#directoryId
   */
  readonly directoryId?: string;

  /**
   * Reference to a Directory in ds to populate directoryId.
   *
   * @schema ConditionalForwarderSpecForProvider#directoryIdRef
   */
  readonly directoryIdRef?: ConditionalForwarderSpecForProviderDirectoryIdRef;

  /**
   * Selector for a Directory in ds to populate directoryId.
   *
   * @schema ConditionalForwarderSpecForProvider#directoryIdSelector
   */
  readonly directoryIdSelector?: ConditionalForwarderSpecForProviderDirectoryIdSelector;

  /**
   * A list of forwarder IP addresses.
   *
   * @schema ConditionalForwarderSpecForProvider#dnsIps
   */
  readonly dnsIps?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConditionalForwarderSpecForProvider#region
   */
  readonly region: string;

  /**
   * The fully qualified domain name of the remote domain for which forwarders will be used.
   *
   * @schema ConditionalForwarderSpecForProvider#remoteDomainName
   */
  readonly remoteDomainName: string;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecForProvider(obj: ConditionalForwarderSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directoryId': obj.directoryId,
    'directoryIdRef': toJson_ConditionalForwarderSpecForProviderDirectoryIdRef(obj.directoryIdRef),
    'directoryIdSelector': toJson_ConditionalForwarderSpecForProviderDirectoryIdSelector(obj.directoryIdSelector),
    'dnsIps': obj.dnsIps?.map(y => y),
    'region': obj.region,
    'remoteDomainName': obj.remoteDomainName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ConditionalForwarderSpecInitProvider
 */
export interface ConditionalForwarderSpecInitProvider {
  /**
   * A list of forwarder IP addresses.
   *
   * @schema ConditionalForwarderSpecInitProvider#dnsIps
   */
  readonly dnsIps?: string[];

}

/**
 * Converts an object of type 'ConditionalForwarderSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecInitProvider(obj: ConditionalForwarderSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsIps': obj.dnsIps?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConditionalForwarderSpecManagementPolicies
 */
export enum ConditionalForwarderSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConditionalForwarderSpecProviderConfigRef
 */
export interface ConditionalForwarderSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConditionalForwarderSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConditionalForwarderSpecProviderConfigRef#policy
   */
  readonly policy?: ConditionalForwarderSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecProviderConfigRef(obj: ConditionalForwarderSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConditionalForwarderSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConditionalForwarderSpecPublishConnectionDetailsTo
 */
export interface ConditionalForwarderSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConditionalForwarderSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConditionalForwarderSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConditionalForwarderSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConditionalForwarderSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConditionalForwarderSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecPublishConnectionDetailsTo(obj: ConditionalForwarderSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConditionalForwarderSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConditionalForwarderSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConditionalForwarderSpecWriteConnectionSecretToRef
 */
export interface ConditionalForwarderSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConditionalForwarderSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConditionalForwarderSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecWriteConnectionSecretToRef(obj: ConditionalForwarderSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Directory in ds to populate directoryId.
 *
 * @schema ConditionalForwarderSpecForProviderDirectoryIdRef
 */
export interface ConditionalForwarderSpecForProviderDirectoryIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConditionalForwarderSpecForProviderDirectoryIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConditionalForwarderSpecForProviderDirectoryIdRef#policy
   */
  readonly policy?: ConditionalForwarderSpecForProviderDirectoryIdRefPolicy;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecForProviderDirectoryIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecForProviderDirectoryIdRef(obj: ConditionalForwarderSpecForProviderDirectoryIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConditionalForwarderSpecForProviderDirectoryIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Directory in ds to populate directoryId.
 *
 * @schema ConditionalForwarderSpecForProviderDirectoryIdSelector
 */
export interface ConditionalForwarderSpecForProviderDirectoryIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConditionalForwarderSpecForProviderDirectoryIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConditionalForwarderSpecForProviderDirectoryIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConditionalForwarderSpecForProviderDirectoryIdSelector#policy
   */
  readonly policy?: ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecForProviderDirectoryIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecForProviderDirectoryIdSelector(obj: ConditionalForwarderSpecForProviderDirectoryIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConditionalForwarderSpecProviderConfigRefPolicy
 */
export interface ConditionalForwarderSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConditionalForwarderSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConditionalForwarderSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConditionalForwarderSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConditionalForwarderSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecProviderConfigRefPolicy(obj: ConditionalForwarderSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConditionalForwarderSpecPublishConnectionDetailsToConfigRef
 */
export interface ConditionalForwarderSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConditionalForwarderSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConditionalForwarderSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecPublishConnectionDetailsToConfigRef(obj: ConditionalForwarderSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConditionalForwarderSpecPublishConnectionDetailsToMetadata
 */
export interface ConditionalForwarderSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConditionalForwarderSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConditionalForwarderSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConditionalForwarderSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecPublishConnectionDetailsToMetadata(obj: ConditionalForwarderSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConditionalForwarderSpecForProviderDirectoryIdRefPolicy
 */
export interface ConditionalForwarderSpecForProviderDirectoryIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConditionalForwarderSpecForProviderDirectoryIdRefPolicy#resolution
   */
  readonly resolution?: ConditionalForwarderSpecForProviderDirectoryIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConditionalForwarderSpecForProviderDirectoryIdRefPolicy#resolve
   */
  readonly resolve?: ConditionalForwarderSpecForProviderDirectoryIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecForProviderDirectoryIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecForProviderDirectoryIdRefPolicy(obj: ConditionalForwarderSpecForProviderDirectoryIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicy
 */
export interface ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicy#resolution
   */
  readonly resolution?: ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicy#resolve
   */
  readonly resolve?: ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicy(obj: ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConditionalForwarderSpecProviderConfigRefPolicyResolution
 */
export enum ConditionalForwarderSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConditionalForwarderSpecProviderConfigRefPolicyResolve
 */
export enum ConditionalForwarderSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConditionalForwarderSpecForProviderDirectoryIdRefPolicyResolution
 */
export enum ConditionalForwarderSpecForProviderDirectoryIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConditionalForwarderSpecForProviderDirectoryIdRefPolicyResolve
 */
export enum ConditionalForwarderSpecForProviderDirectoryIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicyResolution
 */
export enum ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicyResolve
 */
export enum ConditionalForwarderSpecForProviderDirectoryIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConditionalForwarderSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Directory is the Schema for the Directorys API. Provides a directory in AWS Directory Service.
 *
 * @schema Directory
 */
export class Directory extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Directory"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ds.aws.upbound.io/v1beta1',
    kind: 'Directory',
  }

  /**
   * Renders a Kubernetes manifest for "Directory".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DirectoryProps): any {
    return {
      ...Directory.GVK,
      ...toJson_DirectoryProps(props),
    };
  }

  /**
   * Defines a "Directory" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DirectoryProps) {
    super(scope, id, {
      ...Directory.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Directory.GVK,
      ...toJson_DirectoryProps(resolved),
    };
  }
}

/**
 * Directory is the Schema for the Directorys API. Provides a directory in AWS Directory Service.
 *
 * @schema Directory
 */
export interface DirectoryProps {
  /**
   * @schema Directory#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DirectorySpec defines the desired state of Directory
   *
   * @schema Directory#spec
   */
  readonly spec: DirectorySpec;

}

/**
 * Converts an object of type 'DirectoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryProps(obj: DirectoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DirectorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DirectorySpec defines the desired state of Directory
 *
 * @schema DirectorySpec
 */
export interface DirectorySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DirectorySpec#deletionPolicy
   */
  readonly deletionPolicy?: DirectorySpecDeletionPolicy;

  /**
   * @schema DirectorySpec#forProvider
   */
  readonly forProvider: DirectorySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DirectorySpec#initProvider
   */
  readonly initProvider?: DirectorySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DirectorySpec#managementPolicies
   */
  readonly managementPolicies?: DirectorySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DirectorySpec#providerConfigRef
   */
  readonly providerConfigRef?: DirectorySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DirectorySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DirectorySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DirectorySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DirectorySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DirectorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpec(obj: DirectorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DirectorySpecForProvider(obj.forProvider),
    'initProvider': toJson_DirectorySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DirectorySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DirectorySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DirectorySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DirectorySpecDeletionPolicy
 */
export enum DirectorySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DirectorySpecForProvider
 */
export interface DirectorySpecForProvider {
  /**
   * The alias for the directory (must be unique amongst all aliases in AWS). Required for enable_sso.
   *
   * @schema DirectorySpecForProvider#alias
   */
  readonly alias?: string;

  /**
   * Connector related information about the directory. Fields documented below.
   *
   * @schema DirectorySpecForProvider#connectSettings
   */
  readonly connectSettings?: DirectorySpecForProviderConnectSettings[];

  /**
   * A textual description for the directory.
   *
   * @schema DirectorySpecForProvider#description
   */
  readonly description?: string;

  /**
   * The number of domain controllers desired in the directory. Minimum value of 2. Scaling of domain controllers is only supported for MicrosoftAD directories.
   *
   * @schema DirectorySpecForProvider#desiredNumberOfDomainControllers
   */
  readonly desiredNumberOfDomainControllers?: number;

  /**
   * The MicrosoftAD edition (Standard or Enterprise). Defaults to Enterprise.
   *
   * @default Enterprise.
   * @schema DirectorySpecForProvider#edition
   */
  readonly edition?: string;

  /**
   * Whether to enable single-sign on for the directory. Requires alias. Defaults to false.
   *
   * @default false.
   * @schema DirectorySpecForProvider#enableSso
   */
  readonly enableSso?: boolean;

  /**
   * The fully qualified name for the directory, such as corp.example.com
   *
   * @schema DirectorySpecForProvider#name
   */
  readonly name?: string;

  /**
   * The password for the directory administrator or connector user.
   *
   * @schema DirectorySpecForProvider#passwordSecretRef
   */
  readonly passwordSecretRef?: DirectorySpecForProviderPasswordSecretRef;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DirectorySpecForProvider#region
   */
  readonly region: string;

  /**
   * The short name of the directory, such as CORP.
   *
   * @schema DirectorySpecForProvider#shortName
   */
  readonly shortName?: string;

  /**
   * (For SimpleAD and ADConnector types) The size of the directory (Small or Large are accepted values). Large by default.
   *
   * @schema DirectorySpecForProvider#size
   */
  readonly size?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DirectorySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The directory type (SimpleAD, ADConnector or MicrosoftAD are accepted values). Defaults to SimpleAD.
   *
   * @default SimpleAD.
   * @schema DirectorySpecForProvider#type
   */
  readonly type?: string;

  /**
   * VPC related information about the directory. Fields documented below.
   *
   * @schema DirectorySpecForProvider#vpcSettings
   */
  readonly vpcSettings?: DirectorySpecForProviderVpcSettings[];

}

/**
 * Converts an object of type 'DirectorySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProvider(obj: DirectorySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'connectSettings': obj.connectSettings?.map(y => toJson_DirectorySpecForProviderConnectSettings(y)),
    'description': obj.description,
    'desiredNumberOfDomainControllers': obj.desiredNumberOfDomainControllers,
    'edition': obj.edition,
    'enableSso': obj.enableSso,
    'name': obj.name,
    'passwordSecretRef': toJson_DirectorySpecForProviderPasswordSecretRef(obj.passwordSecretRef),
    'region': obj.region,
    'shortName': obj.shortName,
    'size': obj.size,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'vpcSettings': obj.vpcSettings?.map(y => toJson_DirectorySpecForProviderVpcSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DirectorySpecInitProvider
 */
export interface DirectorySpecInitProvider {
  /**
   * The alias for the directory (must be unique amongst all aliases in AWS). Required for enable_sso.
   *
   * @schema DirectorySpecInitProvider#alias
   */
  readonly alias?: string;

  /**
   * Connector related information about the directory. Fields documented below.
   *
   * @schema DirectorySpecInitProvider#connectSettings
   */
  readonly connectSettings?: DirectorySpecInitProviderConnectSettings[];

  /**
   * A textual description for the directory.
   *
   * @schema DirectorySpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The number of domain controllers desired in the directory. Minimum value of 2. Scaling of domain controllers is only supported for MicrosoftAD directories.
   *
   * @schema DirectorySpecInitProvider#desiredNumberOfDomainControllers
   */
  readonly desiredNumberOfDomainControllers?: number;

  /**
   * The MicrosoftAD edition (Standard or Enterprise). Defaults to Enterprise.
   *
   * @default Enterprise.
   * @schema DirectorySpecInitProvider#edition
   */
  readonly edition?: string;

  /**
   * Whether to enable single-sign on for the directory. Requires alias. Defaults to false.
   *
   * @default false.
   * @schema DirectorySpecInitProvider#enableSso
   */
  readonly enableSso?: boolean;

  /**
   * The fully qualified name for the directory, such as corp.example.com
   *
   * @schema DirectorySpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The short name of the directory, such as CORP.
   *
   * @schema DirectorySpecInitProvider#shortName
   */
  readonly shortName?: string;

  /**
   * (For SimpleAD and ADConnector types) The size of the directory (Small or Large are accepted values). Large by default.
   *
   * @schema DirectorySpecInitProvider#size
   */
  readonly size?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DirectorySpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The directory type (SimpleAD, ADConnector or MicrosoftAD are accepted values). Defaults to SimpleAD.
   *
   * @default SimpleAD.
   * @schema DirectorySpecInitProvider#type
   */
  readonly type?: string;

  /**
   * VPC related information about the directory. Fields documented below.
   *
   * @schema DirectorySpecInitProvider#vpcSettings
   */
  readonly vpcSettings?: any[];

}

/**
 * Converts an object of type 'DirectorySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecInitProvider(obj: DirectorySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'connectSettings': obj.connectSettings?.map(y => toJson_DirectorySpecInitProviderConnectSettings(y)),
    'description': obj.description,
    'desiredNumberOfDomainControllers': obj.desiredNumberOfDomainControllers,
    'edition': obj.edition,
    'enableSso': obj.enableSso,
    'name': obj.name,
    'shortName': obj.shortName,
    'size': obj.size,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'vpcSettings': obj.vpcSettings?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DirectorySpecManagementPolicies
 */
export enum DirectorySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DirectorySpecProviderConfigRef
 */
export interface DirectorySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecProviderConfigRef#policy
   */
  readonly policy?: DirectorySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DirectorySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecProviderConfigRef(obj: DirectorySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DirectorySpecPublishConnectionDetailsTo
 */
export interface DirectorySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DirectorySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DirectorySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DirectorySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DirectorySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DirectorySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DirectorySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecPublishConnectionDetailsTo(obj: DirectorySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DirectorySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DirectorySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DirectorySpecWriteConnectionSecretToRef
 */
export interface DirectorySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DirectorySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DirectorySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DirectorySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecWriteConnectionSecretToRef(obj: DirectorySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DirectorySpecForProviderConnectSettings
 */
export interface DirectorySpecForProviderConnectSettings {
  /**
   * The DNS IP addresses of the domain to connect to.
   *
   * @schema DirectorySpecForProviderConnectSettings#customerDnsIps
   */
  readonly customerDnsIps?: string[];

  /**
   * The username corresponding to the password provided.
   *
   * @schema DirectorySpecForProviderConnectSettings#customerUsername
   */
  readonly customerUsername?: string;

  /**
   * The identifiers of the subnets for the directory servers (2 subnets in 2 different AZs).
   *
   * @schema DirectorySpecForProviderConnectSettings#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema DirectorySpecForProviderConnectSettings#subnetIdsRefs
   */
  readonly subnetIdsRefs?: DirectorySpecForProviderConnectSettingsSubnetIdsRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema DirectorySpecForProviderConnectSettings#subnetIdsSelector
   */
  readonly subnetIdsSelector?: DirectorySpecForProviderConnectSettingsSubnetIdsSelector;

  /**
   * The identifier of the VPC that the directory is in.
   *
   * @schema DirectorySpecForProviderConnectSettings#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema DirectorySpecForProviderConnectSettings#vpcIdRef
   */
  readonly vpcIdRef?: DirectorySpecForProviderConnectSettingsVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema DirectorySpecForProviderConnectSettings#vpcIdSelector
   */
  readonly vpcIdSelector?: DirectorySpecForProviderConnectSettingsVpcIdSelector;

}

/**
 * Converts an object of type 'DirectorySpecForProviderConnectSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderConnectSettings(obj: DirectorySpecForProviderConnectSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerDnsIps': obj.customerDnsIps?.map(y => y),
    'customerUsername': obj.customerUsername,
    'subnetIds': obj.subnetIds?.map(y => y),
    'subnetIdsRefs': obj.subnetIdsRefs?.map(y => toJson_DirectorySpecForProviderConnectSettingsSubnetIdsRefs(y)),
    'subnetIdsSelector': toJson_DirectorySpecForProviderConnectSettingsSubnetIdsSelector(obj.subnetIdsSelector),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_DirectorySpecForProviderConnectSettingsVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_DirectorySpecForProviderConnectSettingsVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password for the directory administrator or connector user.
 *
 * @schema DirectorySpecForProviderPasswordSecretRef
 */
export interface DirectorySpecForProviderPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema DirectorySpecForProviderPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DirectorySpecForProviderPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DirectorySpecForProviderPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DirectorySpecForProviderPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderPasswordSecretRef(obj: DirectorySpecForProviderPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DirectorySpecForProviderVpcSettings
 */
export interface DirectorySpecForProviderVpcSettings {
  /**
   * The identifiers of the subnets for the directory servers (2 subnets in 2 different AZs).
   *
   * @schema DirectorySpecForProviderVpcSettings#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema DirectorySpecForProviderVpcSettings#subnetIdsRefs
   */
  readonly subnetIdsRefs?: DirectorySpecForProviderVpcSettingsSubnetIdsRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema DirectorySpecForProviderVpcSettings#subnetIdsSelector
   */
  readonly subnetIdsSelector?: DirectorySpecForProviderVpcSettingsSubnetIdsSelector;

  /**
   * The identifier of the VPC that the directory is in.
   *
   * @schema DirectorySpecForProviderVpcSettings#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema DirectorySpecForProviderVpcSettings#vpcIdRef
   */
  readonly vpcIdRef?: DirectorySpecForProviderVpcSettingsVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema DirectorySpecForProviderVpcSettings#vpcIdSelector
   */
  readonly vpcIdSelector?: DirectorySpecForProviderVpcSettingsVpcIdSelector;

}

/**
 * Converts an object of type 'DirectorySpecForProviderVpcSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderVpcSettings(obj: DirectorySpecForProviderVpcSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subnetIds': obj.subnetIds?.map(y => y),
    'subnetIdsRefs': obj.subnetIdsRefs?.map(y => toJson_DirectorySpecForProviderVpcSettingsSubnetIdsRefs(y)),
    'subnetIdsSelector': toJson_DirectorySpecForProviderVpcSettingsSubnetIdsSelector(obj.subnetIdsSelector),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_DirectorySpecForProviderVpcSettingsVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_DirectorySpecForProviderVpcSettingsVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DirectorySpecInitProviderConnectSettings
 */
export interface DirectorySpecInitProviderConnectSettings {
  /**
   * The DNS IP addresses of the domain to connect to.
   *
   * @schema DirectorySpecInitProviderConnectSettings#customerDnsIps
   */
  readonly customerDnsIps?: string[];

  /**
   * The username corresponding to the password provided.
   *
   * @schema DirectorySpecInitProviderConnectSettings#customerUsername
   */
  readonly customerUsername?: string;

}

/**
 * Converts an object of type 'DirectorySpecInitProviderConnectSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecInitProviderConnectSettings(obj: DirectorySpecInitProviderConnectSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerDnsIps': obj.customerDnsIps?.map(y => y),
    'customerUsername': obj.customerUsername,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecProviderConfigRefPolicy
 */
export interface DirectorySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DirectorySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DirectorySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecProviderConfigRefPolicy(obj: DirectorySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DirectorySpecPublishConnectionDetailsToConfigRef
 */
export interface DirectorySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DirectorySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DirectorySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecPublishConnectionDetailsToConfigRef(obj: DirectorySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DirectorySpecPublishConnectionDetailsToMetadata
 */
export interface DirectorySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DirectorySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DirectorySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DirectorySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DirectorySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecPublishConnectionDetailsToMetadata(obj: DirectorySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DirectorySpecForProviderConnectSettingsSubnetIdsRefs
 */
export interface DirectorySpecForProviderConnectSettingsSubnetIdsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecForProviderConnectSettingsSubnetIdsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecForProviderConnectSettingsSubnetIdsRefs#policy
   */
  readonly policy?: DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderConnectSettingsSubnetIdsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderConnectSettingsSubnetIdsRefs(obj: DirectorySpecForProviderConnectSettingsSubnetIdsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema DirectorySpecForProviderConnectSettingsSubnetIdsSelector
 */
export interface DirectorySpecForProviderConnectSettingsSubnetIdsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DirectorySpecForProviderConnectSettingsSubnetIdsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DirectorySpecForProviderConnectSettingsSubnetIdsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DirectorySpecForProviderConnectSettingsSubnetIdsSelector#policy
   */
  readonly policy?: DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderConnectSettingsSubnetIdsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderConnectSettingsSubnetIdsSelector(obj: DirectorySpecForProviderConnectSettingsSubnetIdsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema DirectorySpecForProviderConnectSettingsVpcIdRef
 */
export interface DirectorySpecForProviderConnectSettingsVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecForProviderConnectSettingsVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecForProviderConnectSettingsVpcIdRef#policy
   */
  readonly policy?: DirectorySpecForProviderConnectSettingsVpcIdRefPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderConnectSettingsVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderConnectSettingsVpcIdRef(obj: DirectorySpecForProviderConnectSettingsVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecForProviderConnectSettingsVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema DirectorySpecForProviderConnectSettingsVpcIdSelector
 */
export interface DirectorySpecForProviderConnectSettingsVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DirectorySpecForProviderConnectSettingsVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DirectorySpecForProviderConnectSettingsVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DirectorySpecForProviderConnectSettingsVpcIdSelector#policy
   */
  readonly policy?: DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderConnectSettingsVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderConnectSettingsVpcIdSelector(obj: DirectorySpecForProviderConnectSettingsVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DirectorySpecForProviderVpcSettingsSubnetIdsRefs
 */
export interface DirectorySpecForProviderVpcSettingsSubnetIdsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecForProviderVpcSettingsSubnetIdsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecForProviderVpcSettingsSubnetIdsRefs#policy
   */
  readonly policy?: DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderVpcSettingsSubnetIdsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderVpcSettingsSubnetIdsRefs(obj: DirectorySpecForProviderVpcSettingsSubnetIdsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema DirectorySpecForProviderVpcSettingsSubnetIdsSelector
 */
export interface DirectorySpecForProviderVpcSettingsSubnetIdsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DirectorySpecForProviderVpcSettingsSubnetIdsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DirectorySpecForProviderVpcSettingsSubnetIdsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DirectorySpecForProviderVpcSettingsSubnetIdsSelector#policy
   */
  readonly policy?: DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderVpcSettingsSubnetIdsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderVpcSettingsSubnetIdsSelector(obj: DirectorySpecForProviderVpcSettingsSubnetIdsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema DirectorySpecForProviderVpcSettingsVpcIdRef
 */
export interface DirectorySpecForProviderVpcSettingsVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecForProviderVpcSettingsVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecForProviderVpcSettingsVpcIdRef#policy
   */
  readonly policy?: DirectorySpecForProviderVpcSettingsVpcIdRefPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderVpcSettingsVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderVpcSettingsVpcIdRef(obj: DirectorySpecForProviderVpcSettingsVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecForProviderVpcSettingsVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema DirectorySpecForProviderVpcSettingsVpcIdSelector
 */
export interface DirectorySpecForProviderVpcSettingsVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DirectorySpecForProviderVpcSettingsVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DirectorySpecForProviderVpcSettingsVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DirectorySpecForProviderVpcSettingsVpcIdSelector#policy
   */
  readonly policy?: DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderVpcSettingsVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderVpcSettingsVpcIdSelector(obj: DirectorySpecForProviderVpcSettingsVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecProviderConfigRefPolicyResolution
 */
export enum DirectorySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecProviderConfigRefPolicyResolve
 */
export enum DirectorySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DirectorySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecPublishConnectionDetailsToConfigRefPolicy(obj: DirectorySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicy
 */
export interface DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicy(obj: DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicy
 */
export interface DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicy(obj: DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecForProviderConnectSettingsVpcIdRefPolicy
 */
export interface DirectorySpecForProviderConnectSettingsVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderConnectSettingsVpcIdRefPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderConnectSettingsVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderConnectSettingsVpcIdRefPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderConnectSettingsVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderConnectSettingsVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderConnectSettingsVpcIdRefPolicy(obj: DirectorySpecForProviderConnectSettingsVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicy
 */
export interface DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicy(obj: DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicy
 */
export interface DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicy(obj: DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicy
 */
export interface DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicy(obj: DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecForProviderVpcSettingsVpcIdRefPolicy
 */
export interface DirectorySpecForProviderVpcSettingsVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderVpcSettingsVpcIdRefPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderVpcSettingsVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderVpcSettingsVpcIdRefPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderVpcSettingsVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderVpcSettingsVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderVpcSettingsVpcIdRefPolicy(obj: DirectorySpecForProviderVpcSettingsVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicy
 */
export interface DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicy(obj: DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicyResolution
 */
export enum DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicyResolve
 */
export enum DirectorySpecForProviderConnectSettingsSubnetIdsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicyResolution
 */
export enum DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicyResolve
 */
export enum DirectorySpecForProviderConnectSettingsSubnetIdsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderConnectSettingsVpcIdRefPolicyResolution
 */
export enum DirectorySpecForProviderConnectSettingsVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderConnectSettingsVpcIdRefPolicyResolve
 */
export enum DirectorySpecForProviderConnectSettingsVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicyResolution
 */
export enum DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicyResolve
 */
export enum DirectorySpecForProviderConnectSettingsVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicyResolution
 */
export enum DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicyResolve
 */
export enum DirectorySpecForProviderVpcSettingsSubnetIdsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicyResolution
 */
export enum DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicyResolve
 */
export enum DirectorySpecForProviderVpcSettingsSubnetIdsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderVpcSettingsVpcIdRefPolicyResolution
 */
export enum DirectorySpecForProviderVpcSettingsVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderVpcSettingsVpcIdRefPolicyResolve
 */
export enum DirectorySpecForProviderVpcSettingsVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicyResolution
 */
export enum DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicyResolve
 */
export enum DirectorySpecForProviderVpcSettingsVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SharedDirectory is the Schema for the SharedDirectorys API. Manages a directory in your account (directory owner) shared with another account (directory consumer).
 *
 * @schema SharedDirectory
 */
export class SharedDirectory extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SharedDirectory"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ds.aws.upbound.io/v1beta1',
    kind: 'SharedDirectory',
  }

  /**
   * Renders a Kubernetes manifest for "SharedDirectory".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SharedDirectoryProps): any {
    return {
      ...SharedDirectory.GVK,
      ...toJson_SharedDirectoryProps(props),
    };
  }

  /**
   * Defines a "SharedDirectory" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SharedDirectoryProps) {
    super(scope, id, {
      ...SharedDirectory.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SharedDirectory.GVK,
      ...toJson_SharedDirectoryProps(resolved),
    };
  }
}

/**
 * SharedDirectory is the Schema for the SharedDirectorys API. Manages a directory in your account (directory owner) shared with another account (directory consumer).
 *
 * @schema SharedDirectory
 */
export interface SharedDirectoryProps {
  /**
   * @schema SharedDirectory#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SharedDirectorySpec defines the desired state of SharedDirectory
   *
   * @schema SharedDirectory#spec
   */
  readonly spec: SharedDirectorySpec;

}

/**
 * Converts an object of type 'SharedDirectoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectoryProps(obj: SharedDirectoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SharedDirectorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SharedDirectorySpec defines the desired state of SharedDirectory
 *
 * @schema SharedDirectorySpec
 */
export interface SharedDirectorySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SharedDirectorySpec#deletionPolicy
   */
  readonly deletionPolicy?: SharedDirectorySpecDeletionPolicy;

  /**
   * @schema SharedDirectorySpec#forProvider
   */
  readonly forProvider: SharedDirectorySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SharedDirectorySpec#initProvider
   */
  readonly initProvider?: SharedDirectorySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SharedDirectorySpec#managementPolicies
   */
  readonly managementPolicies?: SharedDirectorySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SharedDirectorySpec#providerConfigRef
   */
  readonly providerConfigRef?: SharedDirectorySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SharedDirectorySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SharedDirectorySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SharedDirectorySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SharedDirectorySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SharedDirectorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpec(obj: SharedDirectorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SharedDirectorySpecForProvider(obj.forProvider),
    'initProvider': toJson_SharedDirectorySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SharedDirectorySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SharedDirectorySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SharedDirectorySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SharedDirectorySpecDeletionPolicy
 */
export enum SharedDirectorySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SharedDirectorySpecForProvider
 */
export interface SharedDirectorySpecForProvider {
  /**
   * Identifier of the Managed Microsoft AD directory that you want to share with other accounts.
   *
   * @schema SharedDirectorySpecForProvider#directoryId
   */
  readonly directoryId?: string;

  /**
   * Reference to a Directory in ds to populate directoryId.
   *
   * @schema SharedDirectorySpecForProvider#directoryIdRef
   */
  readonly directoryIdRef?: SharedDirectorySpecForProviderDirectoryIdRef;

  /**
   * Selector for a Directory in ds to populate directoryId.
   *
   * @schema SharedDirectorySpecForProvider#directoryIdSelector
   */
  readonly directoryIdSelector?: SharedDirectorySpecForProviderDirectoryIdSelector;

  /**
   * Method used when sharing a directory. Valid values are ORGANIZATIONS and HANDSHAKE. Default is HANDSHAKE.
   *
   * @default HANDSHAKE.
   * @schema SharedDirectorySpecForProvider#method
   */
  readonly method?: string;

  /**
   * Message sent by the directory owner to the directory consumer to help the directory consumer administrator determine whether to approve or reject the share invitation.
   *
   * @schema SharedDirectorySpecForProvider#notesSecretRef
   */
  readonly notesSecretRef?: SharedDirectorySpecForProviderNotesSecretRef;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SharedDirectorySpecForProvider#region
   */
  readonly region: string;

  /**
   * Identifier for the directory consumer account with whom the directory is to be shared. See below.
   *
   * @schema SharedDirectorySpecForProvider#target
   */
  readonly target?: SharedDirectorySpecForProviderTarget[];

}

/**
 * Converts an object of type 'SharedDirectorySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecForProvider(obj: SharedDirectorySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directoryId': obj.directoryId,
    'directoryIdRef': toJson_SharedDirectorySpecForProviderDirectoryIdRef(obj.directoryIdRef),
    'directoryIdSelector': toJson_SharedDirectorySpecForProviderDirectoryIdSelector(obj.directoryIdSelector),
    'method': obj.method,
    'notesSecretRef': toJson_SharedDirectorySpecForProviderNotesSecretRef(obj.notesSecretRef),
    'region': obj.region,
    'target': obj.target?.map(y => toJson_SharedDirectorySpecForProviderTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SharedDirectorySpecInitProvider
 */
export interface SharedDirectorySpecInitProvider {
  /**
   * Method used when sharing a directory. Valid values are ORGANIZATIONS and HANDSHAKE. Default is HANDSHAKE.
   *
   * @default HANDSHAKE.
   * @schema SharedDirectorySpecInitProvider#method
   */
  readonly method?: string;

  /**
   * Identifier for the directory consumer account with whom the directory is to be shared. See below.
   *
   * @schema SharedDirectorySpecInitProvider#target
   */
  readonly target?: SharedDirectorySpecInitProviderTarget[];

}

/**
 * Converts an object of type 'SharedDirectorySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecInitProvider(obj: SharedDirectorySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'target': obj.target?.map(y => toJson_SharedDirectorySpecInitProviderTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SharedDirectorySpecManagementPolicies
 */
export enum SharedDirectorySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SharedDirectorySpecProviderConfigRef
 */
export interface SharedDirectorySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SharedDirectorySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SharedDirectorySpecProviderConfigRef#policy
   */
  readonly policy?: SharedDirectorySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SharedDirectorySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecProviderConfigRef(obj: SharedDirectorySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SharedDirectorySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SharedDirectorySpecPublishConnectionDetailsTo
 */
export interface SharedDirectorySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SharedDirectorySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SharedDirectorySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SharedDirectorySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SharedDirectorySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SharedDirectorySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SharedDirectorySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecPublishConnectionDetailsTo(obj: SharedDirectorySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SharedDirectorySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SharedDirectorySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SharedDirectorySpecWriteConnectionSecretToRef
 */
export interface SharedDirectorySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SharedDirectorySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SharedDirectorySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SharedDirectorySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecWriteConnectionSecretToRef(obj: SharedDirectorySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Directory in ds to populate directoryId.
 *
 * @schema SharedDirectorySpecForProviderDirectoryIdRef
 */
export interface SharedDirectorySpecForProviderDirectoryIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SharedDirectorySpecForProviderDirectoryIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SharedDirectorySpecForProviderDirectoryIdRef#policy
   */
  readonly policy?: SharedDirectorySpecForProviderDirectoryIdRefPolicy;

}

/**
 * Converts an object of type 'SharedDirectorySpecForProviderDirectoryIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecForProviderDirectoryIdRef(obj: SharedDirectorySpecForProviderDirectoryIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SharedDirectorySpecForProviderDirectoryIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Directory in ds to populate directoryId.
 *
 * @schema SharedDirectorySpecForProviderDirectoryIdSelector
 */
export interface SharedDirectorySpecForProviderDirectoryIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SharedDirectorySpecForProviderDirectoryIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SharedDirectorySpecForProviderDirectoryIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SharedDirectorySpecForProviderDirectoryIdSelector#policy
   */
  readonly policy?: SharedDirectorySpecForProviderDirectoryIdSelectorPolicy;

}

/**
 * Converts an object of type 'SharedDirectorySpecForProviderDirectoryIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecForProviderDirectoryIdSelector(obj: SharedDirectorySpecForProviderDirectoryIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SharedDirectorySpecForProviderDirectoryIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Message sent by the directory owner to the directory consumer to help the directory consumer administrator determine whether to approve or reject the share invitation.
 *
 * @schema SharedDirectorySpecForProviderNotesSecretRef
 */
export interface SharedDirectorySpecForProviderNotesSecretRef {
  /**
   * The key to select.
   *
   * @schema SharedDirectorySpecForProviderNotesSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema SharedDirectorySpecForProviderNotesSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SharedDirectorySpecForProviderNotesSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SharedDirectorySpecForProviderNotesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecForProviderNotesSecretRef(obj: SharedDirectorySpecForProviderNotesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SharedDirectorySpecForProviderTarget
 */
export interface SharedDirectorySpecForProviderTarget {
  /**
   * Identifier of the directory consumer account.
   *
   * @schema SharedDirectorySpecForProviderTarget#id
   */
  readonly id?: string;

  /**
   * Type of identifier to be used in the id field. Valid value is ACCOUNT. Default is ACCOUNT.
   *
   * @default ACCOUNT.
   * @schema SharedDirectorySpecForProviderTarget#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SharedDirectorySpecForProviderTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecForProviderTarget(obj: SharedDirectorySpecForProviderTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SharedDirectorySpecInitProviderTarget
 */
export interface SharedDirectorySpecInitProviderTarget {
  /**
   * Identifier of the directory consumer account.
   *
   * @schema SharedDirectorySpecInitProviderTarget#id
   */
  readonly id?: string;

  /**
   * Type of identifier to be used in the id field. Valid value is ACCOUNT. Default is ACCOUNT.
   *
   * @default ACCOUNT.
   * @schema SharedDirectorySpecInitProviderTarget#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SharedDirectorySpecInitProviderTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecInitProviderTarget(obj: SharedDirectorySpecInitProviderTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SharedDirectorySpecProviderConfigRefPolicy
 */
export interface SharedDirectorySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SharedDirectorySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SharedDirectorySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SharedDirectorySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SharedDirectorySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SharedDirectorySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecProviderConfigRefPolicy(obj: SharedDirectorySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SharedDirectorySpecPublishConnectionDetailsToConfigRef
 */
export interface SharedDirectorySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SharedDirectorySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SharedDirectorySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SharedDirectorySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecPublishConnectionDetailsToConfigRef(obj: SharedDirectorySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SharedDirectorySpecPublishConnectionDetailsToMetadata
 */
export interface SharedDirectorySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SharedDirectorySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SharedDirectorySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SharedDirectorySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SharedDirectorySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecPublishConnectionDetailsToMetadata(obj: SharedDirectorySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SharedDirectorySpecForProviderDirectoryIdRefPolicy
 */
export interface SharedDirectorySpecForProviderDirectoryIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SharedDirectorySpecForProviderDirectoryIdRefPolicy#resolution
   */
  readonly resolution?: SharedDirectorySpecForProviderDirectoryIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SharedDirectorySpecForProviderDirectoryIdRefPolicy#resolve
   */
  readonly resolve?: SharedDirectorySpecForProviderDirectoryIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SharedDirectorySpecForProviderDirectoryIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecForProviderDirectoryIdRefPolicy(obj: SharedDirectorySpecForProviderDirectoryIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SharedDirectorySpecForProviderDirectoryIdSelectorPolicy
 */
export interface SharedDirectorySpecForProviderDirectoryIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SharedDirectorySpecForProviderDirectoryIdSelectorPolicy#resolution
   */
  readonly resolution?: SharedDirectorySpecForProviderDirectoryIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SharedDirectorySpecForProviderDirectoryIdSelectorPolicy#resolve
   */
  readonly resolve?: SharedDirectorySpecForProviderDirectoryIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SharedDirectorySpecForProviderDirectoryIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecForProviderDirectoryIdSelectorPolicy(obj: SharedDirectorySpecForProviderDirectoryIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SharedDirectorySpecProviderConfigRefPolicyResolution
 */
export enum SharedDirectorySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SharedDirectorySpecProviderConfigRefPolicyResolve
 */
export enum SharedDirectorySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicy(obj: SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SharedDirectorySpecForProviderDirectoryIdRefPolicyResolution
 */
export enum SharedDirectorySpecForProviderDirectoryIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SharedDirectorySpecForProviderDirectoryIdRefPolicyResolve
 */
export enum SharedDirectorySpecForProviderDirectoryIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SharedDirectorySpecForProviderDirectoryIdSelectorPolicyResolution
 */
export enum SharedDirectorySpecForProviderDirectoryIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SharedDirectorySpecForProviderDirectoryIdSelectorPolicyResolve
 */
export enum SharedDirectorySpecForProviderDirectoryIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SharedDirectorySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

