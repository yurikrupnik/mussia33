// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A ProviderConfig configures a Helm 'provider', i.e. a connection to a particular
 *
 * @schema ProviderConfig
 */
export class ProviderConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'helm.crossplane.io/v1alpha1',
    kind: 'ProviderConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderConfigProps): any {
    return {
      ...ProviderConfig.GVK,
      ...toJson_ProviderConfigProps(props),
    };
  }

  /**
   * Defines a "ProviderConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderConfigProps) {
    super(scope, id, {
      ...ProviderConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderConfig.GVK,
      ...toJson_ProviderConfigProps(resolved),
    };
  }
}

/**
 * A ProviderConfig configures a Helm 'provider', i.e. a connection to a particular
 *
 * @schema ProviderConfig
 */
export interface ProviderConfigProps {
  /**
   * @schema ProviderConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ProviderConfigSpec defines the desired state of a Provider.
   *
   * @schema ProviderConfig#spec
   */
  readonly spec: ProviderConfigSpec;

}

/**
 * Converts an object of type 'ProviderConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigProps(obj: ProviderConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProviderConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ProviderConfigSpec defines the desired state of a Provider.
 *
 * @schema ProviderConfigSpec
 */
export interface ProviderConfigSpec {
  /**
   * Credentials used to connect to the Kubernetes API. Typically a kubeconfig file. Use InjectedIdentity for in-cluster config.
   *
   * @schema ProviderConfigSpec#credentials
   */
  readonly credentials: ProviderConfigSpecCredentials;

  /**
   * Identity used to authenticate to the Kubernetes API. The identity credentials can be used to supplement kubeconfig 'credentials', for example by configuring a bearer token source such as OAuth.
   *
   * @schema ProviderConfigSpec#identity
   */
  readonly identity?: ProviderConfigSpecIdentity;

}

/**
 * Converts an object of type 'ProviderConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpec(obj: ProviderConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ProviderConfigSpecCredentials(obj.credentials),
    'identity': toJson_ProviderConfigSpecIdentity(obj.identity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Credentials used to connect to the Kubernetes API. Typically a kubeconfig file. Use InjectedIdentity for in-cluster config.
 *
 * @schema ProviderConfigSpecCredentials
 */
export interface ProviderConfigSpecCredentials {
  /**
   * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#env
   */
  readonly env?: ProviderConfigSpecCredentialsEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#fs
   */
  readonly fs?: ProviderConfigSpecCredentialsFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#secretRef
   */
  readonly secretRef?: ProviderConfigSpecCredentialsSecretRef;

  /**
   * Source of the provider credentials.
   *
   * @schema ProviderConfigSpecCredentials#source
   */
  readonly source: ProviderConfigSpecCredentialsSource;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentials(obj: ProviderConfigSpecCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': toJson_ProviderConfigSpecCredentialsEnv(obj.env),
    'fs': toJson_ProviderConfigSpecCredentialsFs(obj.fs),
    'secretRef': toJson_ProviderConfigSpecCredentialsSecretRef(obj.secretRef),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Identity used to authenticate to the Kubernetes API. The identity credentials can be used to supplement kubeconfig 'credentials', for example by configuring a bearer token source such as OAuth.
 *
 * @schema ProviderConfigSpecIdentity
 */
export interface ProviderConfigSpecIdentity {
  /**
   * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecIdentity#env
   */
  readonly env?: ProviderConfigSpecIdentityEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecIdentity#fs
   */
  readonly fs?: ProviderConfigSpecIdentityFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecIdentity#secretRef
   */
  readonly secretRef?: ProviderConfigSpecIdentitySecretRef;

  /**
   * Source of the provider credentials.
   *
   * @schema ProviderConfigSpecIdentity#source
   */
  readonly source: ProviderConfigSpecIdentitySource;

  /**
   * Type of identity.
   *
   * @schema ProviderConfigSpecIdentity#type
   */
  readonly type: ProviderConfigSpecIdentityType;

}

/**
 * Converts an object of type 'ProviderConfigSpecIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecIdentity(obj: ProviderConfigSpecIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': toJson_ProviderConfigSpecIdentityEnv(obj.env),
    'fs': toJson_ProviderConfigSpecIdentityFs(obj.fs),
    'secretRef': toJson_ProviderConfigSpecIdentitySecretRef(obj.secretRef),
    'source': obj.source,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsEnv
 */
export interface ProviderConfigSpecCredentialsEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema ProviderConfigSpecCredentialsEnv#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsEnv(obj: ProviderConfigSpecCredentialsEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsFs
 */
export interface ProviderConfigSpecCredentialsFs {
  /**
   * Path is a filesystem path.
   *
   * @schema ProviderConfigSpecCredentialsFs#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsFs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsFs(obj: ProviderConfigSpecCredentialsFs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsSecretRef
 */
export interface ProviderConfigSpecCredentialsSecretRef {
  /**
   * The key to select.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsSecretRef(obj: ProviderConfigSpecCredentialsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source of the provider credentials.
 *
 * @schema ProviderConfigSpecCredentialsSource
 */
export enum ProviderConfigSpecCredentialsSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** InjectedIdentity */
  INJECTED_IDENTITY = "InjectedIdentity",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** Filesystem */
  FILESYSTEM = "Filesystem",
}

/**
 * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecIdentityEnv
 */
export interface ProviderConfigSpecIdentityEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema ProviderConfigSpecIdentityEnv#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecIdentityEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecIdentityEnv(obj: ProviderConfigSpecIdentityEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecIdentityFs
 */
export interface ProviderConfigSpecIdentityFs {
  /**
   * Path is a filesystem path.
   *
   * @schema ProviderConfigSpecIdentityFs#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecIdentityFs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecIdentityFs(obj: ProviderConfigSpecIdentityFs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecIdentitySecretRef
 */
export interface ProviderConfigSpecIdentitySecretRef {
  /**
   * The key to select.
   *
   * @schema ProviderConfigSpecIdentitySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ProviderConfigSpecIdentitySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProviderConfigSpecIdentitySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecIdentitySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecIdentitySecretRef(obj: ProviderConfigSpecIdentitySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source of the provider credentials.
 *
 * @schema ProviderConfigSpecIdentitySource
 */
export enum ProviderConfigSpecIdentitySource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** InjectedIdentity */
  INJECTED_IDENTITY = "InjectedIdentity",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** Filesystem */
  FILESYSTEM = "Filesystem",
}

/**
 * Type of identity.
 *
 * @schema ProviderConfigSpecIdentityType
 */
export enum ProviderConfigSpecIdentityType {
  /** GoogleApplicationCredentials */
  GOOGLE_APPLICATION_CREDENTIALS = "GoogleApplicationCredentials",
}


/**
 * A ProviderConfig configures a Helm 'provider', i.e. a connection to a particular
 *
 * @schema ProviderConfigV1Beta1
 */
export class ProviderConfigV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderConfigV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'helm.crossplane.io/v1beta1',
    kind: 'ProviderConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderConfigV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderConfigV1Beta1Props): any {
    return {
      ...ProviderConfigV1Beta1.GVK,
      ...toJson_ProviderConfigV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ProviderConfigV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderConfigV1Beta1Props) {
    super(scope, id, {
      ...ProviderConfigV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderConfigV1Beta1.GVK,
      ...toJson_ProviderConfigV1Beta1Props(resolved),
    };
  }
}

/**
 * A ProviderConfig configures a Helm 'provider', i.e. a connection to a particular
 *
 * @schema ProviderConfigV1Beta1
 */
export interface ProviderConfigV1Beta1Props {
  /**
   * @schema ProviderConfigV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ProviderConfigSpec defines the desired state of a Provider.
   *
   * @schema ProviderConfigV1Beta1#spec
   */
  readonly spec: ProviderConfigV1Beta1Spec;

}

/**
 * Converts an object of type 'ProviderConfigV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigV1Beta1Props(obj: ProviderConfigV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProviderConfigV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ProviderConfigSpec defines the desired state of a Provider.
 *
 * @schema ProviderConfigV1Beta1Spec
 */
export interface ProviderConfigV1Beta1Spec {
  /**
   * Credentials used to connect to the Kubernetes API. Typically a kubeconfig file. Use InjectedIdentity for in-cluster config.
   *
   * @schema ProviderConfigV1Beta1Spec#credentials
   */
  readonly credentials: ProviderConfigV1Beta1SpecCredentials;

  /**
   * Identity used to authenticate to the Kubernetes API. The identity credentials can be used to supplement kubeconfig 'credentials', for example by configuring a bearer token source such as OAuth.
   *
   * @schema ProviderConfigV1Beta1Spec#identity
   */
  readonly identity?: ProviderConfigV1Beta1SpecIdentity;

}

/**
 * Converts an object of type 'ProviderConfigV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigV1Beta1Spec(obj: ProviderConfigV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ProviderConfigV1Beta1SpecCredentials(obj.credentials),
    'identity': toJson_ProviderConfigV1Beta1SpecIdentity(obj.identity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Credentials used to connect to the Kubernetes API. Typically a kubeconfig file. Use InjectedIdentity for in-cluster config.
 *
 * @schema ProviderConfigV1Beta1SpecCredentials
 */
export interface ProviderConfigV1Beta1SpecCredentials {
  /**
   * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigV1Beta1SpecCredentials#env
   */
  readonly env?: ProviderConfigV1Beta1SpecCredentialsEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigV1Beta1SpecCredentials#fs
   */
  readonly fs?: ProviderConfigV1Beta1SpecCredentialsFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigV1Beta1SpecCredentials#secretRef
   */
  readonly secretRef?: ProviderConfigV1Beta1SpecCredentialsSecretRef;

  /**
   * Source of the provider credentials.
   *
   * @schema ProviderConfigV1Beta1SpecCredentials#source
   */
  readonly source: ProviderConfigV1Beta1SpecCredentialsSource;

}

/**
 * Converts an object of type 'ProviderConfigV1Beta1SpecCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigV1Beta1SpecCredentials(obj: ProviderConfigV1Beta1SpecCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': toJson_ProviderConfigV1Beta1SpecCredentialsEnv(obj.env),
    'fs': toJson_ProviderConfigV1Beta1SpecCredentialsFs(obj.fs),
    'secretRef': toJson_ProviderConfigV1Beta1SpecCredentialsSecretRef(obj.secretRef),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Identity used to authenticate to the Kubernetes API. The identity credentials can be used to supplement kubeconfig 'credentials', for example by configuring a bearer token source such as OAuth.
 *
 * @schema ProviderConfigV1Beta1SpecIdentity
 */
export interface ProviderConfigV1Beta1SpecIdentity {
  /**
   * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigV1Beta1SpecIdentity#env
   */
  readonly env?: ProviderConfigV1Beta1SpecIdentityEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigV1Beta1SpecIdentity#fs
   */
  readonly fs?: ProviderConfigV1Beta1SpecIdentityFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigV1Beta1SpecIdentity#secretRef
   */
  readonly secretRef?: ProviderConfigV1Beta1SpecIdentitySecretRef;

  /**
   * Source of the provider credentials.
   *
   * @schema ProviderConfigV1Beta1SpecIdentity#source
   */
  readonly source: ProviderConfigV1Beta1SpecIdentitySource;

  /**
   * Type of identity.
   *
   * @schema ProviderConfigV1Beta1SpecIdentity#type
   */
  readonly type: ProviderConfigV1Beta1SpecIdentityType;

}

/**
 * Converts an object of type 'ProviderConfigV1Beta1SpecIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigV1Beta1SpecIdentity(obj: ProviderConfigV1Beta1SpecIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': toJson_ProviderConfigV1Beta1SpecIdentityEnv(obj.env),
    'fs': toJson_ProviderConfigV1Beta1SpecIdentityFs(obj.fs),
    'secretRef': toJson_ProviderConfigV1Beta1SpecIdentitySecretRef(obj.secretRef),
    'source': obj.source,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigV1Beta1SpecCredentialsEnv
 */
export interface ProviderConfigV1Beta1SpecCredentialsEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema ProviderConfigV1Beta1SpecCredentialsEnv#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProviderConfigV1Beta1SpecCredentialsEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigV1Beta1SpecCredentialsEnv(obj: ProviderConfigV1Beta1SpecCredentialsEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigV1Beta1SpecCredentialsFs
 */
export interface ProviderConfigV1Beta1SpecCredentialsFs {
  /**
   * Path is a filesystem path.
   *
   * @schema ProviderConfigV1Beta1SpecCredentialsFs#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ProviderConfigV1Beta1SpecCredentialsFs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigV1Beta1SpecCredentialsFs(obj: ProviderConfigV1Beta1SpecCredentialsFs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigV1Beta1SpecCredentialsSecretRef
 */
export interface ProviderConfigV1Beta1SpecCredentialsSecretRef {
  /**
   * The key to select.
   *
   * @schema ProviderConfigV1Beta1SpecCredentialsSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ProviderConfigV1Beta1SpecCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProviderConfigV1Beta1SpecCredentialsSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProviderConfigV1Beta1SpecCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigV1Beta1SpecCredentialsSecretRef(obj: ProviderConfigV1Beta1SpecCredentialsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source of the provider credentials.
 *
 * @schema ProviderConfigV1Beta1SpecCredentialsSource
 */
export enum ProviderConfigV1Beta1SpecCredentialsSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** InjectedIdentity */
  INJECTED_IDENTITY = "InjectedIdentity",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** Filesystem */
  FILESYSTEM = "Filesystem",
}

/**
 * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigV1Beta1SpecIdentityEnv
 */
export interface ProviderConfigV1Beta1SpecIdentityEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema ProviderConfigV1Beta1SpecIdentityEnv#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProviderConfigV1Beta1SpecIdentityEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigV1Beta1SpecIdentityEnv(obj: ProviderConfigV1Beta1SpecIdentityEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigV1Beta1SpecIdentityFs
 */
export interface ProviderConfigV1Beta1SpecIdentityFs {
  /**
   * Path is a filesystem path.
   *
   * @schema ProviderConfigV1Beta1SpecIdentityFs#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ProviderConfigV1Beta1SpecIdentityFs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigV1Beta1SpecIdentityFs(obj: ProviderConfigV1Beta1SpecIdentityFs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigV1Beta1SpecIdentitySecretRef
 */
export interface ProviderConfigV1Beta1SpecIdentitySecretRef {
  /**
   * The key to select.
   *
   * @schema ProviderConfigV1Beta1SpecIdentitySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ProviderConfigV1Beta1SpecIdentitySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProviderConfigV1Beta1SpecIdentitySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProviderConfigV1Beta1SpecIdentitySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigV1Beta1SpecIdentitySecretRef(obj: ProviderConfigV1Beta1SpecIdentitySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source of the provider credentials.
 *
 * @schema ProviderConfigV1Beta1SpecIdentitySource
 */
export enum ProviderConfigV1Beta1SpecIdentitySource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** InjectedIdentity */
  INJECTED_IDENTITY = "InjectedIdentity",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** Filesystem */
  FILESYSTEM = "Filesystem",
}

/**
 * Type of identity.
 *
 * @schema ProviderConfigV1Beta1SpecIdentityType
 */
export enum ProviderConfigV1Beta1SpecIdentityType {
  /** GoogleApplicationCredentials */
  GOOGLE_APPLICATION_CREDENTIALS = "GoogleApplicationCredentials",
}


/**
 * A ProviderConfigUsage indicates that a resource is using a ProviderConfig.
 *
 * @schema ProviderConfigUsage
 */
export class ProviderConfigUsage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderConfigUsage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'helm.crossplane.io/v1alpha1',
    kind: 'ProviderConfigUsage',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderConfigUsage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderConfigUsageProps): any {
    return {
      ...ProviderConfigUsage.GVK,
      ...toJson_ProviderConfigUsageProps(props),
    };
  }

  /**
   * Defines a "ProviderConfigUsage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderConfigUsageProps) {
    super(scope, id, {
      ...ProviderConfigUsage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderConfigUsage.GVK,
      ...toJson_ProviderConfigUsageProps(resolved),
    };
  }
}

/**
 * A ProviderConfigUsage indicates that a resource is using a ProviderConfig.
 *
 * @schema ProviderConfigUsage
 */
export interface ProviderConfigUsageProps {
  /**
   * @schema ProviderConfigUsage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProviderConfigReference to the provider config being used.
   *
   * @schema ProviderConfigUsage#providerConfigRef
   */
  readonly providerConfigRef: ProviderConfigUsageProviderConfigRef;

  /**
   * ResourceReference to the managed resource using the provider config.
   *
   * @schema ProviderConfigUsage#resourceRef
   */
  readonly resourceRef: ProviderConfigUsageResourceRef;

}

/**
 * Converts an object of type 'ProviderConfigUsageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageProps(obj: ProviderConfigUsageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'providerConfigRef': toJson_ProviderConfigUsageProviderConfigRef(obj.providerConfigRef),
    'resourceRef': toJson_ProviderConfigUsageResourceRef(obj.resourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference to the provider config being used.
 *
 * @schema ProviderConfigUsageProviderConfigRef
 */
export interface ProviderConfigUsageProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProviderConfigUsageProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProviderConfigUsageProviderConfigRef#policy
   */
  readonly policy?: ProviderConfigUsageProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProviderConfigUsageProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageProviderConfigRef(obj: ProviderConfigUsageProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProviderConfigUsageProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceReference to the managed resource using the provider config.
 *
 * @schema ProviderConfigUsageResourceRef
 */
export interface ProviderConfigUsageResourceRef {
  /**
   * APIVersion of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#kind
   */
  readonly kind: string;

  /**
   * Name of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#name
   */
  readonly name: string;

  /**
   * UID of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ProviderConfigUsageResourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageResourceRef(obj: ProviderConfigUsageResourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProviderConfigUsageProviderConfigRefPolicy
 */
export interface ProviderConfigUsageProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProviderConfigUsageProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProviderConfigUsageProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProviderConfigUsageProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProviderConfigUsageProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProviderConfigUsageProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageProviderConfigRefPolicy(obj: ProviderConfigUsageProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProviderConfigUsageProviderConfigRefPolicyResolution
 */
export enum ProviderConfigUsageProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProviderConfigUsageProviderConfigRefPolicyResolve
 */
export enum ProviderConfigUsageProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A ProviderConfigUsage indicates that a resource is using a ProviderConfig.
 *
 * @schema ProviderConfigUsageV1Beta1
 */
export class ProviderConfigUsageV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderConfigUsageV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'helm.crossplane.io/v1beta1',
    kind: 'ProviderConfigUsage',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderConfigUsageV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderConfigUsageV1Beta1Props): any {
    return {
      ...ProviderConfigUsageV1Beta1.GVK,
      ...toJson_ProviderConfigUsageV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ProviderConfigUsageV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderConfigUsageV1Beta1Props) {
    super(scope, id, {
      ...ProviderConfigUsageV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderConfigUsageV1Beta1.GVK,
      ...toJson_ProviderConfigUsageV1Beta1Props(resolved),
    };
  }
}

/**
 * A ProviderConfigUsage indicates that a resource is using a ProviderConfig.
 *
 * @schema ProviderConfigUsageV1Beta1
 */
export interface ProviderConfigUsageV1Beta1Props {
  /**
   * @schema ProviderConfigUsageV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProviderConfigReference to the provider config being used.
   *
   * @schema ProviderConfigUsageV1Beta1#providerConfigRef
   */
  readonly providerConfigRef: ProviderConfigUsageV1Beta1ProviderConfigRef;

  /**
   * ResourceReference to the managed resource using the provider config.
   *
   * @schema ProviderConfigUsageV1Beta1#resourceRef
   */
  readonly resourceRef: ProviderConfigUsageV1Beta1ResourceRef;

}

/**
 * Converts an object of type 'ProviderConfigUsageV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageV1Beta1Props(obj: ProviderConfigUsageV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'providerConfigRef': toJson_ProviderConfigUsageV1Beta1ProviderConfigRef(obj.providerConfigRef),
    'resourceRef': toJson_ProviderConfigUsageV1Beta1ResourceRef(obj.resourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference to the provider config being used.
 *
 * @schema ProviderConfigUsageV1Beta1ProviderConfigRef
 */
export interface ProviderConfigUsageV1Beta1ProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProviderConfigUsageV1Beta1ProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProviderConfigUsageV1Beta1ProviderConfigRef#policy
   */
  readonly policy?: ProviderConfigUsageV1Beta1ProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProviderConfigUsageV1Beta1ProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageV1Beta1ProviderConfigRef(obj: ProviderConfigUsageV1Beta1ProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProviderConfigUsageV1Beta1ProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceReference to the managed resource using the provider config.
 *
 * @schema ProviderConfigUsageV1Beta1ResourceRef
 */
export interface ProviderConfigUsageV1Beta1ResourceRef {
  /**
   * APIVersion of the referenced object.
   *
   * @schema ProviderConfigUsageV1Beta1ResourceRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the referenced object.
   *
   * @schema ProviderConfigUsageV1Beta1ResourceRef#kind
   */
  readonly kind: string;

  /**
   * Name of the referenced object.
   *
   * @schema ProviderConfigUsageV1Beta1ResourceRef#name
   */
  readonly name: string;

  /**
   * UID of the referenced object.
   *
   * @schema ProviderConfigUsageV1Beta1ResourceRef#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ProviderConfigUsageV1Beta1ResourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageV1Beta1ResourceRef(obj: ProviderConfigUsageV1Beta1ResourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProviderConfigUsageV1Beta1ProviderConfigRefPolicy
 */
export interface ProviderConfigUsageV1Beta1ProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProviderConfigUsageV1Beta1ProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProviderConfigUsageV1Beta1ProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProviderConfigUsageV1Beta1ProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProviderConfigUsageV1Beta1ProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProviderConfigUsageV1Beta1ProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageV1Beta1ProviderConfigRefPolicy(obj: ProviderConfigUsageV1Beta1ProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProviderConfigUsageV1Beta1ProviderConfigRefPolicyResolution
 */
export enum ProviderConfigUsageV1Beta1ProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProviderConfigUsageV1Beta1ProviderConfigRefPolicyResolve
 */
export enum ProviderConfigUsageV1Beta1ProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A Release is an example API type
 *
 * @schema Release
 */
export class Release extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Release"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'helm.crossplane.io/v1alpha1',
    kind: 'Release',
  }

  /**
   * Renders a Kubernetes manifest for "Release".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReleaseProps): any {
    return {
      ...Release.GVK,
      ...toJson_ReleaseProps(props),
    };
  }

  /**
   * Defines a "Release" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReleaseProps) {
    super(scope, id, {
      ...Release.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Release.GVK,
      ...toJson_ReleaseProps(resolved),
    };
  }
}

/**
 * A Release is an example API type
 *
 * @schema Release
 */
export interface ReleaseProps {
  /**
   * @schema Release#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ReleaseSpec defines the desired state of a Release.
   *
   * @schema Release#spec
   */
  readonly spec: ReleaseSpec;

}

/**
 * Converts an object of type 'ReleaseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseProps(obj: ReleaseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReleaseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ReleaseSpec defines the desired state of a Release.
 *
 * @schema ReleaseSpec
 */
export interface ReleaseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ReleaseSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReleaseSpecDeletionPolicy;

  /**
   * ReleaseParameters are the configurable fields of a Release.
   *
   * @schema ReleaseSpec#forProvider
   */
  readonly forProvider: ReleaseSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReleaseSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReleaseSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReleaseSpec#providerRef
   */
  readonly providerRef?: ReleaseSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReleaseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReleaseSpecPublishConnectionDetailsTo;

  /**
   * RollbackRetriesLimit is max number of attempts to retry Helm deployment by rolling back the release.
   *
   * @schema ReleaseSpec#rollbackLimit
   */
  readonly rollbackLimit?: number;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReleaseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReleaseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReleaseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpec(obj: ReleaseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReleaseSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ReleaseSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReleaseSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReleaseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'rollbackLimit': obj.rollbackLimit,
    'writeConnectionSecretToRef': toJson_ReleaseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ReleaseSpecDeletionPolicy
 */
export enum ReleaseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ReleaseParameters are the configurable fields of a Release.
 *
 * @schema ReleaseSpecForProvider
 */
export interface ReleaseSpecForProvider {
  /**
   * A ChartSpec defines the chart spec for a Release
   *
   * @schema ReleaseSpecForProvider#chart
   */
  readonly chart: ReleaseSpecForProviderChart;

  /**
   * @schema ReleaseSpecForProvider#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseSpecForProvider#patchesFrom
   */
  readonly patchesFrom?: ReleaseSpecForProviderPatchesFrom[];

  /**
   * @schema ReleaseSpecForProvider#set
   */
  readonly set?: ReleaseSpecForProviderSet[];

  /**
   * @schema ReleaseSpecForProvider#values
   */
  readonly values?: any;

  /**
   * @schema ReleaseSpecForProvider#valuesFrom
   */
  readonly valuesFrom?: ReleaseSpecForProviderValuesFrom[];

  /**
   * @schema ReleaseSpecForProvider#wait
   */
  readonly wait?: boolean;

}

/**
 * Converts an object of type 'ReleaseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProvider(obj: ReleaseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chart': toJson_ReleaseSpecForProviderChart(obj.chart),
    'namespace': obj.namespace,
    'patchesFrom': obj.patchesFrom?.map(y => toJson_ReleaseSpecForProviderPatchesFrom(y)),
    'set': obj.set?.map(y => toJson_ReleaseSpecForProviderSet(y)),
    'values': obj.values,
    'valuesFrom': obj.valuesFrom?.map(y => toJson_ReleaseSpecForProviderValuesFrom(y)),
    'wait': obj.wait,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReleaseSpecProviderConfigRef
 */
export interface ReleaseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReleaseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReleaseSpecProviderConfigRef#policy
   */
  readonly policy?: ReleaseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReleaseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecProviderConfigRef(obj: ReleaseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReleaseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReleaseSpecProviderRef
 */
export interface ReleaseSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReleaseSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReleaseSpecProviderRef#policy
   */
  readonly policy?: ReleaseSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReleaseSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecProviderRef(obj: ReleaseSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReleaseSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReleaseSpecPublishConnectionDetailsTo
 */
export interface ReleaseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReleaseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReleaseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReleaseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReleaseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReleaseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReleaseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecPublishConnectionDetailsTo(obj: ReleaseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReleaseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReleaseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReleaseSpecWriteConnectionSecretToRef
 */
export interface ReleaseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReleaseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReleaseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReleaseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecWriteConnectionSecretToRef(obj: ReleaseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ChartSpec defines the chart spec for a Release
 *
 * @schema ReleaseSpecForProviderChart
 */
export interface ReleaseSpecForProviderChart {
  /**
   * @schema ReleaseSpecForProviderChart#name
   */
  readonly name: string;

  /**
   * A SecretReference is a reference to a secret in an arbitrary namespace.
   *
   * @schema ReleaseSpecForProviderChart#pullSecretRef
   */
  readonly pullSecretRef?: ReleaseSpecForProviderChartPullSecretRef;

  /**
   * @schema ReleaseSpecForProviderChart#repository
   */
  readonly repository: string;

  /**
   * @schema ReleaseSpecForProviderChart#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderChart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderChart(obj: ReleaseSpecForProviderChart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'pullSecretRef': toJson_ReleaseSpecForProviderChartPullSecretRef(obj.pullSecretRef),
    'repository': obj.repository,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValueFromSource represents source of a value
 *
 * @schema ReleaseSpecForProviderPatchesFrom
 */
export interface ReleaseSpecForProviderPatchesFrom {
  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseSpecForProviderPatchesFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ReleaseSpecForProviderPatchesFromConfigMapKeyRef;

  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseSpecForProviderPatchesFrom#secretKeyRef
   */
  readonly secretKeyRef?: ReleaseSpecForProviderPatchesFromSecretKeyRef;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderPatchesFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderPatchesFrom(obj: ReleaseSpecForProviderPatchesFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ReleaseSpecForProviderPatchesFromConfigMapKeyRef(obj.configMapKeyRef),
    'secretKeyRef': toJson_ReleaseSpecForProviderPatchesFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SetVal represents a "set" value override in a Release
 *
 * @schema ReleaseSpecForProviderSet
 */
export interface ReleaseSpecForProviderSet {
  /**
   * @schema ReleaseSpecForProviderSet#name
   */
  readonly name: string;

  /**
   * @schema ReleaseSpecForProviderSet#value
   */
  readonly value?: string;

  /**
   * ValueFromSource represents source of a value
   *
   * @schema ReleaseSpecForProviderSet#valueFrom
   */
  readonly valueFrom?: ReleaseSpecForProviderSetValueFrom;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderSet(obj: ReleaseSpecForProviderSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ReleaseSpecForProviderSetValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValueFromSource represents source of a value
 *
 * @schema ReleaseSpecForProviderValuesFrom
 */
export interface ReleaseSpecForProviderValuesFrom {
  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseSpecForProviderValuesFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ReleaseSpecForProviderValuesFromConfigMapKeyRef;

  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseSpecForProviderValuesFrom#secretKeyRef
   */
  readonly secretKeyRef?: ReleaseSpecForProviderValuesFromSecretKeyRef;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderValuesFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderValuesFrom(obj: ReleaseSpecForProviderValuesFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ReleaseSpecForProviderValuesFromConfigMapKeyRef(obj.configMapKeyRef),
    'secretKeyRef': toJson_ReleaseSpecForProviderValuesFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReleaseSpecProviderConfigRefPolicy
 */
export interface ReleaseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReleaseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReleaseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReleaseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReleaseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReleaseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecProviderConfigRefPolicy(obj: ReleaseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReleaseSpecProviderRefPolicy
 */
export interface ReleaseSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReleaseSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReleaseSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReleaseSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReleaseSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReleaseSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecProviderRefPolicy(obj: ReleaseSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReleaseSpecPublishConnectionDetailsToConfigRef
 */
export interface ReleaseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReleaseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReleaseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReleaseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReleaseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecPublishConnectionDetailsToConfigRef(obj: ReleaseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReleaseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReleaseSpecPublishConnectionDetailsToMetadata
 */
export interface ReleaseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReleaseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReleaseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReleaseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReleaseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecPublishConnectionDetailsToMetadata(obj: ReleaseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretReference is a reference to a secret in an arbitrary namespace.
 *
 * @schema ReleaseSpecForProviderChartPullSecretRef
 */
export interface ReleaseSpecForProviderChartPullSecretRef {
  /**
   * Name of the secret.
   *
   * @schema ReleaseSpecForProviderChartPullSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReleaseSpecForProviderChartPullSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderChartPullSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderChartPullSecretRef(obj: ReleaseSpecForProviderChartPullSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseSpecForProviderPatchesFromConfigMapKeyRef
 */
export interface ReleaseSpecForProviderPatchesFromConfigMapKeyRef {
  /**
   * @schema ReleaseSpecForProviderPatchesFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseSpecForProviderPatchesFromConfigMapKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseSpecForProviderPatchesFromConfigMapKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseSpecForProviderPatchesFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderPatchesFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderPatchesFromConfigMapKeyRef(obj: ReleaseSpecForProviderPatchesFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseSpecForProviderPatchesFromSecretKeyRef
 */
export interface ReleaseSpecForProviderPatchesFromSecretKeyRef {
  /**
   * @schema ReleaseSpecForProviderPatchesFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseSpecForProviderPatchesFromSecretKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseSpecForProviderPatchesFromSecretKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseSpecForProviderPatchesFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderPatchesFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderPatchesFromSecretKeyRef(obj: ReleaseSpecForProviderPatchesFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValueFromSource represents source of a value
 *
 * @schema ReleaseSpecForProviderSetValueFrom
 */
export interface ReleaseSpecForProviderSetValueFrom {
  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseSpecForProviderSetValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ReleaseSpecForProviderSetValueFromConfigMapKeyRef;

  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseSpecForProviderSetValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ReleaseSpecForProviderSetValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderSetValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderSetValueFrom(obj: ReleaseSpecForProviderSetValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ReleaseSpecForProviderSetValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'secretKeyRef': toJson_ReleaseSpecForProviderSetValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseSpecForProviderValuesFromConfigMapKeyRef
 */
export interface ReleaseSpecForProviderValuesFromConfigMapKeyRef {
  /**
   * @schema ReleaseSpecForProviderValuesFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseSpecForProviderValuesFromConfigMapKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseSpecForProviderValuesFromConfigMapKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseSpecForProviderValuesFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderValuesFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderValuesFromConfigMapKeyRef(obj: ReleaseSpecForProviderValuesFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseSpecForProviderValuesFromSecretKeyRef
 */
export interface ReleaseSpecForProviderValuesFromSecretKeyRef {
  /**
   * @schema ReleaseSpecForProviderValuesFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseSpecForProviderValuesFromSecretKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseSpecForProviderValuesFromSecretKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseSpecForProviderValuesFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderValuesFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderValuesFromSecretKeyRef(obj: ReleaseSpecForProviderValuesFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReleaseSpecProviderConfigRefPolicyResolution
 */
export enum ReleaseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReleaseSpecProviderConfigRefPolicyResolve
 */
export enum ReleaseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReleaseSpecProviderRefPolicyResolution
 */
export enum ReleaseSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReleaseSpecProviderRefPolicyResolve
 */
export enum ReleaseSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReleaseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReleaseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReleaseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReleaseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReleaseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReleaseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReleaseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReleaseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseSpecForProviderSetValueFromConfigMapKeyRef
 */
export interface ReleaseSpecForProviderSetValueFromConfigMapKeyRef {
  /**
   * @schema ReleaseSpecForProviderSetValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseSpecForProviderSetValueFromConfigMapKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseSpecForProviderSetValueFromConfigMapKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseSpecForProviderSetValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderSetValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderSetValueFromConfigMapKeyRef(obj: ReleaseSpecForProviderSetValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseSpecForProviderSetValueFromSecretKeyRef
 */
export interface ReleaseSpecForProviderSetValueFromSecretKeyRef {
  /**
   * @schema ReleaseSpecForProviderSetValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseSpecForProviderSetValueFromSecretKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseSpecForProviderSetValueFromSecretKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseSpecForProviderSetValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseSpecForProviderSetValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseSpecForProviderSetValueFromSecretKeyRef(obj: ReleaseSpecForProviderSetValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReleaseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReleaseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReleaseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReleaseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A Release is an example API type
 *
 * @schema ReleaseV1Beta1
 */
export class ReleaseV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReleaseV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'helm.crossplane.io/v1beta1',
    kind: 'Release',
  }

  /**
   * Renders a Kubernetes manifest for "ReleaseV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReleaseV1Beta1Props): any {
    return {
      ...ReleaseV1Beta1.GVK,
      ...toJson_ReleaseV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ReleaseV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReleaseV1Beta1Props) {
    super(scope, id, {
      ...ReleaseV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReleaseV1Beta1.GVK,
      ...toJson_ReleaseV1Beta1Props(resolved),
    };
  }
}

/**
 * A Release is an example API type
 *
 * @schema ReleaseV1Beta1
 */
export interface ReleaseV1Beta1Props {
  /**
   * @schema ReleaseV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ReleaseSpec defines the desired state of a Release.
   *
   * @schema ReleaseV1Beta1#spec
   */
  readonly spec: ReleaseV1Beta1Spec;

}

/**
 * Converts an object of type 'ReleaseV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1Props(obj: ReleaseV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReleaseV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ReleaseSpec defines the desired state of a Release.
 *
 * @schema ReleaseV1Beta1Spec
 */
export interface ReleaseV1Beta1Spec {
  /**
   * @schema ReleaseV1Beta1Spec#connectionDetails
   */
  readonly connectionDetails?: ReleaseV1Beta1SpecConnectionDetails[];

  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ReleaseV1Beta1Spec#deletionPolicy
   */
  readonly deletionPolicy?: ReleaseV1Beta1SpecDeletionPolicy;

  /**
   * ReleaseParameters are the configurable fields of a Release.
   *
   * @schema ReleaseV1Beta1Spec#forProvider
   */
  readonly forProvider: ReleaseV1Beta1SpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReleaseV1Beta1Spec#providerConfigRef
   */
  readonly providerConfigRef?: ReleaseV1Beta1SpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReleaseV1Beta1Spec#providerRef
   */
  readonly providerRef?: ReleaseV1Beta1SpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReleaseV1Beta1Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReleaseV1Beta1SpecPublishConnectionDetailsTo;

  /**
   * RollbackRetriesLimit is max number of attempts to retry Helm deployment by rolling back the release.
   *
   * @schema ReleaseV1Beta1Spec#rollbackLimit
   */
  readonly rollbackLimit?: number;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReleaseV1Beta1Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReleaseV1Beta1SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReleaseV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1Spec(obj: ReleaseV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionDetails': obj.connectionDetails?.map(y => toJson_ReleaseV1Beta1SpecConnectionDetails(y)),
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReleaseV1Beta1SpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ReleaseV1Beta1SpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReleaseV1Beta1SpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReleaseV1Beta1SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'rollbackLimit': obj.rollbackLimit,
    'writeConnectionSecretToRef': toJson_ReleaseV1Beta1SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionDetail todo
 *
 * @schema ReleaseV1Beta1SpecConnectionDetails
 */
export interface ReleaseV1Beta1SpecConnectionDetails {
  /**
   * API version of the referent.
   *
   * @schema ReleaseV1Beta1SpecConnectionDetails#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
   *
   * @schema ReleaseV1Beta1SpecConnectionDetails#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema ReleaseV1Beta1SpecConnectionDetails#kind
   */
  readonly kind?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ReleaseV1Beta1SpecConnectionDetails#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ReleaseV1Beta1SpecConnectionDetails#namespace
   */
  readonly namespace?: string;

  /**
   * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema ReleaseV1Beta1SpecConnectionDetails#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * SkipPartOfReleaseCheck skips check for meta.helm.sh/release-name annotation.
   *
   * @schema ReleaseV1Beta1SpecConnectionDetails#skipPartOfReleaseCheck
   */
  readonly skipPartOfReleaseCheck?: boolean;

  /**
   * @schema ReleaseV1Beta1SpecConnectionDetails#toConnectionSecretKey
   */
  readonly toConnectionSecretKey?: string;

  /**
   * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
   *
   * @schema ReleaseV1Beta1SpecConnectionDetails#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecConnectionDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecConnectionDetails(obj: ReleaseV1Beta1SpecConnectionDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'resourceVersion': obj.resourceVersion,
    'skipPartOfReleaseCheck': obj.skipPartOfReleaseCheck,
    'toConnectionSecretKey': obj.toConnectionSecretKey,
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ReleaseV1Beta1SpecDeletionPolicy
 */
export enum ReleaseV1Beta1SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ReleaseParameters are the configurable fields of a Release.
 *
 * @schema ReleaseV1Beta1SpecForProvider
 */
export interface ReleaseV1Beta1SpecForProvider {
  /**
   * A ChartSpec defines the chart spec for a Release
   *
   * @schema ReleaseV1Beta1SpecForProvider#chart
   */
  readonly chart: ReleaseV1Beta1SpecForProviderChart;

  /**
   * InsecureSkipTLSVerify skips tls certificate checks for the chart download
   *
   * @schema ReleaseV1Beta1SpecForProvider#insecureSkipTLSVerify
   */
  readonly insecureSkipTlsVerify?: boolean;

  /**
   * Namespace to install the release into.
   *
   * @schema ReleaseV1Beta1SpecForProvider#namespace
   */
  readonly namespace: string;

  /**
   * PatchesFrom describe patches to be applied to the rendered manifests.
   *
   * @schema ReleaseV1Beta1SpecForProvider#patchesFrom
   */
  readonly patchesFrom?: ReleaseV1Beta1SpecForProviderPatchesFrom[];

  /**
   * @schema ReleaseV1Beta1SpecForProvider#set
   */
  readonly set?: ReleaseV1Beta1SpecForProviderSet[];

  /**
   * SkipCRDs skips installation of CRDs for the release.
   *
   * @schema ReleaseV1Beta1SpecForProvider#skipCRDs
   */
  readonly skipCrDs?: boolean;

  /**
   * SkipCreateNamespace won't create the namespace for the release. This requires the namespace to already exist.
   *
   * @schema ReleaseV1Beta1SpecForProvider#skipCreateNamespace
   */
  readonly skipCreateNamespace?: boolean;

  /**
   * @schema ReleaseV1Beta1SpecForProvider#values
   */
  readonly values?: any;

  /**
   * @schema ReleaseV1Beta1SpecForProvider#valuesFrom
   */
  readonly valuesFrom?: ReleaseV1Beta1SpecForProviderValuesFrom[];

  /**
   * Wait for the release to become ready.
   *
   * @schema ReleaseV1Beta1SpecForProvider#wait
   */
  readonly wait?: boolean;

  /**
   * WaitTimeout is the duration Helm will wait for the release to become ready. Only applies if wait is also set. Defaults to 5m.
   *
   * @default 5m.
   * @schema ReleaseV1Beta1SpecForProvider#waitTimeout
   */
  readonly waitTimeout?: string;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProvider(obj: ReleaseV1Beta1SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chart': toJson_ReleaseV1Beta1SpecForProviderChart(obj.chart),
    'insecureSkipTLSVerify': obj.insecureSkipTlsVerify,
    'namespace': obj.namespace,
    'patchesFrom': obj.patchesFrom?.map(y => toJson_ReleaseV1Beta1SpecForProviderPatchesFrom(y)),
    'set': obj.set?.map(y => toJson_ReleaseV1Beta1SpecForProviderSet(y)),
    'skipCRDs': obj.skipCrDs,
    'skipCreateNamespace': obj.skipCreateNamespace,
    'values': obj.values,
    'valuesFrom': obj.valuesFrom?.map(y => toJson_ReleaseV1Beta1SpecForProviderValuesFrom(y)),
    'wait': obj.wait,
    'waitTimeout': obj.waitTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReleaseV1Beta1SpecProviderConfigRef
 */
export interface ReleaseV1Beta1SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReleaseV1Beta1SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReleaseV1Beta1SpecProviderConfigRef#policy
   */
  readonly policy?: ReleaseV1Beta1SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecProviderConfigRef(obj: ReleaseV1Beta1SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReleaseV1Beta1SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReleaseV1Beta1SpecProviderRef
 */
export interface ReleaseV1Beta1SpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReleaseV1Beta1SpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReleaseV1Beta1SpecProviderRef#policy
   */
  readonly policy?: ReleaseV1Beta1SpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecProviderRef(obj: ReleaseV1Beta1SpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReleaseV1Beta1SpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReleaseV1Beta1SpecPublishConnectionDetailsTo
 */
export interface ReleaseV1Beta1SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReleaseV1Beta1SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReleaseV1Beta1SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReleaseV1Beta1SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReleaseV1Beta1SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecPublishConnectionDetailsTo(obj: ReleaseV1Beta1SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReleaseV1Beta1SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReleaseV1Beta1SpecWriteConnectionSecretToRef
 */
export interface ReleaseV1Beta1SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReleaseV1Beta1SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReleaseV1Beta1SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecWriteConnectionSecretToRef(obj: ReleaseV1Beta1SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ChartSpec defines the chart spec for a Release
 *
 * @schema ReleaseV1Beta1SpecForProviderChart
 */
export interface ReleaseV1Beta1SpecForProviderChart {
  /**
   * Name of Helm chart, required if ChartSpec.URL not set
   *
   * @schema ReleaseV1Beta1SpecForProviderChart#name
   */
  readonly name?: string;

  /**
   * PullSecretRef is reference to the secret containing credentials to helm repository
   *
   * @schema ReleaseV1Beta1SpecForProviderChart#pullSecretRef
   */
  readonly pullSecretRef?: ReleaseV1Beta1SpecForProviderChartPullSecretRef;

  /**
   * Repository: Helm repository URL, required if ChartSpec.URL not set
   *
   * @schema ReleaseV1Beta1SpecForProviderChart#repository
   */
  readonly repository?: string;

  /**
   * URL to chart package (typically .tgz), optional and overrides others fields in the spec
   *
   * @schema ReleaseV1Beta1SpecForProviderChart#url
   */
  readonly url?: string;

  /**
   * Version of Helm chart, late initialized with latest version if not set
   *
   * @schema ReleaseV1Beta1SpecForProviderChart#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderChart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderChart(obj: ReleaseV1Beta1SpecForProviderChart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'pullSecretRef': toJson_ReleaseV1Beta1SpecForProviderChartPullSecretRef(obj.pullSecretRef),
    'repository': obj.repository,
    'url': obj.url,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValueFromSource represents source of a value
 *
 * @schema ReleaseV1Beta1SpecForProviderPatchesFrom
 */
export interface ReleaseV1Beta1SpecForProviderPatchesFrom {
  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseV1Beta1SpecForProviderPatchesFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef;

  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseV1Beta1SpecForProviderPatchesFrom#secretKeyRef
   */
  readonly secretKeyRef?: ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderPatchesFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderPatchesFrom(obj: ReleaseV1Beta1SpecForProviderPatchesFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef(obj.configMapKeyRef),
    'secretKeyRef': toJson_ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SetVal represents a "set" value override in a Release
 *
 * @schema ReleaseV1Beta1SpecForProviderSet
 */
export interface ReleaseV1Beta1SpecForProviderSet {
  /**
   * @schema ReleaseV1Beta1SpecForProviderSet#name
   */
  readonly name: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderSet#value
   */
  readonly value?: string;

  /**
   * ValueFromSource represents source of a value
   *
   * @schema ReleaseV1Beta1SpecForProviderSet#valueFrom
   */
  readonly valueFrom?: ReleaseV1Beta1SpecForProviderSetValueFrom;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderSet(obj: ReleaseV1Beta1SpecForProviderSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ReleaseV1Beta1SpecForProviderSetValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValueFromSource represents source of a value
 *
 * @schema ReleaseV1Beta1SpecForProviderValuesFrom
 */
export interface ReleaseV1Beta1SpecForProviderValuesFrom {
  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseV1Beta1SpecForProviderValuesFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef;

  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseV1Beta1SpecForProviderValuesFrom#secretKeyRef
   */
  readonly secretKeyRef?: ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderValuesFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderValuesFrom(obj: ReleaseV1Beta1SpecForProviderValuesFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef(obj.configMapKeyRef),
    'secretKeyRef': toJson_ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReleaseV1Beta1SpecProviderConfigRefPolicy
 */
export interface ReleaseV1Beta1SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReleaseV1Beta1SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReleaseV1Beta1SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReleaseV1Beta1SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReleaseV1Beta1SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecProviderConfigRefPolicy(obj: ReleaseV1Beta1SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReleaseV1Beta1SpecProviderRefPolicy
 */
export interface ReleaseV1Beta1SpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReleaseV1Beta1SpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReleaseV1Beta1SpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReleaseV1Beta1SpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReleaseV1Beta1SpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecProviderRefPolicy(obj: ReleaseV1Beta1SpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRef
 */
export interface ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRef(obj: ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToMetadata
 */
export interface ReleaseV1Beta1SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecPublishConnectionDetailsToMetadata(obj: ReleaseV1Beta1SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PullSecretRef is reference to the secret containing credentials to helm repository
 *
 * @schema ReleaseV1Beta1SpecForProviderChartPullSecretRef
 */
export interface ReleaseV1Beta1SpecForProviderChartPullSecretRef {
  /**
   * Name of the secret.
   *
   * @schema ReleaseV1Beta1SpecForProviderChartPullSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReleaseV1Beta1SpecForProviderChartPullSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderChartPullSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderChartPullSecretRef(obj: ReleaseV1Beta1SpecForProviderChartPullSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef
 */
export interface ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef {
  /**
   * @schema ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef(obj: ReleaseV1Beta1SpecForProviderPatchesFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef
 */
export interface ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef {
  /**
   * @schema ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef(obj: ReleaseV1Beta1SpecForProviderPatchesFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValueFromSource represents source of a value
 *
 * @schema ReleaseV1Beta1SpecForProviderSetValueFrom
 */
export interface ReleaseV1Beta1SpecForProviderSetValueFrom {
  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseV1Beta1SpecForProviderSetValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef;

  /**
   * DataKeySelector defines required spec to access a key of a configmap or secret
   *
   * @schema ReleaseV1Beta1SpecForProviderSetValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderSetValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderSetValueFrom(obj: ReleaseV1Beta1SpecForProviderSetValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'secretKeyRef': toJson_ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef
 */
export interface ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef {
  /**
   * @schema ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef(obj: ReleaseV1Beta1SpecForProviderValuesFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef
 */
export interface ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef {
  /**
   * @schema ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef(obj: ReleaseV1Beta1SpecForProviderValuesFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReleaseV1Beta1SpecProviderConfigRefPolicyResolution
 */
export enum ReleaseV1Beta1SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReleaseV1Beta1SpecProviderConfigRefPolicyResolve
 */
export enum ReleaseV1Beta1SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReleaseV1Beta1SpecProviderRefPolicyResolution
 */
export enum ReleaseV1Beta1SpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReleaseV1Beta1SpecProviderRefPolicyResolve
 */
export enum ReleaseV1Beta1SpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy(obj: ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef
 */
export interface ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef {
  /**
   * @schema ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef(obj: ReleaseV1Beta1SpecForProviderSetValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataKeySelector defines required spec to access a key of a configmap or secret
 *
 * @schema ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef
 */
export interface ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef {
  /**
   * @schema ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef#name
   */
  readonly name: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef#namespace
   */
  readonly namespace: string;

  /**
   * @schema ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef(obj: ReleaseV1Beta1SpecForProviderSetValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReleaseV1Beta1SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

